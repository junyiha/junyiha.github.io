<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/13/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-robotics_%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-robotics_%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BA/" class="post-title-link" itemprop="url">robotics_机器人学导论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>机器人学导论 第三版<ul>
<li>机器人学研究的是怎样综合运用机械，传感器，驱动器和计算机来实现人类某些方面的功能。</li>
<li>在更高的层次上，可以把机器人学划分为四个主要领域：机械操作，移动，计算机视觉和人工智能</li>
</ul>
</li>
</ul>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ul>
<li>一般来说，对于操作臂的机构和控制理论的研究并不是一门新的学科，它只不过是对传统学科理论的一种综合。<ul>
<li>机械工程理论为研究静态和动态环境下的操作臂提供了方法论；</li>
<li>数学方法用于描述机械手空间运动及其特性</li>
<li>控制理论为实现期望运动或力提供了各种设计方法和评估算法；</li>
<li>电气工程技术可用于传感器及工业机器人接口的设计</li>
<li>计算机技术提供了执行期望任务所需的编程平台</li>
</ul>
</li>
</ul>
<h3 id="位姿描述"><a href="#位姿描述" class="headerlink" title="位姿描述"></a>位姿描述</h3><ul>
<li><p>在机器人研究中，我们通常在三维空间中研究物体的位置。通常这些物理可用两个非常重要的特性来描述：位置和姿态</p>
</li>
<li><p>为了描述空间物体的位姿，我们一般先将物体固置于一个空间坐标系，即参考系中，然后我们就在这个参考坐标系中研究空间物体的位置和姿态</p>
</li>
<li><p>运动学研究物体的运动，而不考虑引起这种运动的力。在运动学中，我们研究位置，速度，加速度和位置变量对于时间或者其他变量的高阶微分。这样操作臂运动学的研究对象就是运动的全部几何和时间特性</p>
</li>
</ul>
<h3 id="操作臂正运动学"><a href="#操作臂正运动学" class="headerlink" title="操作臂正运动学"></a>操作臂正运动学</h3><ul>
<li>几乎所有的操作臂都是由刚性连杆组成的，相邻连杆间由可作相对运动的关节连接。这些关节通常装有位置传感器，用来测量相邻连杆间的相对位置。</li>
<li>如果是转动关节，这个位移被称为关节角。</li>
<li>一些操作臂含有滑动(或移动)关节，那么两个相邻连杆的位移是直线运动，有时将这个位移称为关节偏距</li>
</ul>
<hr>
<ul>
<li><p>操作臂自由度的数目是操作臂中具有独立位置变量的数目，这些位置变量确定了机构中所有部件的位置</p>
</li>
<li><p>对于一个典型的工业机器人来讲，由于操作臂大都是开式的运动链，而且每个关节位置都由一个独立的变量定义，因此关节数目等于自由度数目</p>
</li>
<li><p>末端执行器安全在操作臂的自由端。</p>
</li>
<li><p>我们通常用附着于末端执行器上的工具坐标系描述操作臂的位置，与工具坐标系相对应的是与操作臂固定底座相连的基坐标系</p>
</li>
</ul>
<hr>
<ul>
<li><p>在操作臂运动学的研究中一个典型的问题是操作臂正运动学。计算操作臂末端执行器的位置和姿态是一个静态的几何问题。</p>
</li>
<li><p>正运动学方程描述了各个关节变量在工具坐标系与基坐标系间的函数关系</p>
</li>
<li><p>具体来讲，给定一组关节角的值，正运动学问题是计算工具坐标系相对于基坐标系的位置和姿态。一般情况下，我们将这个过程称为从关节空间描述到笛卡尔空间描述的操作臂位置表示。(第三章)</p>
</li>
<li><p>在笛卡尔坐标系中，我们用三个变量来描述空间一点的位置，而用另外三个变量描述物体的姿态。有时将此称为任务空间或者操作空间</p>
</li>
</ul>
<h3 id="操作臂逆运动学"><a href="#操作臂逆运动学" class="headerlink" title="操作臂逆运动学"></a>操作臂逆运动学</h3><ul>
<li><p>在第四章中，我们将讨论操作臂逆运动学。这个问题就是给定操作臂末端执行器的位置和姿态，计算所有可达给定位置和姿态的关节角。这是操作臂实际应用中的一个基本问题。</p>
</li>
<li><p>给定工具坐标系的位置和姿态，通过逆运动学可以计算各关节变量</p>
</li>
<li><p>从某种程度上讲，逆运动学问题的求解对于操作臂系统来说是最重要的部分。</p>
</li>
<li><p>我们认为这是个“定位”映射问题，是将机器人位姿从三维笛卡尔空间向内部关节空间的映射。</p>
</li>
<li><p>当机器人目标位置用外部三维空间坐标表示时，则需要进行这种映射</p>
</li>
<li><p>运动学方程解的存在与否限定了操作臂的工作空间。无解表示目标点处在工作空间之外，因此操作臂不能达到这个期望位姿</p>
</li>
</ul>
<h3 id="速度-静力-奇异性"><a href="#速度-静力-奇异性" class="headerlink" title="速度 静力 奇异性"></a>速度 静力 奇异性</h3><ul>
<li><p>除了分析静态定位问题之外，我们还希望分析运动中的操作臂。为操作臂定义雅可比矩阵可以比较方便地进行机构的速度分析。</p>
</li>
<li><p>雅可比矩阵定义了从关节空间速度向笛卡尔空间速度的映射。这种映射关系随着操作臂位形的变化而变化。</p>
</li>
<li><p>关节速率和末端执行器速率的几何关系可以通过雅可比矩阵表示</p>
</li>
<li><p>在奇异点雅可比矩阵是不可逆的。对这种现象的正确理解对于操作臂的设计者和用户都是十分重要的。</p>
</li>
<li><p>机构奇异性：所有的机械装置都会有这种问题，包括机器人。正如后座舱机枪一样，这些奇异性并不影响机器人手臂在其工作空间内的定位，然而，机械臂在这些奇异点附近运动时会出现一些问题。</p>
</li>
</ul>
<h3 id="动力学"><a href="#动力学" class="headerlink" title="动力学"></a>动力学</h3><ul>
<li><p>动力学是一个广泛的研究领域，主要研究产生运动所需要的力。为了使操作臂从静止开始加速，使末端执行器以恒定的速度作直线运动，最后减速停止，必须通过关节驱动器产生一组复杂的力矩函数来实现。</p>
<ul>
<li>我们用关节驱动器作为操作臂驱动装置的通用术语，它可以是电机，气缸，液压缸等</li>
</ul>
</li>
<li><p>关节驱动器产生的力矩函数形式取决于末端执行器路径的空间形式和瞬时特性，连杆和负载的质量特性以及关节摩擦等因素。</p>
</li>
<li><p>控制操作臂沿期望路径运动的一种方法是，通过运用操作臂动力学方程求解出这些关节力矩函数。</p>
</li>
</ul>
<h3 id="轨迹生成"><a href="#轨迹生成" class="headerlink" title="轨迹生成"></a>轨迹生成</h3><ul>
<li><p>平稳控制操作臂从一点运动到另一点，通常的方法是使每个关节按照指定的时间连续函数来运动。</p>
</li>
<li><p>一般情况下，操作臂各关节同时开始或者同时停止运动，这样操作臂的运动才显得协调。轨迹生成就是如何准确计算出这些运动函数。</p>
</li>
<li><p>通常，一条路径的描述不仅需要确定期望目标，而且还需要确定一些中间点或者路径点，操作臂必须通过这条路到达目标。有时用术语样条函数来表示通过一系列路径点的连续函数。</p>
</li>
<li><p>为了使末端执行器在空间中走出一条直线(或者其他的几何形状)，那么必须将末端执行器的期望运动转化成一系列等效的关节运动，这种笛卡尔轨迹生成将在第七章讨论</p>
</li>
</ul>
<h2 id="第二章-空间描述和变换"><a href="#第二章-空间描述和变换" class="headerlink" title="第二章 空间描述和变换"></a>第二章 空间描述和变换</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>机器人操作的定义是指通过某种机构使零件和工具在空间运动。这自然就需要表达零件，工具以及机构本身的位置和姿态。为了定义和运用表达位姿的数学量，我们必须定义坐标系并给出表达的规则。</li>
<li>我们采用这样一个体系，即存在着一个世界坐标系，我们讨论任何问题都能够参照这个坐标系。我们定义的位姿都是参照世界坐标系或者由世界坐标系定义的(或者能够定义的)的笛卡尔坐标系</li>
</ul>
<h3 id="位置描述"><a href="#位置描述" class="headerlink" title="位置描述"></a>位置描述</h3><ul>
<li>一旦建立了坐标系，我们就能用一个3 * 1的位置矢量对世界坐标系中的任何点进行定位。</li>
<li>因为经常在世界坐标系中还要定义许多坐标系，因此必须在位置矢量上附加一条信息，表明是在哪一个坐标系被定义的。</li>
<li>总之，我们用一个位置矢量来描述空间中点的位置。</li>
</ul>
<h3 id="姿态描述"><a href="#姿态描述" class="headerlink" title="姿态描述"></a>姿态描述</h3><ul>
<li>为了描述物体的姿态，我们将在物体上固定一个坐标系并且给出此坐标系相对于参考系的表达。</li>
<li>因此，点的位置可用矢量描述，物体的姿态可用固定在物体上的坐标系来描述。</li>
<li>总之，一组三个矢量可以用来确定一个姿态。简单起见，我们用三个矢量作为矩阵的列来构造一个3 * 3 的矩阵。</li>
<li>于是，点的位置可用一个矢量来表示，物体的姿态可用一个矩阵来表示。</li>
</ul>
<h3 id="坐标系的描述"><a href="#坐标系的描述" class="headerlink" title="坐标系的描述"></a>坐标系的描述</h3><ul>
<li><p>我们可在物体上任选一点描述其位置，为方便起见，将其作为连体坐标系的原点。</p>
</li>
<li><p>在机器人学中，位置和姿态经常成对出现，于是我们将此组合称为坐标系，四个矢量为一组，表示了位置和姿态信息。一个矢量表示指端位置，而另外三个矢量表示姿态。</p>
</li>
<li><p>一个坐标系可以等价地用一个位置矢量和一个旋转矩阵来描述。</p>
</li>
<li><p>坐标系可用三个标有箭头的单位矢量定义的坐标系的主轴来描述。从原点到另一点的箭头表示了一个矢量。这个矢量表示了箭头处的原点相对于箭尾所在的坐标系的位置</p>
</li>
<li><p>总之，一个参考系可以用作一个坐标系相对于另一个坐标系的关系来描述。参考系包括了位置和姿态两个概念，大多数情况下被认为是这两个概念的结合</p>
</li>
<li><p>位置可由一个参考系表示，这个参考系中的旋转矩阵是单位阵，并且这个参考系中的位置矢量确定了被描述点的位置。同样，如果参考系中的位置矢量是零矢量，那么它表示的就是姿态。</p>
</li>
</ul>
<h3 id="算子：平移，旋转和变换"><a href="#算子：平移，旋转和变换" class="headerlink" title="算子：平移，旋转和变换"></a>算子：平移，旋转和变换</h3><ul>
<li>用于坐标系间点的映射的通用数学表达式称为算子，包括点的平移算子，矢量旋转算子和平移加旋转的算子</li>
</ul>
<h3 id="X-Y-Z固定角坐标系"><a href="#X-Y-Z固定角坐标系" class="headerlink" title="X-Y-Z固定角坐标系"></a>X-Y-Z固定角坐标系</h3><ul>
<li>每个旋转都是绕着固定参考坐标系{A}的轴，我们规定这种姿态的表示法为X-Y-Z固定角坐标系。</li>
<li>固定，一词是指旋转是在固定(既不运动)参考坐标系中确定的。有时把它们定义为回转角，俯仰角和偏转角</li>
</ul>
<h3 id="Z-Y-X欧拉角"><a href="#Z-Y-X欧拉角" class="headerlink" title="Z-Y-X欧拉角"></a>Z-Y-X欧拉角</h3><ul>
<li>在这种表示法中，每次都是绕运动坐标系{B}的各轴旋转而不是绕固定坐标系{A}的各轴旋转。这样三个一组的旋转被称作欧拉角。</li>
<li>注意每次旋转所绕的轴的方位取决于上次的旋转。由于三个旋转分别是绕着Z，Y和X，所以称这种表示法为Z-Y-X欧拉角</li>
</ul>
<h3 id="Z-Y-Z欧拉角"><a href="#Z-Y-Z欧拉角" class="headerlink" title="Z-Y-Z欧拉角"></a>Z-Y-Z欧拉角</h3><ul>
<li>相对于运动坐标系{B}的旋转描述是一个欧拉角描述。因为三个旋转依次绕Z，Y和Z，所以称此描述为Z-Y-Z欧拉角</li>
</ul>
<h2 id="第三章-操作臂运动学"><a href="#第三章-操作臂运动学" class="headerlink" title="第三章 操作臂运动学"></a>第三章 操作臂运动学</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>操作臂运动学研究操作臂的运动特性，而不考虑使操作臂产生运动时施加的力。在操作臂运动学中，将要研究操作臂的位置，速度，加速度以及位置变量的所有高阶导数(对于时间或其他变量)</li>
</ul>
<h3 id="连杆描述"><a href="#连杆描述" class="headerlink" title="连杆描述"></a>连杆描述</h3><ul>
<li>操作臂可以看成由一系列刚体通过关节连接而成的一个运动链，我们将这些刚体称为连杆</li>
</ul>
<h3 id="驱动器空间，关节空间和笛卡尔空间"><a href="#驱动器空间，关节空间和笛卡尔空间" class="headerlink" title="驱动器空间，关节空间和笛卡尔空间"></a>驱动器空间，关节空间和笛卡尔空间</h3><ul>
<li><p>对于一个具有n个自由度的操作臂来说，它的所有连杆位置可由一组n个关节变量加以确定。这样的一组变量常备称为n * 1 的关节矢量。所有关节矢量组成的空间称为关节空间。</p>
</li>
<li><p>至此，我们关心的是如何将已知的关节空间描述转化为笛卡尔空间的描述。当位置是在空间相互正交的轴上测量，且姿态是按照第二章中的任何一种规定测量时，我们称这个空间为笛卡尔空间，有时称为任务空间和操作空间</p>
</li>
<li><p>到目前为止，我们一直假设每个运动关节都是直接由某种驱动器驱动。然而，对于许多工业机器人来说并非如此。例如有时用两个驱动器以差动的方式驱动一个关节，有时候直线驱动器通过四连杆机构来驱动旋转关节。在这些情况下，就需要考虑驱动器位置。由于测量操作臂位置的传感器尝尝安装在驱动器上，因此进行某些计算时必须把关节矢量表示成一组驱动器函数，即驱动器矢量</p>
</li>
<li><p>一个操作臂的位姿描述有三种表示方法：</p>
<ul>
<li>驱动空间描述</li>
<li>关节空间描述</li>
<li>笛卡尔空间描述</li>
</ul>
</li>
</ul>
<h3 id="坐标系的标准命名"><a href="#坐标系的标准命名" class="headerlink" title="坐标系的标准命名"></a>坐标系的标准命名</h3><ul>
<li><p>为了规范起见，有必要给机器人和工作空间专门命名和确定专门的”标准”坐标系。一种典型的情况：机器人抓持某种工具，并把工具末端移动到操作者指定的位置。</p>
</li>
<li><p>基坐标系{B}</p>
<ul>
<li>基坐标系{B}位于操作臂的基座上。它仅是赋予坐标系{0}的另一个名称。因为它固连在机器人的静止部位，所以有时称为连杆0</li>
</ul>
</li>
<li><p>工作台坐标系{S}</p>
<ul>
<li>工作台坐标系{S}的位置与任务相关。对机器人系统的用户来说，工作台坐标系{S}是一个通用坐标系，机器人所有的运动都是相对于它来执行的。</li>
<li>有时称它为任务坐标系，世界坐标系或通用坐标系。工作台坐标系通常根据基坐标系确定</li>
</ul>
</li>
<li><p>腕部坐标系{W}</p>
<ul>
<li>腕部坐标系{W}附于操作臂的末端连杆。这个固连在机器人末端上的坐标系也可以称为坐标系{N}。</li>
<li>大多数情况，腕部坐标系{W}的原点位于操作臂手腕上，它随着操作臂的末端连杆移动。它相对于基坐标系定义。</li>
</ul>
</li>
<li><p>工具坐标系{T}</p>
<ul>
<li>工具坐标系{T}附于机器人所夹持工具的末端。当手部没有夹持工具时，工具坐标系{T}的原点位于机器人的指端之间。工具坐标系通常根据腕部坐标系来确定</li>
</ul>
</li>
<li><p>目标坐标系{G}</p>
<ul>
<li>目标坐标系{G}是机器人移动工具时对工具位置的描述。特指在机器人运动结束时，工作坐标系应当与目标坐标系重合。</li>
<li>目标坐标系{G}通常根据工作台坐标系来确定</li>
</ul>
</li>
</ul>
<h3 id="工具的位置"><a href="#工具的位置" class="headerlink" title="工具的位置"></a>工具的位置</h3><ul>
<li>机器人的首要功能之一是能够计算它所夹持的工具(或未夹持工具)相对于规范坐标系的位姿，也就是说需要计算工具坐标系{T}相对于工作台坐标系{S}的变换矩阵</li>
</ul>
<h3 id="计算问题"><a href="#计算问题" class="headerlink" title="计算问题"></a>计算问题</h3><ul>
<li><p>在许多实际的操作臂系统中，求解运动学方程所需的时间是一个必须考虑的问题。</p>
</li>
<li><p>一种选择就是使用定点或浮点数表示相关的变量。为便于软件编制，许多计算采用浮点运算，因为程序员不需考虑进行标量运算时变量所占用的相对范围。</p>
</li>
<li><p>通过分量方程，利用局部变量可以减少乘和加的次数(这样做是经济的)，这时为了避免计算机重复运行相同的语句。分量方程已在工厂的计算机辅助制造中得到应用。</p>
</li>
<li><p>运动学计算的主要耗时是计算超越函数(正弦和余弦)。当这些函数作为标准库的一部分时，常需要以成倍的耗时进行一系列展开式的计算。这时操作系统可以提供一些内存，用查表的方式计算超越函数</p>
</li>
</ul>
<h2 id="第四章-操作臂逆运动学"><a href="#第四章-操作臂逆运动学" class="headerlink" title="第四章 操作臂逆运动学"></a>第四章 操作臂逆运动学</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul>
<li>逆运动学问题：<ul>
<li>已知工具坐标系相对于固定坐标系的期望位置和姿态，如何计算一些列满足期望要求的关节角</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-offer_%E5%89%91%E6%8C%87offer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-offer_%E5%89%91%E6%8C%87offer/" class="post-title-link" itemprop="url">offer_剑指offer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>剑指Offer 书籍阅读笔记</li>
</ul>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><ul>
<li><p>双指针是一种常用的解题思路，可以使用两个相反方向或者相同方向的指针扫描数组从而达到解题目的。</p>
</li>
<li><p>指针，并不专指C语言中的指针，而是一个相对宽泛的概念，是能定位数据容器中某个数据的手段。在数组中它实际上是数字的下标</p>
</li>
<li><p>方向相反的双指针经常用来求排序数组中的两个数字之和。一个指针P1指向数组的第一个数字，另一个指针P2指向数组的最后一个数字，然后比较两个指针指向的数字之和及一个目标值。如果两个指针指向的数字之和大于目标值，则向左移动指针P2；如果两个指针指向的数字之和小于目标值，则向右移动指针P1。此时，两个指针的移动方向是相反的。</p>
</li>
<li><p>方向相同的双指针，通常用来求正数数组中子数组的和或者乘积。初始化的时候两个指针P1和P2都指向数组的第一个数字。如果两个指针之间的子数组的和或成绩大于目标值，则向右移动指针P1删除子数组最左边的数字；如果两个指针之间的子数组的和或乘积小于目标值，则向右移动指针P2在子数组的右边增加新的数字。此时两个指针的移动方向是相同的</p>
</li>
<li><p>双指针，是解决与数组相关的面试题的一种常用技术。如果数组是排序的，那么应用双指针技术就能够用O(n)的时间在数组中找出两个和为给定值的数字。</p>
</li>
<li><p>如果数组中的所有数字都是整数，那么应用双指针技术就可以用O(1)的辅助空间找出和为给定值的子数组</p>
</li>
</ul>
<h2 id="双指针-链表"><a href="#双指针-链表" class="headerlink" title="双指针 链表"></a>双指针 链表</h2><ul>
<li><p>所谓双指针是指利用两个指着来解决与链表相关的面试题，这是一种常用思路。双指针思路又可以根据两个指针不同的移动方式细分为两种不同的方法。</p>
</li>
<li><p>第一种方法是前后双指针，即一个指针在链表中提前朝着指向下一个节点的指针移动若干步，然后移动第二个指针。</p>
<ul>
<li>前后双指针的经典应用是查找链表的倒数第K个节点。先让第1个指针从链表的头结点开始朝着下一个节点的指针先移动K - 1步，然后让第二个指针指向链表的头节点，在让两个指针以相同的速度一起移动，当第一个指针达到链表的尾节点时，第二个指针正好指向倒数第K个节点</li>
</ul>
</li>
<li><p>第二种方法是快慢双指针，即两个指针在链表中移动的速度不一样，通常是快的指针朝着下一个节点的指针一次移动两步，慢的指针一次只移动一步。</p>
<ul>
<li>采用这种方法，在一个没有环的链表中，当块的指针到达链表尾节点的时候慢的指针正好指向链表的中间节点</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-UnixNetworkProgramming01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-UnixNetworkProgramming01/" class="post-title-link" itemprop="url">UnixNetworkProgramming01</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>要编写通过计算机网络通信的程序，首先要确定这些程序相互通信所用的协议(protocol)</p>
</li>
<li><p>在深入设计一个协议的细节之前，应该从高层次决断通信由哪个程序发起以及响应在何时产生</p>
</li>
<li><p>举例来说，一般认为Web服务器程序是一个长时间运行的程序(即所谓的守护程序，daemon)</p>
</li>
<li><p>同一网络应用的客户和服务器无需处于同一个局域网(local area network, LAN)</p>
</li>
<li><p>两个局域网是使用路由器(router)连接到广域网(wide area network, WAN)</p>
</li>
<li><p>路由器是广域网的架构设备。当今最大的广域网是因特网(Internet)</p>
</li>
<li><p>许多公司也构建自己的广域网，而这些私有的广域网既可以连接到因特网，也可以不连接到因特网</p>
</li>
</ul>
<h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li><p>socket函数创建一个网际(AF_INET)字节流(SOCK_STREAM)套接字，它是TCP套接字的花哨名字。</p>
</li>
<li><p>该函数返回一个小整数描述符，以后的所有函数调用(例如connect和read)就用该描述符来标识这个套接字</p>
</li>
<li><p>后面，将遇到术语套接字(socket)的许多不同用法。</p>
</li>
<li><p>首先，正在使用的API称为套接字API(sockets API),socket函数就是套接字API的一部分</p>
</li>
<li><p>TCP套接字，它是TCP端点(TCP endpoint)的同义词</p>
</li>
<li><p>如果socket函数调用失败，我们就调用自己的err_sys函数，放弃程序的运行</p>
</li>
<li><p>err_sys函数输出我们作为参数提供的出错消息以及所发生的系统错误的描述</p>
</li>
</ul>
<h3 id="1-3"><a href="#1-3" class="headerlink" title="1.3"></a>1.3</h3><ul>
<li>connect函数应用于一个TCP套接字时，将与由它的第二个参数只想的套接字地址结构指定的服务器建立一个TCP连接。</li>
<li>该套接字地址结构的长度也必须作为该函数的第三个参数指定，对于网际套接字地址结构，我们总是使用C语言的sizeof操作符由编译器来计算这个长度</li>
</ul>
<h3 id="1-4"><a href="#1-4" class="headerlink" title="1.4"></a>1.4</h3><ul>
<li><p>使用read函数读取服务器的应用，并用标准的I&#x2F;O函数fputs输出结果。</p>
</li>
<li><p>使用TCP时必须小心，因为TCP是一个没有记录边界的字节流协议。</p>
</li>
<li><p>计算机网络各层对等实体间交换的单位信息，称为协议数据单元(protocol data unit, PDU)</p>
</li>
<li><p>分节(segment)就是对应于TCP传输层的PDU</p>
</li>
<li><p>按照协议与服务之间的关系，除了最底层(物理层)外，每层的PDU通过由紧邻下层提供给本层的服务接口，作为下层的服务数据单元(service data unit, SDU)传递给下层，并由下层间接完成本层的PDU交换</p>
</li>
<li><p>应用层实体(例如客户和服务器进程)间交换的PDU称为应用数据(application data)，</p>
</li>
<li><p>其中在TCP应用进程之间交换的是没有长度限制的单个双向字节流</p>
</li>
<li><p>在UDP应用进程之间交换的是其长度不超过UDP发送缓冲区大小的单个记录(record)</p>
</li>
<li><p>在SCTP应用进程之间交换的是没有总长度限制的单个或多个记录流</p>
</li>
<li><p>传输层实体(例如对应某个端口的传输层协议代码的一次运行)间交换的PDU称为消息(message),其中TCP的PDU特称为分节(segment)。</p>
</li>
<li><p>消息或分节的长度是有限的。</p>
</li>
<li><p>在TCP传输层中，发送端TCP把来自应用进程的字节流数据(即由应用进程通过一次次输出操作写出到发送端TCP套接字中的数据)按顺序分割后封装在各个分节中传送给接收端TCP。</p>
</li>
<li><p>其中，每个分节所封装的数据既可能是发送端应用进程单次输出操作的结果，也可能是连续数次输出操作的结果，而且每个分节所封装的单次输出操作的结果或者首尾两次操作的结果既可能是完整的，也可能是不完整的，具体取决于可在连接建立阶段由对端通告的最大分节大小(maximum segment size, MMS)以及外出接口的最大传输单元(maximum transmission unit, MTU)或外出路径的路径MTU(如果网络层具有路径MTU发现功能，例如IPv6)</p>
</li>
<li><p>通常服务器返回包含所有26个字节的单个分节，但是如果数据量很大，我们就不能确保一次read调用能返回服务器的整个应答。</p>
</li>
<li><p>因此从TCP套接字读取数据时，我们总是需要把read编写在某个循环中，当read返回0(表明对端关闭连接)或负值(表明发生错误)时终止循环</p>
</li>
</ul>
<h3 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h3><ul>
<li><p>网络层实体间交换的PDU，称为IP数据报(IP datagram)，其长度有限：IPv4数据报最大65535字节，IPv6数据包最大65575字节。</p>
</li>
<li><p>发送端IP把来自传输层的消息(或TCP分节)整个封装在IP数据报中传送</p>
</li>
<li><p>链路层实体间交换的PDU，称为帧(frame)，其长度取决于具体的接口。</p>
</li>
<li><p>IP数据报由IP首部和所承载的传输层数据(即网络层的SDU)构成</p>
</li>
<li><p>过长的IP数据报无法封装在单个帧中，需要先对其SDU进行分片(fragmentation)，再把分成各个片段(fragment)冠以新的IP首部封装到多个帧中</p>
</li>
<li><p>在一个IP数据报从源端到目的端的传送过程中，分片操作既可能发生在源端，也可能发生在途中，而其逆操作，即重组(reassembly)一般只发生在目的端</p>
</li>
<li><p>SCTP为了传送过长的记录采取了类似的分片和重组措施</p>
</li>
<li><p>TCP&#x2F;IP协议族为了提高效率会尽可能避免IP的分片&#x2F;重组操作；TCP根据MSS和MTU限定每个分节的大小以及SCTP根据MTU分片&#x2F;重组过长的记录都是这个目的</p>
</li>
<li><p>不论是否分片，都由IP作为链路层的SDU传入链路层，并由链路层封装在帧中的数据称为，分组(packet, 俗称包)</p>
</li>
<li><p>可见，一个分组既可能是一个完整的IP数据报，也可能是某个IP数据报的SDU的一个片段被冠以新的IP首部后的结果</p>
</li>
<li><p>另外，</p>
<ul>
<li>本书讨论的MSS是应用层(TCP)与传输层之间的接口属性，</li>
<li>MTU则是网络层和链路层之间的接口属性</li>
</ul>
</li>
</ul>
<h3 id="1-6"><a href="#1-6" class="headerlink" title="1.6"></a>1.6</h3><ul>
<li><p>任何现实世界的程序，都必须检查每个函数调用是否返回错误。</p>
</li>
<li><p>既然发生错误时终止程序的运行是普遍的情况，我们可以通过定义包裹函数(wrapper function)来缩短程序。</p>
</li>
<li><p>每个包括函数完成实际的函数调用，检查返回值，并在发生错误时终止进程</p>
</li>
<li><p>我们约定的包裹函数是实际函数名的首字母大写形式，例如</p>
<ul>
<li><code>sockfd = Socket(AF_INET, SOCK_STREAM, 0);</code></li>
</ul>
</li>
<li><p>其中，函数Socket是函数socket的包裹函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int Socket (int family, int type, int protocol) &#123;</span><br><span class="line">    int n;</span><br><span class="line">    if ((n = socket(family, type, protocol)) &lt; 0) &#123;</span><br><span class="line">        err_sys(&quot;socket error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这些包裹函数不见得多节省代码量，但是当我们讨论线程时，将会发现线程函数遇到错误时，并不设置标准Unix的errno变量，而是把errno的值作为函数返回值返回调用者。</p>
</li>
<li><p>这意味着每次调用以pthread_开头的某个函数时，我们必须分配一个变量来存放函数的返回值，以便在调用err_sys前把errno变量设置成该值。</p>
</li>
</ul>
<h3 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h3><ul>
<li><p>通过填写一个网际套接字地址结构并调用bind函数，服务器的众所周知端口被捆绑到所创建的套接字</p>
</li>
<li><p>指定IP地址为INADDR_ANY，这样要是服务器主机有多个网络接口，服务器就可以在任意网络接口上接收客户端连接</p>
</li>
<li><p>调用listen函数把该套接字转换成一个监听套接字，这样来自客户的外来连接就可在该套接字上由内核接受</p>
</li>
<li><p>socket, bind和listen这3个调用步骤是任何TCP服务器准备所谓的监听描述符(listening descriptor)的正常步骤</p>
</li>
<li><p>常值LISTENQ在<code>unp.h</code>头文件中定义。它指定系统内核允许在这个监听描述符上排队的最大客户连接数</p>
</li>
</ul>
<h3 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h3><ul>
<li>通常情况下，服务器进程在accept调用中被投入睡眠，等待某个客户连接的到达并被内核接受</li>
<li>TCP连接使用所谓的三路握手(three-way handshake)来建立连接。<ul>
<li>三次握手在socket API中内部实现，调用该接口时，不需要关心(Unix system programming,line:1807)</li>
</ul>
</li>
<li>握手完毕时accept返回，其返回值是一个称为已连接描述符(connected descriptor)的新描述符</li>
<li>该描述符用于与新近连接的那个客户端通信。</li>
<li>accept为每个连接到本服务器的客户端返回一个新描述符</li>
</ul>
<h3 id="1-9"><a href="#1-9" class="headerlink" title="1.9"></a>1.9</h3><ul>
<li><p>服务器通过调用close关闭与客户的连接。</p>
</li>
<li><p>该调用引发正常的TCP连接终止序列：每个方向上发送一个FIN，每个FIN又由各自的对端确认</p>
</li>
<li><p>总结</p>
<ul>
<li>如果服务器需要用较多时间服务每个客户，那么必须以某种方式重叠对各个客户的服务，这种服务器被称为迭代服务器(iterative server)。因为对于每个客户它都迭代执行一次</li>
<li>同时能处理多个客户的并发服务器(concurrent server)有多种编写技术<ul>
<li>最简单的技术是调用Unix的fork函数，为每个客户创建一个子进程</li>
<li>其他技术包括使用线程代替fork，或在服务器启动时预先fork一定数量的子进程</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-0"><a href="#2-0" class="headerlink" title="2.0"></a>2.0</h3><ul>
<li><p>描述一个网络中各个协议层的常用方法是使用国际标准化组织(International Organization for Standardization, ISO)的计算机通信开发系统互连(open systems interconnection, OSI)模型。</p>
</li>
<li><p>这是一个七层模型：</p>
<ul>
<li>应用程</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
</li>
<li><p>我们认为OSI模型的底下两层是随系统提供的设备驱动程序和网络硬件。</p>
</li>
<li><p>通常情况下，除需要知道数据链路的某些特性外，不必太关心这两层的具体情况</p>
</li>
<li><p>网络层，由IPv4和IPv6这两个协议处理</p>
</li>
<li><p>可以选择的传输层有TCP或UDP</p>
</li>
<li><p>TCP与UDP，之间留有缝隙，表明网络应用绕过传输层直接使用IPv4和IPv6是有可能的，这就是所谓的原始套接字(raw socket)</p>
</li>
<li><p>OSI模型的顶上三层被合并成一层，称为应用层。</p>
</li>
<li><p>这就是Web客户(浏览器)，Telnet客户，Web服务器，FTP服务器和其他我们在使用的网络应用所在的层</p>
</li>
<li><p>对于网际协议，OSI模型的顶上三层协议几乎没有区别</p>
</li>
<li><p>本书讲述的套接字编程接口是从顶上三层(网际协议的应用程)进入传输层的接口</p>
</li>
<li><p>本书的焦点是：如何使用套接字编写使用TCP或UDP的网络应用程序。</p>
</li>
<li><p>为什么套接字提供的是从OSI模型的顶上三层进入传输层的接口？</p>
</li>
<li><p>这样设计有两个理由</p>
<ul>
<li>一，顶上三层处理具体网络应用的所有细节，却对通信细节了解很少；底下四层对具体网络应用了解不多，却处理所有的通信细节：发送数据，等待确认，给无序到达的数据排序，计算并验证校验和，等等</li>
<li>二，顶上三层通常构成所谓的用户进程(user process)，底下四层却通常作为操作系统内核的一部分提供。Unix与其他现代操作系统都提供分隔用户进程和内核的机制。</li>
<li>由此可见，第四层和第五层之间的接口是构建API的自然位置</li>
</ul>
</li>
</ul>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><ul>
<li>POSIX(可移植操作系统接口)，是Portable Operating System Inteface的首字母缩写。</li>
<li>它并不是单个标准，而是由电气与电子工程学会(the Institute for Electrical and Electronics Engineers Inc)即IEEE开发的一系列标准  </li>
<li>具体可查看<code>http://www.pasc.org/standing/sdll.html</code></li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="1-1-1"><a href="#1-1-1" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>TCP提供客户与服务器之间的连接。</p>
</li>
<li><p>TCP客户先与某个给定服务器建立一个连接，再跨该连接与那个服务器交换数据，然后终止这个连接</p>
</li>
<li><p>三路握手</p>
<ul>
<li>服务器必须准备好接受外来的连接。</li>
<li>这通常通过调用socket，bind和listen三个函数来完成，我们称之为被动打开(passive open)</li>
<li>客户通过调用connect发起主动打开(active open)</li>
</ul>
</li>
<li><p>四次挥手</p>
<ul>
<li>某个应用进程首先调用close，我们称该端执行主动关闭(active close)</li>
<li>接收到这个FIN的对端执行被动关闭(passive close)</li>
</ul>
</li>
</ul>
<h3 id="1-2-1"><a href="#1-2-1" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li><p>TIME_WAIT状态有两个存在的理由：</p>
<ul>
<li>可靠地实现TCP全双工连接的终止</li>
<li>允许老的重复分节在网络中消逝</li>
</ul>
</li>
<li><p>套接字对</p>
<ul>
<li>一个TCP连接的套接字对(socket pair)，是一个定义该连接的两个端点的四元组</li>
<li>本地IP地址，本地TCP端口号，外地IP地址，外地TCP端口号</li>
</ul>
</li>
<li><p>套接字对，唯一标识一个网络上的每个TCP连接</p>
</li>
<li><p>标识每个端点的两个值（IP地址和端口号）通常称为一个，套接字</p>
</li>
</ul>
<h2 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h2><h3 id="1-1-2"><a href="#1-1-2" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>IPv4套接字地址结构，通常也称为“网际套接字地址结构”，它以sockaddr_in命名，定义在&lt;netinet&#x2F;in.h&gt;头文件中</p>
</li>
<li><p>通用套接字地址结构</p>
<ul>
<li>当作为一个参数传递进任何套接字函数时，套接字地址结构总是以引用形式(也就是以指向该结构的指针)来传递。</li>
</ul>
</li>
<li><p>在如何声明所传递指针的数据类型上存在一个问题。有了ANSI C后解决办法很简单:void *是通用的指针类型</p>
</li>
<li><p>在1982年采取的办法是在&lt;sys&#x2F;socket.h&gt;头文件中定义一个通用的套接字地址结构</p>
</li>
</ul>
<h3 id="1-2-2"><a href="#1-2-2" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li>前面提到过，当往一个套接字函数传递一个套接字地址结构时，该结构总是以引用形式来传递，也就是说传递的是指向该结构的一个指针。</li>
<li>该结构的长度也作为一个参数来传递，不过其传递方式取决于该结构的传递方向：是从进程到内核，还是从内核到进程<ul>
<li>从进程到内核传递套接字地址结构的函数有三个：bind，connect和sendto。指针和指针所指内容的大小都传递给内核，这样内核知道到底需从进程复制多少数据进来</li>
<li>从内核到进程传递套接字地址结构的函数有四个：accept，recvfrom，getsockname和getpeername。把套接字地址结构大小这个参数从一个整数改为指向某个整数变量的指针，其原因在于：<ul>
<li>当函数被调用时，结构大小是一个值(value)，它告诉内核该结构的大小，这样内核在写该结构时不至于越界</li>
<li>当函数返回时，结构大小又是一个结果(result)，它告诉进程，内核在该结构中究竟存储了多少信息</li>
<li>这种类型的参数称为“值-结果(value-result)”参数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-3-1"><a href="#1-3-1" class="headerlink" title="1.3"></a>1.3</h3><ul>
<li><p>考虑一个16位整数，它由2个字节组成。</p>
</li>
<li><p>内存中存储这两个字节有两种方法</p>
<ul>
<li>一种是将低序字节存储在起始地址，这称为小端(little-endian)字节序</li>
<li>另一种方法是将高序字节存储在起始地址，这称为大端(big-endian)字节序</li>
</ul>
</li>
<li><p>遗憾的是，这两种字节序之间没有标准可循，两种格式都有系统使用。</p>
</li>
<li><p>我们把某个给定系统所用的字节序称为主机字节序(host byte order)</p>
</li>
<li><p>网络协议指定一个网络字节序(network byte order)</p>
</li>
<li><p>在每个TCP分节中都有16位的端口号和32位的IPv4地址。发送协议栈和接收协议栈必须就这些多字节字段各个字节的传送顺序达成一致。</p>
</li>
<li><p>网际协议使用大端字节序来传送这些多字节整数</p>
</li>
</ul>
<h3 id="1-4-1"><a href="#1-4-1" class="headerlink" title="1.4"></a>1.4</h3><ul>
<li><p>inet_aton, inet_addr和inet_ntoa在 点分十进制数串 与 它长度为32位的网络字节序二进制值 间转换IPv4地址</p>
</li>
<li><p>inet_ntoa函数将一个32位的网络字节序二进制IPv4地址转换成响应的点分十进制数串</p>
</li>
<li><p>由该函数的返回值指向的字符串驻留在静态内存中。这意味着该函数是不可重入的</p>
</li>
<li><p>该函数以一个结构而不是以指向该结构的一个指针作为其参数</p>
<ul>
<li>“函数以结构为参数是罕见的，更常见的是以指向结构的指针为参数”</li>
</ul>
</li>
</ul>
<h3 id="1-5-1"><a href="#1-5-1" class="headerlink" title="1.5"></a>1.5</h3><ul>
<li>字节流套接字（例如TCP套接字）上的 read 和 write 函数所表现的行为不同于通常的文件I&#x2F;O。</li>
<li>字节流套接字上调用 read 和 write 输入或输出的字节数可能比请求的数量少，然而这不是出错的状态。</li>
<li>这个现象的原因在于内核中用于套接字的缓冲区可能已达到了极限。此时所需的是调用者再次调用 read 或 write函数，以输出或输出剩余的字节</li>
</ul>
<h2 id="基本TCP套接字编程"><a href="#基本TCP套接字编程" class="headerlink" title="基本TCP套接字编程"></a>基本TCP套接字编程</h2><h3 id="1-1-3"><a href="#1-1-3" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>socket函数在成功时返回一个小的非负整数值，它与文件描述符类似，我们把它称为套接字描述符(socket descriptor)，简称sockfd。</p>
</li>
<li><p>为了得到这个套接字描述符，我们只是指定了协议族(IPv4,IPv6或Unix)和套接字类型(字节流，数据报或原始套接字)。</p>
</li>
<li><p>我们并没有指定本地协议地址和远程协议地址</p>
</li>
<li><p>对比 AF_XXX 和 PF_XXX</p>
<ul>
<li>AF_ 前缀表示地址族，PF_ 前缀表示协议族</li>
</ul>
</li>
<li><p>TCP客户用connect函数来建立与TCP服务器的连接</p>
</li>
<li><p>客户在调用函数connect前不必非得调用bind函数，因为如果需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口</p>
</li>
<li><p>bind函数把一个本地协议地址赋予一个套接字。对于网际网协议，协议地址是32为的IPv4地址或128位的Ipv6地址与16位的TCP或UDP端口号的组合</p>
</li>
<li><p>服务器在启动时捆绑它们的众所周知端口。如果一个TCP客户或服务器未曾调用bind捆绑一个端口，当调用connect或listen时，内核就要为相应的套接字选择一个临时端口。</p>
</li>
<li><p>让内核来选择临时端口对于TCP客户来说是正常的，除非应用需要一个预留端口；然而对于TCP服务器来说却极为罕见，因为服务器是通过它们的众所周知端口被大家认识的</p>
<ul>
<li>这个规则的例外是远程过程调用(Remote Procedure Call, RPC)服务器，它们通常就由内核为它们的监听套接字选择一个临时端口，而该端口随后通过RPC端口映射器进行注册。</li>
<li>客户在connect这些服务器之间，必须与端口映射器联系以获取它们的临时端口，这种秦广也适用于使用UDP的RPC服务器</li>
</ul>
</li>
<li><p>捆绑(binding)操作涉及三个对象：套接字，地址及端口。</p>
<ul>
<li>其中套接字是捆绑的主体，地址和端口是捆绑在套接字上的客体</li>
</ul>
</li>
<li><p>如果指定端口号为0，那么内核就在bind被调用时选择一个临时端口。</p>
</li>
<li><p>然而如果指定IP地址为通配地址，那么内核将等到套接字已连接(TCP)或已在套接字上发出数据包(UDP)时才选择一个本地IP地址</p>
</li>
<li><p>对于IPv4来说，通配地址由常值INADDR_ANY来指定，其值一般为0</p>
</li>
<li><p>如果让内核来为套接字选择一个临时端口号，那么必须注意，函数bind并不返回所选择的值。为了得到内核所选择的这个临时值，必须调用函数getsockname来返回协议地址</p>
</li>
<li><p>到达(arriving)和接收(received)</p>
<ul>
<li>这两个修饰词，它们具有相同的含义，只是视角不同而已</li>
<li>譬如说一个分组的到达接口和接收接口指的是同一个接口，前者在接收主机以外看待这个接口，后者在接收主机以内看待这个接口</li>
</ul>
</li>
</ul>
<h3 id="1-2-3"><a href="#1-2-3" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li><p>listen函数仅由TCP服务器调用，它做两件事情</p>
<ul>
<li>当socket函数创建一个套接字时，它被假设为一个主动套接字，也就是说，它是一个将调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接收指向该套接字的连接请求。调用listen导致套接字从CLOSE状态转换到LISTEN状态</li>
<li>第二个参数规定了内核应该为相应套接字排队的最大连接个数</li>
</ul>
</li>
<li><p>为了理解第二个参数backlog参数，我们必须认识到内核为任何一个给定的监听套接字维护两个队列：</p>
<ul>
<li>未完成连接队列(incomplete connection queue)，每个这样的SYN分节对应其中一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三路握手过程。这些套接字处于SYN_RCVD状态</li>
<li>已完成连接队列(completed connection queue)，每个已完成TCP三路握手过程的客户对应其中一项，这些套接字处于ESTABLISHED状态</li>
</ul>
</li>
</ul>
<h3 id="1-3-2"><a href="#1-3-2" class="headerlink" title="1.3"></a>1.3</h3><ul>
<li><p>accept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程被投入睡眠(假定套接字为默认的阻塞方式)</p>
</li>
<li><p>声明</p>
<ul>
<li><code>#include &lt;sys/socket.h&gt;</code></li>
<li><code>int accept (int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);</code></li>
</ul>
</li>
<li><p>参数cliaddr和addrlen用来返回已连接的对端进程(客户)的协议地址。addrlen是值-结果参数；调用前，我们将由*addrlen所引用的整数值置为由cliaddr所指的套接字地质结构的长度，返回时，该整数值即为由内核存放在该套接字地址结构内的确切字节数</p>
</li>
<li><p>如果accept成功，那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户的TCP连接</p>
</li>
<li><p>在讨论accept函数时，我们称它的第一个参数为监听套接字(listening socket)描述符(由socket创建，随后用作bind和listen的第一个参数的描述符)，称它的返回值为已连接套接字(connect socket)描述符。</p>
</li>
<li><p>区分这两个套接字非常重要！</p>
<ul>
<li>一个服务器通常仅仅创建一个监听套接字，它在该服务器的生命期内一直存在。</li>
<li>内核为每个由服务器进程接受的客户连接创建一个已连接套接字(也就是说对于它的TCP三路握手过程已经完成)。当服务器完成对某个给定客户的服务时，相应的已连接套接字就被关闭</li>
</ul>
</li>
<li><p>accept函数最多返回三个值</p>
<ul>
<li>一个既可能是新套接字描述符也可能是出错指示的整数</li>
<li>客户进程的协议地址(由cliaddr指针所指)以及该地址的大小(由addrlen指针所指)。如果我们对返回客户协议地址不感兴趣，那么可以把cliaddr和addrlen均置为空指针</li>
</ul>
</li>
</ul>
<h3 id="1-4-2"><a href="#1-4-2" class="headerlink" title="1.4"></a>1.4</h3><ul>
<li><p>在阐述如何编写并发服务器程序之前，我们必须首先介绍一下Unix的fork函数。</p>
</li>
<li><p>该函数（包括有些系统可能提供的它的各种变体），是Unix中派生新进程的唯一方法。</p>
</li>
<li><p>如果以前从未接触过该函数，那么理解fork最困难之处在于调用它一次，它却返回两次。它在调用进程（称为父进程）中返回一次，返回值是新派生进程（称为子进程）的进程ID号；在子进程又返回一次，返回值为0.</p>
</li>
<li><p>因此，返回值本身告知当前进程是子进程还是父进程。</p>
</li>
<li><p>fork在子进程返回 0 而不是父进程的 进程ID 的原因在于：</p>
<ul>
<li>任何子进程只有一个父进程，而且子进程总是可以通过调用 getppid 取得父进程的进程ID。</li>
<li>相反，父进程可以有许多子进程，而且无法获取各个子进程的进程ID。如果父进程想要跟踪所有子进程的进程ID，那么它必须记录每次调用 fork 的返回值</li>
</ul>
</li>
<li><p>父进程中调用 fork 之前打开的所有描述符在 fork 返回之后由子进程分享。</p>
</li>
<li><p>我们将看到网络服务器利用了这个特性：</p>
<ul>
<li>父进程调用 accept 之后调用fork。所接受的已连接套接字随后就在父进程与子进程之间共享。</li>
<li>通常情况下，子进程接着读写这个已连接套接字，父进程则关闭这个已连接套接字</li>
</ul>
</li>
<li><p>fork 有两个典型用法</p>
<ul>
<li>一个进程创建一个自身的副本，这样每个副本都可以在另一个副本执行其他任务的同时处理自己的某个操作。这是网络服务器的典型用法</li>
<li>一个进程想要执行另一个程序。既然创建新进程的唯一办法是调用 fork，该进程于是首先调用 fork 创建一个自身的副本，然后其中一个副本（通常为子进程）调用 exec 把自身替换成新的程序。这是诸如 shell 之类程序的典型用法</li>
</ul>
</li>
<li><p>存放在硬盘上的可执行程序文件能够被 Unix 执行的唯一方法是：由一个现有进程调用六个 exec 函数中的某一个。（当这六个函数中是哪一个被调用并不重要时，我们往往把它们统称为 exec 函数。）</p>
</li>
<li><p>exec 把当前进程映像替换成新的程序文件，而且该新程序通常从 main 函数开始执行。进程ID并不改变。我们称调用 exec 的进程为调用进程(calling process)，称新执行的程序为新程序(new program)</p>
</li>
<li><p>这六个 exec 函数之间的区别在于：</p>
<ul>
<li>待执行的程序文件是由文件名(filename)还是由路径名(pathname)指定；</li>
<li>新程序的参数是一一列出还是由一个指针数组来引用；</li>
<li>把调用进程的环境传递给新程序还是给新程序指定新的环境。</li>
</ul>
</li>
<li><p>这些函数只在出错时才返回到调用者。否则，控制将被传递给新程序的起始点，通常就是 main 函数</p>
</li>
<li><p>这六个函数，一般来说，只有 execve 是内核中的系统调用，其他五个都是调用 execve 的库函数（91页，关系图）</p>
</li>
</ul>
<h3 id="1-5-2"><a href="#1-5-2" class="headerlink" title="1.5"></a>1.5</h3><ul>
<li><p>当服务一个客户请求可能花费较长时间时，我们并不希望整个服务器被单个客户长期占用，而是希望同时服务多个客户。</p>
</li>
<li><p>Unix中编写并发服务器程序最简单的办法就是 fork 一个子进程来服务每个客户</p>
</li>
<li><p>当一个连接建立时，accept 返回，服务器接着调用 fork，然后由子进程服务客户（通过已连接套接字 connfd），父进程则等待另一个连接（通过监听套接字 listenfd）。</p>
</li>
<li><p>既然新的客户由子进程提供服务，父进程就关闭已连接套接字</p>
</li>
<li><p>对一个TCP套接字调用 close 会导致发送一个 FIN，随后是正常的TCP连接终止序列。为什么父进程对 connfd 调用 close 没有终止它与客户的连接呢？</p>
<ul>
<li>为了便于理解，我们必须知道每个文件或套接字都有一个引用计数。引用计数在文件表项中维护，它是当前打开着的引用该文件或套接字的描述符的个数。</li>
<li>socket 返回后与 listenfd 关联的文件表项的引用计数值为1。 accept 返回后与 connfd 关联的文件表项的引用计数也为1。</li>
<li>然后 fork 返回后，这两个描述符就在父进程与子进程间共享（也就是被复制），因此与这两个套接字相关联的文件表项各自的访问计数值均为2.这么一来，当父进程关闭connfd时，它只是把相应的引用计数值从2减为1.</li>
<li>该套接字真正的清理和资源释放要等到其引用计数值到达0时才发生。这会在稍后子进程也关闭connfd时发生。</li>
</ul>
</li>
</ul>
<h3 id="1-6-1"><a href="#1-6-1" class="headerlink" title="1.6"></a>1.6</h3><ul>
<li><p>通常的Unix close函数也用来关闭套接字，并终止TCP连接</p>
</li>
<li><p>close一个TCP套接字的默认行为，是把该套接字标记成已关闭，然后立即返回到调用进程。</p>
</li>
<li><p>该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的第一个参数。</p>
</li>
<li><p>然而TCP将尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接终止序列</p>
</li>
<li><p>如果我们确实想在某个TCP连接上发送一个FIN，那么可以改用shutdown函数以代替close</p>
</li>
<li><p>我们还得清楚，如果父进程对每个由 accept 返回的已连接套接字都不调用close，那么并发服务器中将会发生什么？</p>
<ul>
<li>首先，父进程最终将耗尽可用描述符，因为任何进程再任何时刻可拥有的打开着的描述符通常是有限制的</li>
<li>不过更重要的是，没有一个客户连接会被终止。当子进程关闭已连接套接字时，它的引用计数值由2递减为1且保持为1，因为父进程永不关闭任何已连接套接字。这将妨碍TCP连接终止序列的发生，导致连接一直打开着</li>
</ul>
</li>
</ul>
<h3 id="1-7-1"><a href="#1-7-1" class="headerlink" title="1.7"></a>1.7</h3><ul>
<li><p>getsockname 和 getpeername两个函数，</p>
<ul>
<li>或者返回与某个套接字关联的本地协议地址(getsockname)，</li>
<li>或者返回某个套接字关联的外地协议地址(getpeername)</li>
</ul>
</li>
<li><p>需要注意的是，这两个函数的最后一个参数都是值-结果参数。这就是说，这两个函数都得装填由localaddr或peeraddr指针所指向的套接字地址结构</p>
</li>
<li><p>需要这两个函数的理由如下：</p>
<ul>
<li>在一个没有调用bind的TCP客户上，connect成功返回之后，getsockname用于返回由内核赋予该连接的本地IP地址和本地端口号</li>
<li>在以端口号0调用bind(告知内核去选择本地端口号)后，getsockname用于返回由内核赋予的本地端口号</li>
<li>getsockname可用于获取某个套接字的地址族</li>
<li>在一个以通配IP地址调用bind的TCP服务器上，与某个客户的连接一旦建立(accept成功返回)，getsockname就可以用于返回由内核赋予该连接的本地IP地址。在这样的调用中，套接字描述符必须是已连接套接字的描述符，而不是监听套接字的描述符</li>
<li>当一个服务器是由调用过accept的某个进程通过调用exec执行程序时，它能够获取客户身份的唯一途径便是调用getpeername</li>
</ul>
</li>
</ul>
<h2 id="TCP客户-服务器程序示例"><a href="#TCP客户-服务器程序示例" class="headerlink" title="TCP客户&#x2F;服务器程序示例"></a>TCP客户&#x2F;服务器程序示例</h2><h3 id="1-1-4"><a href="#1-1-4" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>信号(signal)，就是告知某个进程发生了某个事件的通知，有时也称为软件中断(software interrupt)。</p>
</li>
<li><p>信号通常是异步发生的，也就是说进程预先不知道信号的准确发生时刻</p>
</li>
<li><p>信号可以：</p>
<ul>
<li>由一个进程发给另一个进程（或自身）</li>
<li>由内核发给某个进程</li>
</ul>
</li>
<li><p>每个信号都有一个与之关联的处置(disposition)，也称为行为(action)。我们通过调用sigaction函数来设定一个信号的处置，并有三种选择</p>
<ul>
<li>我们可以提供一个函数，只要有特定信号发生它就被调用。这样的函数称为信号处理函数(signal handler)，这种行为称为捕获(catching)信号。有两个信号不能被捕获，它们是SIGKILL和SIGSTOP。信号处理函数由信号值这个单一的整数参数来调用，且没有返回值，其原型为<code>void handler(int signo);</code>(信号处理函数，也称为信号处理程序，这是相对于main函数所在的主程序而言的)。对于大多数信号来说，调用sigaction函数并指定信号发生时所调用的函数就是捕获信号所需做的全部工作。</li>
<li>我们可以把某个信号的处置设定为SIG_IGN来忽略(ignore)它。SIGKILL和SIGSTOP这两个信号不能被忽略</li>
<li>我们可以把某个信号的处置设定SIG_DFL来启用它的默认处置。默认处置，通常是收到信号后终止进程，其中某些信号还在当前工作目录产生一个进程的核心映像(core image,也称为内存影像)</li>
</ul>
</li>
</ul>
<h3 id="1-2-4"><a href="#1-2-4" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li><p>设置僵死(zombie)状态的目的，是维护子进程的信息，以便父进程在以后某个时候获取。这些信息包括子进程的进程ID，终止状态以及资源利用信息（CPU时间，内存使用量等）</p>
</li>
<li><p>如果一个进程终止，而该进程有子进程处于僵死状态，那么它的所有僵死子进程的父进程ID将被重置为1（init进程）。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵死状态）</p>
</li>
<li><p>我们显然不愿意留存僵死进程。它们占用内核中的空间，最终可能导致我们耗尽进程资源</p>
</li>
<li><p>无论何时我们fork子进程都得wait它们，以防它们变成僵死进程。为此我们建立一个俘获SIGCHLD信号的信号处理函数，在函数体中我们调用wait</p>
</li>
</ul>
<h3 id="1-3-3"><a href="#1-3-3" class="headerlink" title="1.3"></a>1.3</h3><ul>
<li><p>我们用术语慢系统调用(slow system call)描述过accept函数，该术语也适用于那些可能永远阻塞的系统调用。永远阻塞的系统调用是指调用有可能永远无法返回，多数网络支持函数都属于这一类。</p>
</li>
<li><p>一个值得注意的例外是磁盘I&#x2F;O，它们一般都会返回到调用者（假设没有灾难性的硬件故障）</p>
</li>
<li><p>适用于慢系统调用的基本规则是：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误</p>
</li>
<li><p>本节的目的是示范我们在网络编程时可能会遇到的三种情况</p>
<ul>
<li>当fork子进程时，必须捕获SIGCHLD信号</li>
<li>当捕获信号时，必须处理被中断的系统调用</li>
<li>SIGCHLD的信号处理函数必须正确编写，应使用waitpid函数以免留下僵死进程</li>
</ul>
</li>
</ul>
<h3 id="1-4-3"><a href="#1-4-3" class="headerlink" title="1.4"></a>1.4</h3><ul>
<li><p>当我们的服务器进程正在运行时，服务器主机被操作员关机将会发生什么？</p>
</li>
<li><p>Unix系统关机时，init进程通常先给所有进程发送SIGTERM信号（该信号可被捕获），等待一段固定的时间（往往在5到20秒之间），然后给所有仍在运行的进程发送SIGKILL信号（该信号不能被捕获）。这么做留给所有运行的进程一小段时间来清楚和终止。如果我们不捕获SIGTERM信号并终止，我们的服务器将由SIGKILL信号终止</p>
</li>
<li><p>如果我们忽略SIGTERM信号，我们的服务器将由SIGKILL信号终止。SIGTERM信号的默认处置就是终止进程，因此要是我们不捕获它（也不忽略它），那么起作用的是它的默认处置，我们的服务器将被SIGTERM信号终止，SIGKILL信号不可能再发送给他</p>
</li>
</ul>
<h3 id="1-5-3"><a href="#1-5-3" class="headerlink" title="1.5"></a>1.5</h3><ul>
<li>一般来说，我们必须关心在客户和服务器之间进行交换的数据的格式</li>
</ul>
<h2 id="I-O复用：select和poll函数"><a href="#I-O复用：select和poll函数" class="headerlink" title="I&#x2F;O复用：select和poll函数"></a>I&#x2F;O复用：select和poll函数</h2><h3 id="1-1-5"><a href="#1-1-5" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>进程需要一种预先告知内核的能力，使得内核一旦发现进程指定的一个或多个I&#x2F;O条件就绪（也就是说输入已准备好被读取，或者描述符已能承接更多的输出），它就通知进程。这个能力称为I&#x2F;O复用(I&#x2F;O multiplexing)，是由select和poll这两个函数支持的</p>
</li>
<li><p>在介绍select和poll这两个函数之前，我们需要回顾整体，查看Unix下可用的5种I&#x2F;O模型的基本区别：</p>
<ul>
<li>阻塞式I&#x2F;O</li>
<li>非阻塞式I&#x2F;O</li>
<li>I&#x2F;O复用(select和poll)</li>
<li>信号驱动式I&#x2F;O(SIGIO)</li>
<li>异步I&#x2F;O（POSIX的aio_系列函数）</li>
</ul>
</li>
<li><p>一个输入操作通常包括两个不同的阶段：</p>
<ul>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ul>
</li>
<li><p>对于一个套接字上的输入操作，</p>
<ul>
<li>第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区</li>
<li>第二步就是把数据从内核缓冲区复制到应用进程缓冲区</li>
</ul>
</li>
<li><p>当一个应用进程像这样对一个非阻塞描述符循环调用recvfrom时，我们称之为轮询(polling)。</p>
</li>
<li><p>应用进程持续轮询内核，以查看某个操作是否就绪。这么做往往耗费大量CPU时间</p>
</li>
</ul>
<h3 id="1-2-5"><a href="#1-2-5" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li><p>有了I&#x2F;O复用(I&#x2F;O multiplexing)，我们就可以调用select或poll，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的I&#x2F;O系统调用上</p>
</li>
<li><p>我们阻塞于select调用，等待数据包套接字变为可读。当select返回套接字可读这一条件时，我们调用recvfrom把所读数据包复制到应用进程缓冲区</p>
</li>
<li><p>我们也可以用信号，让内核在描述符就绪时发送SIGIO信号通知我们。我们称这种模型为信号驱动式I&#x2F;O(signal-driven I&#x2F;O)</p>
</li>
<li><p>异步I&#x2F;O(asynchronous I&#x2F;O)由POSIX规范定义</p>
</li>
<li><p>这些函数的工作机制是：告诉内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。</p>
</li>
<li><p>这种模型与信号驱动模型主要区别在于</p>
<ul>
<li>信号驱动式I&#x2F;O，是由内核通知我们何时可以启动一个I&#x2F;O操作</li>
<li>而异步I&#x2F;O模型，是由内核通知我们I&#x2F;O操作何时完成</li>
</ul>
</li>
</ul>
<h3 id="1-3-4"><a href="#1-3-4" class="headerlink" title="1.3"></a>1.3</h3><ul>
<li><p>POSIX把同步I&#x2F;O和异步I&#x2F;O两个术语定义如下：</p>
<ul>
<li>同步I&#x2F;O操作(synchronous I&#x2F;O opetation)，导致请求进程阻塞，直到I&#x2F;O操作完成；</li>
<li>异步I&#x2F;O操作(asynchronous I&#x2F;O opetation)，不导致请求进程阻塞</li>
</ul>
</li>
<li><p>根据上述定义，前四种模型：阻塞式I&#x2F;O模型，非阻塞式I&#x2F;O模型，I&#x2F;O复用模型和信号驱动式I&#x2F;O模型都是同步I&#x2F;O模型，因为其中真正的I&#x2F;O操作(recvfrom)将阻塞进程。</p>
</li>
<li><p>只有异步I&#x2F;O模型与POSIX定义的异步I&#x2F;O相匹配</p>
</li>
</ul>
<h3 id="1-4-4"><a href="#1-4-4" class="headerlink" title="1.4"></a>1.4</h3><ul>
<li><p>select函数，允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的事件后唤醒它</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;sys/select.h&gt;</code></li>
<li><code>#include &lt;sys/time.h&gt;</code></li>
<li><code>int select (int maxfdpl, fd_set *readset, fd_set *writeset, fd_set *execptset, const struct timeval *timeout);</code></li>
</ul>
</li>
<li><p>参数timeout，它告知内核等待所指定描述符中的任何一个就绪可花多长时间。其中timeval结构用于指定这段时间的秒数和微秒数</p>
</li>
<li><p>这个参数有以下三种可能：</p>
<ul>
<li>永远等待下去：仅在有一个描述符准备好I&#x2F;O时才返回。为此，我们把该参数设置为空指针</li>
<li>等待一段固定时间：在有一个描述符准备好I&#x2F;O时返回，但是不超过由该参数所指向的timeval结构中指定的秒数和微秒数</li>
<li>根本不等待：检查描述符后立即返回，这称为轮询(polling)。为此，该参数必须指向一个timeval结构，而且其中的定时器值（由该结构指定的秒数和微秒数）必须为0.</li>
</ul>
</li>
<li><p>中间的三个参数readset，writeset和execptset指定我们要让内核测试读，写和异常条件的描述符。目前支持的异常条件只有两个：</p>
<ul>
<li>某个套接字的外带数据的到达</li>
<li>某个已置为分组模式的伪终端存在可从其主端读取的控制状态信息</li>
</ul>
</li>
<li><p>如何给这三个参数中的每一个参数指定一个或多个描述符值是一个设计上的问题。select使用描述符集，通常是一个整数数组，其中每个整数中的每一位对应一个描述符</p>
</li>
<li><p>select函数的中间三个参数readset，writeset和exceptset中，如果我们对某一个的条件不感兴趣，就可以把它设为空指针</p>
</li>
<li><p>maxfdpl参数指定待测试的描述符个数，它的值是待测试的最大描述符加1（因此我们把该参数命名为maxfdp1）</p>
</li>
<li><p>select函数修改由指针readset，writeset和exceptset所指向的描述符集，因而这三个参数都是值-结果参数</p>
</li>
<li><p>调用该函数时，我们指定所关心的描述符的值，该函数返回时，结果将指示哪些描述符已就绪</p>
</li>
<li><p>使用select时最常见的两个编程错误是</p>
<ul>
<li>忘了对最大描述符加1</li>
<li>忘了描述符集是值-结果参数。</li>
</ul>
</li>
</ul>
<h3 id="1-5-4"><a href="#1-5-4" class="headerlink" title="1.5"></a>1.5</h3><ul>
<li><p>终止网络连接的通常方法是调用close函数。不过close有两个限制，却可以使用shutdown来避免</p>
<ul>
<li>close把描述符的引用计数减一，仅在该计数变为0时才关闭套接字。使用shutdown可以不管引用计数就激发TCP的正常连接终止序列</li>
<li>close终止读和写两个方向的数据传送。既然TCP连接是全双工的，有时候我们需要告知对端我们已经完成了数据发送，即使对端仍有数据要发送给我们</li>
</ul>
</li>
<li><p>声明</p>
<ul>
<li><code>#include &lt;sys/socket.h&gt;</code></li>
<li><code>int shutdown (int sockfd, int howto);</code></li>
</ul>
</li>
<li><p>该函数的行为依赖于howto参数的值</p>
<ul>
<li>SHUT_RD，关闭连接的读这一半 – 套接字中不再有数据可接收，而且套接字接受缓冲区中的现有数据都被丢弃</li>
<li>SHUT_WR，关闭连接的写这一半 –  对于TCP套接字，这称为半关闭(half-close)</li>
<li>SHUT_RDWR，连接的读半部和写半部都关闭 –  这与调用shutdown两次等效：第一次调用指定SHUT_RD，第二次调用指定SHUT_WR</li>
</ul>
</li>
</ul>
<h3 id="1-6-2"><a href="#1-6-2" class="headerlink" title="1.6"></a>1.6</h3><ul>
<li>pselect函数是由POSIX发明的，如今有许多Unix变种支持它</li>
<li>pselect相对于通常的select有两个变化<ul>
<li>pselect使用timespec结构，而不使用timeval结构。timespec结构是POSIX的又一个发明</li>
<li>pselect函数增加了第六个参数：一个指向信号掩码的指针。</li>
</ul>
</li>
</ul>
<h3 id="1-7-2"><a href="#1-7-2" class="headerlink" title="1.7"></a>1.7</h3><ul>
<li>poll提供的功能与select类似，不过在处理流设备时，它能够提供额外的信息</li>
<li>声明<ul>
<li><code>#include &lt;poll.h&gt;</code></li>
<li><code>int poll (struct pollfd *fdarray, unsigned long nfds,int timeout);</code></li>
</ul>
</li>
<li>第一个参数是指向一个结构数组第一个元素的指针。每个数组元素都是一个pollfd结构，用于指定测试某个给定描述符fd的条件</li>
<li>timeout参数指定poll函数返回前等待多长时间。它是一个指定应等待毫秒数的正值</li>
</ul>
<h2 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h2><h3 id="1-1-6"><a href="#1-1-6" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>有很多方法来获取和设置影响套接字的选项</p>
<ul>
<li>getsockopt和setsockopt函数 </li>
<li>fcntl函数</li>
<li>ioctl函数</li>
</ul>
</li>
<li><p>套接字选项粗分为两大基本类型：</p>
<ul>
<li>一是，启用或禁止某个特性的二元选项（称为标志选项）</li>
<li>二是，取得并返回我们可以设置或检查的特定值的选项（称为值选项）</li>
</ul>
</li>
</ul>
<h3 id="1-2-6"><a href="#1-2-6" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li><p>与代表”file control”（文件控制）的名字相符，fcntl函数可执行各种描述符控制操作</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;fcntl.h&gt;</code></li>
<li><code>int fcntl (int fd, int cmd, ... /*int arg*/);</code></li>
</ul>
</li>
<li><p>每种描述符（包括套接字描述符）都有一组由F_GETFL命令获取或由F_SETFL命令设置的文件标志。</p>
</li>
<li><p>其中影响套接字描述符的两个标志是：</p>
<ul>
<li>O_NONBLOCK  –  非阻塞式I&#x2F;O</li>
<li>O_ASYNC     –  信号驱动式I&#x2F;O</li>
</ul>
</li>
<li><p>设置某个文件状态标志的唯一正确的方法是：先取得当前标志，与新标志逻辑或后再设置标志</p>
</li>
</ul>
<h2 id="名字与地址转换"><a href="#名字与地址转换" class="headerlink" title="名字与地址转换"></a>名字与地址转换</h2><h3 id="1-1-7"><a href="#1-1-7" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>到目前为止，本书中所有例子都用数值地址来表示主机，用数值端口号来标识服务器，然而出于许多理由，我们应该使用名字而不是数值</p>
</li>
<li><p>名字比较容易记住，数值地址可以变动而名字保持不变，随着往IPv6上转移，数值地址变得相当长，手工键入数值地址更易出错</p>
</li>
<li><p>gethostbyname和gethostbyaddr在主机名字与IPv4地址之间转换</p>
</li>
<li><p>getservbyname和getservbyport在服务名字和端口号之间进行转换</p>
</li>
<li><p>getaddrinfo和getnameinfo，分别用于主机名字和IP地址之间以及服务名字和端口号之间的转换</p>
</li>
</ul>
<h3 id="1-2-7"><a href="#1-2-7" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li><p>域名系统(Domain Name System, DNS)，主要用于主机名字和IP地址之间的映射</p>
</li>
<li><p>DNS中的条目称为资源记录(resource record, RR)</p>
</li>
<li><p>每个组织机构往往运行一个或多个名字服务器(name server)，它们通常就是所谓的BIND(Berkeley Internet Name Domain)程序</p>
</li>
<li><p>诸如我们在本书中编写的客户和服务器等应用程序通过调用称为解析器(resolver)的函数库中的函数接触DNS服务器</p>
</li>
<li><p>常见的解析器函数是gethostbyname和gethostbyaddr，前者把主机名映射成IPv4地址，后者则执行相反的映射</p>
</li>
</ul>
<h3 id="1-3-5"><a href="#1-3-5" class="headerlink" title="1.3"></a>1.3</h3><ul>
<li><p>查找主机名最基本的函数是gethostbyname。如果调用成功，它就返回一个指向hostent结构的指针，该结构中含有所查找主机的所有IPv4地址。这个函数的局限是只能返回IPv4地址，而getaddrinfo函数能够同时处理IPv4地址和IPv6地址</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;netdb.h&gt;</code></li>
<li><code>struct hostent *gethostbyname (const char *hostname);</code></li>
</ul>
</li>
<li><p>gethostbyaddr函数试图由一个二进制的IP地址找到相应的主机名，与gethostbyname的行为刚好相反</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;netdb.h&gt;</code></li>
<li><code>struct hostent *gethostbyaddr(const char *addr, socklent len, int family);</code></li>
</ul>
</li>
</ul>
<h3 id="1-3-6"><a href="#1-3-6" class="headerlink" title="1.3"></a>1.3</h3><ul>
<li>tcp_listen执行TCP服务器的通常步骤：创建一个TCP套接字，给他捆绑服务器的众所周知端口，并允许接受外来的连接请求</li>
<li>实现步骤：<ul>
<li>调用getaddrinfo</li>
<li>创建套接字并给他捆绑地址</li>
</ul>
</li>
</ul>
<h2 id="守护进程和inetd超级服务器"><a href="#守护进程和inetd超级服务器" class="headerlink" title="守护进程和inetd超级服务器"></a>守护进程和inetd超级服务器</h2><h3 id="1-1-8"><a href="#1-1-8" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>守护进程(daemon)，是在后台运行且不与任何控制终端关联的进程。Unix系统通常有很多守护进程在后台运行（约在20到50个的量级），执行不同的管理任务。</p>
</li>
<li><p>守护进程没有控制终端通常源于它们由系统初始化脚本启动。然而守护进程也可能从某个终端由用户在shell提示符下键入命令启动，这样的守护进程必须亲自脱离与控制终端的关联，从而避免与作业控制，终端会话管理，终端产生信号等发生任何不期望的交互，也可以避免在后台运行的守护进程非预期地输出到终端。</p>
</li>
<li><p>守护进程有多种启动方法：</p>
<ul>
<li>在系统启动阶段，许多守护进程由系统初始化脚本启动。这些脚本通常位于<code>/etc/</code>目录或以<code>/etc/rc</code>开头的某个目录中，它们的具体位置和内容却是实现相关的。由这些脚本启动的守护进程一开始时拥有超级用户特权。有若干个网络服务器通常从这些脚本启动：inetd超级服务器，Web服务器，邮件服务器</li>
<li>许多网络服务器由inetd超级服务器启动。inetd自身由上一条中的某个脚本启动。inetd监听网络请求(Telnet, FTP)等，每当有一个请求到达时，启动相应的实际服务器(Telnet服务器，FTP服务器等）；</li>
<li>cron守护进程按照规则定期执行一些程序，而由它启动执行的程序同样作为守护进程运行。cron自身由第一条启动方法中的某个脚本启动</li>
<li>at命令用于指定将来某个时刻的程序执行。这些程序的执行时刻到来时，通常由cron守护进程启动执行它们，因此这些程序同样作为守护进程运行</li>
<li>守护进程还可以从用户终端或在前台后在后台启动。</li>
</ul>
</li>
<li><p>因为守护进程没有控制终端，所以当有事发生时它们得有输出消息的某种方法可用，而这些消息既可能是普通的通告性消息，也可能是需由系统管理员处理的紧急事件消息。</p>
</li>
<li><p>syslog函数，是输出这些消息的标准方法，它把这些消息发送给syslogd守护进程</p>
</li>
</ul>
<h3 id="1-2-8"><a href="#1-2-8" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li><p>既然守护进程没有控制终端，它们就不能把消息fprintf到stderr上。从守护进程中登记消息的常用技巧就是调用syslog函数</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;syslog.h&gt;</code></li>
<li><code>void syslog(int priority, const char *message, ...);</code></li>
</ul>
</li>
<li><p>本函数的priority参数是级别(level)和设施(fcility)两者的组合</p>
<ul>
<li>日志消息的level可从0到7，它们是按从高到低的顺序排列的。如果发送者未指定level值，那就默认为LOG_NOTICE<ul>
<li><code>LOG_EMERG</code>  –  0  –  系统不可用（最高优先级）</li>
<li><code>LOG_ALERT</code>  –  1  –  必须立即采取行动</li>
<li><code>LOG_CRIT</code>   –  2  –  临界条件</li>
<li><code>LOG_ERR</code>    –  3  –  出错条件</li>
<li><code>LOG_WARNING</code>–  4  –  警告条件</li>
<li><code>LOG_NOTICE</code> –  5  –  正常然而重要的条件（默认值）</li>
<li><code>LOG_INFO</code>   –  6  –  通告消息</li>
<li><code>LOG_DEBUG</code>  –  7  –  调试级消息（最低优先级）</li>
</ul>
</li>
<li>日志消息还包含一个用于标识消息发送进程类型的facility。如果发送者未指定facility值，那就默认为LOG_USER</li>
</ul>
</li>
<li><p>facility和level的目的在于：允许在<code>/etc/syslog.conf</code>文件中统一配置来自同一给定设施的所有消息，或者统一配置具有相同级别的所有消息</p>
</li>
<li><p>当syslog被应用进程首次调用时，它创建一个Unix域数据报套接字，然后调用connect连接到由syslogd守护进程创建的Unix域数据报套接字的众所周知路径名（例如<code>/var/run/log</code>）。这个套接字一直保持打开，直到进程终止为止。</p>
</li>
<li><p>作为替换，进程也可以调用openlog和closelog：openlog可以在首次调用syslog前调用，closelog可以在应用进程不再需要发送日志消息时调用</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;syslog.h&gt;</code></li>
<li><code>void openlog(const char *ident, int options, int facility);</code></li>
<li><code>void closelog(void);</code></li>
</ul>
</li>
<li><p>ident参数，是一个由syslog冠于每个日志消息之前的字符串。它的值通常是程序名</p>
</li>
<li><p>options参数，由一个或多个常值的逻辑或构成</p>
<ul>
<li><code>LOG_CONS</code>  –  若无法发送到syslogd守护进程，则登记到控制台</li>
<li><code>LOG_NDELAY</code>–  不延迟打开，立即创建套接字</li>
<li><code>LOG_PERROR</code>–  既发送到syslogd守护进程，又登记到标准错误输出</li>
<li><code>LOG_PID</code>   –  随每个日志消息登记进程ID</li>
</ul>
</li>
<li><p>openlod的facility参数，为没有指定设施的后续syslog调用指定一个默认值</p>
</li>
</ul>
<h3 id="1-3-7"><a href="#1-3-7" class="headerlink" title="1.3"></a>1.3</h3><ul>
<li>守护进程，是在后台运行并独立于所有终端控制的进程。许多网络服务器作为守护进程运行。守护进程产生的所有输出通常通过调用syslog函数发送给syslogd守护进程。系统管理员可根据发送消息的守护进程以及消息的严重级别，完全控制这些消息的处理方式</li>
<li>启动任意一个程序并让它作为守护进程运行需要以下步骤：<ul>
<li>调用fork以转到后台运行</li>
<li>调用setsid建立一个新的POSIX会话并成为会话头进程，</li>
<li>再次fork以避免无意中获得新的控制终端，改变工作目录和文件创建模式掩码</li>
<li>最后关闭所有非必要的描述符</li>
</ul>
</li>
</ul>
<h3 id="1-4-5"><a href="#1-4-5" class="headerlink" title="1.4"></a>1.4</h3><ul>
<li>recv和send函数，类似标准的read和write函数，不过需要一个额外的参数</li>
<li>声明：<ul>
<li><code>#include &lt;sys/socket.h&gt;</code></li>
<li><code>ssize_t recv (int sockfd, void *buff, size_t nbytes, int flags);</code></li>
<li><code>ssize_t send (int sockfd, const void *buff, size_t nbytes, int flags);</code></li>
</ul>
</li>
<li>recv和send的前三个参数等同于read和write的三个参数，flags参数的值或为0.常见的逻辑或<ul>
<li><code>MSG_DONTROUTE</code>  –  绕过路由表查找，本标志告知内核目的主机在某个直接连接的本地网络上，因而无需执行路由表查找  –  send</li>
<li><code>MSG_DONTWAIT</code>   –  仅本操作非阻塞，本标志在无需打开相应套接字的非阻塞标志的前提下，把单个I&#x2F;O操作临时指定为非阻塞，接着执行I&#x2F;O操作，然后关闭非阻塞标志  –  recv，send</li>
<li><code>MSG_OOB</code>        –  发送或接收外带数据 ，对于send，本标志指明即将发送带外数据；对于recv，本标志指明即将读入的是带外数据而不是普通数据 –  recv，send</li>
<li><code>MSG_PEEK</code>       –  窥看外来消息，本标志适用于recv和recvfrom，它允许我们查看已可读取的数据，而且系统不在recv或recvfrom返回后丢弃这些数据    –  recv</li>
<li><code>MSG_WAITALL</code>    –  等待所有数据，它告知内核不要再尚未读入请求数目的字节之前让一个读操作返回    –  recv</li>
</ul>
</li>
</ul>
<h3 id="1-5-5"><a href="#1-5-5" class="headerlink" title="1.5"></a>1.5</h3><ul>
<li>readv和writev函数，类似read和write，不过readv和writev允许单个系统调用读入到或写出自一个或多个缓冲区。这些操作分别称为分散读(scatter read)和集中写(gather write)，因为读操作的输入数据被分散到多个应用缓冲区中，而来自多个应用缓冲区的输出数据则被集中提供给单个写操作</li>
<li>声明：<ul>
<li><code>#include &lt;sys/uio.h&gt;</code></li>
<li><code>ssize_t readv (int filedes, const struct iovec *iov, int iovcnt);</code></li>
<li><code>ssize_t writev (int filedes, const struct iovec *iov, int iovcnt);</code></li>
</ul>
</li>
<li>readv和writev这两个函数可用于任何描述符，而不仅限于套接字。</li>
<li>另外，writev是一个原子操作，意味着对于一个基于记录的协议（例如UDP）而言，一次writev调用只产生单个UDP数据包</li>
</ul>
<h3 id="1-6-3"><a href="#1-6-3" class="headerlink" title="1.6"></a>1.6</h3><ul>
<li>recvmsg和sendmsg，这两个函数是最通用的I&#x2F;O函数。</li>
<li>实际上，我们可以把所有read，readv，recv和recvfrom调用替换成recvmsg调用。类似的，各种输出函数调用也可以替换成sendmsg调用</li>
<li>声明：<ul>
<li><code>#include &lt;sys/socket.h&gt;</code></li>
<li><code>ssize_t recvmsg (int sockfd, struct msghdr *msg, int flags);</code></li>
<li><code>ssize_t sendmsg (int sockfd, struct msghdr *msg, int flags);</code></li>
</ul>
</li>
<li>这两个函数把大部分参数封装到一个msghdr结构中：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct msghdr &#123;</span><br><span class="line">    void *msg_name;           /* protocol address */</span><br><span class="line">    socklen_t msg_namelen;    /* size of protocol address */</span><br><span class="line">    struct iovec *msg_iov;    /* scatter/gather array */</span><br><span class="line">    int msg_iovlen;           /* elements in msg_iov */</span><br><span class="line">    void *msg_control;        /* ancillary data (cmsghdr struct) */</span><br><span class="line">    socklen_t msg_controllen; /* flags returned by recvmsg() */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>msg_name和msg_namelen，这两个成员用于套接字未连接的场合（例如未连接UDP套接字）。它们类似recvfrom和sendto的第五个和第六个参数：msg_name指向一个套接字地址结构，调用者再其中存放接收者（对于sendmsg调用）或发送者（对于recvmsg调用）的协议地址。如果无需指明协议地址，msg_name应置为空指针。msg_namelen对于sendmsg是一个值参数，对于recvmsg却是一个值-结果参数</li>
<li>msg_iov和msg_iovlen，这两个成员指定输入或输出缓冲区数组（即iovec结构数组），类似readv或writev的第二个和第三个参数</li>
<li>msg_control和msg_controllen，这两个成员指定可选的辅助数据的位置和大小。msg_controllen对于recvmsg是一个值-结果参数</li>
</ul>
</li>
</ul>
<h3 id="1-7-3"><a href="#1-7-3" class="headerlink" title="1.7"></a>1.7</h3><ul>
<li><p>辅助数据(ancillary data)，可通过调用sendmsg和recvmsg这两个函数，使用msghdr结构中的msg_control和msg_controllen这两个成员发送和接收。</p>
</li>
<li><p>辅助数据的另一个称谓，是控制信息(control information)</p>
</li>
<li><p>辅助数据由一个或多个辅助数据对象(ancillary data object)构成，每个对象以一个定义在头文件<code>&lt;sys/socket.h&gt;</code>中的cmsghdr结构开头</p>
</li>
<li><p>声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct cmsghdr &#123;</span><br><span class="line">    socklen_t cmsg_len;    /* length in bytes, including this structure */</span><br><span class="line">    int cmsg_level;        /* originating protocol */</span><br><span class="line">    int cmsg_type;         /* protocol-specific type */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>msg_control指向第一个辅助数据对象，辅助数据的总长度则由msg_controllen指定。每个对象开头都是一个描述该对象的cmsghdr结构。</p>
</li>
</ul>
<h3 id="1-8-1"><a href="#1-8-1" class="headerlink" title="1.8"></a>1.8</h3><ul>
<li><p>到目前为止的所有例子中，我们一直使用也称为Unix I&#x2F;O  –  包括read，write这两个函数及它们的变体(recv，send等等)的函数执行I&#x2F;O。这些函数围绕描述符(descriptor)工作，通常作为Unix内核中的系统调用实现</p>
</li>
<li><p>执行I&#x2F;O的另一个方法是使用标准I&#x2F;O函数库(standard I&#x2F;O library)。这个函数库由ANSI C标准规范，意在便于移植到支持ANSI C的非Unix系统上</p>
</li>
<li><p>标准I&#x2F;O函数库执行以下三类缓冲：</p>
<ul>
<li>完全缓冲(fully buffering)，意味着只在出现下列情况时才发生I&#x2F;O：缓冲区满，进程显示调用fflush，或进程调用exit终止自身。标准I&#x2F;O缓冲区的通常大小为8192字节</li>
<li>行缓冲(line buffering)，意味着只在出现下列情况时才发生I&#x2F;O：碰到一个换行符，进程调用fflush，或进程调用exit终止自身</li>
<li>不缓冲(unbuffering)，意味着每次调用标准I&#x2F;O输出函数都发生I&#x2F;O</li>
</ul>
</li>
<li><p>标准I&#x2F;O函数库的大多数Unix实现使用如下规则：</p>
<ul>
<li>标准错误输出总是不缓冲</li>
<li>标准输入和标准输出完全缓冲，除非它们指代终端设备（这种情况下它们行缓冲）</li>
<li>所有其他I&#x2F;O流都是完全缓冲，除非它们指代终端设备（这种情况下它们行缓冲）</li>
</ul>
</li>
<li><p>套接字不是终端设备，输出流是完全缓冲的。存在的问题有两个解决办法：</p>
<ul>
<li>第一个办法是通过调用setvbuf迫使这个输出流变为行缓冲</li>
<li>第二个办法是在每次调用fputs之后通过调用fflush强制输出每个回射行</li>
</ul>
</li>
<li><p>然而在现实使用中，这两种办法都易于犯错。大多数情况下，最好的解决办法是：彻底避免在套接字上使用标准I&#x2F;O函数库</p>
</li>
</ul>
<h3 id="1-9-1"><a href="#1-9-1" class="headerlink" title="1.9"></a>1.9</h3><ul>
<li><p>在套接字操作上设置时间限制的方法有三个：</p>
<ul>
<li>使用alarm函数和SIGALRM信号；</li>
<li>使用由select提供的时间限制</li>
<li>使用较新的SO_RCVTIMEO和SO_SNDTIMEO套接字选项</li>
</ul>
</li>
<li><p>第一个方法易于使用，不过涉及信号处理，而信号处理可能导致竞争条件。使用select意味着我们阻塞在指定过时间限制的这个函数上，而不是阻塞在read，write或connect调用上。第三个方法也易于使用，不过并非所有实现都提供</p>
</li>
<li><p>recvmsg和sendmsg是所提供的五组I&#x2F;O函数中最为通用的。它们组合了如下能力：</p>
<ul>
<li>指定MSG_XXX标志（出自recv和send）</li>
<li>返回或指定对端的协议地址（出自recvfrom和sendto）</li>
<li>使用多个缓冲区（出自readv和writev）</li>
<li>此外，还增加了两个新的特性：给应用进程返回标志，接收或发送辅助数据</li>
</ul>
</li>
<li><p>辅助数据，由一个或多个辅助数据对象构成，每个对象都以一个cmsghdr结构打头，它指定数据的长度，协议级别及类型。五个以CMSG_打头的函数可用于构建和分析辅助数据</p>
</li>
<li><p>C标准I&#x2F;O函数库也可以用在套接字上，不过这么做将在已经由TCP提供的缓冲级别之上新增一级缓冲。实际上，对由标准I&#x2F;O函数库执行的缓冲缺乏了解是使用这个函数库最常见的问题。既然套接字不是终端设备，这个潜在问题的常用解决办法就是把标准I&#x2F;O流设置成不缓冲，或者干脆不要在套接字上使用标准I&#x2F;O</p>
</li>
</ul>
<h2 id="Unix域协议"><a href="#Unix域协议" class="headerlink" title="Unix域协议"></a>Unix域协议</h2><h3 id="1-1-9"><a href="#1-1-9" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li>Unix域协议并不是一个实际的协议族，而是在单个主机上执行客户&#x2F;服务器通信的一种方法，所用API就是在不同主机上执行客户&#x2F;服务器通信所用的API（套接字APT）</li>
<li>Unix域提供两类套接字：字节流套接字（类似TCP）和数据包套接字（类似UDP）</li>
</ul>
<h3 id="1-2-9"><a href="#1-2-9" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li><p>socketpair函数，创建两个随后连接起来的套接字。本函数仅适用于Unix域套接字</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;sys/socket.h&gt;</code></li>
<li><code>int socketpair (int family, int type, int protocol, int sockfd[2]);</code></li>
</ul>
</li>
<li><p>family参数，必须为AF_LOCAL,</p>
</li>
<li><p>protocol参数，必须为0</p>
</li>
<li><p>type参数，既可以是SOCK_STREAM，也可以是SOCK_DGRAM</p>
</li>
<li><p>新创建的两个套接字描述符作为sockfd[0]和sockfd[1]返回</p>
</li>
<li><p>本函数类似Unix的pipe函数，会返回两个彼此连接的描述符。这样创建的两个套接字不曾命名，也就是说其中没有涉及隐式的bind调用</p>
</li>
<li><p>同一个主机上客户和服务器之间的描述符传递是一个非常有用的技术，它通过Unix域套接字发生</p>
</li>
</ul>
<h2 id="非阻塞式I-O"><a href="#非阻塞式I-O" class="headerlink" title="非阻塞式I&#x2F;O"></a>非阻塞式I&#x2F;O</h2><h3 id="1-1-10"><a href="#1-1-10" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li>套接字的默认状态是阻塞的。这就意味着当发出一个不能立即完成的套接字调用时，其进程将被投入睡眠，等待响应操作完成。可能阻塞的套接字调用可分为以下四类：<ul>
<li>输入操作，包括read,readv,recv,recvfrom和recvmsg共五个函数。如果某个进程对一个阻塞的TCP套接字（默认设置）调用这些输入函数之一，而且该套接字的接收缓冲区中没有数据可读，该进程将被投入睡眠，直到有一些数据到达。对于非阻塞的套接字，如果输入操作不能被满足（对于TCP套接字即至少有一个字节的数据可读，对于UDP套接字即有一个完整的数据报可读），相应调用将立即返回一个EWOULDBLOCK错误</li>
<li>输出操作，包括write,writev,send,sendto和sendmsg共五个函数。对于一个TCP套接字，内核将从应用进程的缓冲区到该套接字的发送缓冲区复制数据。对于阻塞的套接字，如果其发送缓冲区中没有空间，进程将被投入睡眠，直到有空间为止。对于一个非阻塞的TCP套接字，如果其发送缓冲区中根本没有空间，输出函数调用将立即返回一个EWOULDBLOCK错误。如果其发送缓冲区中有一些空间，返回值将是内核能够复制到该缓冲区中的字节数。这个字节数也称为不足计数(short count)</li>
<li>接受外来连接，即accept函数。如果对一个阻塞的套接字调用accept函数，并且尚无新的连接到达，调用进程将被投入睡眠。如果对一个非阻塞的套接字调用accept函数，并且尚无新的连接到达，accept调用将立即返回一个EWOULDBLOCK错误</li>
<li>发起外出连接，即用于TCP的connect函数。（回顾一下，我们直到connect同样可用于UDP，不过它不能使一个“真正”的连接建立起来，它只是使内核保存对端的IP地址和端口号）。TCP连接的建立涉及一个三路握手过程，而且connect函数一直要等到客户收到对于自己的SYN的ACK为止才返回。这意味着TCP的每个connect总会阻塞其调用进程至少一个到服务器的RTT时间。如果对一个非阻塞的TCP套接字调用connect，并且连接不能立即建立，那么连接的建立能照样发起（例如送出TCP三路握手的第一个分组），不过会返回一个EINPROGRESS错误</li>
</ul>
</li>
</ul>
<h2 id="ioctl操作"><a href="#ioctl操作" class="headerlink" title="ioctl操作"></a>ioctl操作</h2><h3 id="1-1-11"><a href="#1-1-11" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>ioctl函数，传统上一直作为那些不适合归入其他精细定义类别的特性的系统接口。POSIX致力于摆脱处于标准化过程中的特定功能的ioctl接口，办法是为它们创造一些特殊的函数以取代ioctl请求</p>
</li>
<li><p>网络程序（特别是服务器程序）经常在程序启动执行后使用ioctl获取所在主机全部网络接口的信息，包括：接口地址，是否支持广播，是否支持多播，等等。我们将自行开发用于返回这些信息的函数</p>
</li>
</ul>
<h3 id="1-2-10"><a href="#1-2-10" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li>ioctl函数，影响由fd参数引用的一个打开的文件</li>
<li>声明：<ul>
<li><code>#include &lt;unistd.h&gt;</code></li>
<li><code>int ioctl (int fd, int request, ... /* void *arg */);</code></li>
</ul>
</li>
<li>其中第三个参数总是一个指针，但指针的类型依赖于request参数</li>
<li>我们可以把和网络相关的请求(request)划分为六类：<ul>
<li>套接字操作（是否位于带外标记等）</li>
<li>文件操作（设置或清楚非阻塞标志等</li>
<li>接口操作（返回接口列表，获取广播地址等）</li>
<li>ARP高速缓存操作（创建，修改，获取或删除）</li>
<li>路由表操作（增加或删除）</li>
<li>流系统</li>
</ul>
</li>
</ul>
<h3 id="1-3-8"><a href="#1-3-8" class="headerlink" title="1.3"></a>1.3</h3><ul>
<li>需要处理网络接口的许多程序沿用的初始步骤之一，就是从内核获取配置在系统中的所有接口</li>
<li>本任务由SIOCGIFCONF请求完成，它使用ifconfi接口，ifconfi又使用ifreq结构</li>
</ul>
<h2 id="路由套接字"><a href="#路由套接字" class="headerlink" title="路由套接字"></a>路由套接字</h2><h3 id="1-1-12"><a href="#1-1-12" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li>我们对路由套接字的主要兴趣点在于，使用sysctl函数检查路由表和接口列表。创建路由套接字（一个AF_ROUTE域的原始套接字）需要超级用户权限，然而使用sysctl检查路由表和接口列表的进程却不限用户权限</li>
<li>声明：<ul>
<li><code>#include &lt;sys/param.h&gt;</code></li>
<li><code>#include &lt;sys/sysctl.h&gt;</code></li>
<li><code>int sysctl (int *name, u_int namelen, void *oldp, size_t oldlenp, void *newp, size_t newlen);</code></li>
</ul>
</li>
<li>name参数，是指定名字的一个整数数组，</li>
<li>namelen参数，指定该数组中的元素数目。</li>
<li>为了获取某个值，oldp参数，指向一个供内核存放该值的缓冲区</li>
<li>oldlenp则是一个值-结果参数：函数被调用时，oldlenp指向的值指定该缓冲区的大小；函数返回时，该值给出内核存放在该缓冲区中的数据量</li>
<li>为了设置某个新值，newp参数，指向一个大小为newlen参数值的缓冲区。如果不准备指定一个新值，那么newp应为一个空指针，newlen应为0</li>
</ul>
<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><h3 id="1-1-13"><a href="#1-1-13" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>广播(broadcasting)和多播(multicasting)。本书迄今为止所有的例子处理的都是单播(unicasting)：一个进程就与另一个进程通信。实际上TCP只支持单播寻址，而UDP和原始IP还支持其他寻址类型</p>
</li>
<li><p>IPv6往寻址体系结构中增加了任播(anycasting)方式。任播允许从一组通常提供相同服务的主机中选择一个（一般是选择按某种测度而言离源主机最近的）。</p>
</li>
<li><p>多播支持在IPv4中是可选的，在IPv6中却是必需的</p>
</li>
<li><p>IPv6不支持广播。使用广播的任何IPv4应用程序一旦移植到IPv6就必须改用多播重新编写</p>
</li>
<li><p>广播和多播要求用于UDP或原始IP，它们不能用于TCP</p>
</li>
<li><p>广播的用途之一，是在本地子网定位一个服务器主机，前提是已知或认定这个服务器主机位于本地子网，但是不知道它的单播IP地址。这种操作也称为资源发现(resource discovery)。另一个用途是在有多个客户主机和单个服务器主机通信的局域网环境中尽量减少分组流通</p>
</li>
<li><p>广播发送的数据报由发送主机某个所在子网上的所有主机接收。广播的劣势在于同一子网上的所有主机都必须处理数据报</p>
</li>
</ul>
<h2 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h2><h3 id="1-1-14"><a href="#1-1-14" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>单播地址标识单个IP接口，广播地址标识某个子网的所有IP接口，多播地址标识一组IP接口。</p>
</li>
<li><p>单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折衷方案</p>
</li>
<li><p>多播数据报只应该由它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上的接口接收</p>
</li>
<li><p>套接字API为支持多播而增添的内容比较简单：九个套接字选项</p>
<ul>
<li>其中三个影响目的地址为多播地址的UDP数据报的发送</li>
<li>另外六个影响主机对于多播数据报的接收</li>
</ul>
</li>
</ul>
<h2 id="信号驱动式I-O"><a href="#信号驱动式I-O" class="headerlink" title="信号驱动式I&#x2F;O"></a>信号驱动式I&#x2F;O</h2><h3 id="1-1-15"><a href="#1-1-15" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>信号驱动式I&#x2F;O，是指进程预先告知内核，使得当某个描述符上发生某事时，内核使用信号通知相关进程。</p>
</li>
<li><p>POSIX通过aio_XXX函数提供真正的异步I&#x2F;O。这些函数允许进程指定I&#x2F;O操作完成时是否由内核产生信号以及产生什么信号。</p>
</li>
<li><p>针对一个套接字使用信号驱动式I&#x2F;O(SIGIO)要求进程执行以下三个步骤：</p>
<ul>
<li>建立SIGIO信号的信号处理函数</li>
<li>设置该套接字的属主，通常使用fcntl的F_SETOWN命令设置</li>
<li>开启该套接字的信号驱动式I&#x2F;O，通常通过使用fcntl的F_SETFL命令打开O_ASYNC标志完成</li>
</ul>
</li>
</ul>
<h3 id="1-2-11"><a href="#1-2-11" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li><p>在UDP上使用信号驱动式I&#x2F;O是简单的。SIGIO信号在发生以下事件时产生：</p>
<ul>
<li>数据报到达套接字；</li>
<li>套接字上发生异步错误</li>
</ul>
</li>
<li><p>因此，当捕获对于某个UDP套接字的SIGIO信号时，我们调用recvfrom或者读入到达的数据报，或者获取发生的异步错误。</p>
</li>
<li><p>信号驱动式I&#x2F;O对于TCP套接字近乎无用。问题在于该信号产生的过于频繁，并且它的出现并没有告诉我们发生了什么事件</p>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="1-1-16"><a href="#1-1-16" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>在传统的UNIX模型中，当一个进程需要另一个实体来完成某事时，它就fork一个子进程并让子进程去执行处理。</p>
</li>
<li><p>Unix上的大多数网络服务器程序就是这么编写的：父进程accept一个连接，fork一个子进程，该子进程处理与该连接对端的客户之间的通信。</p>
</li>
<li><p>尽管这种范式多少年来一直用的挺好，fork调用却存在一些问题：</p>
<ul>
<li>fork是昂贵的。fork要把父进程的内存映像复制到子进程，并在子进程中复制所有描述符，如此等等。当今的实现使用称为写时复制(copy-on-write)的技术，用以避免在子进程切实需要自己的副本之前把父进程的数据空间复制到子进程。然而即便有这样的优化措施，fork仍然是昂贵的</li>
<li>fork返回之后父子进程之间信息的传递需要进程间通信（IPC）机制。调用fork之前父进程向尚未存在的子进程传递信息相当容易，因此子进程将从父进程数据空间及所有描述符的一个副本开始运行。然而从子进程往父进程返回信息却比较费力。</li>
</ul>
</li>
<li><p>线程，有助于解决这两个问题。线程有时称为轻权进程(lightweight process)，因为线程比进程“权重轻些”。也就是说，线程的创建可能比进程的创建快10-100倍</p>
</li>
<li><p>同一进程内的所有线程共享相同的全局内存。这使得线程之间易于共享信息，然而伴随这种简易性而来的确实同步(synchronization)问题</p>
</li>
<li><p>同一进程内的所有线程除了共享全局变量外，还共享：</p>
<ul>
<li>进程指令；</li>
<li>大多数数据</li>
<li>打开的文件（即描述符）</li>
<li>信号处理函数和信号处置</li>
<li>当前工作目录</li>
<li>用户ID和组ID</li>
</ul>
</li>
<li><p>不过每个线程有各自的：</p>
<ul>
<li>线程ID；</li>
<li>寄存器集合，包括程序计数器和栈指针</li>
<li>栈（用于存放局部变量和返回地址）；</li>
<li>errno；</li>
<li>信号掩码；</li>
<li>优先级</li>
</ul>
</li>
</ul>
<h3 id="1-2-12"><a href="#1-2-12" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li>当一个程序由exec启动执行时，称为初始线程(initial thread)或主线程(main thread)的单个线程就创建了。其余线程则由pthread_create函数创建</li>
<li>声明：<ul>
<li><code>#include &lt;pthread.h&gt;</code></li>
<li><code>int pthread_create (pthread_t *tid, const pthread_attr_t *attr, void *(*func)(void *), void *arg);</code></li>
</ul>
</li>
<li>一个进程内的每个线程都由一个线程ID(thread ID)标识，其数据类型为pthread_t（往往是unsigned int）。如果新的线程成功创建，其ID就通过tid指针返回</li>
<li>每个线程都有许多属性(attribute)：优先级，初始栈大小，是否应该成为一个守护线程，等等。</li>
<li>创建一个线程时，我们最后指定的参数是由该线程执行的函数及其参数。该线程通过调用这个函数开始执行，然后或显示终止（通过调用pthread_exit），或者隐式地终止（通过让函数返回）。该函数的地址由func参数指定，该函数的唯一调用参数是指针arg。如果我们需要给该函数传递多个参数，我们就得把它们打包成一个结构，然后把这个结构的地址作为单个参数传递给这个起始函数。</li>
<li>注意func和arg的声明。func所指函数作为参数接受一个通用指针(void *)，又作为返回值返回一个通用指针(void *)。这使得我们可以把一个指针（它指向我们期望的任何内容）传递给线程，又允许线程返回一个指针（它同样指向我们期望的任何内容）</li>
<li>通常情况下Pthread函数的返回值成功时为0，出错时为某个非0值</li>
</ul>
<h3 id="1-3-9"><a href="#1-3-9" class="headerlink" title="1.3"></a>1.3</h3><ul>
<li>我们可以通过调用pthread_join等待一个给定线程终止。对比线程和UNIX进程，pthread_create类似于fork，pthread_join类似于waitpid</li>
<li>声明：<ul>
<li><code>#include &lt;pthread.h&gt;</code></li>
<li><code>int pthread_join (pthread_t *tid, void **status);</code></li>
</ul>
</li>
<li>我们必须指定要等待线程的tid。不幸的是，Pthread没有办法等待任意一个线程（类似指定进程ID参数为-1调用waitpid）</li>
<li>如果status指针非空，来自所等待线程的返回值（一个指向某个对象的指针）将存入由status指向的位置</li>
</ul>
<h3 id="1-4-6"><a href="#1-4-6" class="headerlink" title="1.4"></a>1.4</h3><ul>
<li>每个线程都有一个在所属进程内标识自身的ID。线程ID由pthread_create返回，而且我们已经看到pthread_join使用它。每个线程使用pthread_self获取自身的线程ID</li>
<li>声明：<ul>
<li><code>#include &lt;pthread.h&gt;</code></li>
<li><code>pthread_t pthread_self (void);</code></li>
</ul>
</li>
<li>对比线程和UNIX进程，pthread_self类似于getpid</li>
</ul>
<h3 id="1-5-6"><a href="#1-5-6" class="headerlink" title="1.5"></a>1.5</h3><ul>
<li>一个线程或者是可汇合的(joinable,默认值)，或者是脱离的(detached)。当一个可汇合的线程终止时，它的线程ID和退出状态将留存到另一个线程对他调用pthread_join。脱离的线程却像守护进程，当它们终止时，所有相关资源都被释放，我们不能等待它们终止。如果一个线程需要知道另一个线程什么时候终止，那就最好保持第二个线程的可汇合状态。</li>
<li>pthread_detach函数，把指定的线程转变为脱离状态</li>
<li>声明：<ul>
<li><code>#include &lt;pthread.h&gt;</code></li>
<li><code>int pthread_detach (pthread_t tid);</code></li>
</ul>
</li>
<li>本函数通常由想让自己脱离的线程调用，就如以下语句：<ul>
<li><code>pthread_detach (pthread_self());</code></li>
</ul>
</li>
</ul>
<h3 id="1-6-4"><a href="#1-6-4" class="headerlink" title="1.6"></a>1.6</h3><ul>
<li><p>让一个线程终止的方法之一，是调用pthread_exit。</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;pthread.h&gt;</code></li>
<li><code>void pthread_exit (void *status);</code></li>
</ul>
</li>
<li><p>指针status不能指向局部于调用线程的对象，因为线程终止时这样的对象也消失</p>
</li>
<li><p>让一个线程终止的另外两个方法是：</p>
<ul>
<li>启动线程的函数（即pthread_create的第三个参数）可以返回。既然该函数必须声明成返回一个void指针，它的返回值就是相应线程的终止状态</li>
<li>如果进程的main函数返回或者任何线程调用了exit，整个进程就终止，其中包括它的任何线程。</li>
</ul>
</li>
</ul>
<h3 id="1-7-4"><a href="#1-7-4" class="headerlink" title="1.7"></a>1.7</h3><ul>
<li><p>我们称线程编程为并发编程(concurrent programming)或并行编程(parallel programming)，因为多个线程可以并发地（或并行地）运行且访问相同的变量</p>
</li>
<li><p>我们刚才讨论的多个线程更改一个共享变量的问题是最简单的问题。其解决办法是，使用一个互斥锁（mutex，代表mutual exclusion）保护这个共享变量；访问该变量的前提条件是持有该互斥锁。</p>
</li>
<li><p>按照Pthread，互斥锁是类型为pthread_mutex_t的变量。我们使用以下两个函数为一个互斥锁上锁和解锁：</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;pthread.h&gt;</code></li>
<li><code>int pthread_mutex_lock (pthread_mutex_t *mptr);</code></li>
<li><code>int pthread_mutex_unlock (pthread_mutex_t *mptr);</code></li>
</ul>
</li>
<li><p>如果试图上锁已被另外某个线程锁住的一个互斥锁，本线程将被阻塞，直到该互斥锁倍解锁为止</p>
</li>
</ul>
<h3 id="1-8-2"><a href="#1-8-2" class="headerlink" title="1.8"></a>1.8</h3><ul>
<li><p>互斥锁适合于防止同时访问某个共享变量，但是我们需要另外某种在等待某个条件发生期间能让我们进入睡眠的东西</p>
</li>
<li><p>轮询(polling)，就是不断地循环，每次循环检查一下条件，相当浪费CPU事件</p>
</li>
<li><p>我们需要一个让主循环进入睡眠，直到某个线程通知它有事可做才醒来的方法。条件变量(condition variable)结合互斥锁能够提供这个功能。互斥锁提供互斥机制，条件变量提供信号机制</p>
</li>
<li><p>按照Pthread，条件变量是类型为pthread_cond_t的变量。以下两个函数使用条件变量：</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;pthread.h&gt;</code></li>
<li><code>int pthread_cond_wait (pthread_cond_t *cptr, pthread_mutex_t *mptr);</code></li>
<li><code>int pthread_cond_signal (pthread_cond_t *cptr);</code></li>
</ul>
</li>
<li><p>第二个函数的名字中”signal“一词并不指称Unix的SIGXXX信号</p>
</li>
<li><p>为什么每个条件变量都要关联一个互斥锁呢？因为”条件“通常是线程之间共享的某个变量的值。允许不同线程设置和测试该变量要求有一个与该变量关联的互斥锁</p>
</li>
<li><p>要求pthread_cond_wait被调用时其所关联的互斥锁必须是上锁的，该函数作为单个原子操作解锁该互斥锁并把调用线程投入睡眠也是出于这个理由</p>
</li>
<li><p>pthread_cond_signal通常唤醒等在相应条件变量上的单个线程。有时候一个线程直到自己应该唤醒多个线程，这种情况下它可以调用pthread_cond_broadcast唤醒等在相应条件变量上的所有线程</p>
</li>
<li><p>声明：</p>
<ul>
<li><code>#include &lt;pthread.h&gt;</code></li>
<li><code>int pthread_cond_broadcast (pthread_cond_t *cptr);</code></li>
<li><code>int pthread_cond_timedwait (pthread_cond_t *cptr, pthread_mutex_t *mptr, const struct timespec *abstime);</code></li>
</ul>
</li>
<li><p>pthread_cond_timedwait允许线程设置一个阻塞时间的限制。</p>
</li>
</ul>
<h3 id="1-9-2"><a href="#1-9-2" class="headerlink" title="1.9"></a>1.9</h3><ul>
<li>创建一个新线程通常比使用fork派生一个新进程快得多。仅仅这一点就能够体现线程在繁重使用的网络服务器上的优势，然而线程编程是一个新的编程范式，需要有所训练。</li>
<li>同一进程内的所有线程共享全局变量和描述符，从而允许不同线程之间共享这些信息。然而这种共享却引入了同步问题，我们必须使用的Pthread同步原语是互斥锁和条件变量。共享数据的同步几乎是每个线程化应用程序必不可少的部分。</li>
<li>我们将在第三十章中重新回到线程模型，讨论另外一个服务器程序设计范式：服务器在启动时创建一个线程池，下一个客户请求就由该池中某个闲置的线程来处理</li>
</ul>
<h2 id="IP选项"><a href="#IP选项" class="headerlink" title="IP选项"></a>IP选项</h2><h3 id="1-1-17"><a href="#1-1-17" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>源路径(source route)，是由IP数据报的发送者指定的一个IP地址列表。如果源路径是严格的(strict)，那么数据报必须且只能逐一经过所列的节点，也就是说列在源路径中的所有节点必须前后互为邻居。如果源路径是宽松的(loose)，那么数据报必须逐一经过所列的节点，不过也可以经过未列在源路径中的其他节点</p>
</li>
<li><p>在10个已定义的IPv4选项中最常用的是源路径选项，不过出于安全考虑，它的使用正在日益萎缩。IPv4首部中选项的访问通过IP_OPTIONS套接字选项完成</p>
</li>
</ul>
<h2 id="原始套接字"><a href="#原始套接字" class="headerlink" title="原始套接字"></a>原始套接字</h2><h3 id="1-1-18"><a href="#1-1-18" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>原始套接字提供普通的TCP和UDP套接字所不提供的以下三个能力：</p>
<ul>
<li>有了原始套接字，进程可以读与写ICMPv4, IGMPv4和ICMPv6等分组</li>
<li>有了原始套接字，进程可以读写内核不处理其协议字段的IPv4数据报</li>
<li>有了原始套接字，进程还可以使用IP_HDRINCL套接字选项自行构造IPv4首部，通常用于诊断目的</li>
</ul>
</li>
<li><p>ping和traceroute这两个常用的诊断工具，使用原始套接字完成任务</p>
</li>
</ul>
<h2 id="数据链路访问"><a href="#数据链路访问" class="headerlink" title="数据链路访问"></a>数据链路访问</h2><h3 id="1-1-19"><a href="#1-1-19" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li>目前大多数操作系统都为应用提供访问数据链路层的强大功能。这种功能可以提供如下能力：<ul>
<li>能够监视由数据链路层接收的分组，使得诸如tcpdump之类的程序能够在普通计算机系统上运行，而无需使用专门的硬件设备来监视分组。</li>
<li>能够作为普通应用进程而不是内核的一部分运行某些程序</li>
</ul>
</li>
</ul>
<h3 id="1-2-13"><a href="#1-2-13" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li><p>Linux先后有两个从数据链路层接收分组的方法。</p>
<ul>
<li>较旧的方法，是创建类型为SOCK_PACKET的套接字，这个方法的可用面较宽，不过缺乏灵活性</li>
<li>较新的方法，是创建协议族为PF_PACKET的套接字，这个方法引入了更多的过滤和性能特性</li>
</ul>
</li>
<li><p>从数据链路层接收所有帧应如下创建套接字：</p>
<ul>
<li><code>fd = socket (PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));  /* 较新方法 */</code></li>
<li><code>fd = socket (AF_INET, SOCK_PACKET, htons(ETH_P_ALL)); /* 较旧方法 */</code></li>
</ul>
</li>
<li><p>如果只想捕获IPv4帧，那就如下创建套接字</p>
<ul>
<li><code>fd = socket (PF_PACKET, SOCK_RAW, htons(ETH_P_IP));  /* 较新方法 */</code></li>
<li><code>fd = socket (AF_INET, SOCK_PACKET, htons(ETH_P_IP)); /* 较旧方法 */</code></li>
</ul>
</li>
<li><p>用作socket调用的第三个参数的常值还有ETH_P_ARP, ETH_P_IPV6等</p>
</li>
</ul>
<h3 id="1-3-10"><a href="#1-3-10" class="headerlink" title="1.3"></a>1.3</h3><ul>
<li>libpcap，是访问操作系统所提供的分组捕获机制的分组捕获函数库，它是与实现无关的。</li>
<li>目前它只支持分组的读入</li>
</ul>
<h3 id="1-4-7"><a href="#1-4-7" class="headerlink" title="1.4"></a>1.4</h3><ul>
<li>libnet函数库，提供构造任意协议的分组并将其输出到网络中的接口。它以与实现无关的方式提供原始套接字访问方式和数据链路访问的方式</li>
<li>libnet隐藏了构造IP，UDP和TCP首部的许多细节，并提供简单且便于移植的数据链路和原始套接字写出访问接口</li>
</ul>
<h3 id="1-5-7"><a href="#1-5-7" class="headerlink" title="1.5"></a>1.5</h3><ul>
<li>原始套接字，使得我们有能力读写内核不理解的IP数据报；数据链路层访问，则把这个能力进一步扩展成与读写任何类型的数据链路帧，而不仅仅是IP数据报。tcpdump也许是直接访问数据链路层的最常用程序</li>
<li>不同操作系统有不同的数据链路层访问方法。但是，如果使用公开可得的分组捕获函数库libpcap，我们就可以忽略所有这些区别，依然编写出可移植的代码</li>
<li>在不同系统上编写原始数据报可能各不相同。公开可得的libnet函数库隐藏了这些差异，所提供的数据接口即可以通过原始套接字访问，也可以在数据链路层上直接访问</li>
</ul>
<h2 id="客户-服务器程序设计范式"><a href="#客户-服务器程序设计范式" class="headerlink" title="客户&#x2F;服务器程序设计范式"></a>客户&#x2F;服务器程序设计范式</h2><h3 id="1-1-20"><a href="#1-1-20" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>当开发一个Unix服务器程序时，我们有如下类型的进程控制可供选择</p>
<ul>
<li>本书第一个服务器程序即图1-9是一个迭代服务器(iterative server)程序，不过这种类型的使用情形极为有限，因为这样的服务器在完成对当前客户的服务之前无法处理已经等待服务的新客户</li>
<li>图5-2是本书第一个并发服务器(concurrent server)程序，它为每个客户调用fork派生一个子进程。传统上大多数Unix服务器程序属于这种类型</li>
<li>在6.8节，我们开发的另一个版本的TCP服务器程序由使用select处理任意多个客户的单个进程构成</li>
<li>在图26-3中，我们的并发服务器程序被改为服务器为每个客户创建一个线程，以取代派生一个进程</li>
</ul>
</li>
<li><p>我们将在本章探究并发服务器程序设计的另两类变体：</p>
<ul>
<li>预先派生子进程(preforking)，是让服务器在启动阶段调用fork创建一个子进程池。每个客户请求由当前可用子进程池中的某个（闲置）子进程处理</li>
<li>预先创建线程(prethreading)，是让服务器在启动阶段创建一个线程池，每个客户由当前可用线程池中的某个（闲置）线程处理</li>
</ul>
</li>
<li><p>我们将在本章审视预先派生子进程和预先创建线程这两种类型的众多细节：</p>
<ul>
<li>如果池中进程和线程不够多怎么办？</li>
<li>如果池中进程和线程过多怎么办？</li>
<li>父进程和子进程之间以及多个线程之间怎样彼此同步？</li>
</ul>
</li>
<li><p>我们已经探究了客户程序的各种设计范式，这里有必要汇总它们各自的优缺点：</p>
<ul>
<li>图5-5是基本的TCP客户程序。该程序存在两个问题。首先，进程在被阻塞以等待用户输入期间，看不到诸如对端关闭连接等网络事件。其次，它以停-等模式运作，批处理效率极低</li>
<li>图6-9是下一个迭代客户程序，它通过调用select使得进程能够在等待用户输入期间得到网络事件通知。然而该程序存在不能正确地批量输入的问题。图6-13通过使用shutdown函数解决了这个问题</li>
<li>从图16-3开始给出的是使用非阻塞式I&#x2F;O实现的客户程序</li>
<li>第一个超越单进程单线程设计范畴的客户程序是图16-10，它使用fork派生一个子进程，并由父进程（或子进程）处理从客户到服务器的数据，由子进程（或父进程）处理从服务器到客户的数据</li>
<li>图26-2使用两个线程取代两个进程</li>
</ul>
</li>
<li><p>非阻塞式I&#x2F;O版本尽管是最快的，其代码却比较复杂；使用两个进程或两个线程的版本相比之下代码简化得多，而运行速度只是稍逊而已</p>
</li>
</ul>
<h3 id="1-2-14"><a href="#1-2-14" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li>传统上并发服务器调用fork派生一个子进程来处理每个客户。这使得服务器能够同时为多个客户服务，每个进程一个客户。</li>
<li>客户数目的唯一限制是操作系统对以其名义运行服务器的用户ID能够同时拥有多少子进程的限制</li>
</ul>
<h3 id="1-3-11"><a href="#1-3-11" class="headerlink" title="1.3"></a>1.3</h3><ul>
<li><p>我们的第一个“增强”型服务器程序使用称为预先派生子进程(preforking)的技术。</p>
</li>
<li><p>使用该技术的服务器不像传统意义的并发服务器那样为每个客户现场派生一个子进程，而死在启动阶段预先派生一定数量的子进程，当各个客户连接到达时，这些子进程立即就能为它们服务</p>
</li>
<li><p>这种技术的优点在于无须引入父进程执行fork的开销就能处理新到的客户。缺点则是父进程必须在服务器启动阶段猜测需要预先派生多少子进程</p>
</li>
<li><p>通过增加一些代码，服务器总能应对客户负载的变动。父进程必须做的就是持续监视可用（即闲置）子进程数，一旦该值降到低于某个阈值就派生额外的子进程。同样，一旦该值超过另一个阈值就终止一些过剩的子进程</p>
</li>
</ul>
<h3 id="1-4-8"><a href="#1-4-8" class="headerlink" title="1.4"></a>1.4</h3><ul>
<li>BSD实现允许多个进程在引用同一个监听套接字的描述符上调用accept，然而这种做法也仅仅适用于在内核中实现accept的源自Berkeley的内核。相反，作为一个库函数实现accept的System V内核不允许这么做。</li>
<li>解决办法是，让应用进程在调用accept前后安置某种形式的锁(lock)，这样任意时刻只有一个子进程阻塞在accept调用中，其他子进程则则色在试图获取用于保护accept的锁上</li>
<li>正如本系列丛书第二卷所述，我们有多种方法可用于提供包绕accept调用的上锁功能。本节我们使用以fcntl函数呈现的POSIX文件上锁功能</li>
</ul>
<h3 id="1-5-8"><a href="#1-5-8" class="headerlink" title="1.5"></a>1.5</h3><ul>
<li><p>对预先派生子进程服务器程序的最后一个修改版本，是只让父进程调用accept，然后把所接受的已连接套接字“传递”给某个子进程。这么做绕过了为所有子进程的accept调用提供上锁保护的可能需求，不过需要从父进程到子进程的某种形式的描述符传递。这种技术会使代码多少有点复杂，因为父进程必须跟踪子进程的忙闲状态，以便给空闲子进程传递新的套接字</p>
</li>
<li><p>我们首先查看图30-21给出的child_make函数。在调用fork之前先创建一个字节流管道，它是一对Unix域字节流套接字（第十五章）。派生出子进程之后，父进程关闭其中一个描述符(sockfd[1])，子进程关闭另一个描述符(sockfd[0])。子进程还把流管道的自身拥有端(sockfd[1])复制到标准错误输出，这样每个子进程就通过读写标准错误输出和父进程通信。</p>
</li>
</ul>
<h3 id="1-6-5"><a href="#1-6-5" class="headerlink" title="1.6"></a>1.6</h3><ul>
<li>在支持线程的系统上，我们有理由预期在服务器启动阶段预先创建一个线程池以取代为每个客户现场创建一个线程的做法有类似的性能加速。</li>
<li>本服务器的基本设计是，预先创建一个线程池，并让每个线程各自调用accept。取代让每个线程都阻塞在accept调用之中的做法，我们改用互斥锁以保证任何时刻只有一个线程在调用accept。这里没有理由使用文件上锁保护各个线程中的accept调用，因为对于单个进程中的多个线程，我们总可以使用互斥锁达到同样的目的</li>
</ul>
<h3 id="1-7-5"><a href="#1-7-5" class="headerlink" title="1.7"></a>1.7</h3><ul>
<li>最后一个使用线程的服务器程序设计范式，是在程序启动阶段创建一个线程池之后只让主线程调用accept并把每个客户连接传递给池中某个可用线程</li>
<li>本设计范式的问题，在于主线程如何把一个已连接套接字传递给线程池中某个可用线程。这里有多个实现手段。<ul>
<li>我们原本可以如前使用描述符传递，不过既然所有线程和所有描述符都在同一个进程之内，我们没有必要把一个描述符从一个线程传递到另一个线程</li>
<li>接收线程只需要知道这个已连接套接字描述符的值，二描述符传递实际传递的并非这个值，而是对这个套接字的一个引用，因而将返回一个不同于原值的描述符（该套接字的引用计数也被递增）</li>
</ul>
</li>
</ul>
<h3 id="1-8-3"><a href="#1-8-3" class="headerlink" title="1.8"></a>1.8</h3><ul>
<li><p>我们在本章中讨论了九个不同的服务器程序设计范式，并针对同一个Web风格的客户程序分别运行了它们，以比较它们花在执行进程控制上的CPU时间</p>
<ul>
<li>迭代服务器（无进程控制，用作测量基准）</li>
<li>并发服务器，每个客户请求fork一个子进程</li>
<li>预先派生子进程，每个子进程无保护地调用accept</li>
<li>预先派生子进程，使用文件上锁保护accept</li>
<li>预先派生子进程，使用线程互斥锁上锁保护accept</li>
<li>预先派生子进程，父进程向子进程传递套接字描述符</li>
<li>并发服务器，每个客户请求创建一个线程</li>
<li>预先创建线程服务器，使用互斥锁上锁保护accept</li>
<li>预先创建线程服务器，由主线程调用accept</li>
</ul>
</li>
<li><p>经过比较，我们可以得出以下几点总结性意见：</p>
<ul>
<li>当系统负载较轻时，每来一个客户请求现场派生一个子进程为之服务的传统并发服务器程序模型就足够了。</li>
<li>相比传统的每个客户fork一次设计范式，预先创建一个子进程池或一个线程池的设计范式能够把进程控制CPU时间降低10或以上。编写这些范式的程序并不复杂，不过需超越本章所给的例子的是：监视闲置子进程个数，随着所服务客户数的动态变化而增加或减少这个数目</li>
<li>某些实现允许多个子进程或线程阻塞在同一个accept调用中，另一些实现却要求包绕accept调用安置某种类型的锁加以保护。文件上锁或Pthread互斥锁上锁都可以使用</li>
<li>让所有子进程或线程自行调用accept通常比让父进程或主线程独自调用accept并把描述符传递给子进程或线程来的简单而快速</li>
<li>由于潜在select冲突的原因，让所有子进程或线程阻塞在同一个accept调用中比让它们阻塞在同一个select调用中更可取</li>
<li>使用线程通常远快于使用进程</li>
</ul>
</li>
</ul>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><h3 id="1-1-21"><a href="#1-1-21" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li>我们将在本章给出流系统的概貌以及应用程序用于访问某个流的函数</li>
</ul>
<h2 id="附录A"><a href="#附录A" class="headerlink" title="附录A"></a>附录A</h2><h3 id="1-1-22"><a href="#1-1-22" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li><p>IP层提供无连接不可靠的数据报递送服务。它会尽最大努力把IP数据报递送到指定的目的地，然而并不保证它们一定到达，也不保证它们的到达顺序与发送顺序一致，还不保证每个IP数据报只到达一次。</p>
</li>
<li><p>任何期望的可靠性（即无差错按顺序不重复地递送用户顺序）必须由上层提供。</p>
<ul>
<li>对于TCP（或SCTP）应用程序而言，这由TCP（或SCTP）本身完成</li>
<li>对于UDP应用程序而言，这得由应用程序完成，因为UDP是不可靠的</li>
</ul>
</li>
<li><p>IP层最重要的功能之一是路由(routing)。每个IP数据报包含一个源地址和一个目的地址</p>
</li>
</ul>
<h3 id="1-2-15"><a href="#1-2-15" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li>32位长度的IPv4地址通常书写成以点号分隔的4个十进制数，称为点分十进制数记法(dotted-decimal notation)，其中每个十进制数代表32位地址4个字节中的某一个</li>
<li>无论在何时谈到IPv4网络或子网地址，所说的都是一个32位网络地址和一个相应的32位掩码。掩码中值为1的位涵盖网络地址部分，值为0的位涵盖主机地址部分。既然掩码中值为1的位置总是从最左位向右连续排列，值为0的位总是从最右位向左连续排列，因此地址掩码也可以使用表示从最左位向右排列的值为1的连续位数的前缀长度(prefix length)指定。</li>
<li>举例来说，掩码是255.255.255.0，则前缀长度为24。这些IPv4地址被认为无类的，之所以这么称呼，是因为现在掩码是显式指定而非由地址类型暗指的。</li>
<li>IPv4网络地址通常书写成一个点分十进制数串，后跟一个斜杠，再跟以前缀长度。192.169.4.16&#x2F;24</li>
<li>使用无类地址要求无类路由，它通常称为无类域间路由(classless interdomain routing, CIDR)。使用CIDR的目的，在于减少因特网主干路由表的大小，延缓IPv4地址耗尽的速率。</li>
</ul>
<h3 id="1-3-12"><a href="#1-3-12" class="headerlink" title="1.3"></a>1.3</h3><ul>
<li><p>IPv4地址通常划分子网。这么做增加了另外一级地址层次：</p>
<ul>
<li>网络ID（分配给网点）</li>
<li>子网ID（由网点选择）</li>
<li>主机ID（由网点选择）</li>
</ul>
</li>
<li><p>网络ID和子网ID之间的界线，由所分配网络地址的前缀长度确定，而这个前缀长度通常由相应的组织机构的ISP赋予。然而子网ID和主机ID之间的界线却由网点选择。</p>
</li>
<li><p>某个给定子网上所有主机都共享同一个子网掩码(subnet mask)，它指定子网ID和主机ID之间的界线。子网掩码中值为1的位涵盖网络ID和子网ID，值为0的位则涵盖主机ID</p>
</li>
</ul>
<h3 id="1-4-9"><a href="#1-4-9" class="headerlink" title="1.4"></a>1.4</h3><ul>
<li>环回地址，按照约定，地址127.0.0.1赋予环回接口。任何发送到这个IP地址的分组在内部被环送回来作为IP模块的输入，因而这些分组根本不会出现在网络上</li>
<li>我们在同一个主机上测试客户和服务器程序时经常使用改地址。该地址通常为人所知的名字是INADDR_LOOPBACK</li>
</ul>
<h2 id="附录C-调试技术"><a href="#附录C-调试技术" class="headerlink" title="附录C 调试技术"></a>附录C 调试技术</h2><h3 id="1-1-23"><a href="#1-1-23" class="headerlink" title="1.1"></a>1.1</h3><ul>
<li>tcpdump程序，该程序一边从网络读入分组一边显示关于这些分组的大量信息。它还能够只显示所指定的准则匹配的那些分组</li>
<li>该程序可从<a target="_blank" rel="noopener" href="http://www.tcpdump.org/%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%83%BD%E5%A4%9F%E5%B7%A5%E4%BD%9C%E5%9C%A8%E8%AE%B8%E5%A4%9A%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84Unix%E4%B8%8A">http://www.tcpdump.org/获取，能够工作在许多不同版本的Unix上</a></li>
</ul>
<h3 id="1-2-16"><a href="#1-2-16" class="headerlink" title="1.2"></a>1.2</h3><ul>
<li>netstat程序，该程序服务于多个目的：<ul>
<li>展示网络端点的状态</li>
<li>展示某个主机上各个接口所属的多播组。-ia标志是展露多播组的通常方式</li>
<li>使用-s选项显示各个协议的统计信息</li>
<li>使用-r选项显示路由表或使用-i选项显示接口信息</li>
</ul>
</li>
</ul>
<h3 id="1-3-13"><a href="#1-3-13" class="headerlink" title="1.3"></a>1.3</h3><ul>
<li>lsof程序，名字lsof代表“列出打开的文件(list open files”。与tcpdump一样，losf也是一个公开可得的方便调试的工具</li>
<li>losf的常见用途之一是，找出哪个进程在指定的IP地址或端口上打开了一个套接字。netstat告诉我们那些IP地址和端口正在使用中以及各个TCP连接的状态，却没有标识相应的进程。losf弥补了这个缺陷</li>
<li>该程序的常见用途之一是：如果在启动一个捆绑其众所周知端口的服务器时得到改地址已在使用的出错消息，那么我们可以使用losf找出正在使用该端口的进程</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5_%E7%AC%AC%E4%B9%9D%E7%89%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5_%E7%AC%AC%E4%B9%9D%E7%89%88/" class="post-title-link" itemprop="url">操作系统概念_第九版</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>操作系统概念 第九版 ，作者为 Abraham Silberschatz, Peter B.Galvin,</li>
</ul>
<h2 id="第一部分-概论"><a href="#第一部分-概论" class="headerlink" title="第一部分 概论"></a>第一部分 概论</h2><ul>
<li>操作系统位于计算机用户与计算机硬件之间。操作系统的目的是提供环境，以便用户能够便捷且高效地执行程序</li>
</ul>
<h2 id="第一章-导论"><a href="#第一章-导论" class="headerlink" title="第一章 导论"></a>第一章 导论</h2><ul>
<li>由于操作系统既庞大又复杂，应一部分一部分地构造。每一部分都应具有明确描述的系统部分，而且输入，输出及功能都有明确的定义。</li>
</ul>
<h3 id="1-1-操作系统的功能"><a href="#1-1-操作系统的功能" class="headerlink" title="1.1 操作系统的功能"></a>1.1 操作系统的功能</h3><ul>
<li><p>计算机系统可以粗分为四个组件：硬件，操作系统，应用程序和用户</p>
</li>
<li><p>硬件(hardware)，例如中央处理单元(Center Processing Unit, CPU)，内存(memory)，</p>
</li>
<li><p>输入&#x2F;输出设备(Input&#x2F;Output device, I&#x2F;O Device)，为系统提供基本的计算资源</p>
</li>
<li><p>应用程序(application program)，例如字处理程序编译器，网络浏览器，规定了用户为解决计算问题而使用这些资源的方式。操作系统控制硬件，并且协调各个用户应用程序的硬件使用。</p>
</li>
<li><p>从计算机的视角来看，操作系统是与硬件紧密相连的程序。因此，可以将操作系统看作资源分配器(resource allocator)</p>
</li>
<li><p>操作系统的另一个稍有不同的视角是，强调控制各种I&#x2F;O设备和用户程序的需求。操作系统是个控制程序。控制程序(control program)管理用户程序的执行，以防止计算机资源的错误或不正当使用。</p>
</li>
<li><p>操作系统的定义</p>
<ul>
<li>操作系统是一直运行在计算机上的程序(通常成为内核(kernel)).</li>
<li>除了内核外，还有其他两类程序：系统程序(system program)和应用程序</li>
<li>系统程序是与系统运行有关的程序，但不是内核的一部分；</li>
<li>应用程序是与系统运行无关的所有其他程序</li>
</ul>
</li>
</ul>
<h3 id="1-2-计算机系统的组成"><a href="#1-2-计算机系统的组成" class="headerlink" title="1.2 计算机系统的组成"></a>1.2 计算机系统的组成</h3><ul>
<li><p>现代通用计算机系统包括一个或多个CPU和若干设备控制器，通过公有总线相连而成，该总线提供了共享内存的访问。</p>
</li>
<li><p>每个设备控制器负责一类特定的设备。CPU与设备控制器可以并发执行，并且竞争访问内存。</p>
</li>
<li><p>为了确保有序访问共享内存，需要内存控制器来协调访问内存。</p>
</li>
<li><p>当计算机电源打开或者重启以便开始运行时，它需要运行一个初始程序。该初始程序或者引导程序(booststrap program)通常很简单，一般位于计算机的固件(firmware)，例如只读内存(Read-Only Memory, ROM)或者电可擦可编程只读内存(Electrically Erasable Programmable Read-Only Memory, EEPROM)。</p>
</li>
<li><p>它初始化系统的各个组件，从CPU寄存器，设备控制器到内存内容。引导程序必须知道如何加载操作系统并且开始执行系统。为了完成这一目标，引导程序必须定位操作系统内核并且加到内存。</p>
</li>
<li><p>一旦内核加到内存并且执行，它就开始为系统与用户提供服务。除了内核外，系统程序也提供一些服务，他们在启动时加到内存而成为系统进程(system process)或者系统后台程序(system daemon)，其生命周期与内核一样。对于UNIX，首个系统进程为init，它启动许多其他系统的后台程序。一旦这个阶段完成，系统就完全启动了，并且等待事件发生</p>
</li>
<li><p>事件发生通常通过硬件或者软件的中断(interrupt)来通知。硬件可以随时通过系统总线发送信号到CPU，以触发中断。软件也可以通过执行特别操作即系统调用(system call)(也称为监督程序调用(monitor call))，以触发中断</p>
</li>
<li><p>中断是计算机体系结构的重要部分。虽然每个计算机设计都有自己的中断机制，但是有些功能是共同的。中断应该将控制转移到合适的中断服务程序。处理这一转移的直接方法是，调用一个通用程序以检查中断信息。接着，该程序会调用特定的中断处理程序。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">程序设计语言原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>计算机科学的各个方面都离不开程序设计语言。计算机工作者一生中必然会接触好几种语言：当一种新的语言问世并被广泛接受时，你需要学习这种语言以更新技能；当接受一个新项目时，你必须为这个项目选择一种最合适的实现语言；甚至你可能会为它专门设计并实现一种新的语言。</li>
<li>本书并不教授如何使用一种语言，而是讨论程序设计语言的结构与特性，这些结构与特性在不同语言中的设计与实现以及这些结构与特性给语言的优点与缺点。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-structure_and_interpretation_of_computer_programs_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-structure_and_interpretation_of_computer_programs_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A/" class="post-title-link" itemprop="url">structure_and_interpretation_of_computer_programs_计算机程序的构造和解释</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>计算机程序的构造和解释 书籍的阅读笔记</li>
</ul>
<h2 id="第一章-程序设计的基本元素"><a href="#第一章-程序设计的基本元素" class="headerlink" title="第一章 程序设计的基本元素"></a>第一章 程序设计的基本元素</h2><ul>
<li><p>一个强有力的程序设计语言，不仅是一种指挥计算机执行任务的方式，它还应该称为一种框架，使我们能够在其中组织自己有关计算过程的思想。</p>
</li>
<li><p>每一种强有力的语言都为此提供了三种机制：</p>
<ul>
<li>基本表达形式，用于表示语言所关心的最简单的个体</li>
<li>组合的方式，通过它们可以从较简单的东西出发构造出复合的元素</li>
<li>抽象的方法，通过它们可以为复合对象命名，并将它们当做单元去操作</li>
</ul>
</li>
<li><p>在程序设计中，我们需要处理两类要素：过程和数据</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-computer_system_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-computer_system_%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">computer_system_深入理解计算机系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>深入理解计算机系统书籍的阅读，第一阶段为上下班阅读，拍下来需要记录的文字，回到公司整理到这里</li>
</ul>
<h2 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章 程序的机器级表示"></a>第三章 程序的机器级表示</h2><h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><ul>
<li>链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置</li>
</ul>
<h3 id="反汇编器-disassembler"><a href="#反汇编器-disassembler" class="headerlink" title="反汇编器(disassembler)"></a>反汇编器(disassembler)</h3><ul>
<li>要查看机器代码文件的内容，有一类称为反汇编器的程序非常有用。这些程序根据机器代码产生一种类似于汇编代码的格式</li>
<li>在Linux系统中，带<code>-d</code>命令行标志的程序OBJDUMP表示(object dump)可以充当这个角色</li>
<li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d mstore.o</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="C-指针"><a href="#C-指针" class="headerlink" title="C 指针"></a>C 指针</h3><ul>
<li><p>C语言中所谓的指针，其实就是地址。</p>
</li>
<li><p>间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器</p>
</li>
<li><p>其次，像x这样的局部变量通常是保存在寄存器中，而不是内存中，访问寄存器比访问内存要快得多</p>
</li>
</ul>
<h3 id="C-指针运算"><a href="#C-指针运算" class="headerlink" title="C 指针运算"></a>C 指针运算</h3><ul>
<li><p>C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩</p>
</li>
<li><p>单操作数操作符 <code>&amp;</code> 和 <code>*</code> 可以产生指针和间接引用指针。也就是：</p>
<ul>
<li>对于一个表示某个对象的表达式Expr， &amp;Expr是给出该对象地址的一个指针。</li>
<li>对于一个表示地址的表达式AExpr， *AExpr给出该地址处的值</li>
</ul>
</li>
<li><p>因此，表达式Expr与 * &amp;Expr是等价的。可以对数组和指针应用数据下标操作。</p>
</li>
<li><p>数组引用A[i]等同于表达式 * (A + i)。它计算第 i 个数组元素的地址，然后访问这个内存位置</p>
</li>
</ul>
<h3 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h3><ul>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 16</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> fix_matrix[N][N]</span><br></pre></td></tr></table></figure>
</li>
<li><p>当程序要用一个常数作为数组的维度或者缓冲区的大小时，最好通过 #define 声明将这个常数与一个名字联系起来，然后在后面一直使用这个名字代替常数的数值。</p>
</li>
<li><p>这样一来，如果需要修改这个值，只用简单地修改这个 #define 声明就可以了</p>
</li>
</ul>
<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><ul>
<li><p>C语言过程调用机制的一个关键特性(大多数其他语言也是如此)在于使用了栈数据结构提供的后进先出的内存管理原则</p>
</li>
<li><p>程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据，分配内存所需要的信息。</p>
</li>
</ul>
<h3 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h3><ul>
<li><p>C 语言提供了两种将不同类型的对象组合到一起创建数据类型的机制</p>
<ul>
<li>结构(structure)，用关键字struct来声明，将多个对象集合到一个单位中</li>
<li>联合(union)，用关键字union声明，允许用几种不同的类型来引用一个对象</li>
</ul>
</li>
<li><p>C语言的struct声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。用名字来引用结构的各个组成部分。</p>
</li>
<li><p>类似于数据的实现，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址</p>
</li>
<li><p>编译器维护关于每个结构类型的信息，指示每个字段(field)的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用</p>
</li>
</ul>
<h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><ul>
<li>许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K(通常是2，4，8)的倍数。</li>
<li>这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计</li>
</ul>
<h3 id="栈随机化"><a href="#栈随机化" class="headerlink" title="栈随机化"></a>栈随机化</h3><ul>
<li><p>栈随机化的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的站地址都是不同的。</p>
</li>
<li><p>实现的方式：</p>
<ul>
<li>程序开始时，在栈上分配一段0-n字节之间的随机大小的空间，例如，使用分配函数alloca在栈上分配指定字节数量的空间。</li>
<li>程序不适用这段空间，但是他会导致程序每次执行时后续的栈位置发生了变化。</li>
<li>分配的范围n必须足够大，才能获得足够多的栈地址变化，但是又要足够小，不至于浪费程序太多的空间</li>
</ul>
</li>
<li><p>在Linux系统中，栈随机化已经变成了标准行为。它是更大的一类技术中的一种，这类技术称为地址空间布局随机化(Address-Space Layout Randomization)，或者简称ASLR</p>
</li>
<li><p>采用ASLR，每次运行时程序的不同部分，包括程序代码，库代码，栈，全局变量和堆数据，都会被加载到内存的不同区域。这就意味着在一台机器上运行一个程序，与在其他机器上运行同样的程序，他们的地址映射大相径庭。这样才能对抗一些形式的攻击</p>
</li>
</ul>
<h3 id="第三章-小结"><a href="#第三章-小结" class="headerlink" title="第三章 小结"></a>第三章 小结</h3><ul>
<li><p>编译器C++与编译C非常相似。实际上，C++的早期实现就只是简单地执行了从C++到C的源到源的转换，并对结果运行C编译器，产生目标代码。C++的对象用结构来表示，类似于C的struct。C++的方法是用指向实现方法的代码的指针来表示的。</p>
</li>
<li><p>相比而言，Java的实现方式完全不同。Java的目标代码是一种特殊的二进制表示，称为Java字节代码。这种代码可以看成是虚拟机的机器级程序。正如它的名字暗示的那样，这种机器并不是直接用硬件实现的，而是用软件解释器处理字节代码，模拟虚拟机的行为。</p>
</li>
<li><p>另外，有一种称为及时编译(just-in-time compilation)的方法，动态地将字节代码序列翻译成机器指令。当代码要执行多次时(例如在循环中)，这种方法执行起来更快。用字节代码作为程序的低级表示，优点是相同的代码可以在许多不同的机器上执行。</p>
</li>
</ul>
<h2 id="第五章-优化程序性能"><a href="#第五章-优化程序性能" class="headerlink" title="第五章 优化程序性能"></a>第五章 优化程序性能</h2><h3 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h3><ul>
<li>为了理解改进性能的方法，我们需要理解现代处理器的微体系结构。由于大量的晶体管可以被集成到一块芯片上，现在微处理器采用了复杂的硬件，试图使程序性能最大化。带来的一个后果就是处理器的实际操作与通过观察机器级程序所察觉到的大相径庭。</li>
<li>在代码级上，看上去似乎试一次执行一条指令，每条指令都包括从寄存器或内存取值，执行一个操作，并把结果存回到一个寄存器或内存位置。在实际的处理器中，是同时对多条指令求值的，这个现象称为 指令级并行</li>
</ul>
<h3 id="应用：-性能提高技术"><a href="#应用：-性能提高技术" class="headerlink" title="应用： 性能提高技术"></a>应用： 性能提高技术</h3><ul>
<li><p>优化程序性能的基本策略：</p>
<ul>
<li>高级设计。为遇到的问题选择适当的算法和数据结构。要特别警觉，避免使用那些会渐进地产生糟糕性能的算法或编码技术</li>
</ul>
</li>
<li><p>基本编码原则：避免限制优化的因素，这样编译器就能产生高效的代码</p>
<ul>
<li>消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择地妥协程序的模块性以获取更大的效率</li>
<li>消除不必要的内存引用。引入临时变量来保存中间结果。只有在最后的值计算出来时，才将结果存放到数组或全局变量中</li>
</ul>
</li>
<li><p>低级优化：结构化代码以利用硬件功能</p>
<ul>
<li>展开循环，降低开销，并且使得进一步的优化成为可能</li>
<li>通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行</li>
<li>用功能性的风格重写条件操作，使得编译采用条件数据传送</li>
</ul>
</li>
</ul>
<h3 id="程序剖析-code-profiler"><a href="#程序剖析-code-profiler" class="headerlink" title="程序剖析 code profiler"></a>程序剖析 code profiler</h3><ul>
<li><p>程序剖析运行程序的一个版本，其中插入了工具代码，以确定程序的各个部分需要多少时间。这对于确认程序中我们需要集中注意力优化的部分是很有用的。</p>
</li>
<li><p>剖析的一个有力之处在于可以在现实的基准数据(benchmark data)上运行实际程序的同时，进行剖析</p>
</li>
<li><p>Unix系统提供了一个剖析程序GPROF。这个程序产生两种形式的信息。</p>
<ul>
<li>首先，它确定程序中每个函数花费了多少CPU时间</li>
<li>其次，它计算每个函数被调用的次数，以执行调用的函数来分类</li>
</ul>
</li>
<li><p>这两种形式的信息都非常有用。这些计时给出了不同函数在确定整体运行时间中的相对重要性。调用信息使得我们能够理解程序的动态行为</p>
</li>
<li><p>用GPROF进行剖析需要三个步骤，就像C程序prog.c所示，它运行时命令参数为file.txt：</p>
<ul>
<li>首先，程序必须为剖析而编译和链接。使用GCC(以及其他C编译器),就是在命令行上简单地包括运行时标志<code>-pg</code>。确保编译器不通过内联替换来尝试执行任何优化是很重要的，否则就可能无法正确刻画函数调用。我们使用优化标志<code>-Og</code>，以保证能正确跟踪函数调用<ul>
<li><code>linux&gt; gcc -Og -pg prog.c -o prog</code></li>
</ul>
</li>
<li>其次，程序像往常一样执行：<ul>
<li><code>linux&gt; ./prog file.txt</code></li>
<li>它运行得会比正常时稍微慢一点(大约慢两倍),不过除此之外唯一的区别就是它产生了一个文件gmon.out</li>
</ul>
</li>
<li>调用GPROF来分析gmon.out中的数据<ul>
<li><code>linux&gt; gprof prog</code></li>
</ul>
</li>
</ul>
</li>
<li><p>剖析报告的第一部分列出了执行各个函数花费的时间，按照降序排列。</p>
</li>
<li><p>每一行代表对某个函数的所有调用所花费的时间</p>
<ul>
<li>第一列表明花费在这个函数上的时间占整个时间的百分比</li>
<li>第二列显示的是直到这一行并包括这一行的函数所花费的累计时间</li>
<li>第三列显示的是花费在这个函数上的时间</li>
<li>第四列显示的是它被调用的次数(递归调用不计算在内)</li>
</ul>
</li>
<li><p>剖析报告的第二部分是函数的调用历史</p>
<ul>
<li>根据这个调用信息，我们通常可以推断出关于程序行为的有用信息</li>
</ul>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>当处理大型程序时，将注意力集中在最耗时的部分变得很重要。代码剖析程序和相关的工具能帮助我们系统地评价和改进程序性能。</li>
<li>我们描述了GPROF，一个标准的Unix剖析工具，还有更加复杂完善的剖析程序可用，例如Intel的VTUNE程序开发系统，还有Linux系统基本上都有的VALGRIND。</li>
<li>这些工具可以在过程级分解执行时间，估计程序每个基本块(basic block)的性能。(基本块是内部没有控制转移的指令序列，因此基本块总是整个被执行的)</li>
</ul>
<h2 id="第六章-存储器层次结构"><a href="#第六章-存储器层次结构" class="headerlink" title="第六章 存储器层次结构"></a>第六章 存储器层次结构</h2><ul>
<li><p>存储器系统(memory system)是一个具有不同容量，成本和访问时间的存储设备的层次结构。CPU寄存器保存着最常用的数据。</p>
</li>
<li><p>靠近CPU的小的，快速的高速缓存存储器(cache memroy)作为一部分存储在相对慢速的主存储器(main memory)中的数据和指令的缓冲区域</p>
</li>
<li><p>主存缓存，存储在容量较大的，慢速磁盘上的数据，而这些磁盘常常有作为存储在通过网络连接的其他机器的磁盘或磁带上的数据的缓冲区域</p>
</li>
<li><p>这个思想围绕着计算机程序的一个称为局部性(locality)的基本属性。具有良好局部性的程序倾向于一次又一次地访问相同的数据项集合，或是倾向于访问邻近的数据项集合。</p>
</li>
<li><p>具有良好局部性的程序比局部性差的程序更多地倾向于从存储器层次结构中较高层次出访问数据项，因此运行得更快</p>
</li>
</ul>
<h3 id="随机访问存储器"><a href="#随机访问存储器" class="headerlink" title="随机访问存储器"></a>随机访问存储器</h3><ul>
<li><p>随机访问存储器(Random-Access Memory, RAM)分为两类：静态的和动态的</p>
</li>
<li><p>静态RAM(SRAM)比动态RAM(DRAM)更快，但也贵得多</p>
</li>
<li><p>SRAM用来作为高速缓存存储器，既可以在CPU芯片上，也可以在片下</p>
</li>
<li><p>SRAM将每个位存储在一个双稳态的(bistable)存储器单元里。每个单元是用一个六晶体管电路来实现的。这个电路有这样一个属性，它可以无限期地保持在两个不同电压配置(configuration)或状态(state)之一。其他任何状态都是不稳定的：从不稳定状态开始，电路会讯速地转移到两个稳定状态中的其中一个。这样一个存储器单元类似于一个倒转的钟摆</p>
</li>
<li><p>DRAM将每个位存储为一个电容的充电</p>
</li>
<li><p>内存模块</p>
<ul>
<li>DRAM芯片封装在内存模块(memory module)中，它查到主板的扩展槽上</li>
</ul>
</li>
</ul>
<h3 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h3><ul>
<li><p>如果断电，DRAM和SRAM会丢失它们的信息，从这个意义上说，它们是易失的(volatile)。</p>
</li>
<li><p>另一方面，非易失性存储器(nonvolatile memory)即使是在关电后，仍然保存着它们的信息。</p>
</li>
<li><p>由于历史原因，虽然ROM中有的类型既可以读也可以写，但是它们整体上都被称为只读存储器(Read-Only Memory, ROM)。</p>
</li>
<li><p>ROM是它们能够被重编程(写)的次数和对它们进行重编程所用的机制来区分的</p>
</li>
<li><p>PROM(Programmable ROM, 可编程ROM)只能被编程一次。PROM的每个存储器单元有一种熔丝(fuse)，只能用高电流熔断一次</p>
</li>
<li><p>可擦写可编程ROM(Erasable Programmable ROM, EPROM)有一个透明的石英窗口，允许光到达存储单元。紫外线光照射过窗口，EPROM单元就被清除为0。对EPROM编程是通过使用一种把1写入EPROM的特殊设备来完成的。</p>
</li>
<li><p>EPROM能够被擦除和重编程的次数的数量级可以达到1000次。</p>
</li>
<li><p>电子可擦除EROM(Electrically Erasable PROM, EEPROM)类似于EPROM，但是他不需要一个物理上独立的编程设备，因此可以直接在印制电路卡上编程。EEPROM能够被编程的次数的数量级可以达到10的五次方</p>
</li>
<li><p>闪存(flash memory)是一类非易失性存储器，基于EEPROM，他已经称为了一种重要的存储技术。</p>
</li>
<li><p>新型的基于闪存的磁盘驱动器，称为固态硬盘(Solid State Disk, SSD)，它能提供相对于传统旋转磁盘的一种更快速，更强健和更低能耗的选择</p>
</li>
<li><p>存储在ROM设备中的程序通常被称为固件(firmware)。当一个计算机系统通电以后，他会运行存储在ROM中的固件。一些系统在固件中提供了少量基本的输入和输出函数：例如PC的BIOS(基本输入&#x2F;输出系统)例程</p>
</li>
<li><p>逻辑磁盘块</p>
<ul>
<li>正如我们看到的那样，现代磁盘构造复杂，有多个盘面，这些盘面上有不同的记录区。为了对操作系统隐藏这样的复杂性，现在磁盘将它们的构造呈现为一个简单的视图，一个B个扇区大小的逻辑块的序列，编号为0，1，。。。，B-1。磁盘封装中有一个小的硬件&#x2F;固件设备，称为磁盘控制器，维护着逻辑块号和实际(物理)磁盘扇区之间的映射关系。</li>
</ul>
</li>
<li><p>当操作系统想要执行一个I&#x2F;O操作时，例如读一个磁盘扇区的数据到主存，操作系统会发送一个命令到磁盘控制器，让它读某个逻辑块号。</p>
</li>
<li><p>控制器上的固件执行一个快速表查找，将一个逻辑块号翻译成一个(盘面，磁道，扇区)的三元组，这个三元组唯一的标识了对应的物理扇区，控制器上的硬件会解释这个三元组，将读&#x2F;写头移动到适当的柱面，等待扇区移动到读&#x2F;写头下，将读&#x2F;写头感知到的位放到控制器上的一个小缓冲区中，然后将他们复制到主存中</p>
</li>
<li><p>格式化的磁盘容量</p>
<ul>
<li>磁盘控制器必须对磁盘进行格式化，然后才能在该磁盘上存储数据</li>
<li>格式化包括用标识扇区的信息填写扇区之间的间隙，标识出表面有故障的柱面并且不使用它们，以及在每个区中预留出一组柱面作为备用，如果区中一个或多个柱面在磁盘使用过程中坏掉了，就可以使用这些备用的柱面</li>
<li>因为存在着这些备用的柱面，所以磁盘制造商所说的格式化容量比最大容量要小</li>
</ul>
</li>
</ul>
<h3 id="连接I-O设备"><a href="#连接I-O设备" class="headerlink" title="连接I&#x2F;O设备"></a>连接I&#x2F;O设备</h3><ul>
<li><p>例如图形卡，监视器，鼠标，键盘和磁盘这样的输入&#x2F;输出(I&#x2F;O)设备，都是通过I&#x2F;O总线，例如Intel的外围设备互连(Peripheral Component Interconnect, PCI)总线连接到CPU和主存的。</p>
</li>
<li><p>系统总线和内存总线是与CPU相关的，与它们不同，诸如PCI的I&#x2F;O总线设计成与底层CPU无关</p>
</li>
<li><p>虽然I&#x2F;O总线比系统总线和内存总线慢，但是它可以容纳种类繁多的第三方I&#x2F;O设备。例如</p>
<ul>
<li>通用串行总线(Universal Serial Bus, USB)控制器是一个连接到USB总线的设备的中转机构，USB总线是一个广泛使用的标准，连接各种外围I&#x2F;O设备，包括键盘，鼠标，调制解调器，数码相机，游戏操纵杆，外部磁盘驱动器和固态硬盘。USB 3.0 总线的最大带宽为625MB&#x2F;s。USB 3.1 总线的最大带宽为1250MB&#x2F;s</li>
<li>图形卡(或适配器)包含硬件和软件逻辑，它们负责代表CPU在显示器上画像素</li>
<li>主机总线适配器将一个或多个磁盘连接到I&#x2F;O总线，使用的是一个特别的主机总线接口定义的通信协议。两个最常用的这样的磁盘接口是SCSI和SATA。SCSI主机总线适配器(通常称为SCSI控制器)可以支持多个磁盘驱动器，而SATA适配器与之不同，只能支持一个驱动器</li>
</ul>
</li>
</ul>
<h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><ul>
<li><p>一个编写良好的计算机程序尝尝具有良好的局部性(locality)。也就是，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为局部性原理(principle of locality)，是一个持久的概念，对硬件和软件系统的设计和性能都有着极大地影响。</p>
</li>
<li><p>局部性通常有两种不同的形式：时间局部性(temporal locality)和空间局部性(spatial locality)</p>
<ul>
<li>在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用</li>
<li>在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。</li>
</ul>
</li>
<li><p>量化评价程序中局部性的一些简单原则：</p>
<ul>
<li>重复引用相同变量的程序有良好的时间局部性</li>
<li>对于具有步长为k的引用模式，步长越小，空间局部性越好。具有步长为1的引用模式的程序有很好的空间局部性。在内存中以大步长跳来跳去的程序空间局部性很差</li>
<li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</li>
</ul>
</li>
</ul>
<h3 id="存储器层次结构中的缓存"><a href="#存储器层次结构中的缓存" class="headerlink" title="存储器层次结构中的缓存"></a>存储器层次结构中的缓存</h3><ul>
<li><p>一般而言，高速缓存(cache, 读作”cash”)是一个小而快速的存储设备，它作为存储在更大，也更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程称为缓存(caching 读作”cashing”)</p>
</li>
<li><p>存储器层次结构的中心思想是：对于每个k，位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一层都缓存来自较低一层的数据对象。例如，本地磁盘作为通过网络从远程磁盘取出的文件的缓存，主存作为本地磁盘上数据的缓存，以此类推，直到最小的缓存：CPU寄存器组</p>
</li>
</ul>
<h3 id="存储器层次结构概念小结"><a href="#存储器层次结构概念小结" class="headerlink" title="存储器层次结构概念小结"></a>存储器层次结构概念小结</h3><ul>
<li>概括来说，基于缓存的存储器层次结构行之有效，是因为较慢的存储设备比较快的存储设备更便宜，还因为程序倾向于展示局部性：<ul>
<li>利用时间局部性：由于时间局部性，同一数据对象可能会被多次使用。一旦一个数据对象在第一次不明中时被复制到缓存中，我们就会其往后面对该目标有一系列的访问命中。因为缓存比较低一层的存储设备更快，对后面的命中的服务会比最开始的不命中快很多</li>
<li>利用空间局部性：块通过包括有多个数据对象。由于空间局部性，我们会期望后面对该块中其他对象的访问能够补偿不命中后复制该块的花费。</li>
</ul>
</li>
</ul>
<h2 id="第七章-链接"><a href="#第七章-链接" class="headerlink" title="第七章 链接"></a>第七章 链接</h2><ul>
<li><p>链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载(复制)到内存并执行。</p>
</li>
<li><p>链接可以执行于编译时(compile time)，也就是在源代码被翻译成机器代码时；</p>
</li>
<li><p>也可以执行于加载时(load time)，也就是在程序被加载器(loader)加载到内存并执行时；</p>
</li>
<li><p>甚至执行于运行时(run time)，也就是由应用程序来执行。</p>
</li>
<li><p>在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器(linker)的程序自动执行的</p>
</li>
<li><p>大多数编译系统提供编译器驱动程序(compiler driver)，它代表用户在需要时调用语言预处理器，编译器，汇编器和链接器</p>
</li>
<li><p>链接器的一些基本事实：</p>
<ul>
<li>目标文件纯粹是字节快的集合。</li>
<li>在这些块中，有些包含程序代码，有些包含程序数据，而其他的则包含引导链接器和加载器的数据结构</li>
<li>链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置</li>
<li>链接器对目标机器了解甚少，产生目标文件的编译器和汇编器已经完成了大部分工作</li>
</ul>
</li>
</ul>
<h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><ul>
<li><p>目标文件有三种形式：</p>
<ul>
<li>可重定位目标文件：包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件</li>
<li>可执行目标文件：包含二进制代码和数据，其形式可以被直接复制到内存并执行</li>
<li>共享目标文件：一种特殊类型的可重定位目标文件，可以再加载或者运行时被动态的加载进内存并链接</li>
</ul>
</li>
<li><p>编译器和汇编器生成可重定位目标文件(包括共享目标文件)。</p>
</li>
<li><p>链接器生成可执行目标文件</p>
</li>
<li><p>从技术上来说，一个目标模块(object module)就是一个字节序列，而一个目标文件(object file)就是一个以文件形式存放在磁盘中的目标模块</p>
</li>
<li><p>目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。现代x86-64 Linux和Unix系统使用可执行可链接格式(Executable and Linkable Format, ELF)</p>
</li>
</ul>
<h3 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h3><ul>
<li>每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：<ul>
<li>由模块m定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的C函数和全局变量</li>
<li>由其他模块定义并被模块m引用的全局符号。这些符号称为外部符号，对应于在其他模块中定义的非静态C函数和全局变量</li>
<li>只被模块m定义和引用的局部符号。它们对应于带static属性的C函数和全局变量。这些符号在模块m中任何位置都可见，但是不能被其他模块引用</li>
</ul>
</li>
</ul>
<h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><ul>
<li>链接器解析符号引用的方法是：将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。</li>
<li>对那些和引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字</li>
</ul>
<h3 id="对C-和Java中链接器符号的重整"><a href="#对C-和Java中链接器符号的重整" class="headerlink" title="对C++和Java中链接器符号的重整"></a>对C++和Java中链接器符号的重整</h3><ul>
<li><p>C++和Java都允许重载方法，这些方法在源代码中有相同的名字，却有不同的参数列表。</p>
</li>
<li><p>C++和Java中能使用重载函数，是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这种编码过程叫做重整(mangling)，而相反的过程叫做恢复(demangling)</p>
</li>
<li><p>幸运的是，C++和Java使用兼容的重整策略。一个被重整的类名字是由名字中字符的整数数量，后面跟原始名字组成的。</p>
</li>
</ul>
<h3 id="GCC-fno-common"><a href="#GCC-fno-common" class="headerlink" title="GCC -fno-common"></a>GCC -fno-common</h3><ul>
<li><p>GCC -fno-common标志这样的选调用链接器，这个选项会告诉链接器，在遇到多重定义的全局符号时，触发一个错误。</p>
</li>
<li><p>或者使用-Werror选项，他会把所有的警告都变为错误</p>
</li>
</ul>
<h3 id="与静态库链接"><a href="#与静态库链接" class="headerlink" title="与静态库链接"></a>与静态库链接</h3><ul>
<li><p>所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库(static library)，它可以用做链接器的输入。</p>
</li>
<li><p>当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块</p>
</li>
<li><p>在Linux系统中，静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中，存档文件是一组连起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀.a标识</p>
</li>
<li><p><code>gcc -c main2.c</code></p>
</li>
<li><p><code>gcc -static -o prog2c main2.o -L. -lvector</code></p>
<ul>
<li>-static参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无需更进一步的链接</li>
<li>-lvector参数是libvector.a的缩写，</li>
<li>-L.参数高速链接器在当前目录下查找libvector.a</li>
</ul>
</li>
</ul>
<h3 id="链接器如何使用静态库来解析引用"><a href="#链接器如何使用静态库来解析引用" class="headerlink" title="链接器如何使用静态库来解析引用"></a>链接器如何使用静态库来解析引用</h3><ul>
<li><p>在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件(驱动程序自动将命令行中所有的.c文件翻译为.o文件)</p>
</li>
<li><p>关于库的一般准则是将它们放在命令行的结尾</p>
</li>
</ul>
<h3 id="加载可执行目标文件"><a href="#加载可执行目标文件" class="headerlink" title="加载可执行目标文件"></a>加载可执行目标文件</h3><ul>
<li><p>任何Linux程序都可以通过调用execve函数来调用加载器</p>
</li>
<li><p>加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加载</p>
</li>
<li><p>每个Linux程序都有一个运行时内存映像。</p>
</li>
<li><p>在Linux x86-64系统中，代码段总是从地址0x4000000处开始，后面是数据段。</p>
</li>
<li><p>运行时堆在数据段之后，通过调用malloc库往上增长。</p>
</li>
<li><p>堆后面的区域是为共享模块保留的。</p>
</li>
<li><p>用户栈总是从最大的合法用户地址开始，向较小内存地址增长。</p>
</li>
<li><p>栈上的区域，从地址2的28次方开始，是为内核中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分</p>
</li>
</ul>
<h3 id="加载器实际是如何工作的"><a href="#加载器实际是如何工作的" class="headerlink" title="加载器实际是如何工作的"></a>加载器实际是如何工作的</h3><ul>
<li>Linux系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当shell运行一个程序时，父shell进程生成一个子进程，它是父进程的一个复制。子进程通过execve系统调用启动加载器。加载器删除子进程现有的虚拟内存段，并创建一组新的代码，数据，堆和栈段。新的栈和堆段被初始化为零。通过将虚拟地址空间中的页映射到可执行文件的页大小的片(chunk)，新的代码和数据段被初始化为可执行文件的内容。最后，加载器跳转到_start地址，它最终会调用应用程序的main函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。</li>
</ul>
<h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><ul>
<li><p>共享库(shared library)，是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接(dynamic linking)，是由一个叫做动态链接器(dynamic linker)的程序来执行的</p>
</li>
<li><p>共享库也称为共享目标(shared object)，在Linux系统中通常用.so后缀来表示。微软的操作系统大量地使用了共享库，它们称为DLL(动态链接库)</p>
</li>
<li><p>共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，因而节约宝贵的内存资源</p>
</li>
<li><p>可以加载而无需重定位的代码称为位置无关代码(Position-Independent Code, PIC)。</p>
</li>
<li><p>用户对GCC使用-fpic选项指示GNU编译系统生成PIC代码。共享库的编译必须总是使用该选项</p>
</li>
</ul>
<h3 id="处理目标文件的工具"><a href="#处理目标文件的工具" class="headerlink" title="处理目标文件的工具"></a>处理目标文件的工具</h3><ul>
<li><p>在Linux系统中有大量可用的工具可以帮助理解和处理目标文件。特别的，GNU binutils包尤其有帮助，而且可以运行在每个Linux平台上</p>
</li>
<li><p>AR：创建静态库，插入，删除，列出和提取成员</p>
</li>
<li><p>STRINGS：列出一个目标文件中所有可打印的字符串</p>
</li>
<li><p>STRIP：从目标文件中删除符号表信息</p>
</li>
<li><p>NM：列出一个目标文件的符号表中定义的符号</p>
</li>
<li><p>SIZE：列出目标文件中节的名字和大小</p>
</li>
<li><p>READELF：显示一个目标文件的完整结构，包括ELF头中编码的所有信息，包含SIZE和NM的功能</p>
</li>
<li><p>OBJDUMP：所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编.text节中的二进制指令</p>
</li>
<li><p>Linux系统为操作共享库还提供了LDD程序</p>
</li>
</ul>
<h2 id="第八章-异常控制流"><a href="#第八章-异常控制流" class="headerlink" title="第八章 异常控制流"></a>第八章 异常控制流</h2><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>异常，是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现</li>
<li>异常(exception)就是控制流中的突变，用来相应处理器状态中的某些变化</li>
</ul>
<h3 id="异常的类别"><a href="#异常的类别" class="headerlink" title="异常的类别"></a>异常的类别</h3><ul>
<li><p>异常可以分为四类：</p>
<ul>
<li>中断(interrupt)<ul>
<li>原因：来自I&#x2F;O设备的信号</li>
<li>类型：异步</li>
<li>返回行为：总是返回到下一条指令</li>
</ul>
</li>
<li>陷阱(trap)<ul>
<li>原因：有意的异常</li>
<li>类型：同步</li>
<li>返回行为：总是返回到下一条指令</li>
</ul>
</li>
<li>故障(fault)<ul>
<li>原因：潜在可恢复的错误</li>
<li>类型：同步</li>
<li>返回行为：可能返回到当前指令</li>
</ul>
</li>
<li>终止(abort)<ul>
<li>原因：不可恢复的错误</li>
<li>类型：同步</li>
<li>返回类型：不会返回</li>
</ul>
</li>
</ul>
</li>
<li><p>中断是异步发生的，是来自处理器外部的I&#x2F;O设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序尝尝称为中断处理程序(interrupt handler)</p>
</li>
<li><p>剩下的异常类型(陷阱，故障和终止)是同步发生的，是执行当前指令的结果。我们把这类指令叫做故障指令(faulting instruction)</p>
</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li><p>进程的经典定义就是一个执行中程序的实例</p>
</li>
<li><p>关于操作系统如何实现进程的细节的讨论超出了本书的范围。反之，我们将关注进程提供给应用程序的关键抽象：</p>
<ul>
<li>一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器</li>
<li>一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统</li>
</ul>
</li>
</ul>
<h3 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h3><ul>
<li><p>计算机系统中国逻辑流有许多不同的形式。异常处理程序，进程，信号处理程序，线程和Java进程都是逻辑流的例子</p>
</li>
<li><p>一个逻辑流的执行在时间上与另一个流重叠，称为并发流(concurrent flow)，这两个流被称为并发地运行</p>
</li>
<li><p>多个流并发地执行的一般现象被称为并发(concurrency)。一个进程和其他进程轮流运行的概念称为多任务(multitasking)。一个进程执行它的控制流的一部分的每一个时间段叫做时间片(time slice)。因此，多任务也叫做时间分片(time slicing)</p>
</li>
<li><p>注意，并发流的思想与流运行的处理器核数或者计算机数无关。如果两个流在时间上重叠，那么它们就是并发的，即使它们是运行在同一个处理器上。</p>
</li>
<li><p>不过，有时我们会发现确认并行流是很有帮助的，它是并发流的一个真子集。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为并行流(parallel flow)，它们并行地运行(running in parallel)，且并行地执行(parallel execution)</p>
</li>
</ul>
<h3 id="用户模式和内核模式"><a href="#用户模式和内核模式" class="headerlink" title="用户模式和内核模式"></a>用户模式和内核模式</h3><ul>
<li><p>为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址范围</p>
</li>
<li><p>处理器通常是用某个控制寄存器中的一个模式位(mode bit)来提供这种功能，该寄存器描述了进程当前享有的特权。</p>
</li>
<li><p>当设置了模式位时，进程就运行在内核模式中。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何位置</p>
</li>
<li><p>运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过诸如中断，故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。</p>
</li>
<li><p>Linux提供了一种聪明的机制，叫做&#x2F;proc文件系统，它允许用户模式进程访问内核数据结构的内容。&#x2F;proc文件系统将许多内核数据结构的内容输出位一个用户程序可以读的文本文件的层次结构。</p>
</li>
<li><p>例如：</p>
<ul>
<li>可以使用&#x2F;proc文件系统找出一般的系统属性，例如CPU类型(&#x2F;proc&#x2F;cpuinfo)</li>
<li>某个特殊的进程使用的内存段(&#x2F;proc&#x2F;<process-id> &#x2F;maps)</li>
</ul>
</li>
</ul>
<h3 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h3><ul>
<li><p>从程序员的角度，我们可以认为进程总是处于下面三种状态之一：</p>
<ul>
<li>运行。进程要么在CPU上执行，要么在等待被执行且最终会被内核调度</li>
<li>停止。进程的执行被挂起(supspended)，且不会被调度。当收到SIGSTOP， SIGTSTP,SIGTTIN或者SIGTTOU时，进程就停止，并且保持停止直到它收到一个SIGCONT信号，在这个时刻，进程再次开始运行。</li>
<li>终止。进程永远地停止了。进程会因为三种原因终止：<ul>
<li>收到一个信号，该信号默认行为是终止进程</li>
<li>从主程序返回</li>
<li>调用exit函数</li>
</ul>
</li>
</ul>
</li>
<li><p>fork函数，被调用一次，返回两次：</p>
<ul>
<li>一次是在调用进程(父进程)中，一次是在新创建的子进程中。</li>
<li>在父进程中，fork返回子进程的PID。在子进程中，fork返回0.</li>
</ul>
</li>
</ul>
<h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><ul>
<li><p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，知道被它的父进程回收(reaped)。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已经终止的进程，从此时开始，该进程就不存在了。</p>
</li>
<li><p>一个终止了但是还未被回收的进程称为僵死进程(zombie)</p>
</li>
<li><p>如果一个父进程终止了，内核会安排init进程称为它的孤儿进程的养父。init进程的PID为1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。如果父进程没有回收它的僵死进程就终止了，那么内核会安排init进程去回收它们。不过长时间运行的程序，例如shell或者服务器，总是应该回收它们的僵死子进程。即使僵死子进程没有运行，它们仍然消耗系统的内存资源</p>
</li>
<li><p>pause函数</p>
<ul>
<li>该函数让调用函数休眠，直到该进程收到一个信号</li>
</ul>
</li>
</ul>
<h3 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h3><ul>
<li><p>execve函数在当前进程的上下文中加载并运行一个新程序</p>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>execve函数加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。</p>
</li>
<li><p>只有当出现错误时，例如找不到filename，execve才会返回到调用程序，所以，与fork一次调用返回两次不同，execve调用一次并从不返回</p>
</li>
</ul>
<h3 id="程序与进程"><a href="#程序与进程" class="headerlink" title="程序与进程"></a>程序与进程</h3><ul>
<li><p>确认一下所理解的程序和进程之间的区别。</p>
</li>
<li><p>程序是一堆代码和数据；程序可以作为目标文件存在于磁盘上，或者作为段存在于地址空间中。</p>
</li>
<li><p>进程是执行中程序的一个具体的实例；程序总是运行在某个进程的上下文中。</p>
</li>
<li><p>如果想要理解fork和execve函数，理解这个差异是很重要的。</p>
<ul>
<li>fork函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。</li>
<li>execve函数在当前进程的上下文中加载并运行一个新的程序。他会覆盖当前进程的地址空间，但并没有创建一个新的进程。新的程序仍然有相同的PID，并且继承了调用execve函数时已打开的所有文件描述符</li>
</ul>
</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><ul>
<li><p>Linux信号，它允许进程和内核中断其他进程</p>
</li>
<li><p>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的时间。</p>
</li>
<li><p>转储内存(dumping core)是一个历史术语，意思是把代码和数据内存段的映像写到磁盘上</p>
</li>
</ul>
<h3 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h3><ul>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>signal函数可以通过下列三种方法之一来改变和信号signum相关联的行为：</p>
<ul>
<li>如果handler是SIG_IGN，那么忽略类型为signum的信号</li>
<li>如果handler是SIG_DFL，那么类型为signum的信号行为恢复默认行为</li>
<li>否则，handler就是用户定义的函数的地址，这个函数被称为信号处理程序，只要程序接收到一个类型为signum的信号，就会调用这个程序。通过把处理程序的地址传递到signal函数从而改变默认行为，这叫做设置信号处理程序(installing the handler)。调用信号处理程序被称为捕获信号。执行信号处理程序被称为处理信号</li>
</ul>
</li>
<li><p>不可以用信号来对其他进程中发生的事件计数</p>
</li>
</ul>
<h3 id="C-和Java中的软件异常"><a href="#C-和Java中的软件异常" class="headerlink" title="C++和Java中的软件异常"></a>C++和Java中的软件异常</h3><ul>
<li>C++和Java提供的异常机制是较高层次的，是C语言的setjmp和longjmp函数的更加结构化的版本。你可以把try语句中的catch字句看做类似于setjmp函数。相似的，throw语句就类似于longjmp函数</li>
</ul>
<h3 id="操作进程的工具"><a href="#操作进程的工具" class="headerlink" title="操作进程的工具"></a>操作进程的工具</h3><ul>
<li><p>Linux程序提供了大量的监控和操作进程的有用工具</p>
</li>
<li><p>STRACE:</p>
<ul>
<li>打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。</li>
<li>用-static编译你的程序，能够得到一个更加干净的，不带有大量与共享库有关的输出的轨迹</li>
</ul>
</li>
<li><p>PS：</p>
<ul>
<li>列出当前系统中的进程，包括僵死进程</li>
</ul>
</li>
<li><p>TOP：</p>
<ul>
<li>打印出关于当前进程资源使用的信息</li>
</ul>
</li>
<li><p>PMAP：</p>
<ul>
<li>显示进程的内存映射</li>
</ul>
</li>
<li><p>&#x2F;proc:</p>
<ul>
<li>一个虚拟文件系统，以ASCII文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。例如，输出”cat &#x2F;proc&#x2F;loadavg”，可以看到你的Linux系统上当前的平均负载</li>
</ul>
</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>异常控制流(ECF)发生在计算机系统的各个层次，是计算机系统中提供并发的基本机制</p>
</li>
<li><p>在硬件层，异常是由处理器中的事件触发的控制流中的突变。控制流传递给一个软件处理程序，该处理程序进行一些处理，然后返回控制给被中断的控制流</p>
</li>
<li><p>有四种不同类型的异常：中断，故障，终止和陷阱。</p>
</li>
<li><p>当一个外部I&#x2F;O设备(例如定时器芯片或者磁盘控制器)设置了处理器芯片上的中断管脚时，(对于任意指令)中断会异步地发生。控制返回到故障指令后面的那条指令。一条指令的执行可能导致故障和终止同步发生。故障处理程序会重新启动故障指令，而终止处理程序从不将控制返回给被中断的流。最后，陷阱就像是用来实现向应用提供到操作系统代码的受控的入口点的系统调用的函数调用</p>
</li>
<li><p>在操作系统层，内核用ECP提供进程的基本概念。进程提供给应用两个重要的抽象：</p>
<ul>
<li>逻辑控制流，它提供给每个进程一个假象，好像它是独占地使用处理器</li>
<li>私有地址空间，它提供给每个程序一个假象，好像它是在独占地使用主存</li>
</ul>
</li>
<li><p>在操作系统和应用程序之间的接口处，应用程序可以创建子进程，等待它们的子进程停止或者终止，运行新的程序，以及捕获来自其他进程的信号。信号处理的语义是微妙的，并且随系统不同而不同，然后，在与Posix兼容的系统上存在着一些机制，允许程序清楚地指定期望的信号处理语义</p>
</li>
<li><p>最后，在应用层，C程序可以使用非本地跳转来规避正常的调用&#x2F;返回栈规则，并且直接从一个函数分支到另一个函数。</p>
</li>
</ul>
<h2 id="第九章-虚拟内存"><a href="#第九章-虚拟内存" class="headerlink" title="第九章 虚拟内存"></a>第九章 虚拟内存</h2><ul>
<li><p>为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存(VM)。</p>
</li>
<li><p>虚拟内存是硬件异常，硬件地址翻译，主存，磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的，一致的和私有的地址空间。</p>
</li>
<li><p>通过一个很清晰的机制，虚拟内存提供了三个重要的能力：</p>
<ul>
<li>它将主存看成是一个存储在磁盘上的地址空间的高速缓存，它高效地使用了主存</li>
<li>它为每个进程提供了一致的地址空间，从而简化了内存管理</li>
<li>它保护了每个进程的地址空间不被其他进程破坏</li>
</ul>
</li>
</ul>
<h3 id="物理和虚拟寻址"><a href="#物理和虚拟寻址" class="headerlink" title="物理和虚拟寻址"></a>物理和虚拟寻址</h3><ul>
<li><p>计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址(Physical Address, PA)。</p>
</li>
<li><p>第一个字节的地址为0，接下来的字节地址为1，在下一个为2，以此类推。给定这种简单的结构，CPU访问内存的最自然的方式就是使用物理地址。我们把这种方式称为物理寻址(physical addressing)。</p>
</li>
<li><p>早期的PC使用物理寻址，而且诸如数字信号处理器，嵌入式微控制器以及Cray超级计算机这样的系统仍然继续使用这种寻址方式。</p>
</li>
<li><p>使用虚拟寻址，CPU通过生成一个虚拟地址(Virtual Address, VA)来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。</p>
</li>
<li><p>将一个虚拟地址转换为物理地址的任务叫做地址翻译(address translation)。</p>
</li>
<li><p>就像异常处理一样，地址翻译需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做内存管理单元(Memory Management Unit, MMU)的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p>
</li>
</ul>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><ul>
<li><p>地址空间(address space)是一个非负整数地址的有序集合</p>
</li>
<li><p>如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间(linear address space)</p>
</li>
<li><p>在一个带虚拟内存的系统中，CPU从一个有N&#x3D;2的n次方个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间(virtual address space)</p>
</li>
<li><p>一个地址空间的大小是由表示最大地址所需要的位数来描述的。例如，一个包含N&#x3D;2的n次方个地址的虚拟地址空间就叫做一个n位地址空间。现代系统通常支持32位或者64位虚拟地址空间</p>
</li>
<li><p>一个系统还有一个物理地址空间(physical address space)，对应于系统中物理内存的M个字节</p>
</li>
<li><p>地址空间的概念是很重要的，因为它清楚的区分了数据对象(字节)和它们的属性(地址)。一旦认识到了这种区别，那么我们就可以将其推广，允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想。主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选择物理地址空间的物理地址</p>
</li>
</ul>
<h3 id="虚拟内存作为缓存的工具"><a href="#虚拟内存作为缓存的工具" class="headerlink" title="虚拟内存作为缓存的工具"></a>虚拟内存作为缓存的工具</h3><ul>
<li><p>概念上而言，虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。</p>
</li>
<li><p>和存储器层次结构中其他缓存一样，磁盘(较低层)上的数据被分割成块，这些块作为磁盘和主存(较高层)之间的传输单元。VM系统通过将虚拟内存分割为称为虚拟页(Virtual Page, VP)的大小固定的块来处理这个问题。类似的，物理内存被分割为物理页(Physical Page, PP)物理页也被称为页帧(page frame)</p>
</li>
<li><p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p>
<ul>
<li>未分配的：VM系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间</li>
<li>缓存的：当前已缓存在物理内存中的已分配页</li>
<li>未缓存的：未缓存在物理内存中的已分配页</li>
</ul>
</li>
</ul>
<h3 id="DRAM缓存的组织结构"><a href="#DRAM缓存的组织结构" class="headerlink" title="DRAM缓存的组织结构"></a>DRAM缓存的组织结构</h3><ul>
<li><p>为了有助于清晰理解存储器层次结构中不同的缓存概念，</p>
<ul>
<li>我们将使用术语SRAM缓存来表示位于CPU和主存之间的L1，L2和L3高速缓存</li>
<li>并且用术语DRAM缓存在表示虚拟内存系统的缓存，它在主存中缓存虚拟页</li>
</ul>
</li>
<li><p>虚拟内存是在20世纪60年代早期发明的，远在CPU-内存之间差距的加大引发产生的SRAM缓存之前。因此，虚拟内存系统使用了和SRAM缓存不同的术语，即使它们的许多概念是相似的。</p>
</li>
<li><p>在虚拟内存的习惯说法中，块被称为页。在磁盘和内存之间传送页的活动叫做交换(swapping)或者页面调度(paging)。页从磁盘换入(或者页面调入)DRAM和DRAM换出(或者页面调出)磁盘。一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的这种策略称为按需页面调度(demand paging)</p>
</li>
<li><p>可以利用Linux的getrusage函数检测缺页的数量，以及其他信息</p>
</li>
</ul>
<h3 id="虚拟内存作为内存管理的工具"><a href="#虚拟内存作为内存管理的工具" class="headerlink" title="虚拟内存作为内存管理的工具"></a>虚拟内存作为内存管理的工具</h3><ul>
<li><p>到目前为止，我们都假设有一个单独的页表，将一个虚拟地址空间映射到物理地址空间。实际上操作系统为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。</p>
</li>
<li><p>注意，多个虚拟页面可以映射到同一个共享物理页面上</p>
</li>
<li><p>按需页面调度和独立的虚拟地址空间的结合，对系统中内存的使用和管理造成了深渊的映像。特别的，VM简化了链接和加载，代码和数据共享，以及应用程序的内存分配</p>
</li>
<li><p>简化链接：</p>
<ul>
<li>独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处</li>
<li>对于64位地址空间，代码段总是从虚拟地址0x400000开始。数据段跟在代码段之后，中间有一段符合要求的对其空白。栈占据用户进程地址空间最高的部分，并向下生长。这样的一致性极大地简化了链接器的设计和实现，允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。</li>
</ul>
</li>
<li><p>简化加载：</p>
<ul>
<li>虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中.text和.data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页，把它们标记为无效的(即未被缓存的)，将页表条目指向目标文件中适当的位置。</li>
<li>有趣的是，加载器从不从磁盘到内存实际复制任何数据。在每个页初次被引用时，要么是CPU取指令时引用的，要么是一条正在执行的指令引用一个内存位置时应用的，虚拟内存系统会按照自动地调入数据也。</li>
</ul>
</li>
<li><p>将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称作内存映射(memory mapping)。Linux提供一个称为mmap的系统调用，允许应用程序自己做内存映射</p>
</li>
<li><p>简化共享：</p>
<ul>
<li>独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。</li>
<li>一般而言，每个进程都有自己私有的代码，数据，堆以及栈区域，是不和其他进程共享的。在这种情况中，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面</li>
</ul>
</li>
</ul>
<h3 id="虚拟内存作为内存保护的工具"><a href="#虚拟内存作为内存保护的工具" class="headerlink" title="虚拟内存作为内存保护的工具"></a>虚拟内存作为内存保护的工具</h3><ul>
<li><p>任何现代计算机系统必须为操作系统提供手段来控制对内存系统的访问。</p>
<ul>
<li>不应该允许一个用户进程修改它的只读代码段</li>
<li>不应该允许它读或修改任何内核中的代码和数据结构</li>
<li>不应该允许它读或者写其他进程的私有内存</li>
<li>不允许它修改任何与其他进程共享的虚拟页面，除非所有的共享者都显示的允许它这么做(通过调用明确的进程间通信系统调用)</li>
</ul>
</li>
<li><p>如果一条指令违反了这些许可条件，那么CPU就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Linux shell一般将这种异常报告为 段错误(segmentation fault)</p>
</li>
</ul>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><ul>
<li><p>Linux通过将一个虚拟内存区域与一个磁盘上的对象(object)关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)</p>
</li>
<li><p>虚拟内存区域可以映射到两种类型的对象中的一种：</p>
<ul>
<li>Linux文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分</li>
<li>匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零</li>
</ul>
</li>
<li><p>无论在哪种情况下，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件(swap file)之间换来换去。交换文件也叫做交换空间(swap space)或者交换区域(swap area)</p>
</li>
</ul>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><ul>
<li><p>虽然可以使用低级的mmap和munmap函数来创建和删除虚拟内存的区域，但是C程序员还是会觉得当运行时需要额外虚拟内存时，用动态内存分配器(dynamic memory allocator)更方便，也有更好的可移植性</p>
</li>
<li><p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆(heap)。</p>
</li>
<li><p>假设堆是一个请求二进制零的区域，他紧接着再未初始化的数据区域后开始，并向上生长(向更高的地址)。</p>
</li>
<li><p>对于每个进程，内核维护着一个变量brk(读做 break)，他指向堆的顶部</p>
</li>
<li><p>分配器将堆视为一组不同大小的块(block)的集合来维护。每个块就是一个连续的虚拟内存片(chunk)，要么是已经分配的，要么是空闲的。</p>
</li>
<li><p>已分配的块显示地保留为供应用程序使用。空闲块可用来分配。</p>
</li>
<li><p>空闲块保持空闲，直到他显示的被应用所分配。</p>
</li>
<li><p>一个已经分配的块保持已经分配状态，直到它被释放，这种释放要么是应用程序显示执行的，要么是内存分配器自身隐式执行的</p>
</li>
<li><p>分配器有两种基本风格。两种风格都要求应用显示地分配块。他们的不同之处在于由那个实体来负责释放已经配分的块。</p>
<ul>
<li>显示分配器(explicit allocator)，要求应用显示的释放任何已经分配的块。例如，C标准库提供一种叫做malloc程序包的显示分配器。<ul>
<li>C程序通过调用malloc函数来分配一个块，并通过调用free函数来释放一个块</li>
<li>C++中的new和delete操作符与C中的malloc和free相当</li>
</ul>
</li>
</ul>
</li>
<li><p>隐式分配器(implicit allocator)，另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。</p>
<ul>
<li>隐式分配器也叫做垃圾收集器(garbage collector)，而自动释放未使用的已分配的块的过程叫做垃圾收集(garbag collection)。</li>
<li>例如，诸如Lisp， ML以及Java之类的高级语言就依赖垃圾收集来释放已分配的块</li>
</ul>
</li>
</ul>
<h3 id="为什么要使用动态内存分配"><a href="#为什么要使用动态内存分配" class="headerlink" title="为什么要使用动态内存分配"></a>为什么要使用动态内存分配</h3><ul>
<li>程序使用动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数据结构的大小。</li>
</ul>
<h3 id="分配器的要求和目标"><a href="#分配器的要求和目标" class="headerlink" title="分配器的要求和目标"></a>分配器的要求和目标</h3><ul>
<li>显式分配器必须再一些相当严格的约束条件下工作：<ul>
<li>处理任意请求序列。一个应用可以有任意的分配请求和释放请求序列，只要满足约束条件：每个释放请求必须对应于一个当前已分配块，这个块是由一个以前的分配请求获得的。因此，分配器不可以假设分配和释放请求的顺序。例如，分配器不能假设所有的分配请求都有想匹配的释放请求，或者有相匹配的分配和空闲请求是嵌套的</li>
<li>立即响应请求。分配器必须立即响应分配请求。因此，不允许分配器为了提高性能重新排列或者缓冲请求</li>
<li>只使用堆。为了使分配器是可扩展的，分配器使用的任何非标量数据结构都必须保存在堆里</li>
<li>对齐块(对齐要求)。分配器必须对齐块，使得它可以保存任何类型的数据对象</li>
<li>不修改已分配的块。分配器只能操作或者改变空闲块。特别是，一旦块被分配了，就不允许修改或者移动它了。因此，诸如压缩已分配块这样的技术是不允许使用的。</li>
</ul>
</li>
</ul>
<h3 id="C程序中常见的与内存有关的错误"><a href="#C程序中常见的与内存有关的错误" class="headerlink" title="C程序中常见的与内存有关的错误"></a>C程序中常见的与内存有关的错误</h3><ul>
<li><p>间接引用坏指针</p>
<ul>
<li>再进程的虚拟地址空间中有较大的洞，没有映射到任何有意义的数据。如果我们试图间接引用一个指向这些洞的指针，那么操作系统就会以段异常中止程序。</li>
<li>而且，虚拟内存的某些区域是只读的。试图写这些区域将会以保护异常中止这个程序。</li>
</ul>
</li>
<li><p>读未初始化的内存</p>
<ul>
<li>虽然bss内存位置(诸如未初始化的全局C变量)总是被加载器初始化为零，但是对于堆内存却不是这样的。</li>
<li>一个常见的错误就是假设堆内存被初始化为零</li>
</ul>
</li>
<li><p>允许栈缓冲区溢出</p>
<ul>
<li>如果一个程序不检查输入串的大小就写入栈中的目标缓冲区，那么这个程序就会有缓冲区溢出错误(buffer overflow bug)</li>
</ul>
</li>
<li><p>假设指针和它们指向的对象是相同大小的</p>
<ul>
<li>一种常见的错误是假设指向对象的指针和他们所指向的对象是相同大小的。</li>
</ul>
</li>
<li><p>造成错位错误</p>
<ul>
<li>错位(off-by-one)错误是另一种很常见的造成覆盖错误的来源</li>
</ul>
</li>
<li><p>引用指针，而不是它所指向的对象</p>
<ul>
<li>如果不太注意C操作符的优先级和结合性，我们就会错误地操作指针，而不是指针所指向的对象。</li>
</ul>
</li>
<li><p>误解指针运算</p>
<ul>
<li>另一种常见的错误是忘记了指针的算术操作是以他们指向的对象的大小为单位阿里进行的，而这种大小单位并不一定是字节</li>
</ul>
</li>
<li><p>引用不存在的变量</p>
<ul>
<li>没有太多经验的C程序员不理解栈的规则，有时会引用不合法的本地变量</li>
</ul>
</li>
<li><p>引用空闲堆块中的数据</p>
<ul>
<li>一个相似的错误是引用已经被释放了的堆块中的数据。</li>
</ul>
</li>
<li><p>引起内存泄漏</p>
<ul>
<li>内存泄漏是缓慢，隐性的杀手，当程序员不小心忘记释放已分配块，而再堆里创建了垃圾时，会发生这种问题</li>
</ul>
</li>
</ul>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul>
<li>虚拟内存是对主存的一个抽象。支持虚拟内存的处理器通过使用一种叫做虚拟寻址的间接形式来引用主存。处理器产生一个虚拟地址，在被发送到主存之前，这个地址被翻译成一个物理地址。从虚拟地址空间到物理地址空间的地址翻译要求硬件和软件紧密合作。专门的硬件通过使用页表来翻译虚拟地址，而页表的内容是由操作系统提供的。</li>
</ul>
<h2 id="第十章-系统级I-O"><a href="#第十章-系统级I-O" class="headerlink" title="第十章 系统级I&#x2F;O"></a>第十章 系统级I&#x2F;O</h2><ul>
<li>输入&#x2F;输出(I&#x2F;O)是在主存和外部设备(例如磁盘驱动器，终端和网络)之间复制数据的过程。输入操作是从I&#x2F;O设备复制数据到主存，而输入操作是从主存复制数据到I&#x2F;O设备。</li>
</ul>
<h3 id="Unix-I-O"><a href="#Unix-I-O" class="headerlink" title="Unix I&#x2F;O"></a>Unix I&#x2F;O</h3><ul>
<li>一个Linux文件就是一个m个字节的序列</li>
<li>所有的I&#x2F;O设备(例如网络，磁盘和终端)都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单，低级的应用接口，称为Unix I&#x2F;O。这使得所有的输入和输出都能以一种统一且一致的方式来执行：<ul>
<li>打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I&#x2F;O设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需要记住这个描述符。</li>
<li>Linux shell创建的每个进程开始时都有三个打开的文件：标准输入(描述符为0)，标准输出(描述符为1)和标准错误(描述符为2).头文件&lt;unistd.h&gt;定义了常量STDIN_FILENO, STDOUT_FILENO与STDERR_FILENO，他们可用来代替显示的描述符常量</li>
<li>改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显示地设置文件的当前位置。</li>
<li>读写文件。一个读操作就是从文件复制n &gt; 0个字节到内存，从当前文件位置k开始，然后将k增加k+n。给定一个大小为m字节的文件，当k &gt;&#x3D; m时执行读操作会触发一个称为end-of-file(EOF)的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的EOF符号</li>
<li>关闭文件。当应用完成了对文件的访问之后，就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因中止时，内核都会关闭所有打开的文件并释放他们的内存资源。</li>
</ul>
</li>
</ul>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul>
<li><p>每个Linux文件都有一个类型(type)来表明它在系统中的角色：</p>
</li>
<li><p>普通文件(regular file)包含任意数据。应用程序常常要区分文本文件(text file)和二进制文件(binary file)。</p>
<ul>
<li>文本文件是只包含有ASCII或Unicode字符的普通文件</li>
<li>二进制文件是所有其他的文件。</li>
<li>对内核而言，文本文件和二进制文件没有区别</li>
<li>Linux文本文件包含了一个文本行(text line)序列，其中每一行都是一个字符序列，以一个新行符(“\n”)结束。新行符与ASCII的换行符(LF)是一样的，其数字值为0x0a</li>
</ul>
</li>
<li><p>目录(directory)是包含一组链接(link)的文件，其中每个链接都将一个文件名(filename)映射到一个文件，这个文件可能是另一个目录。每个目录至少包含有两个条目</p>
<ul>
<li><code>.</code>是到该目录自身的链接</li>
<li><code>..</code>是到目录层次结构中父目录(parent directory)的链接</li>
</ul>
</li>
<li><p>套接字(socket)是用来与另一个进程进行跨网络通信的文件</p>
</li>
</ul>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>Linux提供了少量的基于Unix I&#x2F;O模型的系统级函数，它们允许应用程序打开，关闭，读和写文件，提取文件的元数据，以及执行I&#x2F;O重定向。Linux的读和写操作会出现不足值，应用程序必须能正确地预计和处理这种情况。应用程序不应直接调用Unix I&#x2F;O函数</p>
</li>
<li><p>Linux内核使用三个相关的数据结构来表示打开的文件。描述符表中的表项指向打开文件表中的表项，而打开文件表中的表项又指向v-node表中的表项。每个进程都有它自己单独的描述符表，而所有进程共享同一个打开文件表和v-node表。理解这些结构的一般组成就能使我们清楚的理解文件共享和I&#x2F;O重定向</p>
</li>
<li><p>标准I&#x2F;O库是基于Unix I&#x2F;O实现的，并提供了一组强大的高级I&#x2F;O例程。对于大多数应用程序而言，标准I&#x2F;O更简单，是优于Unix I&#x2F;O的选择。然而，因为对标准I&#x2F;O和网络文件的一些相互不兼容的限制，Unix I&#x2F;O比之标准I&#x2F;O更适用于网络应用程序</p>
</li>
</ul>
<h2 id="第十一章-网络编程"><a href="#第十一章-网络编程" class="headerlink" title="第十一章 网络编程"></a>第十一章 网络编程</h2><ul>
<li><p>对主机而言，网络只是又一种I&#x2F;O设备，是数据源和数据接收方。</p>
</li>
<li><p>一个插到I&#x2F;O总线扩展槽的适配器提供了到网络的物理接口。从网络上接收到的数据从适配器经过I&#x2F;O和内存总线赋值到内存，通常是tongguoDMA传送。相似的，数据也能从内存复制到网络</p>
</li>
<li><p>从Linux内核的角度来看，一个套接字就是通信的一个端点。从Linux程序的角度来看，套接字就是一个有相应描述符的打开文件</p>
</li>
</ul>
<h3 id="Web-内容"><a href="#Web-内容" class="headerlink" title="Web 内容"></a>Web 内容</h3><ul>
<li><p>对于Web客户端和服务器而言，内容是与一个MIME(Multipurpose Internet Mail Extensions, 多用途的网际邮件扩充协议)类型相关的字节序列。</p>
</li>
<li><p>常用的MIME类型：</p>
<ul>
<li>text&#x2F;html  – HTML页面</li>
<li>text&#x2F;plain – 无格式文本</li>
<li>application&#x2F;postscript – Postscript文档</li>
<li>image&#x2F;gif  – GIF格式编码的二进制图像</li>
<li>image&#x2F;png  – PNG格式编码的二进制图像</li>
<li>image&#x2F;jpeg – JPEG格式编码的二进制图像</li>
</ul>
</li>
<li><p>Web服务器以两种不同的方式向客户端提供内容：</p>
<ul>
<li>取一个磁盘文件，并将它的内容返回给客户端。磁盘文件称为静态内容(static content),而返回文件给客户端的过程称为服务静态内容(serving static content)</li>
<li>运行一个可执行文件，并将它的输出返回给客户端。运行时可执行文件产出的输出称为动态内容(dynamic content)，而运行程序并返回它的输出到客户端的过程称为服务动态内容(serving dynamic content)</li>
</ul>
</li>
<li><p>状态码(status-code)是一个三位的正整数，指明对请求的处理，状态消息(status message)给出与错误代码等价的英文描述</p>
</li>
<li><p>常见的状态码，以及它们相应的消息：</p>
<ul>
<li>200  –  成功  –  处理请求无误</li>
<li>301  –  永久移动 – 内容已移动到location头中指明的主机上</li>
<li>400  –  错误请求  – 服务器不能理解请求</li>
<li>403  –  禁止  服务器无权访问所请求的文件</li>
<li>404  –  未发现  服务器不能找到所请求的文件</li>
<li>501  –  未实现  服务器不支持请求的方法</li>
<li>505  –  HTTP版本不支持  服务器不支持请求的版本</li>
</ul>
</li>
</ul>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>每个网络应用都是基于客户端-服务器模型的。根据这个模型，一个应用是由一个服务器和一个或多个客户端组成的。服务器管理资源，以某种方式操作资源，为它的客户端提供服务。客户端-服务器模型中的基本操作是客户端-服务器事务，它是由客户端请求和跟随其后的服务器响应组成的。</p>
</li>
<li><p>客户端和服务器通过因特网这个全球网络来通信。从程序员的观点来看，我们可以把因特网看成是一个全球范围的主机集合，具有一下几个属性：</p>
<ul>
<li>每个因特网主机都有一个唯一的32位名字，称为它的IP地址</li>
<li>IP地址的集合被映射为一个因特网域名的集合</li>
<li>不同因特网主机上的进程能够通过连接互相通信</li>
</ul>
</li>
<li><p>客户端和服务器通过使用套接字建立连接。一个套接字是连接的一个端点，连接以文件描述符的形式提供给应用程序。套接字接口提供了打开和关闭套接字描述符的函数。客户端和服务器通过读写这些描述符来实现彼此间的通信</p>
</li>
</ul>
<h2 id="第十二章-并发编程"><a href="#第十二章-并发编程" class="headerlink" title="第十二章 并发编程"></a>第十二章 并发编程</h2><ul>
<li>使用应用级并发的应用程序称为并发程序(concurrent program)。现代操作系统提供了三种基本的构造并发程序的方法：<ul>
<li>进程。用这种方法，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的进程间通信(interprocess communication, IPC)机制</li>
<li>I&#x2F;O多路复用。在这种形式的并发编程中，应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式的从一个状态转换到另一个状态。因为程序是一个单独的进程，所以所有的流都共享同一个地址空间。</li>
<li>线程。线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。你可以把线程看成是其他两种方式的混合体，像进程流一样由内核进行调度，而像I&#x2F;O多路复用流一样共享同一个虚拟地址空间</li>
</ul>
</li>
</ul>
<h3 id="基于线程的并发编程"><a href="#基于线程的并发编程" class="headerlink" title="基于线程的并发编程"></a>基于线程的并发编程</h3><ul>
<li><p>到目前为止，我们已经看到了两种创建并发逻辑流的方法。</p>
<ul>
<li>在第一种方法中，我们为每个流使用了单独的进程。内核会自动调度每个进程，而每个进程都有它自己的私有地址空间，者使得流共享数据很困难</li>
<li>在第二种方法中，我们创建自己的逻辑流，并利用I&#x2F;O多路复用来显式的调度流。因为只有一个进程，所有的流共享整个地址空间</li>
</ul>
</li>
<li><p>线程(thread)就是运行在进程上下文中的逻辑流。线程由内核自动调度。每个线程都有它自己的线程上下文(thread context)，包括一个唯一的整数线程ID(Thread ID, TID)，栈，栈指针，程序计数器，通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间</p>
</li>
</ul>
<h3 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h3><ul>
<li>在任何一个时间点上，线程是可结合的(joinable)或者是分离的(detached)。一个可结合的线程能够被其他线程收回和杀死。在被其他线程回收之前，它的内存资源(例如栈)是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在它终止时由系统自动释放</li>
</ul>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul>
<li><p>当用线程编写程序时，必须小心地编写那些具有称为线程安全性(thread safety)属性的函数。一个函数被称为线程安全的(thread-safe)，当且仅当被多个并发线程反复调用时，它会一直产生正确的结果。如果一个线程不是线程安全的，我们就说它是线程不安全的(thread-unsafe)</p>
</li>
<li><p>我们能够定义出四个(不相交的)线程不安全函数类：</p>
<ul>
<li>不保护共享变量的函数</li>
<li>保护跨越多个调用的状态的函数</li>
<li>返回指向静态变量的指针的函数</li>
<li>调用线程不安全函数的函数</li>
</ul>
</li>
</ul>
<h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><ul>
<li>有一类重要的线程安全函数，叫做可重入函数(reentrant function)，其特点在于它们具有这种一种属性：<ul>
<li>当它们被多个线程调用时，不会引用任何共享数据。</li>
</ul>
</li>
</ul>
<h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><ul>
<li><p>当一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它的控制流中的x点时，就会发生竞争(race)</p>
</li>
<li><p>通常发生竞争是因为程序员假定线程将按照某种特殊的轨迹线穿过执行状态空间，而忘记了另一条准则规定：多线程的程序必须对任何可行的轨迹线都正确工作</p>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li><p>死锁，指的是一组线程被阻塞了，等待一个永远也不会为真的条件</p>
</li>
<li><p>互斥锁加锁顺序规则：</p>
<ul>
<li>给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放的，那么这个程序就是无死锁的</li>
</ul>
</li>
</ul>
<h2 id="附录-错误处理"><a href="#附录-错误处理" class="headerlink" title="附录 错误处理"></a>附录 错误处理</h2><ul>
<li>系统级函数调用使用三种不同风格的返回错误：<ul>
<li>Unix风格</li>
<li>Posix风格</li>
<li>GAI风格</li>
</ul>
</li>
</ul>
<h3 id="Unix风格的错误处理"><a href="#Unix风格的错误处理" class="headerlink" title="Unix风格的错误处理"></a>Unix风格的错误处理</h3><ul>
<li>像fork和wait这样Unix早期开发出来的函数返回值即包括错误代码，也包括有用的结果</li>
</ul>
<h3 id="Posix风格的错误处理"><a href="#Posix风格的错误处理" class="headerlink" title="Posix风格的错误处理"></a>Posix风格的错误处理</h3><ul>
<li>许多较新的Posix函数，例如Pthread函数，只用返回值来表明成功(0)或者失败(非0)。任何有用的结果都返回在通过引用传递进来的函数参数中。我们称这种方法为Posix风格的错误处理</li>
</ul>
<h3 id="GAI风格的错误处理"><a href="#GAI风格的错误处理" class="headerlink" title="GAI风格的错误处理"></a>GAI风格的错误处理</h3><ul>
<li>getaddrinfo(GAI)和getnameinfo函数成功时返回零，失败是返回非零值</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/" class="post-title-link" itemprop="url">算法导论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>算法导论 阅读笔记</li>
</ul>
<h2 id="第一章-算法在计算中的作用"><a href="#第一章-算法在计算中的作用" class="headerlink" title="第一章 算法在计算中的作用"></a>第一章 算法在计算中的作用</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li><p>非形式地说，算法(algorithm)就是任何良定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。这样算法就是把输入转换成输出的计算步骤的一个序列。</p>
</li>
<li><p>一般来说，问题实例由计算该问题解所必须的(满足问题陈述中强加的各种约束的)输入组成。</p>
</li>
<li><p>因为许多程序使用排序作为一个中间步，所以排序是计算机科学中的一个基本操作。</p>
</li>
</ul>
<h2 id="第二章-算法基础"><a href="#第二章-算法基础" class="headerlink" title="第二章 算法基础"></a>第二章 算法基础</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li>插入排序，对于少量元素的排序，它是一个有效的算法</li>
</ul>
<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><ul>
<li><p>许多有用的算法在结构上是递归的：</p>
<ul>
<li>为了解决一个给定的问题，算法一次或多次递归地调用其自身以解决紧密相关的若干子问题。</li>
</ul>
</li>
<li><p>这些算法典型的遵循分治法的思想：</p>
<ul>
<li>将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</li>
</ul>
</li>
<li><p>分治模式在每层递归时都有三个步骤：</p>
<ul>
<li>分解原问题为若干子问题，这些子问题是原问题的规模较小的实例。</li>
<li>解决这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解。</li>
<li>合并这些子问题的解成原问题的解</li>
</ul>
</li>
<li><p>归并排序算法完全遵循分治模式。直观上其操作如下：</p>
<ul>
<li>分解：分解待排序的N个元素的序列成各觉有N&#x2F;2个元素的两个子序列。</li>
<li>解决：使用归并排序递归地排序两个子序列</li>
<li>合并：合并两个已经排序的子序列以产生已排序的答案。</li>
</ul>
</li>
</ul>
<h3 id="分析分治算法"><a href="#分析分治算法" class="headerlink" title="分析分治算法"></a>分析分治算法</h3><ul>
<li>当一个算法包含对其自身的递归调用时，我们往往可以用递归方程或递归式来描述其运行时间，该方程根据在较小输入上的运行时间来描述在规模为n的问题上的总运行时间。然后，我们可以使用数学工具来求解该递归式并给出算法性能的界</li>
</ul>
<h2 id="第三章-函数的增长"><a href="#第三章-函数的增长" class="headerlink" title="第三章 函数的增长"></a>第三章 函数的增长</h2><h3 id="渐近记号"><a href="#渐近记号" class="headerlink" title="渐近记号"></a>渐近记号</h3><ul>
<li>我们将主要使用渐近记号来描述算法的运行时间</li>
</ul>
<h2 id="第四章-分治策略"><a href="#第四章-分治策略" class="headerlink" title="第四章 分治策略"></a>第四章 分治策略</h2><ul>
<li><p>归并排序利用了分支策略。在分支策略中，我们递归地求解一个问题，在每层递归中应用如下三个步骤：</p>
<ul>
<li>分解(Divide)步骤将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。</li>
<li>解决(Conquer)步骤递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。</li>
<li>合并(Combine)步骤将子问题的解组合成原问题的解</li>
</ul>
</li>
<li><p>当子问题足够大，需要递归求解时，我们称之为递归情况(recursive case).</p>
</li>
<li><p>当子问题变得足够小，不再需要递归时，我们说递归已经“触底”，进入了基本情况(base case)。有时，除了与原问题形式完全一样的规模更小的子问题外，还需要求解与原问题不完全一样的子问题。我们将这些子问题的求解看做合并步骤的一部分。</p>
</li>
<li><p>递归式</p>
<ul>
<li>递归式与分支方法是紧密相关的。因为使用递归式可以很自然地刻画分支算法的运行时间。</li>
<li>一个递归式(recurrence)就是一个等式或不等式，他通过更小的输入上的函数值来描述一个函数。</li>
</ul>
</li>
</ul>
<h2 id="第五章-概率分析和随机算法"><a href="#第五章-概率分析和随机算法" class="headerlink" title="第五章 概率分析和随机算法"></a>第五章 概率分析和随机算法</h2><h3 id="概率分析"><a href="#概率分析" class="headerlink" title="概率分析"></a>概率分析</h3><ul>
<li><p>概率分析是在问题分析中应用概率的理念。</p>
</li>
<li><p>更一般的，如果一个算法的行为不仅由输入决定，而且也由随机数生成器(random-number generator)产生的数值决定，则称这个算法是随机的(randomized)</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-%E5%BA%94%E7%94%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6-%E8%BF%90%E5%8A%A8%E5%AD%A6-%E5%8A%A8%E5%8A%9B%E5%AD%A6%E4%B8%8E%E6%8E%A7%E5%88%B6%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-%E5%BA%94%E7%94%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6-%E8%BF%90%E5%8A%A8%E5%AD%A6-%E5%8A%A8%E5%8A%9B%E5%AD%A6%E4%B8%8E%E6%8E%A7%E5%88%B6%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">应用机器人学-运动学-动力学与控制技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>应用机器人学-运动学-动力学与控制技术 阅读笔记</li>
</ul>
<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><ul>
<li>美国机器人学研究所给出了机器人的定义:机器人是一个可重复编程的多功能操纵器,为了执行不同的任务,通过不同的程序驱动可用于移动材料、工具或者专业化装置。</li>
<li>从工程的角度来说,机器人是一个复杂的通用装置,它包含了机械机构、传感系统和自动控制系统。机器人学的理论基础包括:力学、电气科学、自动控制、数学和计算机科学。</li>
</ul>
<h3 id="机器人元器件"><a href="#机器人元器件" class="headerlink" title="机器人元器件"></a>机器人元器件</h3><ul>
<li>在运动学上，机器人手臂是由连接关节的连杆所组成的，以形成一个运动链。</li>
</ul>
<h4 id="连杆"><a href="#连杆" class="headerlink" title="连杆"></a>连杆</h4><ul>
<li>构成机器人的刚体被称为连杆。在机器人学中，我们有时使用机械臂表示连杆</li>
</ul>
<h4 id="关节"><a href="#关节" class="headerlink" title="关节"></a>关节</h4><ul>
<li><p>两个连杆在关节处通过接触而连接，在关节处它们的相对运动可用同一坐标表示。</p>
</li>
<li><p>典型的关节要么是旋转的，要么是棱柱的。</p>
<ul>
<li>旋转关节R，就像一个铰链，允许在两个连杆之间有相对的旋转</li>
<li>棱柱关节P，允许在两连杆之间有相对移动</li>
</ul>
</li>
<li><p>如果旋转关节将两连杆连接起来，它们将绕着一条线发生相对转动，这条线称为关节轴线。</p>
</li>
<li><p>如果棱柱关节将两连杆连接起来，它们将沿着一条直线发生移动，这条线也称为关节轴线</p>
</li>
<li><p>在关节处，描述两被连接连杆的单一坐标值称为关节坐标或者关节变量。</p>
<ul>
<li>对于旋转关节，关节变量是一角度</li>
<li>对于棱柱关节，关节变量则是距离</li>
</ul>
</li>
<li><p>主动关节的坐标由驱动器控制，而从动关节则没有驱动器。</p>
</li>
<li><p>从动关节变量是主动关节变量和机械臂几何参数的函数。因此，从动关节也可称为非主动关节或者自有关节</p>
</li>
<li><p>主动关节通常是移动或者转动，然而从动关节可以是任何能够提供面接触的低副关节，分别为：</p>
<ul>
<li>旋转副</li>
<li>移动副</li>
<li>圆柱副</li>
<li>螺旋副</li>
<li>球副</li>
<li>平面副</li>
</ul>
</li>
<li><p>旋转副关节和移动副关节是最常用的关节，它们用在串联机械手中。</p>
</li>
<li><p>其他的关节类型只不过是为了完成相同的功能或者提供附加自由度的一个实现</p>
</li>
<li><p>棱柱关节(移动副)和旋转关节(旋转副)提供一个自由度，因此一个机械手的关节数就是该机械手的自由度。</p>
</li>
<li><p>典型的机械手应该至少有6个自由度，3个自由度用于定位，3个自由度用于定向。</p>
</li>
<li><p>具有6个以上自由度的机械手在运动学上就是冗余机械手</p>
</li>
</ul>
<h4 id="机械手"><a href="#机械手" class="headerlink" title="机械手"></a>机械手</h4><ul>
<li>由连杆，关节和其他结构零部件所构成的机器人主题称为机械手。当一个机械手上装了手腕，夹持器和控制系统时，该机械手就变成了一个机器人</li>
</ul>
<h4 id="机械手腕"><a href="#机械手腕" class="headerlink" title="机械手腕"></a>机械手腕</h4><ul>
<li>在前臂与末端执行器之间的机器人运动链中的关节指的就是手腕。</li>
<li>用球关节设计机械手是普遍的做法</li>
</ul>
<h4 id="末端执行器"><a href="#末端执行器" class="headerlink" title="末端执行器"></a>末端执行器</h4><ul>
<li><p>末端执行器是安装在最后一根连杆上的元件，用于完成机器人所要求的工作。</p>
</li>
<li><p>最简单的末端执行器就是夹持器，它通常只有两个动作：张开和闭合</p>
</li>
<li><p>机器人中机械臂和手腕的装配基本上用于定位末端执行器或者能够执行的任何机具，就是末端执行器或者机具实际执行任务</p>
</li>
</ul>
<h4 id="驱动器"><a href="#驱动器" class="headerlink" title="驱动器"></a>驱动器</h4><h4 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h4><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><h3 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h3><ul>
<li><p>机械手工作空间是指末端执行器所能到达的空间体积。工作空间受限于机械手结构和机械的关节约束。</p>
</li>
<li><p>工作空间被分为可到达的工作空间和灵活的工作空间。</p>
<ul>
<li>可到达的工作空间就是在至少一个方向由末端执行器所引起的每个关节所到达的空间体积</li>
<li>灵活的工作空间是指在所有可能的方向上由末端执行器所引起的每个关节所到达的空间体积。</li>
</ul>
</li>
<li><p>灵活的工作空间是可能到达工作空间的一个子集</p>
</li>
</ul>
<h3 id="机器人运动学，动力学，控制概述"><a href="#机器人运动学，动力学，控制概述" class="headerlink" title="机器人运动学，动力学，控制概述"></a>机器人运动学，动力学，控制概述</h3><ul>
<li><p>正向运动学问题就是求解关节坐标的运动学参数，这些运动学参数再用来求解笛卡尔坐标系下的相关参数</p>
</li>
<li><p>逆向运动学问题就是求解笛卡尔空间中末端执行器的运动学参数，这些运动参数在关键空间中是必须的。</p>
</li>
<li><p>运动学(Kinematics)，是分析运动科学的一个分支，该学科不注重什么原因引起的运动。</p>
</li>
<li><p>通过运动我们表示任何类型位移，包括空置和方向的改变。因此，位移，相对于时间的连续导数，速度，加速度，加加速度，所有的这些都归入运动学</p>
</li>
<li><p>定位，就是使末端执行器在工作空间范围内到达一个任意点。而定向，就是使末端执行器移向在某位置处所要求的方向。</p>
<ul>
<li>定位是机械臂的工作</li>
<li>定向是手腕的工作</li>
</ul>
</li>
<li><p>动力学是用来研究系统随着时间变化所经历的状态变化的</p>
</li>
<li><p>机器人控制包括以下三个计算问题：</p>
<ul>
<li>笛卡尔坐标系中轨迹的确定</li>
<li>从笛卡尔轨迹到等效关节坐标空间的转换</li>
<li>形成实现轨迹的电动机转矩指令</li>
</ul>
</li>
</ul>
<h3 id="参考坐标系和坐标系统"><a href="#参考坐标系和坐标系统" class="headerlink" title="参考坐标系和坐标系统"></a>参考坐标系和坐标系统</h3><ul>
<li><p>在机器人学中，我们可在机器人的每根连杆上和机器人环境中的每个物体上建立一个或者更多的坐标系。</p>
</li>
<li><p>如此一来，坐标系间的转换，称为坐标转换，这是机器人建模与编程中的一个基本概念。</p>
</li>
<li><p>刚体的角运动可以用好几种方式描述，最常用的方式如下：</p>
<ul>
<li>关于右手定则的全局固定直角坐标轴的一组旋转运动</li>
<li>关于右手定则的运动直角坐标轴的一组旋转运动</li>
<li>空间中固定轴的角位移</li>
</ul>
</li>
<li><p>矢量和参考坐标系是分析复杂系统运动的主要工具，特别是当运动是三维空间的以及涉及许多零部件时</p>
</li>
<li><p>坐标系是由一组基本的矢量所定义的，例如沿着三个坐标轴的单位矢量。因此旋转矩阵作为坐标变换矩阵，也可以用来定义从一个坐标系到另一个坐标系的基本变化</p>
</li>
<li><p>旋转矩阵可用以下三种方式来解释：</p>
<ul>
<li>映射。它主要表述坐标转换，映射和点P在两个不同坐标系中的相关坐标</li>
<li>坐标描述。相对于固定坐标系，它给出变换坐标系的定向</li>
<li>算法。将一个矢量旋转，形成一个新的矢量</li>
</ul>
</li>
<li><p>刚体旋转可用 旋转矩阵R，欧拉角(Euler angles)，角轴公约(angle-axis convention)以及四元数(quaternion)来描述，每种方法都有其优缺点</p>
</li>
<li><p>在基体变化中，旋转矩阵R是正向解释，与此同时其缺点是必须知道9个合成的参数。每个单独参数失去了其物理意义,只有在整体矩阵上才有意义</p>
</li>
<li><p>欧拉角是通过由绕着局部 ( 有时全局)坐标系的 3 个坐标轴进行各自连续旋转来粗略定义的。使用欧拉角的优点是旋转运动可由 3 个具有普通物理意义的独立参数描述。其缺点是描述不独立并会产生奇异性问题。计算复合旋转也并不是一件简单的事情,除扩展成矩阵外。</p>
</li>
<li><p>角轴是能最直观地描述旋转运动的。但是,它要求 4 个参数能合成为一个单一的旋转运动,合成旋转运动的计算并不简单,对于小旋转来说它是病态的</p>
</li>
<li><p>四元数在直观保存角轴方面是很好的,并能克服小旋转的病态,确认一组结构允许合成旋转运动的计算。四元数的缺点是 4 个参数必须能够表述一个旋转运动。参数化比角轴更复杂,并且有时失去了其物理意义。四元数相乘并不像矩阵相乘那样简单明了</p>
</li>
</ul>
<h2 id="第二章-旋转运动学"><a href="#第二章-旋转运动学" class="headerlink" title="第二章 旋转运动学"></a>第二章 旋转运动学</h2><h3 id="全局翻滚角，俯仰角，偏航角"><a href="#全局翻滚角，俯仰角，偏航角" class="headerlink" title="全局翻滚角，俯仰角，偏航角"></a>全局翻滚角，俯仰角，偏航角</h3><ul>
<li>绕全局坐标系X轴的旋转被称为翻滚(roll)，绕全局坐标系Y轴的旋转被称为俯仰角(pitch)，绕全局坐标系Z轴的旋转被称为偏航(yaw)。</li>
</ul>
<h3 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h3><ul>
<li><p>绕全局坐标系的Z轴的旋转被称为旋进(即进动,precession)，绕局部坐标系的x轴的旋转被称为章动(nutation)，绕局部坐标系z轴的旋转被称为自转(spin)</p>
</li>
<li><p>旋进章动自转角(precession-nutation-spin rotation angles)也称为欧拉角。</p>
</li>
</ul>
<h2 id="第三章-定向运动学"><a href="#第三章-定向运动学" class="headerlink" title="第三章 定向运动学"></a>第三章 定向运动学</h2><h2 id="第四章-运动的运动学"><a href="#第四章-运动的运动学" class="headerlink" title="第四章 运动的运动学"></a>第四章 运动的运动学</h2><h3 id="螺旋坐标"><a href="#螺旋坐标" class="headerlink" title="螺旋坐标"></a>螺旋坐标</h3><ul>
<li>任何刚体运动都可以由沿着某轴的单一平动和绕着该轴的单一旋转运动合成产生。这称为沙勒定理(Chasles theorem)。这样的运动被称为螺旋运动</li>
</ul>
<h2 id="第五章-正向运动学"><a href="#第五章-正向运动学" class="headerlink" title="第五章 正向运动学"></a>第五章 正向运动学</h2><ul>
<li>对于给定的一组机器人几何特征，如果指导机器人节点变量，就能够确定机器人中每根连杆的位置和方向。我们可以在每根连杆上建立一个坐标系，并且通过刚体运动方法来确定相邻坐标系的配置，这样的分析被称为正向运动学</li>
</ul>
<h3 id="机器人正向位置运动学"><a href="#机器人正向位置运动学" class="headerlink" title="机器人正向位置运动学"></a>机器人正向位置运动学</h3><ul>
<li><p>正向或者直接运动学是旋转运动中从机器人关节变量空间到笛卡尔坐标系空间的运动变换。</p>
</li>
<li><p>对于一组给定的关节变量，求取末端执行器的位置和方向是正向运动学的主要问题。这个问题可以通过求取用于描述基体连杆坐标系中连杆运动信息的变换矩阵而得到解决</p>
</li>
<li><p>对于机械手，列写正向运动学方程的传统方法是通过D-H标记和坐标系处理连杆而获得的。因此，正向运动学是基本的变换运算</p>
</li>
<li><p>运动学信息包括位置，速度，加速度和突变。然而，正向运动学通常指的是位置分析，因此正向运动学等效于确定一个综合变换矩阵</p>
</li>
</ul>
<h3 id="组装运动学"><a href="#组装运动学" class="headerlink" title="组装运动学"></a>组装运动学</h3><ul>
<li><p>大部分现代工业机器人都有一个主要的机械手和一系列互变的手腕。机械手是多体的，以便他能抓住主要的力学单元，并且为手腕提供一个强有力的运动。</p>
</li>
<li><p>可变手腕是复杂多体，主要用来提供绕在腕点的三个旋转自由度。手腕基本连接至机械手的末端点。</p>
</li>
<li><p>机器人的手腕，实际操作不见也可以称为末端执行器</p>
</li>
</ul>
<h2 id="第六章-逆向运动学"><a href="#第六章-逆向运动学" class="headerlink" title="第六章 逆向运动学"></a>第六章 逆向运动学</h2><ul>
<li><p>对于给定配制的机器人来说，什么是关节变量呢？这就是逆向运动学研究的问题。</p>
</li>
<li><p>确定关节变量能够简化求解一组非线性耦合代数方程。</p>
</li>
<li><p>对于求解逆向运动学问题而言，虽然没有标准方法和常规的应用方法，但是仍有一些求解该问题的分析方法和数值解法。</p>
</li>
<li><p>逆向运动学的主要困难是多解</p>
</li>
</ul>
<h3 id="解耦技术"><a href="#解耦技术" class="headerlink" title="解耦技术"></a>解耦技术</h3><ul>
<li><p>依据末端执行器的位置和方向确定关节变量，称之为逆向运动学。数学上，逆向运动学主要寻找矢量q中的元素</p>
</li>
<li><p>计算机控制的机器人通常在关节变量空间中被驱动，然而通常在全局笛卡尔坐标系中表述被操作的物体。</p>
</li>
<li><p>因此，在机器人学中，必须携带关节空间和笛卡尔空间之间的运动信息。为了控制末端执行器到达一个物体的配置，必须求解逆向运动。</p>
</li>
<li><p>因此，我们需要知道在期望的方向上达到期望点所需的关节变量是什么</p>
</li>
<li><p>6自由度机器人的正向运动结果是一个4 * 4的变换矩阵</p>
</li>
<li><p>有可能将逆向运动学问题解耦成两个自问题，即众所周知的逆向位置运动学问题和逆向方向运动学问题。</p>
</li>
<li><p>这样解耦的一个实际结果就是将这个问题分解为两个独立的问题，每个问题只有3个未知数。按照解耦原理，机器人的综合变换矩阵可以分解为一个平动和一个转动。</p>
</li>
</ul>
<h3 id="逆向运动技术比较"><a href="#逆向运动技术比较" class="headerlink" title="逆向运动技术比较"></a>逆向运动技术比较</h3><ul>
<li><p>显然，当期望的末端执行器坐标位置超出了机器人的工作范围时，机器人关节变量没有任何实解。在这种情况下，平方根符号将使综合结果为负。</p>
</li>
<li><p>因此，通常来说，逆向运动学问题是否存在解取决于机器人的几何配置</p>
</li>
<li><p>正常情况即当关节数量为6时。假设没有多余的自由度，机器人末端执行器的配置在工作空间范围之内，逆向运动学的解有无数多个。为了达到同一末端执行器空间位置，不同解均相当于可能的配置</p>
</li>
<li><p>总的来说，当机器人逆向运动学的解存在时，其解不是唯一的。出现多解，这是因为机器人以不同的配置可以达到工作空间范围内的同一点</p>
</li>
</ul>
<h3 id="逆向运动技术"><a href="#逆向运动技术" class="headerlink" title="逆向运动技术"></a>逆向运动技术</h3><ul>
<li><p>可以用很多种方法求解机器人的逆向运动学问题，例如解耦，逆变换，迭代，螺旋代数，双重矩阵，双重四元数和其他几何技术。</p>
</li>
<li><p>迭代法通常要求大量的计算，而且他并不能保证收敛于正确解。机器人几乎不可能接近于齐次且衰退的配置。迭代求解法也缺乏从多个可能的解中选择最合适解的方法</p>
</li>
</ul>
<h3 id="奇异配置"><a href="#奇异配置" class="headerlink" title="奇异配置"></a>奇异配置</h3><ul>
<li><p>总的来说，对于任何机器人来说，冗余与否均有可能发现一些配置，称之为奇异配置。</p>
</li>
<li><p>在奇异配置总，末端执行器自由度的数目相对于产生动作的维数是次要的。当下列情况发生时会发生奇异配置：</p>
<ul>
<li>棱柱关节的两个轴是平行的，</li>
<li>旋转关节的两个轴是相同的。</li>
</ul>
</li>
<li><p>在奇异位置处，末端执行器失去一个或者更多的自由度，因为运动方程是线性相关的或者是不确定的。随着移动末端执行器所要求的速度理论上是无限的时，必须避免奇异位置。</p>
</li>
<li><p>雅可比矩阵不再满足秩的配置相当于机器人具有奇异性，通常有两种类型：</p>
<ul>
<li>工作空间边界奇异性(Work-space boundary singularities)。当机械手全部伸出或者自身完全折回时，便会出工作空间边界奇异性。在这种情况中，末端执行器接近或者就在工作空间边界处</li>
<li>工作空间内部奇异性(Work-space interior singularities)。这种情况出现在远离边界处。在这种情况中，通常有两个或者更多轴排成了一行</li>
</ul>
</li>
<li><p>在机器人学中，辨别和避开奇异性配置是非常重要的。主要原因如下：</p>
<ul>
<li>运动的确定方向无法达到</li>
<li>一些关节速度是无限的</li>
<li>一些关节转矩是无限的</li>
<li>逆向运动学问题不存在唯一解</li>
</ul>
</li>
</ul>
<h2 id="第七章-角速度"><a href="#第七章-角速度" class="headerlink" title="第七章 角速度"></a>第七章 角速度</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-Unix_system_programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-Unix_system_programming/" class="post-title-link" itemprop="url">Unix_system_programming</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="异步操作-asynchronous-operation"><a href="#异步操作-asynchronous-operation" class="headerlink" title="异步操作(asynchronous operation)"></a>异步操作(asynchronous operation)</h3><ul>
<li>是由于很多计算机系统事件会在不可预测的事件，以不可预测的顺序发生而产生的</li>
</ul>
<h3 id="并发-concurrency"><a href="#并发-concurrency" class="headerlink" title="并发(concurrency)"></a>并发(concurrency)</h3><ul>
<li>是指在相同的时间帧内对资源的共享</li>
<li>并发实体，可以是单个程序内部的执行线程或者其他抽象的对象</li>
<li>并发可能发生在单CPU系统，共享相同内存的多CPU系统，或者运行在网络上的独立系统中</li>
</ul>
<h3 id="通信-communication"><a href="#通信-communication" class="headerlink" title="通信(communication)"></a>通信(communication)</h3><ul>
<li>将一个实体的信息传送给另一个实体</li>
<li>程序在处理磁盘这样的本地设备的I&#x2F;O的同时，还必须要处理网络I&#x2F;O（网络通信）</li>
</ul>
<h3 id="上下文切换时间-context-switch-time"><a href="#上下文切换时间-context-switch-time" class="headerlink" title="上下文切换时间(context-switch time)"></a>上下文切换时间(context-switch time)</h3><ul>
<li>是指从执行一个进程转换到执行另一个进程所花费的时间</li>
</ul>
<h3 id="时间片-quantum"><a href="#时间片-quantum" class="headerlink" title="时间片(quantum)"></a>时间片(quantum)</h3><ul>
<li>大致上就是在一个进程不得不让出处理器让其他进程运行之前，分配给这个进程的CPU时间总量</li>
</ul>
<h3 id="多道程序设计-multiprogramming"><a href="#多道程序设计-multiprogramming" class="headerlink" title="多道程序设计(multiprogramming)"></a>多道程序设计(multiprogramming)</h3><ul>
<li><p>指由于处理时间上的悬殊差异，采取有多个进程准备好要执行，操作系统挑选一个已经准备好的进程来执行，当哪个进程需要等待资源时，操作系统保存从停止处回复此进程所需的所有信息，并选择另一个准备好的进程执行</p>
</li>
<li><p>一次资源请求会引起一次对操作系统的请求（即一次系统调用）</p>
</li>
</ul>
<h3 id="系统调用-system-call"><a href="#系统调用-system-call" class="headerlink" title="系统调用(system call)"></a>系统调用(system call)</h3><ul>
<li>是对操作系统服务的一次请求，它会使正常的CPU周期中断，并将控制权交给操作系统，然后，操作系统就可以切换到另一个进程了</li>
</ul>
<h3 id="分时-timesharing"><a href="#分时-timesharing" class="headerlink" title="分时(timesharing)"></a>分时(timesharing)</h3><ul>
<li>单物理CPU，并发</li>
</ul>
<h3 id="多处理器系统-multiprocessor-systems"><a href="#多处理器系统-multiprocessor-systems" class="headerlink" title="多处理器系统(multiprocessor systems)"></a>多处理器系统(multiprocessor systems)</h3><ul>
<li>几个处理器都访问一个共享的内存</li>
</ul>
<h3 id="硬件层并发"><a href="#硬件层并发" class="headerlink" title="硬件层并发"></a>硬件层并发</h3><ul>
<li>由于有多台设备要同时操作</li>
<li>处理器中有内部的并行机制，可以同时处理几条指令，系统中有多个处理器，而且系统通过网络通信进行交互</li>
</ul>
<h3 id="应用层并发"><a href="#应用层并发" class="headerlink" title="应用层并发"></a>应用层并发</h3><ul>
<li>在信号处理中，I&#x2F;O与其他处理的重叠中，在通信过程中，在进程间或同一进程的不同线程间的资源共享中，都存在应用层的并发</li>
</ul>
<h3 id="中断-interrupt"><a href="#中断-interrupt" class="headerlink" title="中断(interrupt)"></a>中断(interrupt)</h3><ul>
<li>在常规机器层(conventional machine level)程序中，单指令的执行是处理器指令周期(processor instruction cycle)的结果</li>
<li>在处理器指令周期的正常执行过程中，处理器从程序计数器中检索出一个地址，并执行这个地址上的指令。</li>
<li><strong>在常规机器层出现并发</strong>，是因为外围设备会产生一种被称为中断的电信号，在处理器内部设置一个硬件标志符。</li>
<li>检测中断是指令周期自身的一部分。在每个指令周期中，处理器都检查硬件标识。</li>
<li>如果处理器察觉有中断发生，它就保存程序计数器的当前值，并装载一个新的值，这个新的值是一个被称为中断服务例程(interrupt service routine)或中断处理程序(interupt handler)的特殊函数的地址</li>
</ul>
<h3 id="异步-asynchronous"><a href="#异步-asynchronous" class="headerlink" title="异步(asynchronous)"></a>异步(asynchronous)</h3><ul>
<li>如果一个事件发生的时间不是由某个实体确定的，那么这个事件就是异步于这个实体的。<ul>
<li>（外部硬件设备产生的中断通常都异步于系统中执行的程序）</li>
</ul>
</li>
</ul>
<h3 id="同步-synchronous"><a href="#同步-synchronous" class="headerlink" title="同步(synchronous)"></a>同步(synchronous)</h3><ul>
<li>如果向指令提供相同的数据，那么，像被零除这样的错误事件，就总是在执行某个特殊指令的时候发生，从这种意义上来说，错误事件是同步的</li>
</ul>
<h3 id="设备驱动程序-device-driver"><a href="#设备驱动程序-device-driver" class="headerlink" title="设备驱动程序(device driver)"></a>设备驱动程序(device driver)</h3><ul>
<li>被称为设备驱动程序的操作系统例程，通常用来处理外围设备产生的中断。</li>
<li>然后这些驱动程序会通过信号这样的软件机制，来通知相关的进程事件已经发生了</li>
</ul>
<h3 id="定时器-timer"><a href="#定时器-timer" class="headerlink" title="定时器(timer)"></a>定时器(timer)</h3><ul>
<li>操作系统也用中断来实现分时。</li>
<li>大多数计算机都有一个被称为定时器的设备，它可以在一段指定的时间间隔后产生中断。</li>
<li>为了执行用户程序，操作系统在设备程序计数器之前启动定时器。定时器到时的时候，它就产生一个中断，使CPU转而执行定时器中断服务例程。中断服务例程将操作系统代码的地址写入程序计数器，这样，操作系统又获得了控制权</li>
</ul>
<h3 id="信号-signal"><a href="#信号-signal" class="headerlink" title="信号(signal)"></a>信号(signal)</h3><ul>
<li>是事件的软件通知</li>
<li>通常，信号是操作系统对中断（硬件事件）的响应</li>
<li>例如，按下<code>Ctrl-C</code>键会使处理键盘的设备驱动程序产生一个中断。驱动程序将这些字符当做中断字符，并发送信号来通知与这个中断相关的进程</li>
<li>当引发信号的那个事件发生时，信号就产生了(generate)了  –  信号可以同步产生，也可以异步产生<ul>
<li>如果信号由接收它的进程或线程产生，这个信号就是同步产生的。执行非法指令都会产生同步信号</li>
<li>在键盘上输入<code>Ctrl-C</code>会产生一个异步信号</li>
</ul>
</li>
</ul>
<h3 id="捕捉-catch"><a href="#捕捉-catch" class="headerlink" title="捕捉(catch)"></a>捕捉(catch)</h3><ul>
<li>进程执行信号的处理程序时，它就捕捉到了信号</li>
<li>捕捉信号的程序至少有两个并发的部分，主程序和信号处理程序</li>
</ul>
<h3 id="进程，线程和资源共享"><a href="#进程，线程和资源共享" class="headerlink" title="进程，线程和资源共享"></a>进程，线程和资源共享</h3><ul>
<li>在UNIX中实现并发执行的一种传统方法是：用户通过调用<code>fork()</code>函数创建多个进程。</li>
<li>有相同祖先的进程可以通过管道(pipe)进行通信</li>
<li>没有共同祖先的进程可以通过信号，FIFO，信号量，共享的地址空间或消息进行通信</li>
<li>在进程内部可以通过多个执行线程提供并发。</li>
<li>程序执行时，CPU用程序计数器来确定下一步要执行哪条指令。得到的指令流被称为程序的执行线程(thread of execution)。它是进程的控制流</li>
</ul>
<h3 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h3><ul>
<li>并发和通信共同形成新的应用程序</li>
<li>在分布式计算中使用最广泛的模型是客户端-服务器模型(client-server model)。这个模型中的基本实体<ul>
<li>有管理资源的服务器进程，</li>
<li>和需要对共享资源进行访问的客户机进程</li>
</ul>
</li>
<li>基于对象的模型(object-based model)是分布式计算的另一种模型<ul>
<li>系统中的每种资源都被看作一个带有消息处理接口的对象，这样就可以用统一的方式来访问所有的资源</li>
<li>基于对象的模型允许进行受控的增量开发和代码重用</li>
</ul>
</li>
</ul>
<h3 id="缓冲区溢出-buffer-overflow"><a href="#缓冲区溢出-buffer-overflow" class="headerlink" title="缓冲区溢出(buffer overflow)"></a>缓冲区溢出(buffer overflow)</h3><ul>
<li><p>当程序将数据拷贝到一个没有为其分配足够空间的变量中去的时候，就会发生缓冲区溢出</p>
</li>
<li><p>缓冲区溢出的后果</p>
<ul>
<li>要理解缓冲区溢出时会发生什么情况，就要理解程序在内存中是如何布局的<ul>
<li>大多数程序代码都在带有自动局部变量的函数中执行</li>
<li>虽然在不同的机器上实现的细节有所不同，程序通常都在程序栈上分配自动变量</li>
</ul>
</li>
<li>在典型系统中，栈都是从高端内存向低端内存扩展的</li>
<li>调用一个函数时<ul>
<li>栈的低端部分包括传递的参数和返回地址</li>
<li>栈中较高的部分（内存地址比较小的部分）用来存放局部自动变量</li>
</ul>
</li>
<li>栈可以用来存储其他值，也可能包含根本不为程序所用的间隙</li>
<li>一个很重要的事实是：<ul>
<li>每次函数调用的返回地址通常都存储在自动变量后面的内存中（存储在地址比较大的内存中）</li>
</ul>
</li>
<li>当程序向栈中变量的范围之外写入时，回复阿生缓冲区溢出。额外的字节可能会重写未使用的空间，其他变量，返回地址或该程序不能合法访问的其他内存。</li>
<li>结果可能是没什么影响，也可能会造成程序崩溃，信息转储以及不可预测的行为</li>
</ul>
</li>
</ul>
<h2 id="程序，进程和线程"><a href="#程序，进程和线程" class="headerlink" title="程序，进程和线程"></a>程序，进程和线程</h2><h3 id="程序-program"><a href="#程序-program" class="headerlink" title="程序(program)"></a>程序(program)</h3><ul>
<li><p>指的是为了完成特定的任务而准备好的一个指令序列</p>
</li>
<li><p>C编译器将每个源文件翻译成一个目标文件，然后编译器将这些单个的目标文件同必须的一些库链接，形成一个可执行模块(executable module)。程序运行或执行(execute)时，操作系统将可执行模块拷贝到主存储器的程序映像(program image)中去</p>
</li>
</ul>
<h3 id="进程-process"><a href="#进程-process" class="headerlink" title="进程(process)"></a>进程(process)</h3><ul>
<li>是一个正在执行的程序实例</li>
<li>每个实例都有自己的地址空间和执行状态</li>
<li>操作系统记录进程ID和相应的进程状态，并用这些信息来分配和管理系统资源。操作系统还要对进程占用的内存和可分配的内存进行管理</li>
<li>当操作系统向内核数据结构中添加了适当的信息，并为运行程序代码分配了必要的资源之后，程序就变成了进程。</li>
<li>程序拥有地址空间（它可以访问的内存）和至少一个被称为线程的控制流</li>
<li>进程，以执行一个指令序列的控制流开始。处理器程序计数器记录处理器（CPU）要执行的下一条指令。CPU读取一条指令后，对程序计数器的值进行增量运算，并且在指令的执行过程中，比如，在出现分支的时候，还会对其做进一步的修改。</li>
<li>可能有多个进程驻存在内存中并发地执行，他们基本上都互相独立。如果进程要进行通信或互相合作，它们就必须显式地通过文件系统，管道，共享内存或网络这样的操作系统结构来交互</li>
</ul>
<h3 id="线程和执行线程-thread-of-execution"><a href="#线程和执行线程-thread-of-execution" class="headerlink" title="线程和执行线程(thread of execution)"></a>线程和执行线程(thread of execution)</h3><ul>
<li>程序执行时，由进程程序计数器的值来决定下面该执行哪一条进程指令。得到的指令流被称为执行线程</li>
<li>它可以用程序代码执行期间为程序计数器指定的指令地址序列来表示</li>
<li>执行线程中的指令序列对进程来说，就像是一条不间断的地址流。但从处理器的观点来看，来自不同进程的执行线程是混在一起的。</li>
<li>执行从一个进程切换到另一个进程的点被称作上下文切换(context switch)</li>
<li>线程，是代表了进程内执行线程的一种抽象数据类型。线程有自己的执行栈，程序计数器值，寄存器组和状态</li>
<li>通常在一个进程范围内声明多个进程，程序员可以编写出以很低的开销获得并行性的程序。</li>
<li>尽管这些线程提供了低开销的并行性，但由于它们驻留在相同的进程地址空间并共享进程资源，因此，可能还需要对它们进行额外的同步。<ul>
<li>由于启动进程所需要的工作量大，有些人将进程称作是重量级(heavyweight)</li>
<li>与之相反，线程有时被称作轻量级进程(lightweight processes)</li>
</ul>
</li>
</ul>
<h3 id="程序映像的布局"><a href="#程序映像的布局" class="headerlink" title="程序映像的布局"></a>程序映像的布局</h3><ul>
<li>加载之后，可执行程序看起来占据了一个连续的内存块，这个连续的内存块被称为程序映像(program image)</li>
<li>程序映像有几个不同的分区。程序文本或代码显示在内存低端地址中。在映像中已经初始化和未初始化的静态变量也有自己的分区。其他的分区包括堆，栈和环境</li>
<li>活动记录(activation record)<ul>
<li>指的是在进程栈顶端分配的一个内存块，用来装载调用过程中函数的执行上下文。</li>
<li>每次函数调用都在栈上创建一个新的活动记录</li>
</ul>
</li>
<li>除了静态变量和自动变量之外，程序映像中还包括了<code>argc</code>和<code>argv</code>占用的空间以及<code>malloc</code>分配的空间。</li>
<li><code>malloc</code>函数族在一个被称为堆(<code>heap</code>)的空闲内存池中分配存储空间<ul>
<li>在堆上分配的存储空间一直存在，直到它被释放或程序退出为止</li>
<li>如果一个函数调用了<code>malloc</code>，那么在这个函数返回值后，存储空间仍保持已分配状态。</li>
<li>除非程序有一个在函数返回值后仍然可以访问的，指向该存储空间的指针，否则，返回后的程序就不能访问它</li>
</ul>
</li>
<li>在声明时，没有显式初始化的静态变量在运行时被初始化为0</li>
<li>在程序映像中，已初始化的静态变量和未初始化的静态变量占据不同的分区<ul>
<li>通常，已初始化的静态变量是磁盘上可执行模块的一部分，而未初始化的静态变量则不是</li>
<li>自动变量不是可执行模块的一部分，因为只有当定义它们的程序块被调用时，它们才会被分配。除非程序显式地对自动变量进行初始化，否则，它们的初始值是不确定的</li>
</ul>
</li>
<li>对线程化的执行来说，静态变量会使程序变得不安全。</li>
<li>连续调用一个引用了静态变量的函数会出现意料不到的情况，因此，外部静态变量也使得代码的调试更加困难。</li>
<li>出于这些原因，除非是在受控的情况下，否则应该避免使用静态变量</li>
<li>尽管程序映像看起来占据了一个连续的内存块，但实际上，操作系统将程序映像映射到不一定连续的物理内存块中。</li>
<li>通常的映射将程序映像划分成相同大小的片，这些片被称为页(<code>page</code>)<ul>
<li>操作系统将这些页加载到内存中，当处理器引用某页上的内存时，操作系统会从一个表中查找这一页的物理位置。</li>
<li>这种映射方式允许栈和堆有很大的逻辑地址空间。</li>
<li>操作系统隐藏了这种底层映射的存在，这样即使有些页实际上并没有驻留字内存中，程序员也可以认为程序映像在逻辑上是连续的</li>
</ul>
</li>
</ul>
<h3 id="函数返回值和错误"><a href="#函数返回值和错误" class="headerlink" title="函数返回值和错误"></a>函数返回值和错误</h3><ul>
<li>错误处理是编写可靠系统程序中的一个关键问题</li>
<li>处理UNIX程序中错误的标准方法有如下几种<ul>
<li>打印出错误消息并退出程序（仅在main函数中）</li>
<li>返回<code>-1</code>或<code>NULL</code>，并设置<code>errno</code>这样的错误提示符</li>
<li>返回错误码</li>
</ul>
</li>
<li>总的来说，函数永远也不能自己退出，而是应该向调用它的程序报告错误</li>
<li>函数内部的错误消息在调试阶段可能会很有用，但通常不应该出现在最终版本中。</li>
<li>处理调试信息有一种很好的方法：<ul>
<li>将调试打印语句包含在一个条件编译块中，这样在需要的时候可以将其重新激活</li>
</ul>
</li>
</ul>
<h3 id="参数数组-argument-array"><a href="#参数数组-argument-array" class="headerlink" title="参数数组(argument array)"></a>参数数组(argument array)</h3><ul>
<li>是一个指向字符串的指针数组</li>
<li>数组的结尾由一个包含<code>NULL</code>指针的条目来标识。</li>
</ul>
<h3 id="静态变量的使用"><a href="#静态变量的使用" class="headerlink" title="静态变量的使用"></a>静态变量的使用</h3><ul>
<li>静态变量可以用来存储函数调用之间的内部状态信息</li>
</ul>
<h3 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h3><ul>
<li>环境列表(environment list)由一个指针数组组成，其中的指针指向 名字&#x3D;值(name&#x3D;value) 形式的字符串。数组的最后一个条目为<code>NULL</code><ul>
<li>名字，指定一个环境变量(environment variable)</li>
<li>值，指定与环境变量相关的字符串的值</li>
</ul>
</li>
<li>如果进程由<code>execl, execlp, execv, execvp</code>初始化，那么进程就继承了执行<code>exec</code>之前的那个进程的环境列表</li>
<li>环境变量提供了一种用系统特定信息或用户特定信息在程序内部设置默认值的机制。例如，程序可能需要在用户的主目录中写入状态信息，或者需要在特定的地方查找一个可执行文件。用户可以在一个变量中设置信息，用以说明在哪里可以找到可执行文件。应用程序用其特有的方式来解释环境变量的值</li>
<li>用<code>getenv()</code>来确定在进程环境中，一个指定的变量是否有值。将环境变量的名字作为字符串来传递</li>
<li>不要将环境变量与预定义的常量混淆<ul>
<li>预定义的常量是用<code>#define</code>在头文件中定义的，它们的值是常数，在编译时是已知的，要想查看这样一个常量的定义是否存在，可以使用编译器指令<code>#ifndef</code></li>
<li>与之相反，环境变量是动态的，直到运行时才能直到它们的值</li>
</ul>
</li>
</ul>
<h3 id="POSIX环境变量及其含义"><a href="#POSIX环境变量及其含义" class="headerlink" title="POSIX环境变量及其含义"></a>POSIX环境变量及其含义</h3><ul>
<li><code>COLUMNS</code>   –  终端上列的优选宽度</li>
<li><code>HOME</code></li>
<li><code>LINES</code>     –  页或垂直屏幕上的优选行数</li>
<li><code>LOGNAME</code>   –  与进程相关的登录名</li>
<li><code>PATH</code>      –  用于寻找可执行文件的路径前缀</li>
<li><code>PWD</code>       –  当前工作目录的绝对路径名 </li>
<li><code>SHELL</code>     –  用户优选的命令解释程序的路径名</li>
<li><code>TERM</code>      –  输出的终端类型</li>
<li><code>TMPDIR</code>    –  临时文件目录的路径名</li>
<li><code>TZ</code>        –  时区信息</li>
</ul>
<h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><ul>
<li><p>进程终止时，操作系统释放进程资源，更新适当的统计信息并向其他进程通知进程的死亡</p>
</li>
<li><p>终止可以是正常的，也可以是不正常的。进程终止期间执行的动作包括</p>
<ul>
<li>取消挂起的定时器和信号</li>
<li>释放虚拟内存资源</li>
<li>释放其他进程持有的系统资源（例如锁）</li>
<li>关闭打开的文件</li>
</ul>
</li>
<li><p>操作系统记录进程状态和资源的使用情况，同时通知父进程对<code>wait</code>函数进行响应</p>
</li>
<li><p>在UNIX中，进程终止后不会完全释放它的资源，直到父进程等待它为止。</p>
</li>
<li><p>如果进程终止的时候，它的父进程没有等待它，那么这个进程就成为一个僵进程(zombie)。</p>
</li>
<li><p>僵进程是一个不活动的进程，它的资源会在稍后父进程等待它的时候被删除。一个进程终止时，它的孤儿子进程(orphaned child)和僵进程会被一个特殊的系统进程收养。</p>
</li>
<li><p>在传统的UNIX系统中，这个特殊的进程被称为init进程，它的进程ID值为1，并周期性地等待子进程</p>
</li>
<li><p>进程正常终止：</p>
<ul>
<li>从main中return</li>
<li>从main中隐式地返回（main函数执行到末尾）</li>
<li>调用exit, _Exit或_exit</li>
</ul>
</li>
<li><p>C的exit函数调用了用户定义的退出处理程序，这些处理程序是由<code>atexit()</code>按照与登记时相反的顺序记录的</p>
</li>
<li><p>调用了用户定义的处理程序之后，exit对任何一个包含未写入的缓冲数据的打开的流(open stream)进行刷新，然后关系所有打开的流。最后，exit删除所有tmpfile()创建的临时文件，并终止控制进程。</p>
</li>
</ul>
<h2 id="Unix系统中的进程"><a href="#Unix系统中的进程" class="headerlink" title="Unix系统中的进程"></a>Unix系统中的进程</h2><h3 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h3><ul>
<li><p>UNIX用唯一的被称为进程ID(process ID)的整数值来标识进程</p>
</li>
<li><p>每个进程还有一个父进程ID(parent process ID)，这个父进程ID最初是创建它的那个进程的进程ID</p>
</li>
<li><p>返回进程和父进程函数：<code>getpid()</code>, <code>getppid()</code></p>
</li>
<li><p>系统管理员创建用户账户时，为每个用户分配唯一的整型用户ID(user ID)和整型组ID(group ID)</p>
</li>
<li><p>系统通过用户ID和组ID从系统数据库中检索出允许这个用户使用的权限。</p>
</li>
<li><p>返回用户ID和组ID的函数：<code>getegid()</code>, <code>geteuid()</code></p>
</li>
</ul>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul>
<li><p>进程的状态(state)说明了它在某个特定时刻的状况</p>
</li>
<li><p>进程执行I&#x2F;O时是通过一个库函数去请求服务的，这个库函数有时被称为系统调用(system call)</p>
</li>
<li><p>在系统调用的执行过程中，操作系统重新获得对处理器的控制权，并且可以将进程转入阻塞状态，直到操作结束为止</p>
</li>
<li><p>上下文切换(context switch)，是指将一个进程从运行状态移出，并用另一个进程来替代它的行为</p>
</li>
<li><p>进程上下文(process context)，是操作系统在上下文切换之后重启进程<strong>所需的，有关此进程及其环境的信息</strong></p>
<ul>
<li>很明显，就像用于静态和动态变量的内存的当前状态一样，可执行代码，栈，寄存器和程序计数器都是上下文的一部分</li>
<li>为了能够透明地重启进程，操作系统还要记录进程状态，程序I&#x2F;O的状况，用户和进程的标识，权限，调度参数，账号信息以及内存管理信息</li>
<li>如果进程在等待事件或者已经捕捉到了一个信号，那么这个信息也是上下文的一部分</li>
<li>上下文还包括与其他资源相关的信息，例如进程持有的锁等</li>
</ul>
</li>
</ul>
<h3 id="Unix进程的创建与fork调用"><a href="#Unix进程的创建与fork调用" class="headerlink" title="Unix进程的创建与fork调用"></a>Unix进程的创建与fork调用</h3><ul>
<li><p>进程可以通过调用fork来创建新的进程</p>
</li>
<li><p>调用进程就称为父进程(parent)，被创建的进程就被称为子进程(child)</p>
</li>
<li><p>fork函数拷贝了父进程的内存映像，这样新进程就会收到父进程地址空间的一份拷贝。两个进程在fork语句之后，都继续执行后面的指令（分别在它们自己的内存映像中执行）</p>
</li>
<li><p>子进程继承(inherit)了诸如环境和权限这样的父进程属性，还继承了某些父进程资源，例如打开的文件和设备</p>
</li>
</ul>
<h3 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h3><ul>
<li><p>一个进程创建子进程时，父进程和子进程都从fork后的那个点开始继续执行</p>
</li>
<li><p>父进程可以通过执行wait和waitpid一直阻塞到子进程结束</p>
</li>
<li><p>wait函数会使调用者的执行挂起，直到子进程的状态成为可用，或者调用者收到一个信号为止</p>
</li>
</ul>
<h3 id="exec函数"><a href="#exec函数" class="headerlink" title="exec函数"></a>exec函数</h3><ul>
<li><p>fork函数创建了调用进程的一份拷贝，但很多应用程序都需要子进程执行与其父进程不同的代码</p>
</li>
<li><p>exec函数族提供了用新的映像来覆盖调用进程的进程映像的功能</p>
</li>
<li><p>fork-exec配合应用的传统方式是：子进程（用exec函数）执行新程序，而父进程继续执行原来的代码</p>
</li>
<li><p>六种不同形式的exec函数的区别在于命令行参数和环境变量的传递方式。它们的不同还在于是否要给出可执行文件的完整的路径名</p>
<ul>
<li><code>execl(execl, execlp, execle)</code>函数用一个显式的序列来传递命令行参数，如果在编译时就知道命令行参数的数目，这些函数是很有用的</li>
<li><code>execv(execv, execvp, execve)</code>函数将命令行参数放在一个参数数组中传递</li>
</ul>
</li>
<li><p>exec函数将一个新的可执行文件拷贝到进程映像中去。程序的文本，变量，栈和堆都被重写了</p>
</li>
<li><p>除非原始进程调用了<code>execle, execve</code>，否则新进程就继承环境（也就是说，继承了环境变量列表及其相关的值）</p>
</li>
</ul>
<h3 id="后台进程与守护进程"><a href="#后台进程与守护进程" class="headerlink" title="后台进程与守护进程"></a>后台进程与守护进程</h3><ul>
<li><p>命令解释程序是一个用来提示命令，从标准输入中读取命令，创建子进程来执行命令并等待子进程执行完毕的一个命令解释程序。</p>
</li>
<li><p>当标准输入和标准输出来自于一个终端类型的设备时，用户可以通过输入中断字符来终止一个正在执行的命令</p>
<ul>
<li>中断字符是可以设置的，但很多系统都假定中断字符的默认值为<code>Ctrl-C</code></li>
</ul>
</li>
<li><p>大多数命令解释程序将一个以<code>&amp;</code>结束的行解释为应该由后台进程执行的命令</p>
</li>
<li><p>命令解释程序创建了一个后台进程时，它在发出提示符并接受其他的命令之前不用等待进程的结束。而且，从键盘键入的<code>Ctrl-C</code>也不能终止后台进程</p>
</li>
<li><p>守护进程(daemon)，是一个通常能够无限期运行的后台进程</p>
</li>
<li><p>UNIX操作系统依靠很多守护进程来执行例行的任务</p>
</li>
</ul>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><ul>
<li><p>每个进程中对，应该一次只被一个进程使用的资源，进行访问的那部分代码都被称为临界区(critical section)</p>
</li>
<li><p>带有临界区的程序必须要注意不能违反互斥(mutual execlusion)的原则</p>
</li>
<li><p>提供互斥的一种办法是使用锁机制</p>
</li>
<li><p>为了减少内部交互的复杂性，有些操作系统使用了面向对象(object-oriented)的设计。</p>
</li>
<li><p>共享的表和其他资源都被封装成对象，这些对象都带有规定的很明确的访问函数。访问这样一个表的唯一的方法就是使用这些函数，这些函数都内建了恰当的互斥</p>
</li>
<li><p>在分布式系统中，对象接口都使用消息</p>
</li>
<li><p>从表面上看，面向对象的方法与守护进程类似，但从结构上看，这些方式可能会有很大的不同。</p>
<ul>
<li>守护进程并不一定要封装资源。它们可以以一种不受控的方式来争夺共享的数据结构</li>
<li>好的面向对象设计保证了数据结构是被封装的，并且只能通过精心控制的接口对其进行访问。</li>
<li>守护进程可以用面向对象的设计来实现，但并不一定非要这样实现。</li>
</ul>
</li>
</ul>
<h2 id="UNIX-I-O"><a href="#UNIX-I-O" class="headerlink" title="UNIX I&#x2F;O"></a>UNIX I&#x2F;O</h2><ul>
<li>UNIX通过文件描述符来实现统一的设备接口，这种统一的接口允许为终端，磁盘，磁带，音频甚至网络通信使用相同的I&#x2F;O调用</li>
</ul>
<h3 id="设备术语"><a href="#设备术语" class="headerlink" title="设备术语"></a>设备术语</h3><ul>
<li><p>外围设备(peripheral device)是指计算机系统访问的硬件。</p>
<ul>
<li>常见的外围设备包括磁盘，磁带，CD-ROM，显示器，键盘，打印机，鼠标和网络接口</li>
</ul>
</li>
<li><p>用户程序对这些设备的控制和I&#x2F;O操作是通过对被称为<strong>设备驱动程序</strong>(device driver)的操作系统模块所进行的系统调用来实现的。</p>
<ul>
<li>设备驱动程序将设备操作的细节隐藏起来，并保护设备以免其受到未授权的使用</li>
</ul>
</li>
<li><p>有些操作系统为它所支持的每种类型的设备都提供了特定的系统调用，这就要求系统程序员掌握一组复杂的设备控制调用</p>
</li>
<li><p>UNIX为大多数设备提供了标准的访问接口，这就极大地简化了提供给程序员的设备接口</p>
</li>
<li><p>UNIX对设备的标准访问接口是通过5个函数来实现的：<code>open, close, read, write, ioctl</code></p>
</li>
<li><p>所有的设备都用文件来表示，这些文件被称为特殊文件(special file)，存放在目录<code>/dev</code>中</p>
</li>
<li><p>因此，磁盘文件和其他设备都用统一的方式来命名和访问</p>
<ul>
<li>正常文件(regular file)只是磁盘上一个普通的数据文件</li>
<li>块特殊文件(block special file)表示特性和磁盘类似的设备。磁盘驱动程序以块或组块的形式从块特殊设备中传送信息，而且这些设备通常都具有从设备的任何地方检索块的能力</li>
<li>字符特殊文件(character special file)表示特性与终端类似的设备。这些设备看起来表示的是一串必须按顺序访问的字节流</li>
</ul>
</li>
</ul>
<h3 id="读和写"><a href="#读和写" class="headerlink" title="读和写"></a>读和写</h3><ul>
<li><p>UNIX通过read和write函数提供了对文件和其他设备的顺序访问</p>
<ul>
<li>read函数试图从用<code>fildes</code>表示的文件或设备中取出<code>nbyte</code>字节，并将其放入用户变量<code>buf</code>中去。</li>
</ul>
</li>
<li><p><strong>文件描述符</strong>，表示了打开的文件或设备，可以将文件描述符想象成进程文件描述符表的索引</p>
</li>
<li><p><strong>文件描述符表</strong>，在进程的用户区中，提供了对相关文件或设备的系统信息的访问</p>
</li>
<li><p>从命令解释程序中执行一个程序时，程序的启动伴随着三个与文件描述符<code>STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO</code>相关的打开的流</p>
<ul>
<li><code>STDIN_FILENO, STDOUT_FILENO</code>分别为标准输入和标准输出。默认情况下，这两个流通常对应于键盘输入和显示器输出</li>
<li>程序应该为错误消息使用标准错误设备<code>STDERR_FILENO</code>,且永远也不应该将其关闭</li>
</ul>
</li>
<li><p><code>readblock(), r_write()</code></p>
</li>
</ul>
<h3 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h3><ul>
<li><p>open函数将一个文件描述符（程序中使用的句柄）与一个文件或物理设备关联起来</p>
</li>
<li><p>每个文件都有三个与之相关的类：用户（或所有者），组和所有其他人（其他的人）</p>
</li>
<li><p>可能的权限或者特权有读(r)，写(w)和执行(x)</p>
</li>
<li><p>分别独立地为用户，组和其他人指定这些特权</p>
</li>
</ul>
<h3 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h3><ul>
<li><p>对来自不同源端的I&#x2F;O的处理是一个很重要的问题，它可能以多种不同的形式出现</p>
</li>
<li><p>保持阻塞状态，直到一组条件中至少有一个条件为真为止，这种方法被称为或同步(OR synchronization)</p>
</li>
<li><p>描述的情况中的条件是：描述符上的“输入可用(input available”</p>
</li>
<li><p>监视多个文件描述符的一种方法是为每个描述符分别使用一个独立的进程</p>
</li>
<li><p>用独立的进程来监视两个文件描述符可能很有用，但是这两个进程都有独立的地址空间，因此它们之间的交互很困难</p>
</li>
<li><p><code>select()</code>调用提供了一种在单个进程中监视多个文件描述符的办法</p>
</li>
<li><p>它可以对三种可能的状况进行监视：</p>
<ul>
<li>可以无阻塞地进行的读操作</li>
<li>可以无阻塞地进行的写操作</li>
<li>有挂起的错误情况的文件描述符</li>
</ul>
</li>
</ul>
<h3 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h3><ul>
<li><p>poll函数与select类似，但它是用文件描述符而不是条件的类型来组织信息的</p>
</li>
<li><p>也就是说，一个文件描述符的可能事件都存储在struct pollfd中</p>
</li>
<li><p>与之相反，select用事件的类型来组织信息，而读，写和错误情况都有独立的描述符掩码</p>
</li>
<li><p>poll函数有三个参数：<code>fds, nfds, timeout</code></p>
<ul>
<li>fds, 是一个struct polldf数组，用来表示文件描述符的监视信息</li>
<li>nfds，给出了要监视的描述符的数目</li>
<li>timeout，是一个用毫秒表示的事件，是poll在返回前没有接收事件时应该等待的时间<ul>
<li>如果timeout的值为-1， poll就永远都不会超时</li>
<li>如果整数值为32个比特，那么最大的超时周期大约为30分钟</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果超时，poll函数返回0</li>
<li>如果成功，poll返回拥有事件的描述符的数目</li>
<li>如果不成功，poll返回-1并设置errno</li>
</ul>
</li>
</ul>
<h3 id="文件表示"><a href="#文件表示" class="headerlink" title="文件表示"></a>文件表示</h3><ul>
<li><p>在C程序中，文件由文件指针或文件描述符来指定</p>
</li>
<li><p>ISO C的标准I&#x2F;O库函数(<code>fopen, fscanf, fprintf, fread, fwrite, fclose</code> and so on)使用文件指针</p>
</li>
<li><p>UNIX的I&#x2F;O函数(<code>open, read, write, close, ioctl</code>)使用文件描述符</p>
</li>
<li><p>文件指针和文件描述符提供了用来执行独立于设备的输入和输出的逻辑标识，这些逻辑标识被称为句柄(handle)</p>
</li>
<li><p>代表标准输入，标准输出和标准错误的文件指针的符号名分别为<code>stdin, stdout, stderr</code>，这些符号名定义在<code>stdio.h</code>中。</p>
</li>
<li><p>代表标准输入，标准输出和标准错误的文件描述符的符号名分别为<code>STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO</code>，这些符号名定义在<code>unistd.h</code>中</p>
</li>
</ul>
<h3 id="库函数和系统调用之间的区别"><a href="#库函数和系统调用之间的区别" class="headerlink" title="库函数和系统调用之间的区别"></a>库函数和系统调用之间的区别</h3><ul>
<li><p>POSIX标准不区分库函数和系统调用。</p>
</li>
<li><p>传统上，库函数是一个普通的函数，通常因为它有用，得到广泛的应用或者是C这样的规范的一部分，而被放在一个被称为库的函数集合中。</p>
</li>
<li><p>系统调用是对操作系统发出的服务请求。它包含了对操作系统的自陷(trap)，通常还包含上下文切换</p>
</li>
<li><p>系统调用与特定的操作系统相关。</p>
</li>
<li><p>很多的库函数，例如read和write，实际上都是系统调用的外套(jacket)。</p>
</li>
<li><p>也就是说，它们以恰当的，与系统相关的形式重新设置参数的格式，然后调用底层的系统调用来执行实际的操作</p>
</li>
</ul>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><ul>
<li>open函数将文件或物理设备与程序中使用的逻辑句柄相关联。用字符串（例如<code>/home/user/my.data</code>）来指定文件或物理设备。</li>
<li>句柄是一个整数，可以将其理解为进程特定的文件描述符表(file descriptor table)的索引</li>
<li>对进程中每个打开的文件，文件描述符表都包含一个相应条目，文件描述符表是进程用户区的一部分，但是除非通过使用文件描述符的函数，否则程序无法对其进行访问</li>
</ul>
<h3 id="文件指针和缓冲"><a href="#文件指针和缓冲" class="headerlink" title="文件指针和缓冲"></a>文件指针和缓冲</h3><ul>
<li><p>ISO C标准的I&#x2F;O库用文件指针而不是文件描述符作为I&#x2F;O的句柄</p>
</li>
<li><p>文件指针(file pointer)指向进程用户区中的一个被称为FILE结构的数据结构</p>
</li>
<li><p>FILE结构包括一个缓冲区和一个文件描述符值</p>
</li>
<li><p>文件描述符值是文件描述符表中条目的索引，实际上就是通过这个文件描述符表将文件输出到磁盘的</p>
</li>
<li><p>从某种意义上说，文件指针就是句柄的句柄</p>
</li>
<li><p>磁盘文件通常都是完全缓冲(fully buffered)的，这就意味着，<code>fprint</code>实际上没有将消息写入磁盘，而是将这些字节写入了FILE结构的一个缓冲区里。</p>
</li>
<li><p>缓冲区填满时，I&#x2F;O子系统就会用文件描述符来调用write。</p>
</li>
<li><p>文件执行<code>fprintf</code>的时刻和实际进行写操作的时刻之间的时延可能会造成意外的结果，尤其是在程序崩溃的时候。</p>
</li>
<li><p>系统崩溃时，有时会丢失缓冲的数据，因此，甚至会出现：程序看起来是正常结束了，但它的磁盘输出确实不完整的</p>
</li>
<li><p>程序怎样才能避免缓冲对它的影响？</p>
</li>
<li><p>fflush调用会强制写出FILE结构中缓冲的任何内容</p>
</li>
<li><p>程序也可以调用<code>setvbuf</code>来禁止缓冲</p>
</li>
<li><p>终端I&#x2F;O的工作方式不同，与终端相关的文件是行缓冲(line buffered)的，而不是完全缓冲的（标准错误除外，它在默认情况下是不缓冲的）</p>
</li>
<li><p>对输出来说，行缓冲意味着<strong>在缓冲区被填满或遇到一个新行符号之前，行不会被写出</strong></p>
</li>
</ul>
<h3 id="过滤器和重定向"><a href="#过滤器和重定向" class="headerlink" title="过滤器和重定向"></a>过滤器和重定向</h3><ul>
<li><p>UNIX提供了大量作为过滤器而编写的工具</p>
</li>
<li><p>过滤器(filter)从标准输入中读入，执行一个转换，然后将结果输出到标准输出中去</p>
</li>
<li><p>过滤器将它们的错误消息写入标准错误</p>
</li>
<li><p>过滤器所有的参数都作为命令行参数传送</p>
</li>
<li><p>输入数据不应该有首部或尾部，而且过滤器也不应该要求与用户进行任何交互</p>
</li>
<li><p>实用的UNIX过滤器的例子包括：<code>head, tail, more, sort, grep, awk</code></p>
</li>
<li><p>cat命令将一个文件名列表作为命令参数，一个接一个地读其中的每个文件，并将每个文件的内容会送到标准输出中去</p>
</li>
<li><p>但是，如果没有指定输入文件，cat就会从标准输入获取它的输入，并将结果写入标准输出。在这种情况下，cat表现得像过滤器一样</p>
</li>
<li><p>文件描述符是那个进程的文件描述符表的一个索引。文件描述符表中的每个条目都指向系统文件表中的一个条目，该条目是在文件被打开时创建的。</p>
</li>
<li><p>程序可以对文件描述符表的条目进行修改，使其指向系统文件表中的另一个条目。这种动作叫做重定向(redirection)</p>
</li>
<li><p>大多数命令解释程序豆浆命令行中的大于字符(&gt;)解释成对标准输出的重定向，而小于字符(&lt;)解释成对标准输入的重定向</p>
</li>
<li><p>dup2函数有两个参数：fildes, fildes2</p>
</li>
</ul>
<h3 id="文件控制"><a href="#文件控制" class="headerlink" title="文件控制"></a>文件控制</h3><ul>
<li><code>fcntl()</code>函数是一个通用函数，可用来检索和修改与打开的文件描述符相关联的标志符</li>
<li><code>fcntl()</code>参数<code>fildes</code>指定了描述符，参数<code>cmd</code>指定了操作</li>
</ul>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><ul>
<li><p>操作系统将原始存储设备以文件系统的形式组织起来，这样应用程序就可以用高级操作，而不是低级的设备调用来访问信息</p>
</li>
<li><p>UNIX文件系统是树形的，节点表示文件，弧线表示包含关系</p>
</li>
<li><p>UNIX目录项将文件名与文件所在位置关联起来。</p>
</li>
<li><p>这些目录项可以直接指向一个包含文件位置信息的结构（硬链接）</p>
</li>
<li><p>也可以通过符号链接间接地指向文件所在位置</p>
<ul>
<li>符号链接是将一个文件名关联到另一个文件名的文件</li>
</ul>
</li>
</ul>
<h3 id="UNIX文件系统导航"><a href="#UNIX文件系统导航" class="headerlink" title="UNIX文件系统导航"></a>UNIX文件系统导航</h3><ul>
<li><p>文件系统(file system)，是文件和属性的集合，其中的属性包括位置和名字等</p>
</li>
<li><p>应用程序不用指定文件在磁盘上的物理位置，而只需指定文件名和偏移量。操作系统通过它的文件系统将其翻译为物理文件的位置</p>
</li>
<li><p>目录，是一个包含了目录项(directory entry)的文件，目录项将文件名与文件在磁盘上的物理位置关联起来</p>
</li>
<li><p>绝对路径名(absolute pathname)或全称路径名(fully qualified pathname)，指定了文件系统树中从根到文件自身的路径上所有的节点</p>
</li>
<li><p>程序不一定总要用全称路径名来制定文件。</p>
</li>
<li><p>任何时候，每个进程都有一个用来作路径名解析的相关目录，这个目录被称作当前工作目录(current working directory)</p>
</li>
<li><p><code>pathconf</code>函数，是允许程序以一种与平台无关的方式来确定系统和运行期极限的函数族中的一个</p>
</li>
</ul>
<h3 id="目录访问"><a href="#目录访问" class="headerlink" title="目录访问"></a>目录访问</h3><ul>
<li><p>目录不能用普通的<code>open, close, read</code>函数来访问。</p>
</li>
<li><p>相反，访问目录需要使用特定的函数，相应的函数名以<code>dir</code>结束：<code>opendir, closedir, readdir</code></p>
</li>
<li><p><code>opendir()</code>函数，为一个目录流提供了<code>DIR*</code>类型的句柄，该流的当前位置就在目录的第一项上</p>
</li>
<li><p>定义在dirent.h中的DIR类型，表示的是一个<strong>目录流</strong>(directory stream)</p>
</li>
<li><p>目录流是一个特定目录中所有目录项组成的一个有序序列。目录流中的条目不一定是按文件名的字母顺序排列的</p>
</li>
<li><p><code>readdir()</code>函数，是通过返回dirp所指向的目录流中的连续条目来读取目录的</p>
</li>
<li><p><code>readdir()</code>在每次调用之后都将流转移到下一个位置上去</p>
</li>
<li><p><code>closedir()</code>函数，关闭一个目录流，而<code>rewinddir()</code>函数把目录流重新定位在起始处</p>
</li>
<li><p>每个函数都有一个参数<code>dirp</code>，这个参数对应于打开的目录流</p>
</li>
</ul>
<h3 id="访问文件状态信息"><a href="#访问文件状态信息" class="headerlink" title="访问文件状态信息"></a>访问文件状态信息</h3><ul>
<li><p><code>fstat()</code>函数，用打开的文件描述符来访问文件</p>
</li>
<li><p><code>stat()</code>和<code>lstat()</code>函数通过名字来访问文件</p>
<ul>
<li>它们都有两个参数，参数<code>path</code>指定了需要返回状态的文件或符号链接的名字</li>
<li>如果path不对应于符号连接，也就是文件，它们就返回相同的结果</li>
<li>当path是一个符号链接时<ul>
<li><code>lstat()</code>函数返回与链接有关的信息，</li>
<li><code>stat()</code>函数返回与链接所指向的文件有关的信息</li>
</ul>
</li>
<li>参数<code>buff</code>指向一个用户提供的缓冲区，这些函数都将信息存储在这个缓冲区中</li>
</ul>
</li>
</ul>
<h3 id="确定文件的类型"><a href="#确定文件的类型" class="headerlink" title="确定文件的类型"></a>确定文件的类型</h3><ul>
<li>文件模式成员<code>st_mode</code>指定了文件的访问权限和文件的类型</li>
<li>POSIX规定用不同宏来测试不同文件类型的<code>st_mode</code>成员<ul>
<li>S_ISBLK(m)  –  块特殊文件</li>
<li>S_ISCHR(m)  –  字符特殊文件</li>
<li>S_ISDIR(m)  –  目录</li>
<li>S_ISFIFO(m) – 管道或FIFO特殊文件</li>
<li>S_ISLNK(m)  –  字符链接</li>
<li>S_ISREG(m)  –  正常文件</li>
<li>S_ISSOCK(m) – 套接字</li>
<li>S_TYPEISMQ(buf)  –  消息队列</li>
<li>S_TYPEISSEM(buf) –  信号量</li>
<li>S_TYPEISSHM(buf) –  共享的内存对象</li>
</ul>
</li>
<li>测试文件类型的POSIX宏</li>
<li><code>m</code>的类型为<code>mode_t</code>, buf的值是一个指向<code>struct stat</code>结构的指针</li>
</ul>
<h3 id="UNIX文件系统的实现"><a href="#UNIX文件系统的实现" class="headerlink" title="UNIX文件系统的实现"></a>UNIX文件系统的实现</h3><ul>
<li>磁盘格式化将物理磁盘分隔成被称为分区(partition)的区域</li>
<li>每个分区都可以有自己的文件系统与之相关联</li>
</ul>
<h3 id="UNIX文件的实现"><a href="#UNIX文件的实现" class="headerlink" title="UNIX文件的实现"></a>UNIX文件的实现</h3><ul>
<li><p>目录项中包含一个文件名以及对一个定长结构的引用，这个定长结构被称作索引节点(inode)</p>
</li>
<li><p>索引节点中包括了与文件长度，文件位置，文件所有者，创建时间，最后访问时间，最后修改时间，权限等有关的信息</p>
</li>
<li><p>块(block)，可以表示不同的含义（甚至在UNIX系统内部也是如此）。</p>
</li>
<li><p>在这里，块通常是8K字节，一个块中的字节数通常是2的幂</p>
</li>
<li><p>POSIX不要求系统真的采用索引节点来表示它的文件</p>
</li>
<li><p><code>struct stat</code>的成员<code>ino_tst_ino</code>，现在被称为文件序列号(file serial number)，而不是索引节点号(inode number)</p>
</li>
</ul>
<h3 id="硬链接和符号连接"><a href="#硬链接和符号连接" class="headerlink" title="硬链接和符号连接"></a>硬链接和符号连接</h3><ul>
<li><p>UNIX目录中有两种类型的链接：链接和符号链接</p>
</li>
<li><p>链接，是指一个目录项，有时也被称为硬链接(hard link)，目录项可以将文件名与文件位置关联起来</p>
</li>
<li><p>符号链接(symbolic link)，有时也称为软连接(soft link)，是指<strong>存储了一个字符串的文件</strong>。如果在路径名解析过程中遇到了这个字符串，就用它来修改路径名</p>
</li>
</ul>
<h3 id="（硬）链接的创建与删除"><a href="#（硬）链接的创建与删除" class="headerlink" title="（硬）链接的创建与删除"></a>（硬）链接的创建与删除</h3><ul>
<li><p><code>link()</code>函数为<code>path1</code>指定的已存在文件创建一个新的目录项，这个文件位于<code>path2</code>指定的目录中</p>
</li>
<li><p>函数原型：<code>int link(const char *path1, const char *path2)</code></p>
</li>
<li><p>头文件：<code>#include &lt;unistd.h&gt;</code></p>
</li>
<li><p><code>unlink()</code>函数删除了path指定的目录项</p>
</li>
<li><p>函数原型：<code>int unlink(const char *path);</code></p>
</li>
<li><p>头文件：<code>#include &lt;unistd.h&gt;</code></p>
</li>
</ul>
<h3 id="符号链接的创建与删除"><a href="#符号链接的创建与删除" class="headerlink" title="符号链接的创建与删除"></a>符号链接的创建与删除</h3><ul>
<li><p>符号链接，是一个包含了另一个文件或目录名字的文件。</p>
</li>
<li><p>引用符号链接的名字会使操作系统去定位对应于那个链接的索引节点</p>
</li>
<li><p>操作系统假设相应的索引节点的数据块中包含另一个路径名。然后，操作系统对那个路径名的目录项进行定位，并继续跟踪这个链接，直到最终遇到一个硬链接和一个真正的文件为止。</p>
</li>
<li><p>如果系统过了一段时间还没有找到真正的文件，它就放弃并返回ELOOP错误</p>
</li>
<li><p><code>symlink()</code>函数创建一个符号链接，参数path1包含了将成为链接的内容的字符串，path2给出了链接的路径名。</p>
<ul>
<li>换句话来说，path2就是新创建的链接，而新链接指向path1</li>
</ul>
</li>
<li><p>函数原型：<code>int symlink(const char *path1, const char *path2);</code></p>
</li>
<li><p>头文件：<code>#include &lt;unistd.h&gt;</code></p>
</li>
</ul>
<h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><ul>
<li>UNIX的命令解释程序命令<code>du</code>是<code>POSIX:UP</code>扩展的一部分</li>
<li>命令用来显示树的子目录的大小，这个树的根位于它的命令行参数指定的目录中</li>
<li>如果调用时未带目录，du工具就使用当前的工作目录</li>
</ul>
<h2 id="UNIX特殊文件"><a href="#UNIX特殊文件" class="headerlink" title="UNIX特殊文件"></a>UNIX特殊文件</h2><ul>
<li>管道和FIFO是这些特殊文件的两种重要实例。</li>
<li>它们是进程间通信机制，这些机制使得运行在同一个系统中的进程可以共享信息，从而互相合作</li>
</ul>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul>
<li><p>对那些需要相互配合来解决问题的进程来说，通信是一种必备的能力</p>
</li>
<li><p>最简单的UNIX进程间通信机制是管道，管道由特殊文件来表示</p>
</li>
<li><p><code>pipe()</code>函数创建了一个通信缓冲区，程序可以通过文件描述符<code>fildes[0]</code>和<code>fildes[1]</code>来访问这个缓冲区</p>
</li>
<li><p>写入<code>fildes[1]</code>的数据可以按照先进先出的顺序从<code>fildes[0]</code>中读出</p>
</li>
<li><p>使用管道的单个进程并没有很大的用处。</p>
</li>
<li><p>通常父进程会用管道来与它的子进程进行通信</p>
</li>
</ul>
<h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><ul>
<li>垂直线<code>|</code>表示一个管道</li>
<li>管道就像进程间的缓冲区一样，允许进程以不同的速度读和写。read和write的阻塞性本质有效地同步了进程</li>
</ul>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><ul>
<li><p>没有进程打开管道时，管道就消失了，从这个意义上来说，管道是临时的</p>
</li>
<li><p>POSIX用特殊文件来表示FIFO或命名管道(named pipe)，这些特殊文件在所有的进程都将其关闭之后仍然存在</p>
</li>
<li><p>FIFO像普通文件一样，有名字和访问权限，而且会出现在ls列出的目录列表中</p>
</li>
<li><p>任何一个具有恰当权限的进程都可以访问FIFO</p>
</li>
<li><p>可以在命令解释程序中执行<code>mkfifo</code>命令</p>
</li>
<li><p>或者从程序中调用<code>mkfifo()</code>函数来创建FIFO</p>
</li>
<li><p>删除时使用<code>rm</code>命令或<code>unlink()</code>函数</p>
</li>
</ul>
<h3 id="管道与客户机-服务器模型"><a href="#管道与客户机-服务器模型" class="headerlink" title="管道与客户机-服务器模型"></a>管道与客户机-服务器模型</h3><ul>
<li>客户机-服务器模型是进程间交互的一种标准模式。</li>
<li>一个被称为客户机(client)的进程，向另一个称为服务器(server)的进程请求服务</li>
<li>两种类型的客户机-服务器通信方式：<ul>
<li>简单-请求(simple-request)方式，客户机以单向传输的方式向服务器发送消息</li>
<li>请求-应答(request-reply)方式，客户机发送一个请求，服务器就会发送一个应答</li>
</ul>
</li>
</ul>
<h3 id="终端控制"><a href="#终端控制" class="headerlink" title="终端控制"></a>终端控制</h3><ul>
<li><p>很多特殊文件表示的设备都具有与平台相关的特性，这使得标准化工作变得很困难</p>
</li>
<li><p>命令<code>stty</code>用来报告或设置终端I&#x2F;O的特性</p>
</li>
<li><p>执行时不带任何参数或者执行时带有选项<code>-a</code>或<code>-g</code>时，命令将与当前终端有关的信息输出到标准输出中去</p>
</li>
<li><p><code>tcgetattr()</code>函数用来检索出与终端相关的属性，终端由打开的文件描述符<code>fildes</code>引用</p>
</li>
<li><p>原型：<code>int tcgetattr(int fildes, struct termics *termios_p);</code></p>
</li>
<li><p><code>passwordnosigs()</code>函数使用<code>ctermid()</code>函数确定的控制终端，而没有使用标准输入</p>
</li>
<li><p>控制终端通常类似于<code>/dev/tty</code></p>
</li>
</ul>
<h3 id="规范与非规范的输入处理"><a href="#规范与非规范的输入处理" class="headerlink" title="规范与非规范的输入处理"></a>规范与非规范的输入处理</h3><ul>
<li><p>一种常见的误解是：</p>
<ul>
<li>键盘和显示器是以某种方式连在一起的，因此你键入的所有内容都自动地出现在显示器上</li>
</ul>
</li>
<li><p>实际上，键盘和显示器是互相独立的设备，它们分别与运行在计算机上的终端设备驱动程序进行通信</p>
</li>
<li><p>通信驱动程序从键盘接收字节，然后根据这些设备的设置指定的方式对其进行缓冲和编辑</p>
</li>
<li><p>处理终端输入的一种常见的方法是每次处理一行输入，这种处理方法被称为规范模式(canonical mode)</p>
</li>
<li><p>行是一个由新行(NL)，文件结束(EOF)或行结束(EOL)定界的字节序列</p>
</li>
<li><p>在非规范模式(noncanonical mode)下，输入没有被组装成行</p>
</li>
<li><p>非规范输入处理有两个控制参数：MIN和TIME</p>
<ul>
<li>MIN，用来控制read返回之前应该收集的最少的字节数</li>
<li>TIME，指一个粒度为0.1秒的定时器，这个定时器用于突发传输的超时处理</li>
</ul>
</li>
</ul>
<h3 id="音频设备"><a href="#音频设备" class="headerlink" title="音频设备"></a>音频设备</h3><ul>
<li>音频设备（麦克风，扬声器）是由特殊文件表示的外围设备的一种实例</li>
<li>在很多系统中，这些设备的设备表示都是<code>/dev/audio</code></li>
</ul>
<h3 id="路障"><a href="#路障" class="headerlink" title="路障"></a>路障</h3><ul>
<li>路障(barrier)，是协同操作的进程使用的一种同步结构</li>
<li>使用了路障之后，在所有的进程都到达一个特定点之前，进程一直保持阻塞</li>
</ul>
<h2 id="项目：令牌环（180）"><a href="#项目：令牌环（180）" class="headerlink" title="项目：令牌环（180）"></a>项目：令牌环（180）</h2><h3 id="环的形成"><a href="#环的形成" class="headerlink" title="环的形成"></a>环的形成</h3><ul>
<li>在程序代码中引用这些文件描述符时，一定要使用<code>STDIN_FILENO, STDOUT_FILENO</code></li>
<li>文件描述符表的条目，就是指向系统文件表条目的指针</li>
<li>例如<ul>
<li>条目<code>[4]</code>中的<code>pipe写</code>表示：指向系统文件表中pipe的写条目的指针</li>
<li>条目<code>[0]</code>中的<code>标准输入</code>表示：指向系统文件中对应于默认标准输入设备的条目的指针（默认的标准输入通常是键盘）</li>
</ul>
</li>
</ul>
<h3 id="匿名环中的领导者选举"><a href="#匿名环中的领导者选举" class="headerlink" title="匿名环中的领导者选举"></a>匿名环中的领导者选举</h3><ul>
<li><p>分布式算法的规范，将执行算法的实体称为进程(process)或处理器(processor)</p>
</li>
<li><p>这种算法通常用有限状态机的形式来说明底层的处理器模型。</p>
</li>
<li><p>处理器模型，是按照状态转移是如何被驱动的（同步）以及处理器是否被标记来划分的</p>
</li>
<li><p>在同步处理器模型(synchronous processor model)中，处理器按照锁步执行，而状态转移是时钟驱动的</p>
</li>
<li><p>在异步处理器模型(asynchronous processor model)中，状态转移是消息驱动的</p>
<ul>
<li>在通信链路上接收消息会出发处理器状态的改变。处理器可能会向它的邻居发送消息执行某些计算，或者因为有消息输入而暂停。</li>
<li>在处理器键任意给定的链接上，消息都按照发送的顺序到达。消息会有一个有限的，但不可预测的传输时延</li>
</ul>
</li>
<li><p>处理器模型还必须说明单独的处理器是否被标记，或者它们是否是不可辨别的。</p>
</li>
<li><p>在一个匿名系统(anonymous system)中，处理器不具有可以辨别的特性。</p>
</li>
<li><p>总的来说，包含了匿名处理器或进程的系统的算法，比包含有标记的处理器或进程的系统的相应算法更复杂一些</p>
</li>
</ul>
<h3 id="图像过滤"><a href="#图像过滤" class="headerlink" title="图像过滤"></a>图像过滤</h3><ul>
<li><p>过滤器，是对图像进行的一种变换</p>
</li>
<li><p>根据变换类型的不同，过滤可能会消除噪声，增强细节或者模糊图像的特征。</p>
</li>
<li><p>针对一副由<code>n x n</code>字符数组表示的灰度数字图像进行过滤</p>
</li>
<li><p>通用的空间过滤器(spatial filter)，用一个原始像素及其邻居的函数来替换这幅图像中的每个像素值。</p>
</li>
<li><p>过滤器算法用一个掩码来说明对计算做出贡献的邻居范围。因为函数是掩码中像素的加权和，所以这个特定的掩码，表示了一个线性过滤器(linear filter)</p>
</li>
<li><p>与之相反，非线性过滤器不能写成掩码中像素的线性组合。使用邻近像素的中位数就是非线性滤波器的一个例子</p>
</li>
<li><p>块的计算</p>
<ul>
<li>并行处理中另外一个重要的问题就是问题的粒度，以及如何将这种粒度映射为进程数</li>
</ul>
</li>
</ul>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><ul>
<li>重点强调了信号处理并发方面的问题</li>
</ul>
<h3 id="信号的基本概念"><a href="#信号的基本概念" class="headerlink" title="信号的基本概念"></a>信号的基本概念</h3><ul>
<li><p>信号(signal)， 是向进程发送的软件通知，通知进程有事件发生</p>
</li>
<li><p>引发信号的事件发生时，信号就被<strong>生成</strong>(generate)了。</p>
</li>
<li><p>进程根据信号采取行动时，信号就被<strong>传递</strong>(deliver)了。</p>
</li>
<li><p>信号的寿命(lifetime)就是，<strong>信号的生成和传递之间的时间间隔</strong>。</p>
</li>
<li><p>已经生成但还未被传递的信号被称为挂起(pending)的信号，</p>
</li>
<li><p>在信号生成和信号传递之间可能会有相当长的时间。传递信号时，进程必须在处理器上运行</p>
</li>
<li><p>如果在传递信号时，进程执行了信号处理程序(signal handler)，那么进程就捕捉(catch)到了这个信号</p>
</li>
<li><p>如果将进程设置为忽略(ignore)某个信号，那么在传递时那个信号就会被丢弃，不会对进程产生影响</p>
</li>
<li><p>信号生成时，所采取的的行动取决于那个信号当前使用的信号处理程序和进程信号掩码(process signal mask)</p>
</li>
<li><p>信号掩码中包含一个当前被阻塞信号(blocked signal)的列表</p>
</li>
<li><p>阻塞一个信号很容易和忽略一个信号混淆起来</p>
<ul>
<li>被阻塞的信号不会像被忽略的信号一样丢弃</li>
<li>如果一个挂起信号被阻塞了，那个当进程解决了对那个信号的阻塞时，信号就会被传递出去</li>
</ul>
</li>
</ul>
<h3 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h3><ul>
<li><p>每个信号都有一个以SIG开头的符号名。</p>
</li>
<li><p>信号的名字都定义在<code>signal.h</code>中，任何一个使用了信号的C程序中都要包含这个文件</p>
</li>
<li><p>信号的名字表示的是大于0的小整数</p>
</li>
<li><p>在命令解释程序上可以用kill命令产生信号。</p>
</li>
<li><p>历史上，很多信号的默认行为都是将进程终止，kill这个名字就由此而来</p>
</li>
<li><p>在一个程序中调用<code>kill()</code>函数会向一个进程发送信号。</p>
</li>
<li><p>原型：<code>int kill(pid_t pid, int sig);</code></p>
</li>
<li><p>函数将进程ID和一个信号码作为参数。</p>
<ul>
<li>如果参数pid大于0，kill就向那个ID表示的进程发送信号。</li>
<li>如果pid为0，kill就像调用程序的进程组成员发送信号</li>
<li>如果参数pid为-1， kill就向所有它有权发送信息的进程发送信号</li>
<li>如果参数pid的值是其他负数，kill就将信号发送到组ID等于pid的进程组中去</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
<li><p>进程可以用<code>raise()</code>函数向自己发送一个信号</p>
</li>
<li><p><code>int raise(int sig);</code></p>
</li>
<li><p>函数只有一个参数，即信号码</p>
</li>
<li><p>返回值</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回一个非零的错误值，并设置errno</li>
</ul>
</li>
</ul>
<h3 id="对信号掩码和信号集进行操作"><a href="#对信号掩码和信号集进行操作" class="headerlink" title="对信号掩码和信号集进行操作"></a>对信号掩码和信号集进行操作</h3><ul>
<li><p>进程可以通过阻塞信号暂时地阻止信号的传递。在传递之前，被阻塞的信号不会影响进程的行为</p>
</li>
<li><p>进程的信号掩码(signal mask)给出了当前被阻塞的信号的集合。信号掩码的类型为<code>sigset_t</code></p>
</li>
<li><p>可以用类型为sigset_t的信号集来指定对信号组的操作（例如阻塞或接触阻塞的操作）</p>
</li>
<li><p>信号集由下面的五个函数来操作，每个函数的第一个参数都是一个指向<code>sigset_t</code>的指针</p>
<ul>
<li><code>int sigaddset(sigset_t *set, int signo)</code>  –  负责将<code>signo</code>加入信号集</li>
<li><code>int sigdelset(sigset_t *set, int signo)</code>  –  将<code>signo</code>从信号集中删除</li>
<li><code>int sigemptyset(sigset_t *set);</code>          –  对一个<code>sigset_t</code>类型的信号集进行初始化，使其不包含任何信号</li>
<li><code>int sigfillset(sigset_t *set);</code>           –  对一个<code>sigset_t</code>类型的信号集进行初始化，使其包含所有的信号</li>
<li><code>int sigismember(const sigset_t *set, int signo);</code>  –  报告<code>signo</code>是否在<code>sigset_t</code>中</li>
</ul>
</li>
</ul>
<h3 id="捕捉与忽略信号-–-sigaction"><a href="#捕捉与忽略信号-–-sigaction" class="headerlink" title="捕捉与忽略信号  –  sigaction"></a>捕捉与忽略信号  –  sigaction</h3><ul>
<li><p><code>sigaction()</code>函数，允许调用程序检查或指定与特定信号相关的动作</p>
</li>
<li><p><code>int sigaction(int sig, const struct sigaction *restrict act, struct sigaction *restrict oact);</code></p>
</li>
<li><p>函数的参数<code>sig</code>来指定动作的信号码</p>
</li>
<li><p>参数<code>act</code>是一个指向<code>struct sigaction</code>结构的指针，用来说明要采取的动作</p>
</li>
<li><p>在基于POSIX的标准中，信号处理程序是一个普通函数，它返回void， 并有一个整型的参数</p>
</li>
</ul>
<h3 id="等待信号-–-pause-sigsuspend-sigwait"><a href="#等待信号-–-pause-sigsuspend-sigwait" class="headerlink" title="等待信号  –  pause, sigsuspend, sigwait"></a>等待信号  –  pause, sigsuspend, sigwait</h3><ul>
<li><p>信号提供了一种不需要忙等(busy waiting)来等待事件的方法。</p>
</li>
<li><p>忙等，是指连续地使用CPU周期来检测事件的发生。通常，程序都通过在循环中测试一个变量的值来进行这种检测。</p>
</li>
<li><p>更有效的方法是，将进程挂起直到所等待的事件发生为止；这样，其他的进程就可以更有效地使用CPU了</p>
</li>
<li><p>POSIX中的<code>pause(), sigsupend(), sigwait()</code>提供了三种机制，用来挂起进程，直到信号发生为止</p>
</li>
<li><p><code>pause()</code>函数，将调用线程挂起，直到传递了一个信号为止，这个信号的动作或者是执行用户定义的处理程序，或者是终止进程</p>
</li>
<li><p>如果信号的动作是终止进程，pause就不返回。如果信号被进程捕捉，pause就会在信号处理程序返回之后返回</p>
</li>
<li><p><code>#include &lt;unistd.h&gt;  int pause(void);</code></p>
</li>
<li><p>pause函数总是返回-1，如果被信号中断，pause就将errno设置为EINTR</p>
</li>
<li><p>要用pause来等待一个待定的信号，就必须确定哪个信号会使用pause返回。这个信息并不是直接可用的，因此信号处理程序必须设置一个标志符，以便程序在pause返回之后对其进行检查</p>
</li>
<li><p><code>sigsuspend()</code>，用sigmask指向的那个掩码来设置信号掩码，并将进程挂起，知道进程捕捉到信号为止</p>
</li>
<li><p><code>int sigsuspend(const sigset_t *sigmask);</code></p>
</li>
<li><p>被捕捉信号的信号处理程序返回时，sigsuspend函数就返回。</p>
</li>
<li><p><code>sigwait()</code>函数，一直阻塞直到<code>*sigmask</code>指定的任何一个信号被挂起为止，然后从挂起信号集中删除那个信号，并接触对它的阻塞</p>
</li>
<li><p>当<code>sigwait()</code>返回时，从挂起信号集中删除的信号的个数被存储在<code>signo</code>指向的那个位置中</p>
</li>
<li><p><code>int sigwait(const sigset_t *restrict sigmask, int *restrict signo);</code></p>
</li>
<li><p>如果成功，返回0。如果失败，返回-1，并设置errno</p>
</li>
</ul>
<h3 id="信号处理原则"><a href="#信号处理原则" class="headerlink" title="信号处理原则"></a>信号处理原则</h3><ul>
<li>如果拿不准，就在程序中显式地重启库函数调用，或者使用重启库</li>
<li>检查信号处理程序中使用的每个库函数，确保函数在异步信号安全函数的列表中</li>
<li>仔细地分析修改外部变量的信号处理程序和访问的那个变量的其他按程序代码之间潜在的交互，阻塞信号以防出现不希望的交互</li>
<li>适当的时候保存并回复errno</li>
</ul>
<h3 id="用异步I-O编程"><a href="#用异步I-O编程" class="headerlink" title="用异步I&#x2F;O编程"></a>用异步I&#x2F;O编程</h3><ul>
<li><p>通常，在执行读操作或写操作时，进程会一直阻塞直到I&#x2F;O完成为止。</p>
</li>
<li><p>某些注重性能的应用程序宁愿先初始化请求，然后继续执行，这样就允许I&#x2F;O操作的处理异步(asynchronously)于程序的执行</p>
</li>
<li><p>POSIX：AIO扩展对异步I&#x2F;O的定义基于四个主要函数。</p>
<ul>
<li><code>#include &lt;aio.h&gt;</code></li>
<li><code>int aio_read(struct aiocb *aiocbp);</code>  – 允许进程对一个打开的文件描述符上的读操作请求进行排队</li>
<li><code>int aio_write(struct aiocb *aiocbp);</code> –  对写操作请求进行排队</li>
<li>它们都只有一个参数  –  aiocbp，它是一个指向异步I&#x2F;O控制块的指针。</li>
<li><code>aio_read()</code>从与<code>aiocbp-&gt;aio_fildes</code>相关的文件中将<code>aiocbp-&gt;aio_bytes</code>字节读入一个由<code>aiocbp-&gt;aio_buf</code>指定的缓冲区中。请求被放入队列之后，函数就返回。</li>
<li><code>ssize_t aio_return(struct aiocv *aiocbp);</code>  –  指定I&#x2F;O操作的状态</li>
<li><code>int aio_error(const struct aiocb *aiocbp);</code> –</li>
</ul>
</li>
</ul>
<h2 id="时间和定时器"><a href="#时间和定时器" class="headerlink" title="时间和定时器"></a>时间和定时器</h2><ul>
<li>操作系统为进程调度，网络协议超时以及定期更新系统的统计信息等目的使用定时器</li>
<li>应用程序通过对系统时间和定时器函数的访问来测量性能或确定事件发生的时间</li>
<li>应用程序也可以用定时器来实现协议，控制与用户的交互</li>
</ul>
<h3 id="POSIX时间"><a href="#POSIX时间" class="headerlink" title="POSIX时间"></a>POSIX时间</h3><ul>
<li><p>POSIX规定系统应该记录从<code>Epoch</code>开始的以秒为单位的时间，每天都被精确地计为86400秒</p>
</li>
<li><p><code>Epoch</code>，新纪元被定义为协调世界时（也称为UTC，格林尼治标准时间或GMT）的1970年1月1日，00:00（午夜）</p>
</li>
<li><p>POSIX基本标准只支持秒级的分辨率，并用类型<code>time_t</code>来表示从Epoch开始的时间，<code>time_t</code>类型通常都用<code>long</code>类型来实现</p>
</li>
<li><p>程序可以通过调用<code>time()</code>函数来访问系统时间（从Epoch开始的秒数表示）。如果tloc不为NULL，time函数还会将时间存储在*tloc中</p>
<ul>
<li><code>#include &lt;time.h&gt;  time_t time(time_t *tloc);</code></li>
<li>如果成功，返回从Epoch开始计算的秒数</li>
<li>如果失败，返回-1，</li>
</ul>
</li>
<li><p>difftime函数负责计算两个<code>time_t</code>类型的日历时间之间的差值，以简化包含时间的计算</p>
</li>
<li><p>difftime函数有两个<code>time_t</code>类型的参数，并返回一个double类型的值，其中包含的是第一个参数减去第二个参数得到的差值</p>
<ul>
<li><code>#include &lt;time.h&gt;</code></li>
<li><code>double difftime(time_t time1, time_t time0);</code></li>
</ul>
</li>
<li><p>对于需要计算时间差值的计算来说，使用<code>time_t</code>类型是很方便的，但是用来打印日期就非常繁琐</p>
</li>
<li><p>函数<code>localtime()</code>有一个参数，这个参数用来说明从Epoch开始的秒数，并返回一个结构，这个结构中带有根据本地需求调整过的时间成分（例如，日，月和年）</p>
<ul>
<li><code>struct tm *localtime(const time_t *timer);</code></li>
</ul>
</li>
<li><p><code>asctime()</code>函数将<code>localtime()</code>返回的结构转换成字符串</p>
<ul>
<li><code>char *asctime(const struct tm *timeptr);</code></li>
</ul>
</li>
<li><p><code>ctime()</code>函数的额功能等同于<code>asctime(localtime(clock))</code></p>
<ul>
<li><code>char *ctime(const time_t *clock);</code></li>
<li><code>ctime()</code>函数用静态存储的方式来保存时间字符串，对ctime的两次调用都将字符串存储在同一个位置，因此在使用第一个值之前，第二次调用可能会将第一个值覆盖</li>
</ul>
</li>
<li><p><code>gmtime()</code>函数的额参数为从Epoch开始的描述，并返回一个结构，这个结构中带有协调时间时表示（UTC）的时间成分</p>
<ul>
<li><code>struct tm *gmtime(const time_t *timer);</code></li>
<li>gmtime函数和localtime函数将时间划分成独立的字段，使得程序可以很容易地输出日期或时间的不同部分</li>
</ul>
</li>
<li><p>ISO定义结构体<code>struct tm</code>中应该包含下列成员：</p>
<ul>
<li><code>int tm_sec; int tm_min; int tm_hour; int tm_mday; int tm_mon; int tm_year; int tm_wday; int tm_yday; int tm_isdst;</code></li>
</ul>
</li>
<li><p>对于程序定时或者控制程序事件来说，用秒作为事件的尺度太粗糙了</p>
</li>
<li><p>POSIX：XSI扩展用<code>struct timeval</code>结构，以更精细的尺度来表示时间。</p>
</li>
<li><p><code>struct timeval</code>结构包含如下成员</p>
<ul>
<li><code>time_t tv_sec; /* 从Epoch开始的秒数*/</code></li>
<li><code>time_t tv_usec; /* 从Epoch开始的微秒数 */</code></li>
</ul>
</li>
<li><p>gettimeofday函数用来获取自Epoch以来的，用秒和微妙表示的系统时间。</p>
</li>
<li><p>tp指向的<code>struct timeval</code>结构负责接收获取的时间，指针tzp必须为NULL，这个指针是由于历史原因才包含进来的</p>
<ul>
<li><code>#include &lt;sys/time.h&gt;</code></li>
<li><code>int gettimeofday(struct timeval *restrict tp, void *restrict tzp);</code></li>
<li>函数返回0，没有保留其他的值来指示错误</li>
</ul>
</li>
</ul>
<h3 id="使用实时时钟"><a href="#使用实时时钟" class="headerlink" title="使用实时时钟"></a>使用实时时钟</h3><ul>
<li><p>时钟(clock)，是一个计数器，它的值以固定间隔增加，这个固定间隔被称为时钟分辨率(clock resolution)</p>
</li>
<li><p>POSIX:TMR定时器扩展中包含了各种用<code>clockid_t</code>类型的变量表示的时钟</p>
</li>
<li><p><code>struct timespec</code>结构用来为POSIX：TMR时钟和定时器指定时间，也用来为支持超时的POSIX线程函数指定超时值。</p>
</li>
<li><p><code>struct timespec</code>结构至少包含下列成员</p>
<ul>
<li><code>time_t tv_sec; /* 秒 */</code></li>
<li><code>long   tv_nsec; /* 纳秒 */</code></li>
</ul>
</li>
<li><p>POSIX提供了设置时钟时间的函数(clock_settime)，获取时钟时间的函数(clock_gettime)和确定时钟分辨率的函数(clock_getres)</p>
<ul>
<li><code>#include &lt;time.h&gt;</code></li>
<li><code>int clock_getres(clockid_t clock_id, struct timespec *res);</code></li>
<li><code>int clock_gettime(clockid_t clock_id, struct timespec *tp);</code></li>
<li><code>int clock_settime(clockid_t clock_id, const struct timespec *tp);</code></li>
</ul>
</li>
<li><p>每个函数都有两个参数：</p>
<ul>
<li>用来标识特定时钟的<code>clockid_t</code></li>
<li>一个指向<code>struct timespec</code>结构的指针</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
<li><p>time函数测量的是实际时间(real time)，有时又称为实耗时间或挂钟时间。</p>
</li>
<li><p>在多道程序设计环境中，很多进程共享CPU，因此实际时间并不能精确地测量出执行时间</p>
</li>
<li><p>进程的虚拟时间(virtual time)是进程在运行(running)状态耗费的时间总量。执行时间通常都用虚拟时间而不用挂钟时间来表示</p>
</li>
<li><p>times函数用时间账单信息来填充它的参数buffer指向的<code>struct tms</code>结构</p>
<ul>
<li><code>#include &lt;sys/times.h&gt;</code></li>
<li><code>clock_t times(struct tms *buffer);</code></li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功，返回用时钟滴答计数表示的实际耗费的时间，这个时间是从过去的任意一点开始计算的，比如可以从系统或进程的起始时间开始计算</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
<li><p><code>struct tms</code>结构至少包含以下成员</p>
<ul>
<li><code>clock_t tms_utime; /*进程的用户CPU时间*/</code></li>
<li><code>clock_t tms_stime; /* 由进程使用的系统CPU时间 */</code></li>
<li><code>clock_t tms_cutime;/* 进程及其已终止的子进程的用户CPU时间*/</code></li>
<li><code>clock_t tms_cstime; /* 由进程及其已终止的子进程使用的系统CPU时间 */</code></li>
</ul>
</li>
</ul>
<h3 id="睡眠函数-247"><a href="#睡眠函数-247" class="headerlink" title="睡眠函数(247)"></a>睡眠函数(247)</h3><ul>
<li><p>自愿地阻塞一段特定时间的进程被称为在睡眠(sleep)。</p>
</li>
<li><p>sleep函数使调用线程挂起，直到经过了特定的秒数，或者调用线程捕捉到信号的时候为止</p>
<ul>
<li><code>unsigned sleep(unsigned seconds);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果请求的时间已经到了，函数就返回0</li>
<li>如果被中断了，sleep函数就返回还没有睡眠的时间值</li>
</ul>
</li>
<li><p>sleep函数与<code>SIGALRM</code>之间有交互作用，所以应该避免在同一个进程中同时使用它们</p>
</li>
<li><p>nanosleep函数会使调用线程的执行挂起，直到rqtp指定的时间间隔到期或线程收到一个信号为止</p>
<ul>
<li><code>#include &lt;time.h&gt;</code></li>
<li><code>int nanosleep(const struct timespec *rqtp, struct timespec *tmtp);</code></li>
</ul>
</li>
<li><p>如果函数被信号中断，且rmtp不为NULL，则rmtp指定的位置上包含的就是剩余时间，这样函数可以被重启动</p>
</li>
<li><p>系统时钟CLOCK_REALTIME决定了rqtp的分辨率</p>
</li>
<li><p>返回值</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
<li><p>nanosleep函数试图取代usleep，现在任免都认为usleep已经过时了</p>
<ul>
<li>与usleep相比，nanosleep最主要的有点是，它不会影响包括SIGALRM在内的任何信号的使用</li>
</ul>
</li>
</ul>
<h3 id="间隔定时器"><a href="#间隔定时器" class="headerlink" title="间隔定时器"></a>间隔定时器</h3><ul>
<li><p>定时器会在经过一段特定的时间之后产生一个通知</p>
</li>
<li><p>时钟采用增量的方式来记录所经过的时间，定时器与之不同，它通常是减少它的值，并在值为零时产生一个信号</p>
</li>
<li><p>计算机系统通常只有少量的硬件间隔定时器，操作系统通过使用这些硬件定时器可以实现多个软件定时器</p>
</li>
<li><p>分时操作系统也可以用间隔定时器来进行进程调度。</p>
</li>
<li><p>操作系统调度一个进程时，它就为一个被称为调度时间片(scheduling quantum)的时间间隔启动了一个间隔定时器</p>
</li>
<li><p>如果这个定时器到期，而进程还在执行，调度程序就将程序转移到一个就绪队列中去，这样其他进程就可以执行了</p>
</li>
<li><p>在多处理其系统中，每个处理器都需要一个这样的间隔定时器</p>
</li>
<li><p>getitimer函数，获取当前的时间间隔</p>
</li>
<li><p>setitimer函数，启动和终止用户的间隔定时器</p>
<ul>
<li><code>#include &lt;sys/time.h&gt;</code></li>
<li><code>int getitimer(int which, struct itimerval *value);</code></li>
<li><code>int setitimer(int which, const struct itimerval *restrict value, struct itimerval *restrict ovalue);</code></li>
</ul>
</li>
<li><p>参数which用来指定定时器(即ITIMER_REAL，ITIMER_VIRTUAL, ITIMER_PROF)</p>
</li>
<li><p>返回值：</p>
<ul>
<li>函数成功，返回0</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
</ul>
<h3 id="实时信号"><a href="#实时信号" class="headerlink" title="实时信号"></a>实时信号</h3><ul>
<li><p>在基本的POSIX标准中，信号处理程序是一个带有单个整型参数的函数，这个整数代表了所产生信号的信号码</p>
</li>
<li><p>POSIX：XSI扩展和POSIX：RTS实时信号扩展都对信号处理能力进行了扩展，包含了信号排队和向信号处理程序传递信息的能力</p>
</li>
<li><p>标准对sigaction结构进行了扩展，以允许信号处理程序使用额外的参数。</p>
</li>
<li><p>如果定义了_POSIX_REALTIME_SIGNALS，实现就可以支持实时信号</p>
</li>
<li><p>sigqueue函数向ID为pid的进程发送带有值value的信号signo</p>
</li>
<li><p>如果signo为零，就会执行错误检测，但是不会发送信号</p>
<ul>
<li><code>#include &lt;signal.h&gt;</code></li>
<li><code>int sigqueue(pid_t pid, int signo, const union sigval value);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
</ul>
<h3 id="POSIX：TMR间隔定时器"><a href="#POSIX：TMR间隔定时器" class="headerlink" title="POSIX：TMR间隔定时器"></a>POSIX：TMR间隔定时器</h3><ul>
<li><p>POSIX：XSI扩展的间隔定时器功能分配给每个进程少量的，固定数目的定时器</p>
</li>
<li><p>POSIX：TMR扩展采用了一种替换方法，在这种方法中只有少量的时钟，一个进程可以为每个时钟创建很多独立的定时器</p>
</li>
<li><p>POSIX：TMR定时器是基于<code>struct itimerspec</code>结构的，这个结构包含下列成员</p>
<ul>
<li><code>struct timespec it_interval;  /* 定时器周期 */</code></li>
<li><code>struct timespec it_value;     /* 定时器到期值 */</code></li>
</ul>
</li>
<li><p>对POSIX：XSI定时器来说，<code>it_interval</code>是定时器到期后，用来重置定时器的时间</p>
</li>
<li><p>成员<code>it_value</code>装载的是定时器到期之前剩余的时间</p>
</li>
<li><p>进程可以通过调用<code>timer_create</code>创建特定的定时器。</p>
</li>
<li><p>定时器是每个进程自己的，不是在fork时继承的</p>
<ul>
<li><code>#include &lt;signal.h&gt;</code></li>
<li><code>#include &lt;time.h&gt;</code></li>
<li><code>int timer_create(clockid_t clock_id, struct sigevent *restrict evp, timer_t *restrict timerid);</code></li>
</ul>
</li>
<li><p>参数：</p>
<ul>
<li><code>timer_create()</code>的参数<code>clock_id</code>说明定时器是基于哪个时钟的，</li>
<li><code>*timerid</code>装载的是被创建的定时器的ID</li>
<li>参数evp指定了定时器到期时要产生的异步通知，如果为NULL，那么定时器就会产生默认的信号</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
<li><p>代码段</p>
<ul>
<li><code>timer_t timerid;</code></li>
<li><code>if(timer_create(CLOCK_REALTIME, NULL, &amp;timerid) == -1) &#123;perror(&quot;Failed to create a new timer)&#125;;</code></li>
</ul>
</li>
<li><p><code>timer_delete()</code>函数删除了ID为timerid的POSIX：TMR定时器</p>
<ul>
<li><code>#include &lt;time.h&gt;</code></li>
<li><code>int timer_delete(timer_t timerid);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
<li><p>操纵每个进程一个的POSIX：TMR定时器</p>
<ul>
<li>函数timer_settime负责启动或停止timer_create创建的定时器。参数flags说明定时器使用的是相对时间还是绝对时间<ul>
<li>相对时间与POSIX：XSI定时器使用的策略类似，</li>
<li>绝对时间的精确度更高，并可以对定时器漂移进行控制</li>
</ul>
</li>
<li>函数timer_settime用value指向的值来设置timerid指定的定时器。如果ovalue不为NULL，timer_settime就将定时器以前的值放在ovalue指定的位置上。</li>
</ul>
</li>
<li><p>有可能一个定时器到期了，而同一个定时器上一次到期时产生的信号还处于挂起状态，在这种情况下，其中的一个信号可能会丢失，这就称作定时器超限(timer overrun)</p>
</li>
<li><p>程序可以通过调用<code>imer_getoverrun()</code>来确定一个特定的定时器出现这种超限的次数</p>
<ul>
<li>定时器超限，只会发生在同一个定时器产生的信号上</li>
<li>由多个定时器，甚至是那些使用相同的时钟和信号的定时器，所产生的信号都会排队而不会丢失</li>
</ul>
</li>
</ul>
<h3 id="定时器漂移，超限和绝对时间"><a href="#定时器漂移，超限和绝对时间" class="headerlink" title="定时器漂移，超限和绝对时间"></a>定时器漂移，超限和绝对时间</h3><ul>
<li><p>一个与POSIX：TMR定时器和POSIX：XSI定时器有关的问题就是，根据相对时间来设置这些定时器的方式</p>
</li>
<li><p>假设，设置了一个间隔2秒的周期性中断，当定时器到期后，系统自动地用另一个2秒的间隔来重启定时器。</p>
</li>
<li><p>假设从定时器到期，到定时器被重新设置之间的等待时间为5纳秒，那么定时器的实际周期为2.000005秒，在1000此中断之后，定时器会偏离5ms</p>
</li>
<li><p>这种不准确型就被称为定时器漂移(timer drift)</p>
</li>
<li><p>处理漂移问题的一种方法是记录定时器实际上什么时候应该到期，并调整每次设置定时器的值。</p>
</li>
<li><p>这种方法使用绝对时间(absolute time)，而不是相对时间(relative time)来设置定时器</p>
</li>
</ul>
<h2 id="破解命令解释程序"><a href="#破解命令解释程序" class="headerlink" title="破解命令解释程序"></a>破解命令解释程序</h2><ul>
<li><p>命令解释程序(shell)，是一个用来对命令行进行解释的程序</p>
</li>
<li><p>换句话来说，命令解释程序从标准输入读入命令行，并执行对应于输入行的命令</p>
</li>
<li><p>在最简单的情况下，命令解释程序读入一条命令并创建一个子进程来执行命令。然后父进程要在读入另一条命令之前，等待这个子进程执行完毕。</p>
</li>
<li><p>实际的命令解释程序，要负责处理进程流水线和重定向，以及前台进程组，后台进程组和信号</p>
</li>
</ul>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul>
<li>POSIX通过文件描述符用独立于设备的方式来处理I&#x2F;O。</li>
<li>通过open或pipe这样的调用获得一个打开的文件描述符之后，程序就可以用从调用中返回的句柄来执行read或write了</li>
<li>重定向允许程序将一个已经打开了的句柄重新分配，去标识另一个文件</li>
</ul>
<h3 id="进程组，会话和控制终端"><a href="#进程组，会话和控制终端" class="headerlink" title="进程组，会话和控制终端"></a>进程组，会话和控制终端</h3><ul>
<li><p>进程组(process group)，是为信号传递这样的目的建立的进程集合。</p>
</li>
<li><p>每个进程都有一个进程组ID(process group ID)来表示它所属的进程组</p>
</li>
<li><p>kill命令和kill函数都将负的进程ID值作为进程组ID来处理，并向相应进程组的每个成员发送一个信号</p>
</li>
<li><p>进程组组长(process group leader)，是一个进程，它的进程ID值与进程组ID值相同。</p>
</li>
<li><p>只要进程组里还有进程，进程组就一直存在。如果组长死了或者加入了另一个组，进程组可能就没有组长了</p>
</li>
<li><p>进程可以用setpgid来改变它的进程组。</p>
</li>
<li><p>setpdig函数将进程pid的进程组ID设置为进程组ID gpid。如果pid为0，它就使用调用进程的进程ID。如果pgid为0，pid指定的进程就成为一个组长</p>
<ul>
<li><code>#include &lt;unistd.h&gt;</code></li>
<li><code>int setpgid(pid_t pid, pid_t gpid);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
<li><p>getpgrp函数返回调用进程的进程组ID</p>
<ul>
<li><code>#include &lt;unistd.h&gt;</code></li>
<li><code>pid_t getpgrp(void);</code></li>
</ul>
</li>
<li><p>为了实现信号的透明传递，POSIX使用了会话和控制终端</p>
</li>
<li><p>会话(session)，是为作业控制建立的一个进程组的集合。</p>
</li>
<li><p>会话的创建者就被称为会话组长(session leader)</p>
</li>
<li><p>用会话组长的进程ID来标识会话。每个进程都属于一个会话，会话是它们从父进程那里继承来的</p>
</li>
<li><p>每个会话都应该有一个与之相关的控制终端(controlling terminal)</p>
</li>
<li><p>命令解释程序用它的会话的控制终端来与用户交互</p>
</li>
<li><p>一个特定的控制终端只与一个会话有关，一个会话中可能有多个进程组，但在任一给定的时候，只有一个进程组可以从控制终端接收输入并向控制终端发送输出。</p>
</li>
<li><p>这个特定的进程组被称为前台进程控制组(foreground process group)或前台作业(foreground job)</p>
</li>
<li><p>会话中其余的进程组被称为后台进程组(background process group)或后台作业(background job)</p>
</li>
<li><p>作业控制的主要目的是改变在前台的进程组</p>
</li>
<li><p>用ctermid函数来获取控制终端的名字</p>
<ul>
<li><code>#include &lt;stdio.h&gt;</code></li>
<li><code>char *ctermid(char *s);</code></li>
</ul>
</li>
<li><p>函数返回一个指向字符串的指针，这个字符串对应于当前进程的控制终端的路径名</p>
</li>
<li><p>如果s是一个NULL指针，这个字符串可能位于静态生成的区域中，</p>
</li>
<li><p>如果s不为NULl，它应该指向一个至少有L_Ctermid字节的字符数组</p>
</li>
<li><p>ctermid函数将一个表示控制终端的字符串拷贝到那个数组中去</p>
</li>
<li><p>如果失败，返回空字符串</p>
</li>
<li><p>进程可以通过调用setsid来创建一个以它自己为组长的新会话</p>
<ul>
<li><code>#include &lt;unistd.h&gt;</code></li>
<li><code>pid_t setsid(void);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回新的进程组ID值</li>
<li>失败，返回-1， 并设置errno</li>
</ul>
</li>
<li><p>进程可以通过调用getsid来发现会话ID</p>
</li>
<li><p>函数getsid将一个进程组ID–pid，作为参数，并返回pid指定的那个进程的会话组长的进程组ID</p>
<ul>
<li><code>#include &lt;unistd.h&gt;</code></li>
<li><code>pid_t getsid(pid_t pid);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回一个进程组ID</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
</ul>
<h3 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h3><ul>
<li><p>如果命令解释器程序允许用户将前台进程组移到后台去，并允许用户将进程组从后台移到前台，那么这个命令解释程序就是有作业控制(job control)功能的</p>
</li>
<li><p>作业控制包括对控制终端前台进程组进行修改</p>
</li>
<li><p>tcgetpgrp函数，用来返回一个特定控制终端的前台进程组的进程组ID</p>
</li>
<li><p>要获得控制终端的打开的文件描述符，就要打开ctermid函数中获得的路径名</p>
<ul>
<li><code>#include &lt;unistd.h&gt;</code></li>
<li><code>pid_t tcgetpgrp(int fildes);</code></li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功，返回与终端相关的前台进程组的进程组ID</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
<li><p>tcsetpgrp函数将与fildes相关的控制终端的前台进程组设置为pgid_id</p>
<ul>
<li><code>#include &lt;unistd.h&gt;</code></li>
<li><code>int tcsetpgrp(int fildes, pid_t pgid_id);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
</ul>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul>
<li>实现并行的一种方法是多个进程通过共享内存或消息传递来进行协作和同步，另一种方法是在单个地址空间中使用多个执行线程</li>
</ul>
<h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3><ul>
<li><p>线程包中通常包含了用于线程创建和线程销毁，调度，强制互斥和条件等待的函数</p>
</li>
<li><p>典型的线程包中还包括一个运行系统来对线程进行透明的管理，也就是说，用户是不知道运行系统的存在的</p>
</li>
<li><p>线程被创建时，运行系统分配数据结构来状态线程ID，栈和程序计数器值。</p>
</li>
<li><p>线程的内部数据结构中可能还包括调度和使用信息。</p>
</li>
<li><p>一个进程的各个线程共享那个进行的整个地址空间。它们可以修改全局变量，访问打开的文件描述符，并用其他的方式互相配合或互相干扰</p>
</li>
<li><p>因为所有的线程函数都以pthread开始，所以有时POSIX线程被称为pthreads</p>
</li>
<li><p>POSIX线程管理函数</p>
<ul>
<li><code>pthread_cancel</code>  –  终止另一个线程</li>
<li><code>pthread_create</code>  –  创建一个线程<ul>
<li><code>int pthread_create(pthread_t *restrict thread, const pthread_attr_t *restrict attr, void*(*start_routine)(void *), void *restrict arg);</code></li>
<li>pthread_create函数创建了一个线程。与有些线程工具，例如Java编程语言提供的那些线程工具不同，POSIX的pthread_create会<strong>自动使线程成为可运行的，而不需要一个单独的启动操作</strong></li>
<li>参数<ul>
<li>thread，指向新创建的线程ID</li>
<li>attr， 表示一个封装了线程的各种属性的属性对象。如果为NULL，新线程就具有默认的属性</li>
<li>start_routine，是线程开始执行的时候调用的函数的名字。<ul>
<li>start_routine有一个由arg指定的参数，这个参数是一个指向void的指针</li>
<li>start_routine返回一个指向void的指针，这个返回值被pthread_join当做退出状态来处理</li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功，返回0</li>
<li>失败，返回一个非零的错误码</li>
</ul>
</li>
</ul>
</li>
<li><code>pthread_detach</code>  –  设置线程以释放资源</li>
<li><code>pthread_equal</code>   –  测试两个线程ID是否相等<ul>
<li><code>pthread_t pthread_equal(pthread_t t1, pthread_t t2);</code></li>
<li>如果t1等于t2，pthread_equal返回一个非零值；如果不相等，返回0</li>
</ul>
</li>
<li><code>pthread_exit</code>    –  退出线程，而不退出进程</li>
<li><code>pthread_kill</code>    –  向线程发送一个信号</li>
<li><code>pthread_join</code>    –  等待一个线程</li>
<li><code>pthread_self</code>    –  找出自己的线程ID<ul>
<li><code>pthread_t pthread_self(void);</code></li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，大多数线程函数都返回0</li>
<li>失败，大多数线程函数都会返回非零的错误码，它们不设置errno，因此调用程序不能用perror来报告错误</li>
</ul>
</li>
</ul>
<h3 id="分离和连接"><a href="#分离和连接" class="headerlink" title="分离和连接"></a>分离和连接</h3><ul>
<li><p>除非是一个分离线程，否则在线程退出时，它是不会释放它的资源的</p>
</li>
<li><p>pthread_detach函数将线程分离，它设置线程的内部选项来说明线程退出后，线程的存储空间可以被重新收回</p>
</li>
<li><p>分离线程退出时不会报告它们的状态。没有分离的线程是可接合的，而且在另一个线程为它们调用pthread_join或者整个进程退出之前，这些线程不会释放它们所有的资源</p>
</li>
<li><p>pthread_detach函数有一个参数thread，这个参数是要分离的线程的线程ID</p>
<ul>
<li><code>int pthread_detach(pthread_t thread);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0，</li>
<li>失败，返回一个非零的错误码</li>
</ul>
</li>
<li><p>在另一个线程用终止线程的ID值作为第一个参数调用pthread_join之前，未分离线程的资源是不会被释放的</p>
<ul>
<li><code>int pthread_join(pthread_t thread, void **value_ptr);</code></li>
</ul>
</li>
<li><p>pthread_join函数将调用线程挂起，直到第一个参数指定的目标线程终止为止</p>
</li>
<li><p>参数value_ptr为指向返回值的指针提供了一个位置，这个返回值是由目标线程传递给pthread_exit或return的</p>
</li>
<li><p>如果value_ptr为NULL，调用程序就不会对目标线程的返回状态进行检索了</p>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回一个非零的错误码</li>
</ul>
</li>
<li><p>如果线程执行<code>pthread_join(pthread_self());</code>，会发生什么情况</p>
<ul>
<li>假设线程是可接合的（不是已分离的），这条语句就会造成死锁</li>
<li>有些实现可以检测到死锁，并迫使pthread_join带着错误EDEADLK返回</li>
<li>但是，POSIX：THR扩展并不要求进行这种检测</li>
</ul>
</li>
</ul>
<h3 id="退出和取消"><a href="#退出和取消" class="headerlink" title="退出和取消"></a>退出和取消</h3><ul>
<li><p>进程的终止可以通过直接调用exit，执行main中的return，或者通过进程的某个其他线程调用exit来实现</p>
</li>
<li><p>在任何一种情况下，所有的线程都会终止</p>
</li>
<li><p>如果主线程在创建了其他线程之后没有工作可做，它就应该阻塞到所有线程都结束为止，或者应该调用<code>pthread_exit(NULL)</code></p>
</li>
<li><p>调用exit会使整个进程终止</p>
</li>
<li><p>调用pthread_exit只会使调用线程终止</p>
</li>
<li><p><code>void pthread_exit(void *value_ptr);</code></p>
</li>
<li><p>在顶层执行return的线程隐式地调用了pthread_exit，调用时将返回值（一个指针）当做pthread_exit的参数使用。</p>
</li>
<li><p>如果进程的最后一个线程调用了pthread_exit，进程会带着状态返回值0退出</p>
</li>
<li><p>对一个成功的pthread_join来说，value_ptr的值是可用的。</p>
</li>
<li><p>但是，pthread_exit中的value_ptr必须指向线程退出后仍然存在的数据，因此线程不应该为value_ptr使用指向自动局部数据的指针</p>
</li>
<li><p>线程可以通过取消机制，迫使其他线程返回。线程可以调用pthread_cancel来请求取消另一个线程。</p>
</li>
<li><p>结果由目标线程的类型和取消状态决定</p>
<ul>
<li><code>int pthread_cancel(pthread_t thread);</code></li>
</ul>
</li>
<li><p>参数：</p>
<ul>
<li>thread， 要取消的目标线程的线程ID</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回一个非零的错误码</li>
</ul>
</li>
<li><p>线程收到一个取消请求时会发生什么情况取决于它的状态和类型。</p>
</li>
<li><p>如果线程处于PTHREAD_CANCEL_ENABLE状态，它就接收取消请求</p>
</li>
<li><p>另一方面，如果线程处于PTHREAD_CANCEL_DISABLE状态，取消请求就会被保持在挂起状态。</p>
</li>
<li><p>默认情况下，线程处于PTHREAD_CANCEL_ENABLE状态</p>
</li>
<li><p>pthread_setcancelstate函数用来改变调用线程的取消状态</p>
<ul>
<li><code>int pthread_setcancelstat(int state, int *oldstate);</code></li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li>state，说明要设置的新状态</li>
<li>oldstate, 指向一个整数的指针，这个整数中装载了以前的状态</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回一个非零的错误码</li>
</ul>
</li>
<li><p>作为一个通用的原则，改变了其取消状态或类型的函数应该在返回之前回复它们的值</p>
</li>
<li><p>pthread_setcanceltype函数，根据它的type参数指定的值来修改线程的取消类型</p>
</li>
</ul>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul>
<li><p>线程中隐藏的一个问题是它们可能会调用非线程安全的库函数，这样可能会产生错误的结果。</p>
</li>
<li><p>如果多个线程能够同时执行函数的多个活动请求而不会相互干扰，那么这个函数就是线程安全的(thread-safe)</p>
</li>
<li><p>在传统的UNIX实现中，errno是一个全局外部变量，当系统函数产生一个错误时，就会设置errno。</p>
</li>
<li><p>对多线程来说，这种实现方式是无法工作的，在大多数线程实现中，errno是一个用来返回线程的特定信息的宏</p>
</li>
<li><p>本质上来说，每个线程都有一份私有的errno拷贝。</p>
</li>
<li><p>主线程不能直接访问一个接合线程的errno，因此如果需要的话，必须通过pthread_join的最后一个参数来返回这些信息</p>
</li>
</ul>
<h3 id="用户线程和内核线程"><a href="#用户线程和内核线程" class="headerlink" title="用户线程和内核线程"></a>用户线程和内核线程</h3><ul>
<li><p>用户级线程(user-level thread)和内核级线程(kernel-level thread)是两种传统的线程控制模式</p>
</li>
<li><p>用户级线程，通常都运行在一个现存的操作系统之上。</p>
</li>
<li><p>这些线程对内核来说是不可见的，它们之间还会竞争分配给它们的封装进程的资源。</p>
</li>
<li><p>线程由一个线程运行系统来调度，这个系统是进程代码的一部分</p>
</li>
<li><p>带有用户级线程的程序通常会连接到一个特殊的库上去，这个库中的每个库函数都用外套(jacket)包装起来</p>
</li>
<li><p>POSIX引入了一个线程调度竞争范围(thread-scheduling contention scope)的概念，这个概念赋予了程序员一些控制权，使他们可以控制怎样将内核实体映射为线程</p>
</li>
</ul>
<h3 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h3><ul>
<li><p>POSIX将栈的大小和调度策略这样的特征封装到一个pthread_attr_t类型的对象中去，用面向对象的方式表示和设置特征</p>
</li>
<li><p>属性对象只是在线程创建的时候会对线程产生映像。可以先创建一个属性对象，然后再将栈的大小和调度策略这样的特征与属性对象关联起来</p>
</li>
<li><p>可以通过向pthread_create传递相同的线程属性对象来创建多个具有相同特征的线程</p>
</li>
<li><p>pthread_attr_init用默认值对一个线程属性对象进行初始化</p>
</li>
<li><p>pthread_attr_destroy函数将属性对象的值设为无效的</p>
<ul>
<li><code>int pthread_attr_destroy(pthread_attr *attr);</code></li>
<li><code>int pthread_attr_init(pthread_attr *attr);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回一个非零的错误码</li>
</ul>
</li>
<li><p>pthread_attr_getdetachstate函数用来查看一个属性对象的状态</p>
</li>
<li><p>pthread_attr_setdetachstate函数用来设置一个属性对象的状态</p>
</li>
</ul>
<h3 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h3><ul>
<li><p>线程有一个栈，用户可以设置栈的位置和大小，如果必须将线程栈放在一个特定的内存区中，这就是一个有用的特征</p>
</li>
<li><p>要为线程定义栈的布局和大小，就必须先用特定的栈属性来创建一个属性对象，然后用这个属性对象来调用pthread_create</p>
</li>
<li><p>pthread_attr_getstack函数用来查看栈的参数</p>
</li>
<li><p>pthread_attr_setstack函数用来设置一个属性对象的栈参数</p>
<ul>
<li><code>int pthread_attr_getstack(const pthread_attr_t *restrict attr, void **restrict stackaddr, size_t *restrict stacksize);</code></li>
<li><code>int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);</code></li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li>每个函数的参数attr都是一个指向属性对象的指针</li>
<li>pthread_attr_setstack函数将栈的地址和栈的大小作为额外的参数</li>
<li>pthread_attr_getstack函数则将指向这些条目的指针当做参数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回一个非零的错误码</li>
</ul>
</li>
<li><p>如果用户还没有设置stackaddr，POSIX还提供了检查栈溢出或者为栈溢出设置警戒的函数</p>
</li>
<li><p>pthread_attr_getguardsize函数用来查看警戒参数</p>
</li>
<li><p>pthread_attr_setguardsize函数在一个属性对象中设置了用来控制栈溢出的警戒参数</p>
<ul>
<li><code>int pthread_attr_setguardsize(const pthread_attr_t *restrict attr, size_t *restrict guardsize);</code></li>
<li><code>int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回一个非零的错误码</li>
</ul>
</li>
</ul>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ul>
<li><p>对象的竞争范围(contention space)控制了线程是在进程内部还是在系统级竞争调度资源</p>
</li>
<li><p>pthread_attr_getscope用来查看竞争范围</p>
</li>
<li><p>pthread_attr_setscope用来设置一个属性对象的竞争范围</p>
<ul>
<li><code>int pthread_attr_getscope(const pthread_attr_t *restrict attr, int *restrict conttentionspace);</code></li>
<li><code>int pthread_attr_setscope(pthread_attr_t *attr, int contentionscope);</code></li>
</ul>
</li>
<li><p>参数：</p>
<ul>
<li>attr是一个指向属性对象的指针</li>
<li>contentionscope对应于要为pthread_attr_setscope设置的值，以及一个指向要从pthread_attr_getscope获得的值的指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回一个非零的错误码</li>
</ul>
</li>
<li><p>POSIX允许线程用不同的方式继承调度策略</p>
</li>
<li><p>pthread_attr_getinheritsched函数负责查看调度继承策略</p>
</li>
<li><p>pthread_attr_setinheritsched函数负责为一个属性对象设置调度继承策略</p>
<ul>
<li><code>int pthread_attr_getinheritsched(const pthread_attr_t *restrict attr, int *restrict inheritsched);</code></li>
<li><code>int pthread_attr_setinheritsched(pthread_attr_t *attr, int inheritsched);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回一个非零的错误码</li>
</ul>
</li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul>
<li>POSIX支持用于短期锁定的互斥锁以及可以等待无期限事件的条件变量</li>
</ul>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><ul>
<li><p>互斥量，是一种特殊的变量，它可以处于锁定(locked)状态，也可以处于解锁(unlocked)状态</p>
</li>
<li><p>如果互斥量是锁定的，就有一个特定的线程持有(hold)或拥有(own)这个互斥量</p>
</li>
<li><p>如果没有线程持有这个互斥量，就说这个互斥量处于解锁(unlocked)，空闲(free)或可用(available)的状态</p>
</li>
<li><p>互斥量还有一个等待持有该互斥量的线程队列。</p>
</li>
<li><p>互斥量的等待队列中的线程获得互斥量的顺序由线程调度策略确定，但POSIX没有要求实现任何特定的策略</p>
</li>
<li><p>互斥量(mutex)或互斥锁(mutex lock)，是最简单也是最有效的线程同步机制</p>
</li>
<li><p>程序用互斥锁来保护临界区，以获得对资源的排他性访问权</p>
</li>
<li><p>互斥量只能被段时间地持有。</p>
</li>
<li><p>互斥函数不是线程取消点，也不能被信号中断</p>
</li>
<li><p>除非进程终止了，（从信号处理程序中）用pthread_exit终止了线程，或者异步取消了线程(通常不用这种方法)，否则，等待互斥量的线程不能被逻辑地中断</p>
</li>
<li><p>出现等待输入这样的持续时间不确定的情况下，用条件变量来进行同步</p>
</li>
<li><p>POSIX使用 pthread_mutex_t 类型的变量来表示互斥锁</p>
</li>
<li><p>程序在用 pthread_mutex_t 变量进行同步之前，通常必须对其进行初始化</p>
<ul>
<li>对静态分配的 pthread_mutex_t 变量来说，只要将PTHREAD_MUTEX_INITIALIZER赋给变量就可以了</li>
<li>对动态分配或没有默认互斥属性的互斥变量来说，要调用pthread_mutex_init来执行初始化工作</li>
</ul>
</li>
<li><p>pthread_mutex_init的参数mutex是一个指向要初始化的互斥量的指针</p>
<ul>
<li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code></li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li>attr， 互斥属性对象，传入NULL，使用默认属性</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回非零的错误码</li>
</ul>
</li>
<li><p>pthread_mutex_destroy函数销毁了它的参数所引用的互斥量</p>
<ul>
<li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li>mutex，是一个指向要销毁的互斥量指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回非零的错误码</li>
</ul>
</li>
<li><p>pthread_mutex_lock函数会一直阻塞到互斥量可用为止</p>
</li>
<li><p>pthread_mutex_trylock函数，通常会立即返回</p>
</li>
<li><p>pthread_mutex_unlock函数用来释放指定的互斥量</p>
<ul>
<li><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></li>
<li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></li>
<li><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></li>
</ul>
</li>
<li><p>这三个函数都只有一个参数mutex，这个参数是一个指向互斥量的指针</p>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回非零的错误码</li>
</ul>
</li>
<li><p>因为互斥锁必须能被所有需要同步的线程访问，所以，它们通常会以全局变量的形式出现（内部或外部链接）</p>
</li>
<li><p>线程化程序中大多数共享的数据结构都必须由同步机制保护，以确保能得到正确的结果</p>
</li>
</ul>
<h3 id="最多一次和至少一次的执行"><a href="#最多一次和至少一次的执行" class="headerlink" title="最多一次和至少一次的执行"></a>最多一次和至少一次的执行</h3><ul>
<li>单次初始化的概念非常重要，POSIX甚至还提供了一个pthread_once函数来确保这个语义的实现<ul>
<li><code>int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));</code></li>
<li><code>pthread_once_t once_control = PTHREAD_ONCE_INIT;</code></li>
</ul>
</li>
<li>必须用PTHREAD_ONCE_INIT对参数<code>once_control</code>进行静态初始化</li>
<li>返回值：<ul>
<li>成功，返回0</li>
<li>失败，返回非零的错误码</li>
</ul>
</li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><ul>
<li><p>考虑一个使进程一直等待，直到某个任意的条件被满足了为止的问题。</p>
</li>
<li><p>具体来说，假设有两个变量x和y被多个线程共享。希望一个线程一直等到x和y相等为止。</p>
</li>
<li><p>典型的不正确的忙等解决方法是：</p>
<ul>
<li><code>while (x != y);</code></li>
</ul>
</li>
<li><p>断言x &#x3D;&#x3D; y为真所用的正确的非忙等策略</p>
<ul>
<li>锁定互斥量</li>
<li>测试条件x &#x3D;&#x3D; y</li>
<li>如果为真，解除对互斥量的锁定，并退出循环</li>
<li>如果为假，将线程挂起，并解除对互斥量的锁定</li>
</ul>
</li>
<li><p>应用程序通过使用pthread_mutex_lock和pthread_mutex_unlock这样定义的很明确的系统库函数来操纵互斥队列。</p>
</li>
<li><p>这些函数还不足以实现（用一种简单的方式）这里要求的队列操作。</p>
</li>
<li><p>需要一种新的数据类型，一种与等待x &#x3D;&#x3D; y这样的任意条件为真的进程队列相关的数据类型。这样的数据类型被称为条件变量(condition variable)</p>
</li>
<li><p>函数pthread_cond_wait将一个条件变量和一个互斥量作为参数，它原子地挂起调用线程并解除对互斥量的锁定</p>
</li>
<li><p>可以认为它将线程放入了一个线程队列，队列中的线程都在等待条件发生变化的通知</p>
</li>
<li><p>线程收到通知时，函数会带着重新获得的互斥量返回</p>
</li>
<li><p>在继续执行之前，线程必须再次对条件进行测试</p>
</li>
<li><p>如何用POSIX条件变量v和互斥量m来等待条件x &#x3D;&#x3D; y</p>
<ul>
<li><code>pthread_mutex_lock(&amp;m);</code></li>
<li><code>while (x != y)</code><ul>
<li><code>pthread_cond_wait(&amp;v, &amp;m);</code></li>
</ul>
</li>
<li><code>pthread_mutex_unlock(&amp;m);</code></li>
</ul>
</li>
<li><p>函数pthread_cond_wait只能由拥有互斥量的线程调用，当函数返回时，线程就再次拥有了互斥量</p>
</li>
</ul>
<h3 id="条件变量的使用和sigsuspend的使用"><a href="#条件变量的使用和sigsuspend的使用" class="headerlink" title="条件变量的使用和sigsuspend的使用"></a>条件变量的使用和sigsuspend的使用</h3><ul>
<li><p>两个概念是相似的</p>
</li>
<li><p>阻塞信号并对条件进行测试。因为在信号被阻塞的时候，信号处理程序不能访问全局变量sigreceived，所以阻塞信号与锁定互斥是类似的</p>
</li>
<li><p>当sigsuspend返回时，信号再次被阻塞。</p>
</li>
<li><p>线程用条件变量锁定互斥量来保护它的临界区并对条件进行测试。</p>
</li>
<li><p>pthread_cond_wait原子地释放了互斥量并将进行挂起。当pthread_cond_wait返回时，线程就再次拥有了互斥量</p>
</li>
</ul>
<h3 id="创建和销毁条件变量"><a href="#创建和销毁条件变量" class="headerlink" title="创建和销毁条件变量"></a>创建和销毁条件变量</h3><ul>
<li><p>POSIX用pthread_cond_t类型的变量来表示条件变量</p>
</li>
<li><p>程序必须在使用该变量之前对其进行初始化</p>
</li>
<li><p>对那些静态分配的，带有默认属性的pthread_cond_t变量来说，简单地将PTHREAD_COND_INITIALIZE赋给变量就可以完成初始化</p>
</li>
<li><p>对那些动态分配的或不具有默认属性的变量来说，就要调用pthread_cond_init来执行初始化</p>
<ul>
<li><code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code></li>
<li><code>pthread_cond_t cond = PTHREAD_COND_INITIALIZE;</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回非零的错误码</li>
</ul>
</li>
<li><p>函数pthread_cond_destroy销毁了它的参数cond引用的条件变量</p>
<ul>
<li><code>int pthread_cond_destroy(pthread_cond_t *cond);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回非零的错误码</li>
</ul>
</li>
</ul>
<h3 id="等待并通知条件变量"><a href="#等待并通知条件变量" class="headerlink" title="等待并通知条件变量"></a>等待并通知条件变量</h3><ul>
<li><p>条件变量是与断言或条件的测试一同调用的，条件变量的名字就是从这个事实引申出来的</p>
</li>
<li><p>通常，线程会对一个断言进行测试，如果测试失败，就调用pthread_cond_wait</p>
</li>
<li><p>函数pthread_cond_timewait可以用来等待一段有限的时间</p>
<ul>
<li><code>int pthread_cond_timewait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code></li>
<li><code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code></li>
</ul>
</li>
<li><p>这些函数的第一个参数是cond，这是一个指向条件变量的指针</p>
</li>
<li><p>第二个参数是mutex，这是一个指向互斥连的遏制真</p>
<ul>
<li>线程在调用之前应该拥有这个互斥量</li>
<li>当线程被放置在条件变量等待队列中时，等待操作会使线程释放这个互斥量</li>
</ul>
</li>
<li><p>pthread_cond_timewait函数的第三个参数是一个指向返回时间的指针，这个值表示的是绝对时间，而不是时间间隔</p>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回非零的错误码</li>
</ul>
</li>
<li><p>当另一个线程修改了可能会使断言成真的变量时，它应该唤醒一个或多个在等待断言成真的线程</p>
</li>
<li><p>pthread_cond_signal函数至少解除了对一个阻塞在cond指向的条件变量上的线程的阻塞</p>
</li>
<li><p>pthread_cond_broadcast函数解除了所有阻塞在cond指向的条件变量上的线程的阻塞</p>
<ul>
<li><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></li>
<li><code>int pthread_cond_signal(pthread_cond_t *cond);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回非零的错误码</li>
</ul>
</li>
</ul>
<h3 id="条件变量规则"><a href="#条件变量规则" class="headerlink" title="条件变量规则"></a>条件变量规则</h3><ul>
<li><p>条件变量没有被链接到特定的断言上去，pthread_cond_wait可能会因为假唤醒而返回</p>
</li>
<li><p>使用条件变量时要遵守的规则</p>
<ul>
<li>在测试断言之前获得互斥量</li>
<li>因为返回可能是由某些不相关的事件或无法使断言成真的pthread_cond_signal引起的，所以要在从pthread_cond_wait返回值后重新对断言进行测试</li>
<li>在修改断言中出现的任一变量之前，要获得互斥量</li>
<li>仅仅在较短的时间段中持有互斥量 – 通常是在测试断言或者修改共享变量的时候</li>
<li>显示地(用pthread_mutex_unlock)或隐式地(用pthread_cond_wait)释放互斥量</li>
</ul>
</li>
</ul>
<h3 id="信号处理与线程"><a href="#信号处理与线程" class="headerlink" title="信号处理与线程"></a>信号处理与线程</h3><ul>
<li><p>进程中所有线程都共享进程的信号处理程序，但每个线程都有它自己的信号掩码</p>
</li>
<li><p>由于线程的操作可以异步于信号，所以线程与信号的交互会比较复杂</p>
</li>
<li><p>三种类型的信号及其相应的传递方法</p>
<ul>
<li>异步  –  传递给某些解除了对该信号的阻塞的线程</li>
<li>同步  –  传递给引发（该信号）的线程</li>
<li>定向的  – 传递给标识了的线程(pthread_kill)</li>
</ul>
</li>
<li><p>SIGFPE(浮点异常)这样的信号就是同步于引发它们的线程（也就是说，它们通常在线程执行的相同位置上产生）</p>
</li>
<li><p>pthread_kill函数要求产生信号码为sig的信号，并将其传送到thread指定的线程中去</p>
<ul>
<li><code>int pthread_kill(pthread_t thread, int sig);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回非零的错误码</li>
</ul>
</li>
<li><p>使线程将它自己和整个进程都杀死</p>
<ul>
<li><code>if (pthread_kill(pthread_self(), SIGKILL))</code><ul>
<li><code>fprintf(stderr, &quot;Failed to commit suicide \n&quot;);</code></li>
</ul>
</li>
</ul>
</li>
<li><p>一种常见的概念混淆是假定pthread_kill总是会使进程终止的，但实际上并不是这样的，pthread_kill仅仅为线程产生一个信号</p>
</li>
<li><p>为线程屏蔽信号。虽然信号处理程序是进程范围的，但是每个线程都有它自己的信号掩码</p>
</li>
<li><p>线程可以用pthread_sigmask函数来检查或设置它的信号掩码</p>
<ul>
<li><code>int pthread_sigmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);</code></li>
</ul>
</li>
<li><p>参数how和set指出了修改信号掩码的方式</p>
<ul>
<li>how的值SIG_SETMASK会使线程的信号掩码被set取代</li>
<li>也就是说，现在线程阻塞set中所有的信号，但不阻塞任何其他信号</li>
<li>how的值SIG_BLOCK使线程阻塞set中的其他信号（添加到线程当前的信号掩码中）</li>
<li>how的值SIG_UNBLOCK从线程当前的信号掩码中将set中当前被阻塞的信号删除（不再阻塞）</li>
</ul>
</li>
<li><p>如果参数oset不为NULL，函数就将*oset设置为线程的前一个信号掩码</p>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回非零的错误码</li>
</ul>
</li>
<li><p>为信号处理指定专用线程</p>
</li>
<li><p>信号处理程序是进程范围的，与在单线程的进程中一样，可以用sigaction调用来安装它们</p>
</li>
<li><p>在线程化程序中，进程范围的信号处理程序和线程特定的信号掩码之间的区别是很重要的</p>
</li>
<li><p>在多线程的进程中进行信号处理的一种推荐策略是：为信号处理使用特定的线程</p>
</li>
<li><p>主线程在创建线程之前阻塞了所有的信号。信号掩码是从创建线程中继承的。</p>
</li>
<li><p>这样，所有的线程都将信号阻塞了。然后，专门用来处理信号的线程对那个信号执行sigwait</p>
</li>
<li><p>或者，线程可以用pthread_sigmask来接触对信号的阻塞</p>
</li>
</ul>
<h3 id="读者和写者"><a href="#读者和写者" class="headerlink" title="读者和写者"></a>读者和写者</h3><ul>
<li><p>读-写者问题指的是这样的一种情况：</p>
<ul>
<li>在这种情况下，允许对资源进行两种类型的访问（读和写）</li>
<li>一种类型的访问必须确保是排他的（比如，写操作），但是另一种类型的访问可以是共享的（比如，读操作）</li>
</ul>
</li>
<li><p>处理读-写者同步的两种常见的策略被称为强读者同步(strong reader synchronization)和强写者同步(strong writer synchronization)</p>
<ul>
<li>在强读者同步中，总是给读者以优先权，只要写者当前没有进行写操作，读者就可以获得访问权</li>
<li>在强写者同步中，通常将优先权交给写者，二将读者延迟到所有等待或活动的写者都完成了为止</li>
</ul>
</li>
<li><p>POSIX提供了读-写锁：如果写者没有持有锁，就允许多个读者获得这个锁</p>
</li>
<li><p>POSIX声明，当前写者阻塞在锁上时，就由实现来决定是否允许读者获取锁</p>
</li>
<li><p>POSIX读-写锁由pthread_rwlock_t类型的变量表示。</p>
</li>
<li><p>程序在用pthread_rwlock_t变量进行同步之前，必须调用pthread_rwlock_init来初始化这个变量</p>
<ul>
<li><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code></li>
</ul>
</li>
<li><p>参数rwlock是一个指向读-写锁的指针</p>
</li>
<li><p>将NULL传递给pthread_rwlockattr_t，以便用默认属性来初始化读-写锁。否则，就要使用与线程属性对象类似的方法，县创建，然后再初始化读-写锁属性对象</p>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回非零的错误码</li>
</ul>
</li>
<li><p>pthread_rwlock_destroy函数销毁了它的参数引用的读-写锁</p>
<ul>
<li><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code></li>
</ul>
</li>
<li><p>参数rwlock是一个指向读-写锁的指针</p>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回非零的错误码</li>
</ul>
</li>
<li><p>pthread_rwlock_rdlock和pthread_rwlock_tryrdlock函数允许线程为读操作获取一个读-写锁</p>
</li>
<li><p>pthread_rwlock_wrlock和pthread_rwlock_trywrlock函数允许线程为写操作获取一个读-写锁</p>
</li>
<li><p>pthread_rwlock_ldlock和pthread_rwlock_wrlock函数一直保持阻塞，到有锁可用为止</p>
</li>
<li><p>pthread_rwlock_tryldlock和pthread_rwlock_trywrlock函数则会立即返回</p>
</li>
<li><p>pthread_rwlock_unlock函数会将锁释放掉</p>
<ul>
<li><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></li>
<li><code>int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);</code></li>
<li><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></li>
<li><code>int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);</code></li>
<li><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code></li>
</ul>
</li>
<li><p>这些函数要求将一个指向锁的指针作为参数传递</p>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回非零的错误码</li>
</ul>
</li>
</ul>
<h3 id="strerror-r的实现"><a href="#strerror-r的实现" class="headerlink" title="strerror_r的实现"></a>strerror_r的实现</h3><ul>
<li><p>通常，主线程是唯一一个打印错误消息的线程</p>
</li>
<li><p>strerror为非线程安全的函数</p>
</li>
<li><p>perror_r和sterror_r函数既是线程安全的，又是异步信号安全的</p>
</li>
</ul>
<h2 id="临界区和信号量"><a href="#临界区和信号量" class="headerlink" title="临界区和信号量"></a>临界区和信号量</h2><ul>
<li>管理共享资源的程序必须以互斥的方式来执行被称为临界区的代码段</li>
</ul>
<h3 id="处理临界区"><a href="#处理临界区" class="headerlink" title="处理临界区"></a>处理临界区</h3><ul>
<li><p>共享设备，被称为排他性资源(exclusive resources)，因为它们一次只能由一个进程访问</p>
</li>
<li><p>进程必须以互斥(mutually exclusive)的方式来执行访问这些共享资源的代码</p>
</li>
<li><p>临界区(critical section)，是必须以互斥的方式执行的代码段，也就是说，在临界区的范围内，只能有一个活动的执行线程</p>
</li>
<li><p>临界区问题(critical section problem)，是指安全，公平和对称的方式来执行临界区代码的问题</p>
</li>
<li><p>可以将带有同步临界区的代码组织成不同的部分</p>
<ul>
<li>入口区(entry section)，包含了请求对共享变量或其他资源进行修改的代码</li>
<li>临界区(critical section)，包括访问共享资源或执行不可重入代码的代码</li>
<li>退出区(exit section)，提供的对访问权的显示释放是必须的</li>
<li>剩余区(remainder section)，释放了访问权之后，线程可以执行的其他代码</li>
</ul>
</li>
<li><p>好的临界区问题解决方案要求公平和排他性访问(exclusive access)。</p>
<ul>
<li>试图进入临界区的执行线程不应该被无限期地推迟</li>
<li>线程也应该有进展</li>
<li>如果当前没有线程在临界区，就应该允许一个等待线程进入</li>
</ul>
</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul>
<li><p>信号量是一个整型变量，它带有两个原子操作wait和signal</p>
<ul>
<li>wait还可以被称为down， P或lock</li>
<li>signal还可以称为up， V， unlock或post</li>
</ul>
</li>
<li><p>在POSIX：SEM的术语中，wait和signal操作分别被称为信号量锁定(semaphore lock)和信号量解锁(semaphore unlock)</p>
</li>
<li><p>我们可以把信号量想成一个整数值和一个等待signal操作的进程列表</p>
</li>
<li><p>wait和signal操作必须是原子的。</p>
</li>
<li><p>原子操作(atomic operation)是这样一种操作，一旦将其启动了，就要以一种逻辑上不可分割的方式来完成（也就是说，不会与任何其他相关的指令产生交错）</p>
</li>
</ul>
<h3 id="POSIX：SEM无名信号量"><a href="#POSIX：SEM无名信号量" class="headerlink" title="POSIX：SEM无名信号量"></a>POSIX：SEM无名信号量</h3><ul>
<li><p>POSIX：SEM信号量是一个sem_t类型的变量，有相关的原子操作来对它的值进行初始化，增量和减量操作</p>
</li>
<li><p>POSIX：SEM信号量扩展定义了两种类型的信号量：命名信号量和无名信号量</p>
</li>
<li><p>如果一个实现在unistd.h中定义了_POSIX_SEMAPHORES，那么这个实现就支持POSIX：SEM信号量</p>
</li>
<li><p>无名信号量和命名信号量之间的区别类似于普通管道和命名管道(FIFO)之间的区别</p>
<ul>
<li><code>#include &lt;semaphore.h&gt;</code></li>
<li><code>sem_t sem;</code></li>
</ul>
</li>
<li><p>必须在使用POSIX：SEM信号量之前对其进行初始化</p>
</li>
<li><p>sem_init函数将sem引用的无名信号量初始化为value</p>
<ul>
<li><code>int sem_init(sem_t *sem, int pshared, unsigned value);</code></li>
</ul>
</li>
<li><p>参数value不能为负</p>
</li>
<li><p>pshared等于0，说明信号量只能由初始化这个信号量的进程中的线程使用</p>
</li>
<li><p>如果pshared非0，任何可以访问sem的进程就都可以使用这个信号量</p>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，sem_init就将sem初始化</li>
<li>（没有定义返回值）</li>
</ul>
</li>
<li><p>sem_destroy函数销毁了一个参数sem引用的，已经初始化了的无名信号量</p>
<ul>
<li><code>int sem_destroy(sem_t *sem);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
<li><p>sem_post对信号量的值进行增量操作</p>
<ul>
<li><code>int sem_post(sem_t *sem);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
<li><p>sem_wait函数实现了经典的信号量wait操作</p>
<ul>
<li><code>int sem_wait(sem_t *sem);</code></li>
</ul>
</li>
<li><p>如果信号量的值为0，调用进程就一直阻塞直到一个相应的sem_post调用解除了对它的阻塞为止，或者直到它被信号中断为止</p>
</li>
<li><p>sem_trywait与sem_wait类似，只是在试图对一个为零的信号量进行减量操作时，它不阻塞，而是返回-1并将errno置为EAGAIN</p>
<ul>
<li><code>int sem_trywait(sem_t *sem);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
<li><p>sem_getvalue函数允许用户检测一个命名信号量或者无名信号量的值</p>
<ul>
<li><code>int sem_getvalue(sem_t *restrict sem, int *strict sval);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
</ul>
<h3 id="POSIX-SEM命名信号量"><a href="#POSIX-SEM命名信号量" class="headerlink" title="POSIX:SEM命名信号量"></a>POSIX:SEM命名信号量</h3><ul>
<li><p>可以用POSIX：SEM命名信号量来同步那些不共享内存的进程</p>
</li>
<li><p>命名信号量和文件一样，有一个名字，一个用户ID，一个组ID的权限</p>
</li>
<li><p>信号量的名字是一个遵守路径名构造规则的字符串</p>
</li>
<li><p>sem_open函数建立了命名信号量和sem_t值之间的连接</p>
<ul>
<li><code>sem_t *sem_open(const char *name, int oflag, ...);</code></li>
</ul>
</li>
<li><p>参数name是一个用名字来标识信号量的字符串，这个名字可以对应于文件系统中实际的对象，也可以不对应</p>
</li>
<li><p>参数oflag用来确定是创建信号量，还是仅仅由函数对其进行访问</p>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回信号量的地址</li>
<li>失败，返回SEM_FAILED，并设置errno</li>
</ul>
</li>
<li><p>sem_close函数关闭命名信号量，但是这样做并不能将信号量从系统中删除</p>
<ul>
<li><code>int sem_close(sem_t *sem);</code></li>
</ul>
</li>
<li><p>参数sem，用来指定要关闭的信号量</p>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
<li><p>sem_unlink函数与文件或FIFO的unlink函数类似，在所有的进程关闭了命名信号量之后将命名信号量从系统中删除</p>
</li>
<li><p>当进程显式地调用sem_close, _exit, exit, exec或执行从main的返回时，就会出现关闭操作</p>
<ul>
<li><code>int sem_unlink(const char *name);</code></li>
</ul>
</li>
<li><p>参数name，指向要删除的信号量的指针</p>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回0</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
</ul>
<h2 id="POSIX-IPC"><a href="#POSIX-IPC" class="headerlink" title="POSIX IPC"></a>POSIX IPC</h2><ul>
<li>共享内存，消息队列和信号量集等经典的UNIX进程间通信(IPC)机制都在POSIX：XSI扩展中进行了标准化</li>
<li>这些机制允许不相关的进程通过一种合理有效的途径来交换信息，这些机制用键(key)来标识，创建或访问相应的额实体</li>
</ul>
<h3 id="POSIX：XSI进程间通信"><a href="#POSIX：XSI进程间通信" class="headerlink" title="POSIX：XSI进程间通信"></a>POSIX：XSI进程间通信</h3><ul>
<li><p>POSIX进程间通信(interprocess communication, IPC)，是POSIX：XSI扩展的一部分，起源于UNIX System V进程间通信</p>
</li>
<li><p>IPC中包含消息队列，信号量集和共享内存，为同一个系统中的进程提供了共享信息的机制</p>
<ul>
<li>消息队列<ul>
<li>msgctl  –  控制</li>
<li>msgget  –  创建或访问</li>
<li>msgrcv  –  接收消息</li>
<li>msgsnd  –  发送消息</li>
</ul>
</li>
<li>信号量<ul>
<li>semctl  –  控制</li>
<li>semget  –  创建或访问</li>
<li>semop   –  执行操作（等待或发送）</li>
</ul>
</li>
<li>共享内存<ul>
<li>shmat   –  将内存附加到进程中去</li>
<li>shmctl  –  控制</li>
<li>shmdt   –  将内存从进程中分离开</li>
<li>shmget  –  创建并初始化或访问</li>
</ul>
</li>
</ul>
</li>
<li><p>POSIX：XSI用一个唯一的整数来标识每个IPC对象，这个整数大于或等于零，从对象的获取函数中返回这个整数的方式与open函数返回表示文件描述符的整数的方式类似</p>
</li>
<li><p>创建或访问一个IPC对象时，必须指定一个键来说明要创建或访问的特定对象。</p>
</li>
<li><p>有三种方式来选择一个键</p>
<ul>
<li>由系统来选择一个键(IPC_PRIVATE)</li>
<li>直接选一个键</li>
<li>通过调用ftok请求系统从指定的路径中生成一个键</li>
</ul>
</li>
<li><p>ftok函数允许独立的进程根据一个已知的路径名导出相同的键。</p>
<ul>
<li><code>#include &lt;sys/ipc.h&gt;</code></li>
<li><code>key_t ftok(const char *path, int id);</code></li>
</ul>
</li>
<li><p>对应于路径名的文件必须存在，并且必须能够被那些想访问IPC对象的进程访问</p>
</li>
<li><p>path和id的组合唯一地标识了IPC对象。</p>
</li>
<li><p>参数id允许几个相同类型的IPC对象从一个路径名中生成键值</p>
</li>
<li><p>返回值：</p>
<ul>
<li>成功，返回一个键</li>
<li>失败，返回-1，并设置errno</li>
</ul>
</li>
<li><p>从命令解释程序中访问POSIX：XSI IPC资源</p>
<ul>
<li>命令解释程序和实用程序的POSIX：XSI扩展定义了检查和删除IPC资源的命令解释程序命令，这时POSIX：SEM信号量所没有的一项很方便的特性</li>
<li>ipcs命令，显示了与POSIX：XSI进程间通信资源有关的信息<ul>
<li><code>ipcs [-qms] [-a | -bcopt]</code></li>
</ul>
</li>
<li>小写的-q, -s, -m选项用对象ID分别指定要删除的消息队列，信号量集或共享内存段</li>
<li>大写的选项使用初始的创建键(creation key)</li>
</ul>
</li>
</ul>
<h3 id="POSIX-XSI信号量集"><a href="#POSIX-XSI信号量集" class="headerlink" title="POSIX:XSI信号量集"></a>POSIX:XSI信号量集</h3><ul>
<li><p>POSIX：XSI信号量由一个信号量元素(semaphore element)数组组成</p>
</li>
<li><p>信号量元素与Dijsktra提出的标准的整数信号量类似，但两者并不完全相同。</p>
</li>
<li><p>进程可以在单个调用中对整个集合执行操作</p>
</li>
<li><p>将POSIX：XSI信号量称为信号量集(semaphore set)，与POSIX：SEM信号量区分开</p>
</li>
<li><p>每个信号量元素中至少包含下列信息</p>
<ul>
<li>一个表示信号量元素值的非负整数(semval)</li>
<li>最后一个操纵信号量元素的进程的进程ID(sempid)</li>
<li>等待信号量元素值增加的进程的数量(semncnt)</li>
<li>等待信号量元素值变为零的进程的数量(semzcnt)</li>
</ul>
</li>
<li><p>信号量主要的数据结构是semid_ds，它是在sys&#x2F;sem.h中定义的</p>
</li>
<li><p>每个信号量元素都有两个与之相关的队列：</p>
<ul>
<li>一个等待信号量值变为0的进程队列</li>
<li>一个等待信号量值增加的进程对量</li>
</ul>
</li>
<li><p>信号量元素操作允许进程阻塞，知道信号量元素值为0或者它增加到一个大于零的特定值为止</p>
</li>
<li><p>信号量集的创建</p>
<ul>
<li>semget</li>
</ul>
</li>
</ul>
<p>(393) 暂时不看</p>
<h2 id="面向连接的通信"><a href="#面向连接的通信" class="headerlink" title="面向连接的通信"></a>面向连接的通信</h2><ul>
<li><p>服务，是指由服务器代表客户机执行的动作</p>
</li>
<li><p>客户机-服务器模型出现在计算机系统的很多层面</p>
</li>
<li><p>例如：</p>
<ul>
<li>在面向对象的程序中，一个对象去调用另一个对象的方法，就被称为对象的客户(client of the object)</li>
<li>在系统层，管理诸如打印机之类的资源的守护进程就是系统用户（客户）的服务器</li>
<li>在因特网中，浏览器是向Web服务器请求资源的客户机进程</li>
</ul>
</li>
<li><p>客户机-服务器模型的关键要素</p>
<ul>
<li>由客户，而不是服务提供者，发起动作</li>
<li>服务器被动地等待来自客户机的请求</li>
<li>客户机和服务器通过一条通信信道连接起来，它们通过通信端点来访问这个通信信道</li>
</ul>
</li>
<li><p>面对不可预料的客户机行为时，服务器要能够健全地处理多个同时发出的客户机请求。</p>
</li>
<li><p>在客户机-服务器交互动作的过程中，捕捉错误并采取适当行动的重要性</p>
</li>
<li><p>服务器要长时间的运行，并且必须能够释放分配给独立的客户机请求的所有资源</p>
</li>
</ul>
<h3 id="通信信道"><a href="#通信信道" class="headerlink" title="通信信道"></a>通信信道</h3><ul>
<li><p>通信信道(communication channel)，是信息的逻辑通道，通信的参与者通过通信端点对其进行访问</p>
</li>
<li><p>信道可以是共享的或私有的，单工的或双工的。双工信道可以是对称的或不对称的</p>
</li>
<li><p>信道和底层的物理管道有所区别，物理管道可以支持多种类型的信道</p>
</li>
<li><p>在面向对象的编程中，客户机通过调用一个方法来和对象进行通信</p>
</li>
<li><p>命名管道有一个相关的路径名，执行命令<code>mkfifo</code>时，系统会在文件系统目录中创建一个对应于这个路径名的条目</p>
</li>
<li><p>文件系统提供了底层的管道。进程通过调用<code>open</code>来创建通信端点，并通过文件描述符来访问这些端点</p>
</li>
<li><p>命名管道可用于短的用户请求</p>
</li>
<li><p>当请求很长或服务器必须做出响应时，命名管道会面临一些困难。</p>
<ul>
<li>如果服务器只是简单地为响应打开另一个命名管道，就不能保证各个客户机一定能读到发送给它们的相应</li>
<li>如果服务器为每个相应打开一个唯一的管道，那么客户机和服务器就必须事先对命名约定进行协商</li>
<li>另外，命名管道具有持久性，除非管道所有者显示地将其删除，否则它们始终存在。当交互各方不再存在时，一个通用的通信机制应该释放它的资源</li>
</ul>
</li>
<li><p>TCP(Transmission Control Protocol， 传输控制协议)， 是面向连接的协议，它在可能并不可靠的通道上，为通信提供可靠的信道</p>
</li>
<li><p>面向连接(Connectionoriented)，是指起始端（客户机）先建立一个与目的端（服务器）的连接，之后双方就都可以发送和接收消息了</p>
</li>
<li><p>在起始端和目的端之间，TCP通过一种被称为三次握手(three-way handshake)的消息交换方式建立连接</p>
</li>
<li><p>TCP通过接收端确认和重传来实现可靠通信。TCP还提供流量控制，这样发送端就不会用大量的信息将接收端淹没了</p>
</li>
<li><p>幸运的是，操作系统的网络子系统实现了TCP，所以协议交换的细节在<strong>进程级是不可见的</strong></p>
</li>
<li><p>如果网络出现了故障，进程会在通信端点上检测出错误。</p>
</li>
<li><p>由于对服务的请求中包含可见的通信过程，从这个意义上讲，无连接和面向连接协议都是低层次的。</p>
</li>
<li><p>程序员要明确地知道服务器的位置，而且必须显示地命名要访问的特定的服务器</p>
</li>
<li><p>在网络环境中命名服务器和服务是个很难的问题。</p>
</li>
<li><p>标识服务器的一种显而易见的办法就是利用它的进程ID和主机ID。</p>
</li>
<li><p>但是，操作系统一般是根据进程的创建时间按时间顺序分配进程ID的，因此客户机不可能事先知道主机上一个特定服务器进程的进程号</p>
</li>
<li><p>指定一个服务最常用的方法是，使用主机地址(IP地址)和一个被称作端口号的整数。</p>
</li>
<li><p>采用这种方式时，服务器要监视一个或多个通信信道，这些通信信道与事先为特定服务指定的端口号相关联</p>
</li>
<li><p>客户机为通信显式地指定一个主机地址和一个端口号（有相关的主机名访问IP地址的库函数调用）</p>
</li>
<li><p>本章的重点是与由主机地址和端口号指定的服务器进行的面向连接的通信，通信采用了TCP&#x2F;IP和流套接字</p>
</li>
</ul>
<h3 id="面向连接的服务器策略"><a href="#面向连接的服务器策略" class="headerlink" title="面向连接的服务器策略"></a>面向连接的服务器策略</h3><ul>
<li><p>一旦服务器收到一个请求，它就可以用很多不同的策略来处理这个请求</p>
</li>
<li><p>串行服务器(serial server)，要在完全地处理好一个请求之后才能接受其他的请求</p>
</li>
<li><p>串行服务器一次只处理一个请求，因此处理像文件传输这样长寿命请求的繁忙的服务器不能采用串行服务器策略</p>
</li>
<li><p>什么是僵子进程？</p>
<ul>
<li>僵进程(zombie)，是一种已经执行完毕但没有被其父进程等待的进程</li>
<li>僵进程没有释放它所有的资源，所以系统最终会耗尽一些关键的资源，例如：内存或进程ID</li>
</ul>
</li>
<li><p>线程化服务器(threaded server)，服务器在它自己的进程空间创建一个线程，而不是创建子进程来处理客户机请求。</p>
</li>
</ul>
<h3 id="通用因特网通信接口"><a href="#通用因特网通信接口" class="headerlink" title="通用因特网通信接口"></a>通用因特网通信接口</h3><ul>
<li><p>UICI(Universal Internet Communication Interface，通用因特网通信接口)库，为UNIX中的面向连接通信提供了简化接口</p>
</li>
<li><p>UICI，不是任何UNIX标准的一部分。</p>
</li>
<li><p>接口是由作者设计的，在隐藏了底层网络协议细节的同时，对网络通信的实质进行了抽象。</p>
</li>
<li><p>UICI是公开的，使用UICI的程序中应该包含uici.h头文件</p>
</li>
<li><p>使用套接字时，服务器创建一个通信端点(一个套接字)并将其与一个知名端口相关联(将套接字绑定到端口上)</p>
</li>
<li><p>在等待客户机请求之前，服务器要将套接字设置为被动的，这样套接字就可以接收客户机请求了(将套接字设置为监听状态)</p>
</li>
<li><p>一旦在这个端点检测到客户机连接请求，服务器就为此客户机的私有双工通信创建一个新的通信端点</p>
</li>
<li><p>客户机和服务器通过文件描述符进行读和写操作来实现对通信端点的访问。</p>
</li>
<li><p>当通信完成时，两端都关闭文件描述符，释放与此通信信道相关的资源</p>
</li>
<li><p>客户机-服务器通信中使用的UICI调用的典型顺序</p>
<ul>
<li>服务器创建一个通信端点(u_open)并等待客户机发送请求(u_accept)</li>
<li>u_accept函数返回一个私有通信文件描述符</li>
<li>客户机为服务器的通信创建一个通信端点(u_connect)</li>
</ul>
</li>
<li><p>一旦它们之间建立了连接，客户机和服务器就可以在网络上用普通的read和write函数进行通信了</p>
</li>
<li><p>总之，UICI服务器按如下步骤工作：</p>
<ul>
<li>打开一个知名的监听端口(u_open)。u_open函数返回一个监听文件描述符(listening file descriptor)</li>
<li>在监听文件描述符上等待连接请求(u_accept)。u_accept函数一直阻塞，直到有客户机请求连接为止，然后它返回一个通信文件描述符(communication file descriptor)，并将这个文件描述符用作私有双工客户机-服务器通信的句柄</li>
<li>通过通信文件描述符(read和write)与客户机进行通信</li>
<li>关闭通信文件描述符(close)</li>
</ul>
</li>
<li><p>UICI客户机按如下步骤工作：</p>
<ul>
<li>连接到一个指定的主机和端口(u_connect)。连接请求返回与服务器进行双工通信时使用的通信文件描述符</li>
<li>通过通信文件描述符(read和write)与服务器通信</li>
<li>关闭通信文件描述符(close)</li>
</ul>
</li>
</ul>
<h3 id="UICI的套接字实现"><a href="#UICI的套接字实现" class="headerlink" title="UICI的套接字实现"></a>UICI的套接字实现</h3><ul>
<li><p>通过使用带有TCP的套接字实现UICI API的概况</p>
<ul>
<li>socket  –  创建通信端点</li>
<li>bind    –  将端点与指定的端口相关联</li>
<li>listen  –  将端点设置为被动的监听者</li>
<li>accept  –  接收来自客户机的连接请求</li>
<li>socket  –  创建通信端点</li>
<li>connect –  请求向服务器建立连接</li>
</ul>
</li>
<li><p>服务器创建一个句柄(socket)，将它与网络上的一个物理位置相关联(bind)，然后设置挂起请求的队列长度(listen)</p>
</li>
<li><p>UICI的u_open函数中封装了这三个函数，它返回一个对应于被动或监听套接字的文件描述符，然后，服务器监听客户机的请求(accept)</p>
</li>
<li><p>客户机也创建一个句柄(socket)，并将这个句柄与服务器的网络位置相关联(connect)</p>
</li>
<li><p>UICI的u_connect函数封装了这两个函数。</p>
</li>
<li><p>服务器和客户机句柄是文件描述符，有时也将它们称作通信端点(communication endpoint)或传输端点(transmission endpoint)</p>
</li>
<li><p>一旦客户机和服务器建立了连接，它们就可以通过普通的read和write调用进行通信了</p>
</li>
<li><p>socket函数，创建了一个通信端点并返回一个文件描述符</p>
<ul>
<li><code>#include &lt;sys/socket.h&gt;</code></li>
<li><code>int socket(int domain, int type, int protocol);</code></li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><code>domain</code>  –  选择所用的协议族，AF_INET，代表IPv4</li>
<li><code>type</code>    –  <ul>
<li>SOCK_STREAM, 表示有序，可靠，双工，面向连接的字节流，通常由TCP实现</li>
<li>SOCK_DGRAM， 通过定长的，不可靠消息提供无连接通信，通常由UDP实现</li>
</ul>
</li>
<li><code>protocol</code>– 指定特定的通信type使用的协议。在大多数实现中，每个type参数只能使用一种协议。例如，SOCK_STREAM使用TCP， SOCK_DGRAM使用UDP</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功  –  返回一个对应于套接字文件描述符的非负整数</li>
<li>失败  –  返回-1，并设置errno</li>
</ul>
</li>
<li><p>使用面向连接的协议为因特网通信创建一个套接字通信端点</p>
<ul>
<li><code>int sock;</code></li>
<li><code>if ((sock = socket(AF_INET, SOCK_STREAM, 0) == -1))</code><ul>
<li><code>perror(&quot;Failed to create socket!\n);</code></li>
</ul>
</li>
</ul>
</li>
<li><p>bind函数，将套接字通信端点的句柄与一个特定的逻辑网络连接关联起来。因特网域协议用端口号来指定逻辑连接</p>
<ul>
<li><code>#include &lt;sys/socket.h&gt;</code></li>
<li><code>int bind(int socket, const struct sockaddr *address, socklen_t address_len);</code></li>
</ul>
</li>
<li><p>参数：</p>
<ul>
<li><code>socket</code>      –  前一个socket函数调用返回的文件描述符</li>
<li><code>*address</code>    –  该结构中包含一个协议族名和与协议相关的信息</li>
<li><code>address_len</code> –  是<code>*address</code>结构中的字节数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功  –  返回0</li>
<li>失败  –  返回-1，并设置errno</li>
</ul>
</li>
<li><p>因特网域用<code>struct sockaddr_in</code>代替<code>struct sockaddr</code></p>
</li>
<li><p>POSIX规定应用程序在和套接字函数一同使用时，要将<code>struct sockaddr_in</code>强制转换成<code>struct sockaddr</code></p>
</li>
<li><p>在<code>netinet/in.h</code>中定义的<code>struct sockaddr_in</code>结构至少包含下列成员，这些成员都是用网络字节顺序来表示的</p>
<ul>
<li><code>sa_family_t sin_family;  /* AF_NET */</code></li>
<li><code>in_port_t   sin_port;    /* port number */</code></li>
<li><code>struct in_addr sin_addr; /* IP address */</code></li>
</ul>
</li>
<li><p>对因特网通信来说，sin_family的值为AF_INET， sin_port指的是端口号</p>
</li>
<li><p>struct in_addr结构有一个被称为s_addr的成员，s_addr成员是in_addr_t类型，装载了因特网地址的数字值</p>
</li>
<li><p>服务器可以将sin_addr.s_addr字段设置为INADDR_ANY，表示套接字应该接收任何一个主机网络接口上的连接请求</p>
</li>
<li><p>客户机将sin_addr.s_addr字段设置为服务器主机的IP地址</p>
</li>
<li><p>将端口8652与一个对应于打开的文件描述符sock的套接字相关联</p>
<figure class="highlight plaintext"><figcaption><span>sockaddr_in server;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int sock;</span><br><span class="line">server.sin_family = AF_INET;</span><br><span class="line">server.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">server.sin_port = htons((short)8652);</span><br><span class="line">if (bind(sock, (struct sockaddr *)&amp;server, sizeof(server)) == -1)</span><br><span class="line"> perror(&quot;Failed to bind the socket to port !\n);`</span><br></pre></td></tr></table></figure></li>
<li><p><code>htonl</code>和<code>htons</code>将INADDR_ANY和8652的字节按照网络字节顺序重新排序</p>
<ul>
<li><code>htonl</code>函数对long（长整数）重新排序，将其从主机字节顺序转换为网络字节顺序</li>
<li><code>htons</code>函数将short（短整数）重新排序为网络字节顺序</li>
</ul>
</li>
<li><p>它们的镜像函数<code>ntohl</code>和<code>ntohs</code>对整数进行重新排序，将整数从网络字节顺序转到主机字节顺序</p>
</li>
<li><p>大尾数计算机先存储最高有效字节(most significant byte), 小尾数计算机先存储最低有效字节(least significant type)  –  大端，小端</p>
</li>
<li><p>当使用不同字节存放次序的计算机进行通信时，整数的字节顺序会带来一个问题， 因为不同的计算机会对端口号这样的协议信息产生错误的理解</p>
</li>
<li><p>不幸的是，这两种字节存放次序都很常见</p>
<ul>
<li>SPARC结构(由Sun Microsystems公司开发)采用大数在先结构</li>
<li>而Intel结构采用小数在先结构</li>
</ul>
</li>
<li><p>因特网协议规定网络字节顺序(network byte order)，采用大数在先结构，POSIX要求某些套接字地址字段按网络字节顺序给出</p>
</li>
<li><p>socket函数创建了一个通信端点，而bind函数将这个通信端点与一个特定的网络地址相关联。</p>
</li>
<li><p>此时，客户机可以用套接字与服务器进行连接。要用套接字来接收连接请求，应用程序必须通过调用listen函数将套接字设置成被动状态</p>
</li>
<li><p>listen函数使底层的系统网络基础结构分配队列以承载那些待处理的连接请求</p>
<ul>
<li><code>#include &lt;sys/socket.h&gt;</code></li>
<li><code>int listen(int socket, int backlog);</code></li>
</ul>
</li>
<li><p>当客户机发出连接请求时，客户机和服务器网络子系统交换信息（TCP的三次握手）以建立连接</p>
</li>
<li><p>因为服务器可能正忙，所以主机的网络子系统会将客户机的连接请求排队，直到服务器准备好接收这些请求为止</p>
</li>
<li><p>如果服务器主机拒绝了客户机的连接请求，客户机会收到一个ECONNREFUSED错误。</p>
</li>
<li><p>参数：</p>
<ul>
<li>socket值，就是上一次socket调用返回的描述符，</li>
<li>backlog，给出了允许排队等待的客户机请求数目的最大值</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功  –  返回0</li>
<li>失败  –  返回-1，并设置errno</li>
</ul>
</li>
<li><p>建立了一个被动的监听套接字(socket, bind, listen)之后，服务器通过调用accept函数来处理到来的客户机连接</p>
<ul>
<li><code>#include &lt;sys/socket.h&gt;</code></li>
<li><code>int accept(int socket, struct sockaddr *restrict address, socklen_t *restrict address_len);</code></li>
</ul>
</li>
<li><p>accept的参数与bind的参数类似，</p>
<ul>
<li>但是，bind函数要求在调用之前将<code>*address</code>字段填好，这样它才能知道服务器会在哪个端口和接口上接收连接请求</li>
<li>与之相反，accept函数用<code>*address</code>字段来返回与建立连接的客户机有关的信息。尤其要支出的是，<code>struct sockaddr_in</code>结构的<code>sin_addr</code>成员中包含一个<code>s_addr</code>成员，这个成员中装载了客户机的因特网地址</li>
<li>accept函数的<code>*address_len</code>参数的值指定了address指向的缓冲区的长度。在调用之前，要在这个参数中填上<code>*address</code>结构的长度，调用之后，<code>*address_len</code>中函数的是由accept调用实际填写的缓冲区字节数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功  –  返回对应于已接收套接字的非负文件描述符</li>
<li>失败  –  返回-1，并设置errno</li>
</ul>
</li>
<li><p>客户机调用socket来建立一个传输端点，然后用connect来建立远程服务器知名端口的连接</p>
<ul>
<li><code>#include &lt;sys/socket.h&gt;</code></li>
<li><code>int connect(int socket, const struct sockaddr *address, socklen_t address_len);</code></li>
</ul>
</li>
<li><p>connect像bind一样填写struct sockaddr结构</p>
</li>
<li><p>返回值：</p>
<ul>
<li>成功  –  返回0</li>
<li>失败  –  返回-1，并设置errno</li>
</ul>
</li>
</ul>
<h3 id="主机名和IP地址"><a href="#主机名和IP地址" class="headerlink" title="主机名和IP地址"></a>主机名和IP地址</h3><ul>
<li><p>对大多数网络库调用来说，主机名都必须映射成数字网络地址</p>
</li>
<li><p>作为系统配置的一部分，系统管理员要定义将名字翻译成网络地址的机制。这个机制可能包括本地表查询，如果必要的话，还可以对域名服务器进行查询。</p>
</li>
<li><p>域名服务(Domain Name Service, DNS)，是整合因特网命名的粘合剂</p>
</li>
<li><p>一般来说，主机可以由它的名字或者地址来指定。程序中的主机名通常用ASCII字符串来标识</p>
</li>
<li><p>IPv4地址可以用二进制格式（采用与struct in_addr的s_addr字段一样的网络字节顺序）或人类易读的格式表示，这种易读的格式被称作点分十进制表示法(dotted-decimal notation)或因特网地址点分表示法(Internet address dot notation)</p>
</li>
<li><p>地址的点分形式是一个字符串，这个字符串的值是以小数点分隔，用十进制表示的四个字节</p>
</li>
<li><p>IPv4地址的二进制表示有4字节长。因此4字节地址没有为未来的因特网扩展提供足够的空间，所以这个协议的新版本IPv6，采用了16字节的地址结构</p>
</li>
<li><p>inet_addr和inet_ntoa函数在点分十进制表示法和struct sockaddr_in的struct in_addr字段中使用二进制网络字节顺序格式之间进行转换</p>
</li>
<li><p>inet_addr函数将采用点分十进制表示法的地址转换成采用网络字节顺序的二进制地址。得到的值可以直接存储在struct sockaddr_in的sin_addr.s_addr字段中</p>
<ul>
<li><code>#include &lt;arpa/inet.h&gt;</code></li>
<li><code>in_addr_t inet_addr(const char *cp);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功  –  返回因特网地址</li>
<li>失败  –  返回-1</li>
</ul>
</li>
<li><p>inet_ntoa函数，接收一个struct in_addr结构，这个结构中包含一个采用网络字节顺序的二进制地址，并返回相应的用点分十进制表示法表示的字符串</p>
<ul>
<li><code>#include &lt;arpa/inet.h&gt;</code></li>
<li><code>char *inet_ntoa(const struct in_addr in);</code></li>
</ul>
</li>
<li><p>二进制地址可以从<code>struct sockaddr_in</code>结构的<code>sin_addr</code>字段中得到</p>
</li>
<li><p>返回的字符串是静态分配的，因此在线程化应用程序中使用inet_ntoa可能不安全</p>
</li>
<li><p>返回值：</p>
<ul>
<li>返回一个指向网络地址的指针，这个网络地址是用因特网标准的点分表示法表示的</li>
</ul>
</li>
<li><p>将主机名转换成二进制地址的传统方法是调用gethostbyname函数</p>
<ul>
<li><code>#include &lt;netdb.h&gt;</code></li>
<li><code>struct hostent *gethostbyname(const char *name);</code></li>
</ul>
</li>
<li><p>函数将主机名字符串作为参数，并返回一个指向struct hostent结构的指针，该结构中包含相应主机的名字和地址信息</p>
</li>
<li><p>返回值：</p>
<ul>
<li>成功  –  返回一个指向struct hostent指针</li>
<li>失败  –  返回一个NULL指针，并设置errno</li>
</ul>
</li>
<li><p>从地址到名字的转换可以用gethostbyaddr实现，</p>
<ul>
<li><code>#include &lt;netdb.h&gt;</code></li>
<li><code>struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type);</code></li>
</ul>
</li>
<li><p>对IPv4来说，type应该是AF_INET，len的值应该是4字节，参数addr应该指向一个struct in_addr结构</p>
</li>
<li><p>返回值：</p>
<ul>
<li>成功  –  返回一个指向struct hostent结构的指针</li>
<li>失败  –  返回一个NULL指针，并设置errno</li>
</ul>
</li>
<li><p>在主机名和地址之间进行转换的第二种方法是使用<code>getnameinfo</code>和<code>getaddrinfo</code>，它们在2001年首次称为被认可的POSIX标准</p>
<ul>
<li><code>#include &lt;sys/socket.h&gt;</code></li>
<li><code>#include &lt;netdb.h&gt;</code></li>
<li><code>void freeaddrinfo(struct addrinfo *ai);</code></li>
<li><code>int getaddrinfo(const char *restrict nodename, const char *restrict servname, const struct addrinfo *restrict hints, struct addrinfo **restrict res);</code></li>
<li><code>int getnameinfo(const struct sockaddr *restrict sa, socklen_t salen, char *restrict node, socklen_t nodelen, char *restrict service, socklen_t servicelen, unsigned flags);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功  –  返回0</li>
<li>失败  –  返回一个错误码</li>
</ul>
</li>
<li><p>使用uname来获取主机名</p>
<ul>
<li><code>#include &lt;sys/utsname.h&gt;</code></li>
<li><code>int uname(struct utsname *name);</code></li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功  –  返回一个非负值</li>
<li>失败  –  返回-1，并设置errno</li>
</ul>
</li>
<li><p>在<code>sys/utsname.h</code>中定义的struct ustname结构至少包含下列成员</p>
<ul>
<li><code>char sysname[];  /* 本OS实现的名字 */</code></li>
<li><code>char nodenamep[];  /* 在通信网络中本节点的名字 */</code></li>
<li><code>char release[];  /* 本实现当前发布的级别 */</code></li>
<li><code>char version[];  /* 本次发布的当前版本的级别 */</code></li>
<li><code>char machine[];  /* 系统正在运行的硬件类型名 */</code></li>
</ul>
</li>
</ul>
<h2 id="WWW重定向-497"><a href="#WWW重定向-497" class="headerlink" title="WWW重定向 (497)"></a>WWW重定向 (497)</h2><ul>
<li>万维网采用客户机-服务器体系结构，这种结构基于一种资源表示方案(URI)，一种通信协议(HTTP)和一种文档格式(HTML)，三者共同作用使用户可以很方便地进行信息的访问和交互</li>
</ul>
<h3 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h3><ul>
<li>万维网，是客户机和服务器的集合，这些客户机和服务器商定好以特定的格式来进行交互和信息交换</li>
</ul>
<h3 id="统一资源定位符"><a href="#统一资源定位符" class="headerlink" title="统一资源定位符"></a>统一资源定位符</h3><ul>
<li><p>统一资源定位符(Universal Resource Locator, URL)的格式为 – 模式:位置(scheme : location)</p>
<ul>
<li>模式(scheme)，指的是访问资源的方法，例如HTTP</li>
<li>位置(location)，则说明了资源放在哪里</li>
</ul>
</li>
<li><p>当用户通过浏览器打开一个URL时，浏览器解析服务器的主机名并建立一个到那个服务器主机上指定端口的TCP连接</p>
</li>
<li><p>然后，浏览器通过下一节中描述的HTTP协议向服务器发送一个资源请求，请求URL的绝对路径指定的资源</p>
</li>
</ul>
<h3 id="HTTP入门"><a href="#HTTP入门" class="headerlink" title="HTTP入门"></a>HTTP入门</h3><ul>
<li>在客户端和Web服务器上都有一个被称为超文本传输协议(HyperText Transfer Protocol, HTTP)的特定的规则集合。</li>
<li>这个规则的集合也可以称为协议(protocol)，客户机和服务器通过这个协议来交换信息</li>
</ul>
<h3 id="Web通信模式"><a href="#Web通信模式" class="headerlink" title="Web通信模式"></a>Web通信模式</h3><ul>
<li><p>根据HTTP的术语，客户(client)，是建立连接的应用程序，服务器(server)，是接受连接并做出相应的应用程序。</p>
</li>
<li><p>用户代理(user agent)，是一个发起服务请求的客户。</p>
</li>
<li><p>根据这些术语，浏览器就既是客户又是用户代理</p>
</li>
<li><p>起源服务器(origin server)，是一个拥有资源的服务器</p>
</li>
<li><p>隧道(tunnel)，是一个充当盲中继(blind relay)的中间体，隧道不解析HTTP，而是将它传送给服务器。</p>
</li>
<li><p>隧道从客户端接受一个HTTP连接并建立一个到服务器的连接。在这种情况下，尽管它既不是用户代理也不是起源服务器，但根据HTTP的定义，隧道即充当客户端，又充当服务器</p>
</li>
<li><p>隧道将信息从客户端传递到服务器。当服务器响应时，隧道就将响应传送到客户端。</p>
</li>
<li><p>代理(proxy)，是一种中间体，它在客户端和服务器之间，代表它的客户发起请求</p>
</li>
<li><p>客户通过一种特殊形式的GET向代理发出请求，而且代理必须解析HTTP。</p>
</li>
<li><p>与隧道一样，代理也是即充当客户端又充当服务器。但是，代理存在的时间通常很长，而且通常会充当多个客户端的中间体</p>
</li>
<li><p>透明代理(transparent proxy)，除了在代理的标识和鉴权方面所需的修改之外，不对请求或应答进行修改</p>
</li>
<li><p>非透明代理(nontransparent proxy)，可能会代表它们的客户端执行很多其他类型的服务，例如注释，匿名过滤，内容过滤，审查，媒体转换等</p>
</li>
<li><p>代理可以保存与它们的客户有关的统计信息和其他信息</p>
</li>
<li><p>Google这样的搜索引擎是另外一种类型的代理，它缓存了与页面内容和指向页面的URL有关的信息。用户可以通过关键词或短语来访问缓存的信息</p>
</li>
<li><p>代理代表客户执行的最重要的服务就是高速缓存。</p>
</li>
<li><p>高速缓存(cache)，是响应信息在本地的存储。浏览器通常会将近期的响应消息缓存在磁盘上。当用户打开一个URL时，浏览器首先查看在磁盘上能够找到资源，只有当它在本地找不到对象时，才会启动一个网络请求</p>
</li>
<li><p>代理高速缓存(proxy cache)，将它读取的资源存储起来，以便更有效地为将来申请这些资源的请求服务</p>
</li>
<li><p>通常，代理高速缓存都安装在局域网的网管上。本地网络中的客户通过这个代理来转发它所有的请求。</p>
</li>
<li><p>可以用代理高速缓存的本地存储中的对象来响应来自不同用户的请求。如果已经有人请求过这个对象，而且代理缓存了这个对象，那么对当前请求的响应就要快得多了</p>
</li>
<li><p>可以将代理看成客户端的中间体，那么，网关(gateway)，则是服务端的机制。</p>
</li>
<li><p>网关可以接收请求，就像它是起源服务器一样。网关可以位于局域网的边界路由器上，也可以位于保护内部网的防火墙之外。</p>
</li>
<li><p>网关可以提供很多服务，例如安全，翻译和负载平衡。网关可以作为某个组织的一群Web服务器的公共接口，也可以作为位于防火墙之内的Web服务器的前端门户使用</p>
</li>
<li><p>网关和隧道有什么不同？</p>
<ul>
<li>隧道，是一种管道，它将信息从一个点传到另一个点，不对信息进行修改。</li>
<li>网关，则充当资源的前端，可能还会充当一群服务器的前端</li>
</ul>
</li>
</ul>
<h3 id="各种服务器的常见的缺陷和错误"><a href="#各种服务器的常见的缺陷和错误" class="headerlink" title="各种服务器的常见的缺陷和错误"></a>各种服务器的常见的缺陷和错误</h3><ul>
<li><p>线程和时序错误</p>
</li>
<li><p>这类程序的大部分时序错误都是由于对TCP的不正确理解造成的。</p>
</li>
<li><p>就算提供了一个足够大的缓冲区，也不要假定在单个读操作中就能读入整个请求。TCP提供了对一个没有分组和消息便捷的字节流的抽象。</p>
</li>
<li><p>未捕捉到的错误和错误的退出</p>
</li>
<li><p>你的服务器对错误会有什么样的响应，服务器在什么时候应该退出，如果没有认真或正确解决这些问题，运行的程序对程序可能就是一个很大的威胁，尤其是当以很高的特权级别运行时</p>
</li>
<li><p>服务器通常应该一直运行下去，直到系统重启为止，因此要考虑退出的策略。不要从除了main函数之外任何其他的函数中退出。</p>
</li>
<li><p>总的来说，其他的函数或者应该对错误进行处理，或者应该向调用程序返回一个错误码。客户不应当会造成服务器的退出。只有由于资源（内存，描述符等）缺乏出现了无法恢复的错误而危及到未来的正确执行时，服务器才能退出</p>
</li>
<li><p>即使库函数返回了一个错误，C程序仍然不加理会地继续执行，就有可能在后继的执行中造成一个致命的，实际上无法定位的错误。</p>
</li>
<li><p>要避免这类问题，就要对每一个能够返回错误的库函数的返回值进行检查</p>
</li>
<li><p>释放资源总是很重要的。在服务器中，这是非常关键的。当客户端的通信结束时，要关闭所有相应的文件描述符。如果函数分配了缓冲区，就一定要在某个地方将其释放掉。查看那些资源是否在函数执行的每条路径上都被释放了，要特别注意出现错误时会发生什么情况</p>
</li>
<li><p>确定函数什么时候应该输出一条错误消息，什么时候应该返回一个错误码。用条件编译将通知性的消息放在源代码中，但不要让它们出现在发布的应用程序中</p>
</li>
<li><p><strong>记住：</strong></p>
<ul>
<li>在现实世界里，这些消息都应该有地方可去，可能是到一些不走运的控制台日志里去</li>
<li>将消息写到标准错误而不是标准输出中去</li>
<li>通常，标准错误会被重定向到一个控制台日志中去。同样，系统不对标准错误进行缓冲，因此出现错误时，消息就会显示出来</li>
</ul>
</li>
<li><p>编程错误和不好的风格</p>
</li>
<li><p>要避免大的或不相容的缩进。也要避免大的循环，可以使用函数来降低复杂性</p>
</li>
<li><p>不要做重复的工作。如果可能，就使用库函数，此外，还要合并通用的代码</p>
</li>
<li><p>随时都要释放分配了的资源，例如缓冲区，但是不要多次释放它们，因为这样会造成随后的资源分配失败</p>
</li>
</ul>
<h2 id="第22章-服务器性能-572"><a href="#第22章-服务器性能-572" class="headerlink" title="第22章 服务器性能(572)"></a>第22章 服务器性能(572)</h2><ul>
<li><p>三种客户机服务器通信模型</p>
<ul>
<li>串行服务器</li>
<li>父-服务器</li>
<li>线程化服务器</li>
</ul>
</li>
<li><p>因为父-服务器策略对每个客户端请求都创建一个新的子进程，有时也被称为每个请求一个进程策略(process-per-request)</p>
</li>
<li><p>类似的，线程化服务器策略对每个请求创建一个单独的线程，所以也经常被称为每个请求一个线程策略(thread-per-request)</p>
</li>
<li><p>一种变通的策略是在接收请求之前，先创建一些进程或线程，构建一个工作者池(worker pool)</p>
</li>
<li><p>工作者们都在同步点阻塞，等待请求到达。每个到达的请求激活一个线程或进程，其余的则继续阻塞。</p>
</li>
<li><p>工作者池消除了创建线程或进程的开销，但是带来了额外的同步开销。同时，性能和池的大小密切相关。</p>
</li>
<li><p>灵活的实现可能会动态调整池中的线程或进程数量来维持系统的平衡</p>
</li>
<li><p>缓冲区池的方法能用一个子进程的池来实现吗？</p>
<ul>
<li>通信文件描述符是小的整型数值，用来表示文件描述符表中的一个位置。</li>
<li>这个数值只在同一个进程内的上下文之间有意义，所以用子进程来实现缓冲区池是不可能的</li>
</ul>
</li>
<li><p>在每个请求一个线程(thread-per-request)的体系结构中，主线程阻塞在accept调用上，并为每个请求创建一个线程。</p>
</li>
<li><p>而在工作者池的方法中，池的大小限制了竞争资源的并发线程数。每个请求一个线程的设计，如果没有仔细的监视，就容易发生资源过度分配</p>
</li>
<li><p>何为每个请求一个进程(process-per-request)策略？如何实现它？</p>
<ul>
<li>每个请求一个进程的策略类似每个请求一个线程的策略。</li>
<li>服务器接收请求，创建子进程（而不是创建新线程）来处理它。</li>
<li>因此主进程在得到了通信文件描述符之后才去创建子进程，子进程继承了其文件描述符表，所以该通信文件描述符对于子进程也是有效的</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="设计模式是什么？"><a href="#设计模式是什么？" class="headerlink" title="设计模式是什么？"></a>设计模式是什么？</h2><ul>
<li><p>设计模式,是软件设计中常见问题的典型解决方案。它们就像能根据需求进行调整的预制蓝图，可用于解决代码中反复出现的设计问题。</p>
</li>
<li><p>设计模式与方法或库的使用方式不同，你很难直接在自己的程序中套用某个设计模式。 </p>
</li>
<li><p>模式并不是一段特定的代码，而是解决特定问题的一般性概念。你可以根据模式来实现符合自己程序实际所需的解决方案</p>
<ul>
<li>类库，是由程序组合而成的组件，</li>
<li>而设计模式则用来表现内部组件是符合被组装的，以及每一个组件是如何通过相互关联来构成一个庞大系统的</li>
</ul>
</li>
<li><p>人们常常会混淆模式和算法，因为两者在概念上都是已知特定问题的典型解决方案。</p>
</li>
<li><p>但算法总是明确定义达成特定目标所需的一系列步骤，而模式则是对解决方案的更高层次描述。同一模式在两个不同程序中的实现代码可能会不一样</p>
</li>
<li><p>设计模式的目标之一，就是提高程序的可复用性</p>
</li>
<li><p>算法更像是菜谱：提供达成目标的明确步骤。</p>
</li>
<li><p>而模式更像是蓝图：你可以看到最终的结果和模式的功能，但需要自己确定实现步骤</p>
</li>
<li><p>模式包含哪些内容？</p>
<ul>
<li>意图部分，简单描述问题和解决方案</li>
<li>动机部分，将进一步解释问题并说明模式会如何提供解决方案</li>
<li>结构部分，展示模式的每个部分和它们之间的关系</li>
<li>在不同语言中的实现提供流行编程语言的代码， 让读者更好地理解模式背后的思想</li>
</ul>
</li>
</ul>
<h2 id="模式的历史"><a href="#模式的历史" class="headerlink" title="模式的历史"></a>模式的历史</h2><ul>
<li><p>谁发明了设计模式？ 这是一个很好的问题， 但也有点不太准确。 </p>
</li>
<li><p>设计模式并不是晦涩的、复杂的概念——事实恰恰相反。模式是面向对象设计中常见问题的典型解决方案。同样的解决方案在各种项目中得到了反复使用，所以最终有人给它们起了名字，并对其进行了详细描述。这基本上就是模式被发现的历程了</p>
</li>
<li><p>模式的概念是由克里斯托佛·亚历山大在其著作《建筑模式语言》中首次提出的。本书介绍了城市设计的 “语言”， 而此类 “语言” 的基本单元就是模式。模式中可能会包含对窗户应该在多高、一座建筑应该有多少层以及一片街区应该有多大面积的植被等信息的描述</p>
</li>
<li><p>埃里希·伽玛、约翰·弗利赛德斯、拉尔夫·约翰逊和理查德·赫尔姆这四位作者接受了模式的概念。 1994 年，他们出版了《设计模式： 可复用面向对象软件的基础》一书，将设计模式的概念应用到程序开发领域中。 </p>
</li>
<li><p>该书提供了 23 个模式来解决面向对象程序设计中的各种问题，很快便成为了畅销书。由于书名太长，人们将其简称为 “四人组 （<code>Gang of Four， GoF</code>） 的书”， 并且很快进一步简化为 “<strong>GoF 的书</strong>”</p>
</li>
<li><p>此后，人们又发现了几十种面向对象的模式。“模式方法” 开始在其他程序开发领域中流行起来。如今，在面向对象设计领域之外，人们也提出了许多其他的模式</p>
</li>
</ul>
<h2 id="为什么以及如何学习设计模式？"><a href="#为什么以及如何学习设计模式？" class="headerlink" title="为什么以及如何学习设计模式？"></a>为什么以及如何学习设计模式？</h2><ul>
<li><p><strong>设计模式是针对软件设计中常见问题的工具箱</strong>，其中的工具就是各种经过实践验证的解决方案。 即使你从未遇到过这些问题，了解模式仍然非常有用，因为它能指导你如何使用面向对象的设计原则来解决各种问题</p>
</li>
<li><p><strong>设计模式定义了一种让你和团队成员能够更高效沟通的通用语言</strong>。 你只需说 “哦， 这里用单例就可以了”， 所有人都会理解这条建议背后的想法。 只要知晓模式及其名称， 你就无需解释什么是单例</p>
</li>
</ul>
<h2 id="关于模式的争议"><a href="#关于模式的争议" class="headerlink" title="关于模式的争议"></a>关于模式的争议</h2><ul>
<li><p>一种针对不完善编程语言的蹩脚解决方案</p>
<ul>
<li>通常当所选编程语言或技术缺少必要的抽象功能时， 人们才需要设计模式。 在这种情况下， 模式是一种可为语言提供更优功能的蹩脚解决方案</li>
<li>例如， 策略模式在绝大部分现代编程语言中可以简单地使用匿名 （lamb­da） 函数来实现。</li>
</ul>
</li>
<li><p>低效的解决方案</p>
<ul>
<li>模式试图将已经广泛使用的方式系统化。 许多人会将这样的统一化认为是某种教条， 他们会 “全心全意” 地实施这样的模式， 而不会根据项目的实际情况对其进行调整</li>
</ul>
</li>
<li><p>不当使用</p>
<ul>
<li>如果你只有一把铁锤， 那么任何东西看上去都像是钉子。</li>
<li>这个问题常常会给初学模式的人们带来困扰： 在学习了某个模式后， 他们会在所有地方使用该模式， 即便是在较为简单的代码也能胜任的地方也是如此</li>
</ul>
</li>
</ul>
<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><ul>
<li><p>不同设计模式的复杂程度、 细节层次以及在整个系统中的应用范围等方面各不相同</p>
</li>
<li><p><strong>最基础的、 底层的模式通常被称为惯用技巧</strong>。 这类模式一般只能在一种编程语言中使用</p>
</li>
<li><p><strong>最通用的、 高层的模式是构架模式</strong>。 开发者可以在任何编程语言中使用这类模式。 与其他模式不同， 它们可用于整个应用程序的架构设计。</p>
</li>
<li><p>此外， 所有模式可以根据其意图或目的来分类。 本书覆盖了三种主要的模式类别：</p>
<ul>
<li>创建型模式提供创建对象的机制， 增加已有代码的灵活性和可复用性。</li>
<li>结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</li>
<li>行为模式负责对象间的高效沟通和职责委派。</li>
</ul>
</li>
</ul>
<h2 id="Iterator模式"><a href="#Iterator模式" class="headerlink" title="Iterator模式"></a>Iterator模式</h2><ul>
<li><p>for循环语句遍历数组，for语句中的i++的作用是让i的值在每次循环后自增1，这样就可以访问数组的下一个元素，下下一个元素，再下下一个元素，也就实现了从头至尾逐一遍历的功能</p>
</li>
<li><p>将这里的循环变量i的作用抽象化，通用化后形成的模式，在设计模式中成为Iterator模式</p>
</li>
<li><p>Iterator模式，用于在数据集合中按照循序遍历集合。英文单词Iterate有反复做某件事情的意思，汉语称为“迭代器”</p>
</li>
<li><p>为什么一定要考虑引入Iterator这种复杂的设计模式？如果是数组，直接使用for循环语句进行遍历处理不就可以了？</p>
<ul>
<li>一个重要的理由是，<strong>引入Iterator后可以将遍历与实现分离开来</strong></li>
</ul>
</li>
<li><p>设计模式的作用就是帮助编写可复用的类，</p>
</li>
<li><p>所谓“可复用”，就是指将类实现为“组件”，当一个组件发生改变时，不需要对其他的组件进行修改或者只是需要很小的修改即可应对。</p>
</li>
<li><p>抽象类和接口</p>
<ul>
<li>人们总想用具体的类来解决所有的问题</li>
<li>但是如果只使用具体的类来解决问题，很容易导致类之间的强耦合，这些类也难以作为组件被再次利用。</li>
<li>为了弱化类之间的耦合，进而使得类更加容易作为组件被再次利用，需要引入<strong>抽象类</strong>和<strong>接口</strong></li>
</ul>
</li>
<li><p><strong>不要只使用具体类来变成，要优先使用抽象类和接口来编程</strong></p>
</li>
</ul>
<h2 id="Adapter模式"><a href="#Adapter模式" class="headerlink" title="Adapter模式"></a>Adapter模式</h2><ul>
<li><p>在程序世界中，经常会存在现有的程序无法直接使用，需要做适当的变换之后才能使用的情况。</p>
</li>
<li><p>这种用于填补“现有的程序”和“所需的程序”之间差异的设计模式就是<strong>Adapter模式</strong></p>
</li>
<li><p><strong>Adapter模式，也被称为Wrapper模式</strong>。Wrapper有“包装器”的意思，就像精美的包装纸将普通商品包装成礼物那样，替我们把某样东西包起来，使其能够用于其他用途的东西就被称为“包装器”或者是“适配器”</p>
</li>
<li><p>Adapter模式有两种</p>
<ul>
<li>类适配器模式（使用继承的适配器）</li>
<li>对象适配器模式（使用委托的适配器）<ul>
<li>委托，通俗来讲，就是交给其他人，在Java语言中，委托就是将某个方法中的实际处理交给其他实例的方法</li>
</ul>
</li>
</ul>
</li>
<li><p>什么时候使用Adapter模式？</p>
<ul>
<li>有人认为：如果某个方法就是我们所需要的方法，那么直接在程序中使用不就可以了？为什么还要考虑使用Adapter模式呢？</li>
<li>很多时候，我们并非从零开始编程，经常会用到现有的类。</li>
<li>特别是当现有的类已经被充分测试过了，Bug很少，而且已经被用于其他软件时，我们更愿意将这些类作为组件重复利用</li>
<li><strong>Adapter模式会对现有的类进行适配，生成新的类</strong>。通过该模式可以很方便地创建我们需要的方法群</li>
</ul>
</li>
<li><p>版本升级和兼容性</p>
<ul>
<li>版本的生命周期总是伴随版本的升级，而在版本升级的时候经常会出现“与旧版本的兼容性”的问题。</li>
<li>如果能够完全抛弃旧版本，那么软件的维护工作将会轻松很多，但是现实中往往无法这样做。</li>
<li>这时，可以使用Adapter模式使新旧版本兼容，帮助我们轻松的同时维护新版本和旧版本</li>
</ul>
</li>
<li><p>功能完全不同的类，Adapter模式是无法使用的</p>
</li>
</ul>
<h2 id="Template-Method模式"><a href="#Template-Method模式" class="headerlink" title="Template Method模式"></a>Template Method模式</h2><ul>
<li><p>什么是模板？</p>
<ul>
<li>模板的愿意是指带有镂空文字的薄薄的塑料板</li>
</ul>
</li>
<li><p>什么是Template Method模式？</p>
<ul>
<li>Template Method模式是带有模板功能的模式，组成模板的方法被定义在父类中。</li>
<li>由于这些方法是抽象方法，所以只查看父类的代码是无法知道这些方法最终会进行何种具体处理的，唯一能够知道的就是父类是如何调用这些方法的。</li>
</ul>
</li>
<li><p>实现上述这些抽象方法的是子类。在子类中实现了抽象方法也就决定了具体的处理。也就是说，只要在不同的子类中实现不同的具体处理，当父类的模板方法被调用时程序行为也会不同。</p>
</li>
<li><p>但是，不论子类中的具体实现如何，处理的流程都会按照父类中所定义的那样进行。</p>
</li>
<li><p>像这样<strong>在父类中定义处理流程的框架，在子类中实现具体处理的模式就称为Template Method模式</strong></p>
</li>
</ul>
<h3 id="延伸阅读：类的层次与抽象类"><a href="#延伸阅读：类的层次与抽象类" class="headerlink" title="延伸阅读：类的层次与抽象类"></a>延伸阅读：类的层次与抽象类</h3><ul>
<li><p>我们在理解类的层次时，通常是站在子类的角度进行思考的。也就是说，很容易着眼于以下几点</p>
<ul>
<li>在子类中可以使用父类中定义的方法</li>
<li>可以通过在子类中增加方法以实现新的功能</li>
<li>在子类中重写父类的方法可以改变程序的行为</li>
</ul>
</li>
<li><p>改变一下立场，站在父类的角度进行思考。在父类中，我们声明了抽象方法，而将该方法的实现交给了子类。换言之，就程序而言，声明抽象方法是希望达到以下目的</p>
<ul>
<li>期待子类去实现抽象方法</li>
<li>要求子类去实现抽象方法</li>
</ul>
</li>
<li><p>也就是说，子类具有实现父类中所声明的抽象方法的责任。因此，这种责任被称为“子类责任(subclass responsibility)”</p>
</li>
<li><p>抽象类的意义</p>
<ul>
<li>对于抽象类，我们是无法生成其实例的。</li>
<li>由于在抽象方法中并没有编写具体的实现，所以我们无法知道在抽象方法中到底进行了什么样的处理。</li>
<li>但是我们可以决定抽象方法的名字，然后通过调用使用了抽象方法的模板方法去编写处理。虽然具体的处理内容是由子类决定的，不过在抽象类阶段确定处理的流程非常重要。</li>
</ul>
</li>
</ul>
<h3 id="父类与子类之间的写作"><a href="#父类与子类之间的写作" class="headerlink" title="父类与子类之间的写作"></a>父类与子类之间的写作</h3><ul>
<li>父类与子类的相互协作支撑起了整个程序。</li>
<li>虽然将更多方法的实现放在父类中会让子类变得更轻松，但是同时也降低了子类的灵活性</li>
<li>如果父类中实现的方法过少，子类就会变得臃肿不堪，而且还会导致各子类间的代码出现重复</li>
</ul>
<h2 id="Factory-Method模式"><a href="#Factory-Method模式" class="headerlink" title="Factory Method模式"></a>Factory Method模式</h2><ul>
<li><p>Factory有“工厂”的意思。用Template Method模式来构建生成实例的工厂，这就是Factory Method模式</p>
</li>
<li><p>在Factory Method模式中，父类决定实例的生成方式，但是并不决定所要生成的具体的类，具体的处理全部交给子类负责。这样就可以将生成实例的框架(<code>framework</code>)和实际负责生成实例的类解耦</p>
</li>
</ul>
<h3 id="使用模式与开发人员之间的沟通"><a href="#使用模式与开发人员之间的沟通" class="headerlink" title="使用模式与开发人员之间的沟通"></a>使用模式与开发人员之间的沟通</h3><ul>
<li>无论是Template Method模式还是Factory Method模式，在实际工作中使用时，都会让我们感到比较困难。</li>
<li>这是因为，如果仅阅读一个类的代码，是很难理解这个类的行为的。必须要理解父类中所定义的处理的框架和它里面所使用的的抽象方法，然后阅读代码，了解这些抽象方法在子类中的实现才行。</li>
</ul>
<h2 id="Singleton模式"><a href="#Singleton模式" class="headerlink" title="Singleton模式"></a>Singleton模式</h2><ul>
<li><p>想确保任何情况下都绝对只有1个实例，在程序上表现出“只存在一个实例”。想这样的确保只生成一个实例的模式被称为Singleton模式。</p>
</li>
<li><p>Singleton是指只包含有一个元素的集合。</p>
</li>
<li><p>为什么必须设置限制？</p>
<ul>
<li>设置限制其实就是为程序增加一项前提条件</li>
<li>当存在多个实例时，实例之间相互影响，可能会产生意想不到的Bug</li>
<li>但是，如果我们可以确保只有一个实例，就可以在这个前提条件下放心地编程</li>
</ul>
</li>
</ul>
<h2 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a>Builder模式</h2><ul>
<li>Builder模式：用于组装具有复杂结构的实例</li>
</ul>
<h3 id="谁知道什么"><a href="#谁知道什么" class="headerlink" title="谁知道什么"></a>谁知道什么</h3><ul>
<li>在面向对象编程中，“谁知道什么”是非常重要的。也就是说，我们需要在编程时注意哪个类可以使用哪个方法以及使用这个方法到底好不好</li>
</ul>
<h3 id="设计时能够决定的事情和不能决定的事情"><a href="#设计时能够决定的事情和不能决定的事情" class="headerlink" title="设计时能够决定的事情和不能决定的事情"></a>设计时能够决定的事情和不能决定的事情</h3><ul>
<li>虽然类的设计者并不是神仙，无法准确地预测到将来可能发生的变化。但是，还是有必要让设计出的类能够尽可能灵活地应对近期可能发生的变化</li>
</ul>
<h3 id="代码的阅读方法和修改方法"><a href="#代码的阅读方法和修改方法" class="headerlink" title="代码的阅读方法和修改方法"></a>代码的阅读方法和修改方法</h3><ul>
<li><p>在编程时，虽然有时需要从零开始编写代码，但更多时候我们都是在现有代码的基础上进行增加和修改</p>
</li>
<li><p>这时，我们需要先阅读现有代码。不过，只是阅读抽象类的代码是无法获取很多信息的（虽然可以从方法名中获得线索）</p>
</li>
<li><p>如果没有理解各个类的角色就动手增加和修改代码，在判断到底应该修改哪个类时，就会很容易出错</p>
</li>
</ul>
<h2 id="Abstract-Factory模式"><a href="#Abstract-Factory模式" class="headerlink" title="Abstract Factory模式"></a>Abstract Factory模式</h2><ul>
<li><p>Abstract的意思是“抽象的”，Factory的意思是“工厂”，将他们组合起来就可以知道Abstract Factory表示“抽象工厂”的意思。</p>
</li>
<li><p>抽象工厂的工作是将“抽象零件”组装为“抽象产品”</p>
</li>
<li><p>面向对象编程中的“抽象”</p>
<ul>
<li>它指的是“不考虑具体怎样实现，而是仅关注接口（API）”的状态</li>
<li>例如，抽象方法（Abstract Method）并不定义方法的具体实现，而是仅仅只确定了方法的名字和签名（参数的类型和个数）</li>
</ul>
</li>
</ul>
<h2 id="Bridge模式"><a href="#Bridge模式" class="headerlink" title="Bridge模式"></a>Bridge模式</h2><ul>
<li><p>Bridge的意思是“桥梁”。就像在现实世界中，桥梁的功能是将河流的两侧连接起来一样，Bridge模式的作用也是将两样东西连接起来，他们分别是<strong>类的功能层次结构和类的实现层次结构</strong></p>
</li>
<li><p>Bridge模式的作用是在“类的功能层次结构”和“类的实现层次结构”之间搭建桥梁，换句话说，将类的功能层次结构与实现层次结构分离</p>
</li>
<li><p>类的功能层次结构</p>
<ul>
<li>假设现在有一个类Something.当我们想在Something中增加新功能时（想增加一个具体方法时），会编写一个Something类的子类（派生类），即SomethingGood类。这样就构成了一个小小的类层次结构</li>
<li>这就是为了增加新功能而产生的层次结构：父类具有基本功能，在子类中增加新的功能</li>
<li>以上这种层次结构被称为<strong>类的功能层次结构</strong></li>
<li>当要增加新的功能时，可以从各个层次的类中找出最符合自己需求的类，然后以它为父类编写子类，并在子类中增加新的功能。这就是类的功能层次结构</li>
</ul>
</li>
<li><p>类的实现层次结构</p>
<ul>
<li>抽象类声明了一些抽象方法，定义了接口（API），然后子类负责去实现这些抽象方法。父类的任务是通过声明抽象方法的方式定义接口（API），而子类的任务是实现抽象方法。正式由于父类和子类的这种任务分担，我们才可以编写出具有高可替换性的类</li>
<li>这里其实也存在层次结构。例如，当子类ConcreteClass实现了父类AbstractClass类的抽象方法时，它们之间就构成了一个小小的层次结构。但是，这里的类的层次结构并非用于增加功能，也就是说，这种层次结构并非用于方便我们增加新的方法。它的真正作用是帮助我们实现两个任务分担<ul>
<li>父类通过声明抽象方法来定义接口（API）</li>
<li>子类通过实现具体方法来实现接口（API）</li>
</ul>
</li>
<li>这种层次结构被称为类的实现层次结构</li>
</ul>
</li>
<li><p>类的层次结构的混杂与分离</p>
<ul>
<li>当我们想要编写子类时，就需要先确认自己的意图：<strong>是要增加功能呢？还是要增加实现呢？</strong></li>
<li>当类的层次结构只有一层时，功能层次结构与实现层次结构是混杂在一个层次结构中的。这样很容易使类的层次结构变得复杂，也难以透彻地理解类的层次结构。因为自己难以确认究竟应该在类的哪一个层次结构中去增加子类。</li>
<li>因此，我们需要将“类的功能层次结构”与“类的实现层次结构”分离为两个独立的类层次结构。当然，<strong>如果只是简单地将他们分开，两者之间必然会缺少联系，所以我们还需要在他们之间搭建一座桥梁，而Bridge模式的作用就是搭建这座桥梁</strong></li>
</ul>
</li>
<li><p>Bridge模式的特征是将“类的功能层次结构”与“类的实现层次结构”分离开了。将类的这两个层次结构分离开有利于独立地对他们进行扩展</p>
</li>
<li><p>当想要增加功能时，只需要在“类的功能层次结构”一侧增加类即可，不必对“类的实现层次结构”做任何修改。而且，增加后的功能可以被“所有的实现”使用</p>
</li>
<li><p>继承是强关联关系，委托是弱关联关系。在设计类的时候，我们必须充分理解这一点</p>
</li>
</ul>
<h2 id="Strategy模式"><a href="#Strategy模式" class="headerlink" title="Strategy模式"></a>Strategy模式</h2><ul>
<li><p>Strategy的意思是“策略”，指的是与敌军对垒时行军作战的方法。**在编程中，我们可以将它理解为“算法”</p>
</li>
<li><p>无论什么程序，其目的都是解决问题。而为了解决问题，我们又需要编写特定的算法。</p>
</li>
<li><p>使用Strategy模式，<strong>可以整体地替换算法的实现部分</strong>。能够整体地替换换发，能让我们轻松地以不同的算法去解决同一个问题，这种模式就是Strategy模式</p>
</li>
</ul>
<h2 id="Composite模式"><a href="#Composite模式" class="headerlink" title="Composite模式"></a>Composite模式</h2><ul>
<li><p>在计算机的文件系统中，有文件夹的概念（在有些操作系统中，也称为目录）。文件夹里面既可以放入文件，也可以放入其他文件夹（子文件夹）。</p>
</li>
<li><p>在子文件夹中，一样地既可以放入文件，也可以放入子文件夹。可以说，<strong>文件夹是形成了一种容器结构，递归结构</strong></p>
</li>
<li><p>文件夹和文件有时也被统称为“目录条目”(directory entry)。<strong>在目录条目中，文件夹和文件被当作是同一种对象看待（即一致性）</strong></p>
</li>
<li><p>有时，与将文件夹和文件都作为目录条目看待一样，将容器和内容作为同一种东西看待，可以帮助我们方便地处理问题。</p>
</li>
<li><p>能够使容器与内容具有一致性，创造出递归结构的模式就是Composite模式。Composite在英文中是混合物，复合物的意思</p>
</li>
</ul>
<h2 id="Decorator模式"><a href="#Decorator模式" class="headerlink" title="Decorator模式"></a>Decorator模式</h2><ul>
<li>不断地为对象添加装饰的设计模式，被称为Decorator模式。Decorator指的是“装饰物”</li>
</ul>
<h2 id="Visitor模式"><a href="#Visitor模式" class="headerlink" title="Visitor模式"></a>Visitor模式</h2><ul>
<li><p>在Visitor模式中，数据结构与处理被分离开来。</p>
</li>
<li><p>编写一个表示“访问者”的类来访问数据结构中的元素，并把对各元素的处理交给访问者类。这样，当需要增加新的处理时，我们只需要编写新的访问者，然后让数据结构可以接受访问者的访问即可</p>
</li>
<li><p>双重分发</p>
<ul>
<li>accept（接受）方法的调用方式：<code>element.accept(visitor);</code></li>
<li>而visit（访问）方法的调用方式：<code>visitor.visit(element);</code></li>
<li>对比两个方法会发现，他们是相反的关系。element接受visitor，而visitor又访问element</li>
<li>在Visitor模式中，ConcreteElement和ConcreteVisitor这两个角色共同决定了实际进行的处理，<strong>这种消息分发的方式一般被称为双重分发(double dispatch)</strong></li>
</ul>
</li>
<li><p>Visitor模式的目的是将处理从数据结构中分离出来。数据结构很重要，它能将元素集合和管理在一起。</p>
</li>
<li><p>但是，需要注意的是，保存数据结构与以数据结构为基础进行处理是两种不同的东西</p>
</li>
</ul>
<h2 id="Observer模式"><a href="#Observer模式" class="headerlink" title="Observer模式"></a>Observer模式</h2><ul>
<li><p>Observer的意思就是“进行观察的人”，也就是“观察者”的意思</p>
</li>
<li><p>在Observer模式中，当观察对象的状态发生变化时，会通知给观察者。Observer模式适用于根据对象状态进行相应处理的场景。</p>
</li>
<li><p>利用抽象类和接口从具体类中抽出抽象方法</p>
</li>
<li><p>在将实例作为参数传递至类中，或者在类的字段中保存实例时，不使用具体类型，而是使用抽象类型的接口</p>
</li>
<li><p>这样的实现方式可以帮助我们轻松替换具体类</p>
</li>
</ul>
<h2 id="State模式"><a href="#State模式" class="headerlink" title="State模式"></a>State模式</h2><ul>
<li><p>在面向对象编程中，是用类表示对象的。</p>
</li>
<li><p>也就是说，程序的设计者需要考虑用类来表示什么东西。类对应的东西可能存在于现实世界中，也可能不存在于现实世界中。对于后者，可能有人看到代码后会感到吃惊：这些东西居然也可以是类啊</p>
</li>
<li><p>分而治之</p>
<ul>
<li>在编程时，会经常使用分而治之的方针。它非常适用于大规模的复杂处理。当遇到庞大且复杂的问题，不能用一般的方法解决时，会先将问题分解为多个小问题。如果还是不能解决这些小问题，会将它们继续划分为更小的问题，直至可以解决它们为止。</li>
<li>分而治之，简单而言，就是将一个复杂的大问题分解为多个小问题然后逐个解决。</li>
</ul>
</li>
<li><p>在State模式中，用类来表示状态，并为每一种具体的状态都定义一个相应的类。这样问题就被分解了</p>
</li>
<li><p>换言之，State模式用类表示系统的“状态”，并以此将复杂的程序分解开来</p>
</li>
<li><p>在State模式中，我们应该如何编程，以实现“依赖于状态的处理”呢？总结起来有如下两点</p>
<ul>
<li>定义接口，声明抽象方法</li>
<li>定义多个类，实现具体方法</li>
</ul>
</li>
</ul>
<h2 id="Flyweight模式"><a href="#Flyweight模式" class="headerlink" title="Flyweight模式"></a>Flyweight模式</h2><ul>
<li><p>Flyweight是“轻量级”的意思，指的是拳击比赛中选手体重最轻的登记。顾名思义，该设计模式的作用是为了让对象变“轻”</p>
</li>
<li><p>对象在计算机中是虚拟存在的东西，它的“重”和“轻”并非指实际重量，而是<strong>它们“所使用的的内存大小”</strong>。使用内存多的对象就是“重”对象，使用内存小的对象就是“轻”对象</p>
</li>
<li><p>为了能够在计算机中保存该对象，需要分配给其足够的内存空间。当程序中需要大量对象时，如果都是用new关键字来分配内存，将会消耗大量内存空间</p>
</li>
<li><p>关于Flyweight模式，一言以蔽之就是 ： <strong>通过尽量共享示例来避免new出实例</strong></p>
</li>
<li><p>Intrinsic与Extrinsic</p>
<ul>
<li>应当共享的信息被称作<code>Intrinsic</code>信息。Intrinsic的意思是“本质的，固有的”。<ul>
<li>换言之，它指的是不论实例在哪里，不论在什么情况下都不会改变的信息，或者是不依赖于实例的信息</li>
</ul>
</li>
<li>不应当共享的信息被称作<code>Extrinsic</code>信息。Extrinsic的意思是“外在的，非本质的”。<ul>
<li>也就是说，它是当实例的位置，状况发生改变时会变化的信息，或是依赖于实例状态的信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Proxy模式"><a href="#Proxy模式" class="headerlink" title="Proxy模式"></a>Proxy模式</h2><ul>
<li>Proxy是“代理人”的意思，它指的是代替别人进行工作的人。</li>
<li>在面向对象编程中，“本人”和“代理人”都是对象。如果“本人”对象太忙了，有些工作无法自己亲自完成，就将其交给“代理人”对象负责</li>
</ul>
<h2 id="Command模式"><a href="#Command模式" class="headerlink" title="Command模式"></a>Command模式</h2><ul>
<li>一个类在进行工作时会调用自己或是其他类的方法，虽然调用结果会反应在对象的状态中，但并不会留下工作的历史记录。</li>
<li>这时，如果我们有一个类，用来表示“请进行这项工作”的“命令”就会方便很多。每一项想做的工作就不再是“方法的调用”这种动态处理了，而是一个表示命令的类的实例，即–可以用“物”来标识。要想管理工作的历史记录，只需管理这些实例的集合即可，而且还可以随时再次执行过去的命令，或是将多个过去的命令整合为一个新命令并执行。</li>
<li>在设计模式中，称这样的“命令”为Command模式</li>
</ul>
<h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul>
<li><p>设计模式能够解决软件开发中的所有问题吗？</p>
<ul>
<li>不能，每个设计模式都是用于解决软件开发过程中遇到的问题，但是无论使用什么解决方法，都需要从整体权衡。设计模式并不能解决所有问题</li>
</ul>
</li>
<li><p>怎样才能选择出合适的设计模式呢？</p>
<ul>
<li>首先必须要明确知道自己的软件中存在什么样的问题。如果问题不够明确，是无法选择出合适的设计模式的。</li>
<li><strong>在学习设计模式时，我们要注意该模式“可以解决什么问题”</strong></li>
</ul>
</li>
<li><p>所谓设计模式，其解决方法都是理所当然的，并不认为有值得关注和重新学习的价值。为什么设计模式很重要呢？</p>
<ul>
<li>在向经验丰富的开发人员介绍设计模式时，他们会认为这是“理所当然”的。当然是这样的，因为本来设计模式就是开发人员对反复遇到的问题总结出来的解决办法</li>
<li>设计模式的重要性在于，<strong>可以帮助大家很快地掌握那些经验丰富的开发人员才具有的知识和经验</strong></li>
</ul>
</li>
<li><p>设计模式很难背下来</p>
<ul>
<li>机械的背下来这些设计模式是没有意义的。重要的是在自己脑海中理解设计模式是怎样解决问题的</li>
</ul>
</li>
<li><p>设计模式对初级开发人员也有帮助吗？</p>
<ul>
<li>对于刚刚掌握了编程语言，并逐渐开始慢慢编写一些程序的初级开发人员来说，通过设计模式可以学习到“<strong>在进行面向对象编程时，应该注意什么</strong>”</li>
<li>例如，通过设计模式，我们可以学到本书中讲解过得可复用性，可替换性，接口（API），继承和委托，抽象化等</li>
<li>此外，设计模式的知识也会对我们自己使用类库有所帮助。这是因为类库中的许多部分都与设计模式有关</li>
</ul>
</li>
<li><p>除了“设计模式”外，还常听到“模式”这个词，两者的意思是相同的吗？</p>
<ul>
<li>严格来讲，两者的意思是有区别的</li>
<li>不论是在什么领域，给“<strong>在某种场景下重复发生的问题的解决办法</strong>”赋予名字，并整理而成的东西一般都称为“模式”</li>
<li>设计模式，是适用于软件设计和开发领域的模式，它是模式中的一种</li>
<li>不过，有时候在软件领域也会将“设计模式”简称为模式</li>
</ul>
</li>
</ul>
<hr>
<h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><ul>
<li><p>《深入设计模式》</p>
</li>
<li><p><code>https://refactoringguru.cn/design-patterns</code></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">设计模式_可复用面向对象软件的基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>设计模式：可复用面向对象软件的基础 阅读笔记</li>
</ul>
<h2 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h2><ul>
<li>设计面向对象软件比较困难，而设计可复用的面向对象软件就更加困难。你必须找到相关的对象，以适当的粒度将它们归类，再定义类的接口和继承层次，建立对象之间的基本关系</li>
</ul>
<h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><ul>
<li><p>一般而言，一个模式有四个基本要素：</p>
<ul>
<li>模式名称(pattern name)，一个助记名，它用一两个词来描述模式的问题，解决方案和效果。</li>
<li>问题(problem)，描述了应该在何时使用模式。它解释了设计问题和问题存在的前因后果，它可能描述了特定的设计问题，例如怎样用对象表示算法等。也可能描述了导致了不灵活设计的类或对象结构。</li>
<li>解决方案(solution)，描述了设计的组成成分，它们之间的相互关系以及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合(类或对象组合)来解决这个问题</li>
<li>效果(consequences)，描述了模式应用的效果以及使用模式应权衡的问题。尽管我们描述设计决策时，并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价和好处具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性，扩充性或者可移植性的映像。</li>
</ul>
</li>
<li><p>本书中的设计模式是对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述</p>
</li>
</ul>
<h3 id="组织编目"><a href="#组织编目" class="headerlink" title="组织编目"></a>组织编目</h3><ul>
<li><p>根据两条准则对模式进行分类。</p>
</li>
<li><p>第一是目的准则，即模式是用来完成什么工作的。</p>
<ul>
<li>模式依据其目的可分为创建型(Creational)，结构型(Structural)，或行为型(Behavioral)三种。<ul>
<li>创建型模式与对象的创建有关；</li>
<li>结构型模式处理类或对象的组合；</li>
<li>行为型模式对类或对象怎样交互和怎样分配职责进行描述</li>
</ul>
</li>
</ul>
</li>
<li><p>第二是范围准则，指定模式主要用作于类还是用作于对象。</p>
<ul>
<li>类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了。</li>
<li>对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具有动态性。</li>
<li>从某种意义上来说，几乎所有模式都使用继承机制，所以 类模式 只指那些集中于处理类间关系的模式，而大部分模式都属于对象模式的范畴</li>
</ul>
</li>
</ul>
<h3 id="设计模式怎样解决设计问题"><a href="#设计模式怎样解决设计问题" class="headerlink" title="设计模式怎样解决设计问题"></a>设计模式怎样解决设计问题</h3><ul>
<li>设计模式采用多种方法解决面向对象设计者经常碰到的问题</li>
</ul>
<h4 id="寻找合适的对象"><a href="#寻找合适的对象" class="headerlink" title="寻找合适的对象"></a>寻找合适的对象</h4><ul>
<li><p>面向对象程序由对象组成，对象包括数据和对数据进行操作的过程，过程通常称为方法或者操作。对象在收到客户的请求(或消息)后，执行相应的操作</p>
</li>
<li><p>客户请求是使对象执行操作的唯一方法，操作又是对象改变内部数据的唯一方法。由于这些限制，对象的内部状态是被封装的，他不能被直接访问，它的表示对于对象外部是不可见的</p>
</li>
<li><p>面向对象设计最困难的部分是将系统分解成对象集合。因为要考虑许多因素：封装，粒度，依赖关系，灵活性，性能，演化，复用等等，它们都影响着系统的分解，并且这些因素通常还是互相冲突的</p>
</li>
<li><p>设计模式帮你确定并不明显的抽象和描述这些抽象的对象</p>
</li>
</ul>
<h4 id="决定对象的粒度"><a href="#决定对象的粒度" class="headerlink" title="决定对象的粒度"></a>决定对象的粒度</h4><ul>
<li>对象在大小和数目上变化极大。它们能表示下自硬件或者上自整个应用的任何事物</li>
</ul>
<h4 id="指定对象接口"><a href="#指定对象接口" class="headerlink" title="指定对象接口"></a>指定对象接口</h4><ul>
<li><p>对象声明的每一个操作指定操作名，作为参数的对象和返回值，这就是所谓的操作的型构(signature)。</p>
</li>
<li><p>对象操作所定义的所有操作型构的集合被称为该对象的接口(interface)。</p>
</li>
<li><p>对象接口描述了该对象所能接受的全部请求的集合，任何匹配对象接口中型构的请求都可以发送给该对象</p>
</li>
<li><p>类型(type)是用来标识特定接口的一个名字。</p>
</li>
<li><p>接口可以包含其他接口作为子集。当一个类型的接口包含另一个类型的接口时，我们就说它是另一个类型的子类型(subtype)，另一个类型称之为它的超类型(supertype)。</p>
</li>
<li><p>我们常说子类型继承了它的超类型的接口</p>
</li>
<li><p>当给对象发送请求时，所引起的具体操作即与请求本身有关又与接收对象有关。支持相同请求的不同对象可能对请求激发的操作有不同的实现。发送给对象的请求和它的相应操作在运行时刻的连接就称之为动态绑定(dynamice binding)</p>
</li>
<li><p>动态绑定是指发送的请求直到运行时刻才受到你的具体的实现的约束。</p>
</li>
<li><p>进一步将，动态绑定允许你在运行时刻彼此替换有相同接口的对象。这种可替换性就称为多态(polymorphism)，它是面向对象系统中的核心概念之一</p>
</li>
</ul>
<h4 id="描述对象的实现"><a href="#描述对象的实现" class="headerlink" title="描述对象的实现"></a>描述对象的实现</h4><ul>
<li><p>对象的实现是由它的类决定的，类指定了对象的内部数据和表示，也定义了对象所能够完成的操作。</p>
</li>
<li><p>对象通过实例化类来创建，此时对象被称为该类的实例。当实例化类时，要给对象的内部数据(由实例变量组成)分配存储空间，并将操作与这些数据联系起来。</p>
</li>
<li><p>新的类可以由已存在的类通过类继承(class inheritance)来定义。当子类(subclass)继承父类(parent class)时，子类包含了父类定义的所有数据和操作</p>
</li>
<li><p>抽象类(abstrace class)的主要目的是为它的子类定义公共接口。一个抽象类将把它的部分或者全部操作的实现延迟到子类中，因此，一个抽象类不能被实例化。在抽象类中定义却没有实现的操作被称为抽象操作(abstract operation)。</p>
</li>
<li><p>非抽象类称为具体类</p>
</li>
<li><p>子类能够改进和重新定义它们的父类的操作。更具体的说，类能够重定义(override)父类定义的操作，重定义使得子类能够接管父类对请求的处理操作。</p>
</li>
<li><p>混入类(mixin class)是给其他类提供可选择的接口或者功能的类。它与抽象类一样不能实例化。混入类要求多继承</p>
</li>
</ul>
<h5 id="类继承与接口继承的比较"><a href="#类继承与接口继承的比较" class="headerlink" title="类继承与接口继承的比较"></a>类继承与接口继承的比较</h5><ul>
<li><p>理解对象的类(class)与对象的类型(type)之间的差别非常重要</p>
</li>
<li><p>一个对象的类定义了对象是怎样实现的，同时也定义了对象的内部状态和操作的实现。</p>
</li>
<li><p>但是对象的类型只与它的接口有关，接口即对象能够响应的请求的集合。</p>
</li>
<li><p>一个对象可以有多个类型，不同类的对象可以有相同的类型。</p>
</li>
<li><p>理解类继承和接口继承(或子类型化)之间的差别也十分重要。</p>
</li>
<li><p>类继承根据一个对象的实现定义了另一个对象的实现。简而言之，它是代码和表示的共享机制。</p>
</li>
<li><p>然而，接口继承(或子类型化)描述了一个对象什么时候能被用来替代另一个对象。</p>
</li>
<li><p>因为许多语言并不显式地区分这两个概念，所以容易被混淆。在C++ 和 Eiffel语言中，继承既指接口的继承又指实现的继承。</p>
</li>
<li><p>C++中接口继承的标准方法是公有继承一个含(纯)虚成员函数的类。</p>
</li>
<li><p>C++中纯接口继承接近于公有继承纯抽象类，纯实现继承或纯类继承接近于私有继承</p>
</li>
</ul>
<h5 id="对接口编程，而不是对实现编程"><a href="#对接口编程，而不是对实现编程" class="headerlink" title="对接口编程，而不是对实现编程"></a>对接口编程，而不是对实现编程</h5><ul>
<li><p>类继承是一个通过复用父类功能而扩展应用功能的基本机制。</p>
</li>
<li><p>然而，实现的复用只是成功的一半，继承所拥有的定义具有相同接口的对象族的能力也是很重要的(通常可以从抽象类来继承)。</p>
</li>
<li><p>为什么？因为多态依赖于这种能力</p>
</li>
<li><p>当继承被恰当使用时，所有从抽象类导出的类将共享该抽象类的接口。这意味着子类仅仅添加或重定义操作，而没有隐藏父类的操作。</p>
</li>
<li><p>这时，所有的子类都能响应抽象类接口中的请求，从而子类的类型都是抽象类的子类型。</p>
</li>
<li><p>只根据抽象类中定义的接口来操作对象有以下两个好处：</p>
<ul>
<li>客户无须知道它们使用对象的特定类型，只须对象有客户所期望的接口</li>
<li>客户无须知道它们使用的对象是用什么类来实现的，它们只须知道定义接口的抽象类。</li>
</ul>
</li>
<li><p>这将极大地减少子系统实现之间的相互依赖关系，也产生了可复用的面向对象设计的如下原则：</p>
<ul>
<li>针对接口编程，而不是针对实现编程。</li>
</ul>
</li>
<li><p>不将变量声明为某个特定的具体类的实例对象，而是让它遵循从抽象类所定义的接口。这是本书设计模式的一个常见主题。</p>
</li>
</ul>
<h5 id="运用复用机制"><a href="#运用复用机制" class="headerlink" title="运用复用机制"></a>运用复用机制</h5><ul>
<li><p>面向对象系统中功能复用的两种最常用技术是类继承和对象组合(object composition)</p>
</li>
<li><p>类继承允许你根据其他类的实现来定义一个类的实现。这种通过生成子类的复用通常被称为白箱复用(white-box reuse)。</p>
</li>
<li><p>术语 白箱 是相对可视性而言：在继承方式中，父类的内部细节对子类可见</p>
</li>
<li><p>对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。</p>
</li>
<li><p>对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部细节是不可见的。对象只以 黑箱 的形式出现</p>
</li>
<li><p>类继承的优点：</p>
<ul>
<li>在编译时刻静态定义的，且可直接使用，因为程序设计语言直接支持类继承。</li>
<li>较方便地改变被复用的实现。</li>
<li>当一个子类重定义一些而不是全部操作时，他也能影响他所继承的操作，只要在这些操作中调用了被重定义的操作。</li>
</ul>
</li>
<li><p>类继承的缺点：</p>
<ul>
<li>因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现</li>
<li>父类通常至少定义了部分子类的具体表示</li>
<li>因为继承对子类揭示了其父类的实现细节，所以继承常被认为破坏了封装性</li>
<li>子类中的实现与他的父类有紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类的变化</li>
</ul>
</li>
<li><p>当你需要复用子类时，实现上的依赖性就会产生一些问题。如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。</p>
</li>
<li><p>一个可用的解决方法就是只继承抽象类，因为抽象类通常提供较少的实现</p>
</li>
<li><p>对象组合是通过获得对其他对象的引用而在运行时刻动态定义的。</p>
</li>
<li><p>组合要求对象遵守彼此的接口约定，进而要求更仔细的定义接口，而这些接口并不妨碍你将一个对象和其他对象一起使用。</p>
</li>
<li><p>这会产生良好的结果：</p>
<ul>
<li>因为对象只能通过接口访问，所以我们并不破坏封装性</li>
<li>只要类型一致，运行时刻还可以用一个对象来替代另一个对象</li>
<li>更进一步，因为对象的实现是基于接口写的，所以实现上存在较少的依赖关系</li>
</ul>
</li>
<li><p>对象组合对系统设计还有另一个作用，既优先使用对象组合有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</p>
</li>
<li><p>另一方面，基于对象组合的设计会有更多的对象(而有较少的类)，且系统的行为将依赖于对象间的关系而不是被定义在某个类中</p>
</li>
<li><p>这导出了我们的面向对象设计的第二个原则：</p>
<ul>
<li>优先使用对象组合，而不是类继承。</li>
</ul>
</li>
<li><p>理想情况下，你不应该为获得复用而去创建新的构件。你应该能够只使用对象组合技术，通过组装已有的构建就能获得你需要的功能。</p>
</li>
<li><p>但是事实很少如此，因为可用构建的集合实际上并不足够丰富。使用继承的复用使得创建新的构建要比组装旧的构建来的容易。</p>
</li>
<li><p>这样，继承和对象组合常一起使用。</p>
</li>
<li><p>委托(delegation)是一种组合方法，他使组合具有与继承同样的复用能力。在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给他的代理者(delegate)</p>
</li>
<li><p>这类似于子类将请求交给他的父类处理。使用继承时，被继承的操作总能引用接受请求的对象，C++中通过this成员变量</p>
</li>
<li><p>委托是对象组合的特例。它告诉你对象组合作为一个代码复用机制可以代替继承</p>
</li>
<li><p>另一种功能复用技术(并非严格的面向对象技术)是参数化类型(parameterized type)，也就是类属(generic)或者模板(templates (C++))。他允许你在定义一个类型时并不指定该类型所用到的其他所有类型。未经指定的类型在使用时以参数形式提供。</p>
</li>
<li><p>参数化类型给我们提供了除了类继承和对象组合外的第三种方法来组合面向对象系统中的行为。许多设计可以使用这三种技术中的任何一种来实现。</p>
</li>
<li><p>实现一个以元素比较操作为可变元的排序例程，可有如下方法：</p>
<ul>
<li>通过子类实现该操作</li>
<li>实现为传给排序例程的对象的职责</li>
<li>作为C++模板或Ada类属的参数，以指定元素比较操作的名称</li>
</ul>
</li>
</ul>
<h4 id="关联运行时刻和编译时刻的结构"><a href="#关联运行时刻和编译时刻的结构" class="headerlink" title="关联运行时刻和编译时刻的结构"></a>关联运行时刻和编译时刻的结构</h4><ul>
<li><p>一个面向对象程序运行时刻的结构通常与他的代码结构相差很大。</p>
</li>
<li><p>代码结构在编译时刻就被确定下来了，他由继承关系固定的类组成。而程序的运行时刻结构是由快速变化的通信对象网格组成。</p>
</li>
<li><p>事实上，两个结构是彼此独立的，试图由一个区理解另一个就好像试图从静态的动植物分类去理解活生生的生态系统的动态性。反之亦然。</p>
</li>
<li><p>聚合(aggregation)，意味着一个对象拥有另一个对象或对另一个对象负责。</p>
</li>
<li><p>一般我们称一个对象包含另一个对象或者另一个对象的一部分。聚合意味着聚合对象和其所有者具有相同的生命周期</p>
</li>
</ul>
<h4 id="设计应支持变化"><a href="#设计应支持变化" class="headerlink" title="设计应支持变化"></a>设计应支持变化</h4><ul>
<li><p>一些导致重新设计的一般原因，以及解决这些问题的设计模式：</p>
<ul>
<li>通过显示的指定一个类来创建对象 ： 在创建对象时指定类名将使你受特定实现的约束而不是特定接口的约束。这会使未来的变化更复杂。要避免这种情况，应该间接地创建对象<ul>
<li>设计模式： Abstract Factory, Factory Method, Prototype</li>
</ul>
</li>
<li>对特殊操作的依赖 ： 当你为请求指定一个特殊的操作时，完成该请求的方式就固定下来了。为避免把请求代码写死，你将可以在编译时刻或运行时刻很方便地改变响应请求的方式<ul>
<li>设计模式： Chain of Resposibility, Command</li>
</ul>
</li>
<li>对硬件和软件平台的依赖 ： 外部的操作系统接口和应用编成接口(API)在不同的软硬件平台上是不同的。依赖于特定平台的软件将很难移植到其他平台上，甚至都很难跟上本地平台的更新。所以设计系统时限制其平台相关性就很重要了。<ul>
<li>设计模式： Abstract Factory, Bridge</li>
</ul>
</li>
<li>对对象表示或实现的依赖 ： 知道对象怎样表示，保存，定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能够阻止连锁变化<ul>
<li>设计模式： Abstract Factory, Bridge, Memento, Proxy</li>
</ul>
</li>
<li>算法依赖 ： 算法在开发和复用时常常被扩展，优化和替代。依赖于某个特定算法的对象在算法发生变化时不得不变化。因此有可能发生变化的算法应该被孤立起来。<ul>
<li>设计模式： Builder, Iterator, Strategy, Template Method, Visitor</li>
</ul>
</li>
<li>紧耦合 ： 紧耦合的类很难孤立的被复用，因为它们是互相依赖的。紧耦合产生单块的系统，要改变或者删掉一个类，你必须理解和改变其他许多类。这样的系统是一个很难学习移植和维护的密集体。松散耦合提高了一个类本身被复用的可能性，并且系统更易于学习，移植，修改和扩展。设计模式使用抽象耦合和分层技术来提高系统的松散耦合性。<ul>
<li>设计模式： Abstract Factory, Command, Facade, Mediator, Observer, Chain of Responsibility</li>
</ul>
</li>
<li>通过生成子类来扩充功能 ： 通常很难通过定义子类来定制对象。每一个新类都有固定的实现开销(初始化，终止处理等)。子类方法会导致类爆炸，因为即使对于一个简单的扩充，你也不得不引入许多新的子类。一般的对象组合技术和具体的委托技术，是继承之外组合对象行为的另一种灵活方法。新的功能可以通过以新的方式组合已有对象，而不是通过定义已存在类的子类的方式加到应用中去。另一方面，过多使用对象组合会使设计难于理解。许多设计模式产生的设计中，你可以定义一个子类，且将它的实例和已存在实例进行组合来引入定制的功能。<ul>
<li>设计模式：Bridge, Chain of Responsibility, Composite, Decorator, Observer, Strategy</li>
</ul>
</li>
<li>不能方便地对类进行修改 ： 有时你不得不改变一个难以修改的类。<ul>
<li>设计模式： Adapter, Decorator, Visitor</li>
</ul>
</li>
</ul>
</li>
<li><p>设计模式在开发如下三类主要软件中所起作用：</p>
<ul>
<li>应用程序</li>
<li>工具箱</li>
<li>框架</li>
</ul>
</li>
<li><p>如果要建造像文档编辑器的应用程序(Application Program)，那么它的内部复用性，可维护性和可扩充性是要优先考虑的。</p>
</li>
<li><p>内部复用性确保你不会做多余的设计和实现</p>
</li>
<li><p>设计模式通过减少依赖型来提高内部复用性。</p>
</li>
<li><p>松散耦合也增强了一类对象与其他多个对象协作的可能性。</p>
</li>
</ul>
<h3 id="怎样选择设计模式"><a href="#怎样选择设计模式" class="headerlink" title="怎样选择设计模式"></a>怎样选择设计模式</h3><ul>
<li><p>考虑设计模式是怎样解决设计问题的</p>
</li>
<li><p>浏览模式的意图部分</p>
</li>
<li><p>研究模式怎样互相关联</p>
</li>
<li><p>研究目的相似的模式</p>
</li>
<li><p>检查重新设计的原因</p>
</li>
<li><p>考虑你的设计中那些是可变的</p>
</li>
</ul>
<h3 id="怎样使用设计模式"><a href="#怎样使用设计模式" class="headerlink" title="怎样使用设计模式"></a>怎样使用设计模式</h3><ul>
<li><p>大致浏览一遍模式。 </p>
<ul>
<li>特别注意其适用性部分和效果部分，确定它适合你的问题</li>
</ul>
</li>
<li><p>回头研究结构部分，参与者部分和协作部分</p>
<ul>
<li>确保你理解这个模式的类和对象以及他们是怎样关联的</li>
</ul>
</li>
<li><p>选择模式参与者的名字，使他们在应用上下文中有意义</p>
</li>
<li><p>定义类</p>
<ul>
<li>声明它们的接口，建立他们的继承关系，定义代表数据和对象引用的实例变量。</li>
<li>识别模式会影响的你的应用中存在的类，作出相应的修改</li>
</ul>
</li>
<li><p>定义模式中专用于应用的操作名称</p>
<ul>
<li>名字一般依赖于应用。使用与每一个操作相关联的责任和写作作为指导</li>
<li>名字约定要一致</li>
</ul>
</li>
<li><p>实现执行模式中责任和写作的操作</p>
</li>
</ul>
<h2 id="第二章-实例研究：-设计一个文档编辑器"><a href="#第二章-实例研究：-设计一个文档编辑器" class="headerlink" title="第二章 实例研究： 设计一个文档编辑器"></a>第二章 实例研究： 设计一个文档编辑器</h2><h3 id="递归组合"><a href="#递归组合" class="headerlink" title="递归组合"></a>递归组合</h3><ul>
<li>层次结构信息的表述通常是通过一种被称为递归组合(Recursive Composition)的技术来实现的。</li>
<li>递归组合可以由较简单的元素逐渐建立复杂的元素，是我们通过简单图形元素构造文档的方法之一。</li>
</ul>
<h2 id="第三章-创建型模式"><a href="#第三章-创建型模式" class="headerlink" title="第三章 创建型模式"></a>第三章 创建型模式</h2><ul>
<li><p>创建型模式抽象了实例化过程。它们帮助一个系统独立于如何创建，组合和表示它的哪些对象。一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。</p>
</li>
<li><p>创建型模式在什么被创建，谁创建它，它是怎样被创建的，以及何时创建这方面给予很大的灵活性。它们允许你用结构和功能差别很大的产品对象配置一个系统。配置可以是静态的(即在编译时指定的)，也可以是动态的(在运行时)</p>
</li>
</ul>
<h3 id="ABSTRACT-FACTORY-抽象工厂-–-对象创建型模式"><a href="#ABSTRACT-FACTORY-抽象工厂-–-对象创建型模式" class="headerlink" title="ABSTRACT FACTORY(抽象工厂) – 对象创建型模式"></a>ABSTRACT FACTORY(抽象工厂) – 对象创建型模式</h3><ul>
<li><p>意图：</p>
<ul>
<li>提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类</li>
</ul>
</li>
<li><p>别名：</p>
<ul>
<li>Kit</li>
</ul>
</li>
<li><p>动机</p>
<ul>
<li>考虑一个支持多种视感(look-and-feel)标准的用户界面工具包。不同的视感风格，为诸如滚动条，窗口和按钮等用户界面”窗口组件”定义不同的外观和行为。</li>
<li>为保证视感风格标准间的可移植性，一个应用不应该为一个特定的视感外观硬编码它的窗口组件。在整个应用中实例化特定视感风格的窗口组件类将使得以后很难改变视感风格</li>
</ul>
</li>
</ul>
<h2 id="第五章-行为模式"><a href="#第五章-行为模式" class="headerlink" title="第五章 行为模式"></a>第五章 行为模式</h2><h3 id="5-1-CHAIN-OF-RESPON-SIBILITY-责任链-–-对象行为型模式"><a href="#5-1-CHAIN-OF-RESPON-SIBILITY-责任链-–-对象行为型模式" class="headerlink" title="5.1 CHAIN OF RESPON SIBILITY(责任链)  – 对象行为型模式"></a>5.1 CHAIN OF RESPON SIBILITY(责任链)  – 对象行为型模式</h3><h3 id="5-2-COMMAND-命令-–-对象行为型模式"><a href="#5-2-COMMAND-命令-–-对象行为型模式" class="headerlink" title="5.2 COMMAND(命令)  – 对象行为型模式"></a>5.2 COMMAND(命令)  – 对象行为型模式</h3><h3 id="5-3-INTERPRETER-解释器-–-对象行为型模式"><a href="#5-3-INTERPRETER-解释器-–-对象行为型模式" class="headerlink" title="5.3 INTERPRETER(解释器) – 对象行为型模式"></a>5.3 INTERPRETER(解释器) – 对象行为型模式</h3><h3 id="5-4-ITERATOR-迭代器-–-对象行为型模式"><a href="#5-4-ITERATOR-迭代器-–-对象行为型模式" class="headerlink" title="5.4 ITERATOR(迭代器) – 对象行为型模式"></a>5.4 ITERATOR(迭代器) – 对象行为型模式</h3><h3 id="5-5-MEDIATOR-中介者-–-对象行为型模式"><a href="#5-5-MEDIATOR-中介者-–-对象行为型模式" class="headerlink" title="5.5 MEDIATOR(中介者)  – 对象行为型模式"></a>5.5 MEDIATOR(中介者)  – 对象行为型模式</h3><h3 id="5-6-MEMENTO-备忘录-–-对象行为型模式"><a href="#5-6-MEMENTO-备忘录-–-对象行为型模式" class="headerlink" title="5.6 MEMENTO(备忘录)  – 对象行为型模式"></a>5.6 MEMENTO(备忘录)  – 对象行为型模式</h3><h3 id="5-7-OBSERVER-观察者-–-对象行为型模式"><a href="#5-7-OBSERVER-观察者-–-对象行为型模式" class="headerlink" title="5.7 OBSERVER(观察者)  – 对象行为型模式"></a>5.7 OBSERVER(观察者)  – 对象行为型模式</h3><h3 id="5-8-STATE-状态-–-对象行为型模式"><a href="#5-8-STATE-状态-–-对象行为型模式" class="headerlink" title="5.8 STATE(状态)  – 对象行为型模式"></a>5.8 STATE(状态)  – 对象行为型模式</h3><h4 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h4><ul>
<li>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</li>
</ul>
<h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><ul>
<li>状态对象(Objects for States)</li>
</ul>
<h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><ul>
<li>考虑一个表示网络连接的类TCPConnection。一个TCPConnection对象的状态处于若干不同状态之一：连接已建立(Established)，正在监听(Listening)，连接已关闭(Closed)。当一个TCPConnection对象收到其他对象的请求时，它根据自身的当前状态做出不同的反应。例如：一个Open请求的结果依赖于该连接是处于连接已关闭状态还是连接已建立状态。</li>
<li>State模式描述了TCPConnection如何在每一种状态下表现出不同的行为。</li>
<li>这一模式的关键思想是引入了一个称为TCPState的抽象类来表示网络的连接状态。TCPState类为各表示不同的操作状态的子类声明了一个公共接口。TCPState的子类实现与特定状态相关的行为。例如，TCPEstablished和TCPClosed类分别实现了特定于TCPConnection的连接已建立状态和连接已关闭状态的行为。<br><img src="/images/Books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80/STATE--TCPConnection.png" alt="STATE--TCPConnection"></li>
<li>TCPConnection类维护一个表示TCP连接当前状态的状态对象(一个TCPState子类的实例)。TCPConnection类将所有与状态相关的请求委托给这个状态对象。TCPConnection使用它的TCPState子类实例来执行特定于连接状态的操作。</li>
<li>一旦连接状态改变，TCPConnection对象就会改变它所使用的状态对象。例如当连接从已建立状态转为已关闭状态时，TCPConnection会用一个TCPClosed的实例来代替原来的TCPEstablished的实例。</li>
</ul>
<h4 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h4><ul>
<li>在下面的两种情况下均可使用State模式<ul>
<li>一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为</li>
<li>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化</li>
</ul>
</li>
</ul>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="/images/Books/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80/STATE--%E7%BB%93%E6%9E%84.png" alt="STATE--结构"></p>
<h4 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h4><ul>
<li>Context(环境，例如TCPConnection)：<ul>
<li>定义客户感兴趣的接口</li>
<li>维护一个ConcreteState子类的实例，这个实例定义当前状态。</li>
</ul>
</li>
<li>State(状态，例如TCPState)<ul>
<li>定义一个接口以封装与Context的一个特定状态相关的行为</li>
</ul>
</li>
<li>ConcreteState subclasses(具体状态子类，例如TCPEstablished, TCPListen, TCPClosed)<ul>
<li>每一子类实现一个与Context的一个状态相关的行为</li>
</ul>
</li>
</ul>
<h4 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h4><ul>
<li>Context将与状态相关的请求委托给当前的ConcreteState对象处理</li>
<li>Context可将自身作为一个参数传递给处理该请求的状态对象。这使得状态对象在必要时可访问Context</li>
<li>Context是客户使用的主要接口。客户可用状态对象来配置一个Context，一旦一个Context配置完毕，它的客户不再需要直接与状态对象打交道。</li>
<li>Context或ConcreteState子类都可决定哪个状态是另外哪一个的后继者，以及是在何种条件下进行状态转换。</li>
</ul>
<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><ul>
<li><strong>它将与特定状态相关的行为局部化，并且将不同状态的行为分割开来</strong>。State模式将所有与一个特定的状态相关的行为都放入一个对象中。因为所有与状态相关的代码都存在于某一个State子类中，所以通过定义新的子类可以很容易的增加新的状态和转换。另一个方法是使用数据值定义内部状态并且让Context操作来显示的检查这些数据。但这样会使整个Context的实现中遍布看起来很相似的条件语句或case语句。增加一个新的状态可能需要改变若干个操作，这就使得维护变得复杂了。State模式避免了这个问题，但可能会引入另一个问题，因为该模式将不同状态的行为分布在多个State子类中。这就增加了子类的数目，相对于单个类的实现来说不够紧凑。但是如果有许多状态时这样的分布实际上更好一些，否则需要使用巨大的条件语句。正如很长的过程一样，巨大的条件语句是不受欢迎的。他们形成一大整块并且使得代码不够清晰，这又使得它们难以修改和扩展。State模式提供了一个更好的方法来组织与特定状态相关的代码。决定状态转移的逻辑不在单块的if或switch语句中，而是分布在State子类之间。将每一个状态转换和动作封装到一个类中，就把着眼点从执行状态提高到整个对象的状态。这将使代码结构化并使其意图更加清晰。</li>
<li><strong>它使得状态转换显示化</strong>。当一个对象仅以内部数据值来定义当前状态时，其状态仅表现为对一些变量的赋值，这不够明确。为不同的状态引入独立的对象使得转换变得更加明确。而且，State对象可保证Context不会发生内部状态不一致的情况，因为从Context的角度看，状态转换是原子的–只需重新绑定一个变量(即Context的State对象变量)，而无需多个变量赋值</li>
<li><strong>State对象可被共享</strong>。如果State对象没有实例变量–即它们表示的状态完全以它们的类型来编码，那么各Context对象可以共享一个State对象。当状态以这种方式被共享时，它们必然是没有内部状态，只有行为的轻量级对象。</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>实现State模式有多方面的考虑<ul>
<li><strong>谁定义状态转换</strong>。State模式不指定哪一个参与者定义状态转换准则。如果该准则是固定的，那么它们可在Context中完全实现。然而若让State子类自身指定它们的后继状态以及何时进行转换，通常更灵活更何时。这需要Context增加一个接口，让State对象显示的设定Context的当前状态。用这种方法分散转换逻辑可以很容易的定义新的State子类来修改和扩展该逻辑。这样做的一个缺点是，一个State子类至少拥有一个其他子类的信息，这就在各子类之间产生了实现依赖。</li>
<li><strong>基于表的另一种方法</strong>。在C++ Programming Style中，Cargil描述了另一种将结构加载在状态驱动的代码上的方法：他使用表将输入映射到状态转换。对每一个状态，一张表将每一个可能的输入映射到一个后继状态。实际上，这种方法将条件代码(和State模式下的虚函数)映射为一个查找表。表的主要好处是它们的规则性：你可以通过更改数据而不是更改程序代码来改变状态转换的准则。然而他也有一些缺点：<ul>
<li>对表的查找通常不如函数调用效率高</li>
<li>用统一的，表格的形式表示转换逻辑使得转换准则变得不够明确而难以理解</li>
<li>通常难以加入伴随状态转换的一些动作。表驱动的方法描述了状态和它们之间的转换，但必须扩充这个机制以便在每一个转换上能够进行任意的计算。</li>
<li>表驱动的状态机和State模式的主要区别可以被总结如下：<strong>State模式对与状态相关的行为进行建模，而表驱动的方法着重于定义状态转换</strong>。</li>
</ul>
</li>
<li><strong>创建和销毁State对象</strong>。一个常见的值的考虑的实现上的权衡是，究竟是 仅当需要State对象时才创建它们并随后销毁它们，还是提前创建它们并且始终不销毁它们。<ul>
<li>当将要进入的状态在运行时是不可知的，并且上下文不经常改变状态时，第一种选择较为可取。这种方法避免创建不会被用到的对象，如果State对象存储大量的信息时这一点很重要。</li>
<li>当状态改变很频繁时，第二种方法较好。在这种情况下最好避免销毁状态，因为可能很快再次需要用到它们。此时可以预先一次付清创建各个状态对象的开销，并且在运行过程中根本不存在销毁状态对象的开销。但是这种方法可能不太方便，因为Context必须保存对所有可能进入的那些状态的引用。</li>
</ul>
</li>
<li><strong>使用动态继承</strong>。改变一个响应特定请求的行为可以用在运行时刻改变这个对象的类的办法实现，但这在大多数面向对象程序设计语言中都是不可能的。和其他一些基于委托的语言确实例外，它们提供这种机制，从而直接支持State模式。Self中的对象可将操作委托给其他对象以达到某种形式的动态继承。在运行时刻改变委托的目标有效的改变了继承的结构。这一机制允许对象改变它们的行为，也就是改变它们得类。</li>
</ul>
</li>
</ul>
<h3 id="5-9-STRATEGY-策略-–-对象行为型模式"><a href="#5-9-STRATEGY-策略-–-对象行为型模式" class="headerlink" title="5.9 STRATEGY(策略)  – 对象行为型模式"></a>5.9 STRATEGY(策略)  – 对象行为型模式</h3><h3 id="5-10-TEMPLATE-METHOD-模板方法-–-对象行为型模式"><a href="#5-10-TEMPLATE-METHOD-模板方法-–-对象行为型模式" class="headerlink" title="5.10 TEMPLATE METHOD(模板方法)  – 对象行为型模式"></a>5.10 TEMPLATE METHOD(模板方法)  – 对象行为型模式</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/2024-05-22-README/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/2024-05-22-README/" class="post-title-link" itemprop="url">README</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C编程语言相关的笔记</li>
</ul>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul>
<li>C_1_理论基础.md [archive]<ul>
<li>C_1_理论基础.pdf</li>
</ul>
</li>
<li>C_2_重要函数.md</li>
<li>C_3_编程技巧.md</li>
<li>C_4_1_常用函数.md [archive]<ul>
<li>C_4_1_常用函数.pdf</li>
</ul>
</li>
<li>C_4_2_常用函数.md</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/2024-05-22-1_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/2024-05-22-1_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">1_2_常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>boost常用函数</li>
</ul>
<h2 id="boost-ignore-unused"><a href="#boost-ignore-unused" class="headerlink" title="boost::ignore_unused()"></a>boost::ignore_unused()</h2><p><code>boost::ignore_unused()</code> 不是一个函数，而是一个辅助函数宏，用于防止编译器产生“未使用变量”的警告。这个宏是在 Boost 库中定义的，位于 <code>&lt;boost/core/ignore_unused.hpp&gt;</code> 头文件中。</p>
<p>在 C++中，如果你声明了一个变量但在后续的代码中没有使用，编译器可能会发出警告。为了避免这样的警告，可以使用 <code>boost::ignore_unused()</code> 来告诉编译器你有意不使用这个变量。</p>
<p>下面是 <code>boost::ignore_unused()</code> 的简要说明和示例：</p>
<ol>
<li><p><strong>函数签名：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ignore_unused</span><span class="params">(Ts <span class="type">const</span>&amp;...)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个宏接受任意数量的参数，并在编译时告诉编译器忽略这些参数的未使用警告。</p>
</li>
<li><p><strong>使用场景：</strong></p>
<ul>
<li><strong>防止未使用变量的警告：</strong> 当你有意声明了一个变量但在后续的代码中没有使用时，可以使用 <code>boost::ignore_unused()</code> 来避免编译器产生未使用变量的警告。</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/core/ignore_unused.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止编译器警告，因为 y 没有在后续的代码中使用</span></span><br><span class="line">    boost::<span class="built_in">ignore_unused</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>boost::ignore_unused(x)</code> 告诉编译器忽略变量 <code>x</code> 的未使用警告。这在一些情况下很有用，例如在编写模板代码时，你可能有一些参数是在某些情况下使用的，但在其他情况下可能未使用。</p>
</li>
</ol>
<p>总的来说，<code>boost::ignore_unused()</code> 是一个方便的宏，用于防止编译器因未使用变量而产生的警告。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">1_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>boost库相关的笔记</li>
</ul>
<h2 id="Boost-库-编译-教程-详解"><a href="#Boost-库-编译-教程-详解" class="headerlink" title="Boost 库 编译 教程 详解"></a>Boost 库 编译 教程 详解</h2><p>Boost C++ 库是一个非常强大的 C++ 库，提供了大量的功能和工具，包括智能指针、多线程、正则表达式、容器、图形学等。编译 Boost 库可能会有一些复杂性，因为 Boost 包含了大量的头文件和库，但下面是一个简要的教程，演示如何编译 Boost 库。</p>
<p><strong>步骤 1：下载 Boost 库</strong></p>
<p>首先，您需要下载 Boost 库的源代码。您可以从 Boost 官方网站（<a target="_blank" rel="noopener" href="https://www.boost.org/%EF%BC%89%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84">https://www.boost.org/）下载最新版本的</a> Boost 库。将源代码文件解压到您选择的目录中。</p>
<p><strong>步骤 2：打开终端</strong></p>
<p>在终端中导航到 Boost 库的源代码目录。您可以使用 <code>cd</code> 命令切换到该目录。</p>
<p><strong>步骤 3：运行 Bootstrap 脚本</strong></p>
<p>Boost 提供了一个名为 <code>bootstrap.sh</code>（Linux&#x2F;macOS）或 <code>bootstrap.bat</code>（Windows）的脚本，用于配置编译过程。在终端中运行以下命令：</p>
<p>对于 Linux&#x2F;macOS：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bootstrap.sh</span><br></pre></td></tr></table></figure>

<p>对于 Windows：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.bat</span><br></pre></td></tr></table></figure>

<p>这将为您的系统配置 Boost 库的编译过程。</p>
<p><strong>步骤 4：运行 b2 命令</strong></p>
<p>接下来，您需要运行 <code>b2</code> 命令来编译 Boost 库。您可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./b2</span><br></pre></td></tr></table></figure>

<p>这将默认编译所有 Boost 库的组件。如果您只需要特定的库，您可以在 <code>b2</code> 命令后面添加库名称，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./b2 --prefix=/tmp/boost --with-filesystem --with-system</span><br></pre></td></tr></table></figure>

<p>这将仅编译文件系统和系统库。</p>
<p><strong>步骤 5：等待编译完成</strong></p>
<p>编译 Boost 库可能需要一些时间，具体取决于您的系统性能和所选的库。一旦编译完成，您将在 Boost 源代码目录中找到生成的库文件。</p>
<p><strong>步骤 6：安装 Boost 库</strong></p>
<p>您可以选择将编译后的库文件安装到系统目录中，以便其他项目可以轻松使用它们。运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./b2 install</span><br></pre></td></tr></table></figure>

<p>这将把库文件复制到系统的默认位置。</p>
<p>注意：在 Windows 上，您可能需要使用 Visual Studio 编译工具来编译 Boost 库。您可以在 Boost 官方网站上找到有关使用 Visual Studio 的更多信息。</p>
<p>这是一个简要的 Boost 库编译教程。具体的步骤可能因您的系统和需求而有所不同。为了获得更详细的信息和特定于您的平台的说明，请查阅 Boost 文档或参考 Boost 官方网站上的编译指南。</p>
<h2 id="cmake中引用Boost库"><a href="#cmake中引用Boost库" class="headerlink" title="cmake中引用Boost库"></a>cmake中引用Boost库</h2><ul>
<li><p>通过调用find_package可以找到头文件和所需要的库文件或者是一个CMake打包配置文件</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Boost</span><br><span class="line">  [version] [EXACT]      <span class="comment"># 可选项，最小版本或者确切所需版本</span></span><br><span class="line">  [REQUIRED]             <span class="comment"># 可选项，如果找不到所需库，报错</span></span><br><span class="line">  [COMPONENTS &lt;libs&gt;...] <span class="comment"># 所需的库名称，比如说. &quot;date_time&quot; 代表 &quot;libboost_date_time&quot;</span></span><br><span class="line">  )     </span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Boost <span class="number">1.62</span>.<span class="number">0</span> REQUIRED</span><br><span class="line">             COMPONENTS system filesystem thread)</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行之后可以得到很多变量，下面列了一些主要的:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Boost_FOUND            - 如果找到了所需的库就设为<span class="keyword">true</span></span><br><span class="line">Boost_INCLUDE_DIRS     - Boost头文件搜索路径</span><br><span class="line">Boost_LIBRARY_DIRS     - Boost库的链接路径</span><br><span class="line">Boost_LIBRARIES        - Boost库名，用于链接到目标程序</span><br><span class="line">Boost_VERSION          - 从boost/version.hpp文件获取的版本号</span><br><span class="line">Boost_LIB_VERSION      - 某个库的版本</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果Boost库是自定义安装路径，可以在搜索package之前，通过设置一些变量来帮助boost库查找</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOST_ROOT             - 首选的Boost安装路径</span><br><span class="line">BOOST_INCLUDEDIR       - 首选的头文件搜索路径 e.g. &lt;prefix&gt;/<span class="keyword">include</span></span><br><span class="line">BOOST_LIBRARYDIR       - 首选的库文件搜索路径 e.g. &lt;prefix&gt;/lib</span><br><span class="line">Boost_NO_SYSTEM_PATHS  - 默认是<span class="keyword">OFF</span>. 如果开启了，则不会搜索用户指定路径之外的路径</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果目标程序foo需要链接Boost库的regex和system，编写如下的CMakeist文件</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">project</span>(tutorial-<span class="number">0</span>)</span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.7</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(BOOST_ROOT /usr/local/<span class="keyword">install</span>/boost_1_62_0) // 设置boost库搜索路径</span><br><span class="line"><span class="keyword">set</span>(Boost_NO_SYSTEM_PATHS <span class="keyword">ON</span>) // 只搜索上语句设置的搜索路径</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Boost COMPONENTS regex system REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Boost_FOUND)</span><br><span class="line">    <span class="keyword">include_directories</span>(<span class="variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">MESSAGE</span>( STATUS <span class="string">&quot;Boost_INCLUDE_DIRS = $&#123;Boost_INCLUDE_DIRS&#125;.&quot;</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span>( STATUS <span class="string">&quot;Boost_LIBRARIES = $&#123;Boost_LIBRARIES&#125;.&quot;</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span>( STATUS <span class="string">&quot;Boost_LIB_VERSION = $&#123;Boost_LIB_VERSION&#125;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">add_executable</span>(foo foo.cpp)</span><br><span class="line">    <span class="keyword">target_link_libraries</span> (foo <span class="variable">$&#123;Boost_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></li>
<li><p>通过设置BOOST_ROOT来设置首选的搜索路径</p>
</li>
<li><p>通过MESSAGE函数把差找的结果都打印出来</p>
</li>
<li><p>Boost动态库链接。如果项目包含多个子模块，且子模块只用到顶层模块find_package找到的部分库，则用下述语句实现只链接子模块需要的Boost动态库</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(foo Boost::regex) // 只使用regex</span><br></pre></td></tr></table></figure>
</li>
<li><p>Boost头文件库链接。在Boost库中有部分库只用头文件实现，并没有响应的动态库，若使用这部分库可以通过以下语句实现</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(foo Boost::boost)</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Boost-C-库-使用示例-详解"><a href="#Boost-C-库-使用示例-详解" class="headerlink" title="Boost C++ 库 使用示例 详解"></a>Boost C++ 库 使用示例 详解</h2><p>Boost C++ 库包含了众多功能和组件，因此无法在一篇回答中详尽介绍所有。下面将展示一个使用 Boost 库的示例，涵盖智能指针、正则表达式和文件系统三个常用部分。请确保您已经成功编译了 Boost 库并将其包含在项目中。</p>
<p><strong>1. 智能指针（Smart Pointers）示例：</strong></p>
<p>智能指针帮助管理动态分配的内存，防止内存泄漏。以下是一个使用 Boost 智能指针的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">boost::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sharedInt</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared pointer value: &quot;</span> &lt;&lt; *sharedInt &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reference count: &quot;</span> &lt;&lt; sharedInt.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sharedInt 在离开作用域时会自动释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用了 <code>boost::shared_ptr</code> 来创建一个智能指针，它会自动管理整数的内存分配和释放。<code>use_count()</code> 函数用于获取引用计数。</p>
<p><strong>2. 正则表达式示例：</strong></p>
<p>Boost.Regex 提供了强大的正则表达式功能。以下是一个使用 Boost.Regex 的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/regex.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;Boost Libraries are awesome!&quot;</span>;</span><br><span class="line">    <span class="function">boost::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;Boost.*awesome&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (boost::<span class="built_in">regex_search</span>(text, reg)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中，我们使用 <code>boost::regex</code> 创建了一个正则表达式，然后使用 <code>boost::regex_search</code> 检查字符串中是否包含匹配的文本。</p>
<p><strong>3. 文件系统示例：</strong></p>
<p>Boost 文件系统库提供了文件和目录操作功能。以下是一个使用 Boost 文件系统库的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::<span class="function">filesystem::path <span class="title">dirPath</span><span class="params">(<span class="string">&quot;./my_directory&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (boost::filesystem::<span class="built_in">exists</span>(dirPath)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (boost::filesystem::<span class="built_in">is_directory</span>(dirPath)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Directory exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Not a directory.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Directory does not exist.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 <code>boost::filesystem::path</code> 表示目录路径，并使用 <code>boost::filesystem::exists</code> 和 <code>boost::filesystem::is_directory</code> 函数来检查目录是否存在以及是否为目录。</p>
<p>这些示例涵盖了 Boost C++ 库的一小部分功能。要使用 Boost 的其他组件和功能，请查阅 Boost 官方文档，其中包含了详细的教程和示例代码，以帮助您更好地理解和应用 Boost 库的各个组件。</p>
<h2 id="Boost-C-库-详解"><a href="#Boost-C-库-详解" class="headerlink" title="Boost C++ 库 详解"></a>Boost C++ 库 详解</h2><p>Boost C++ 库是一个非常受欢迎的开源 C++ 库集合，提供了各种功能和工具，用于增强 C++ 编程，包括数据结构、算法、多线程、正则表达式、智能指针、文件系统操作等。以下是 Boost C++ 库的一些主要组成部分和功能的详细介绍：</p>
<ol>
<li><p><strong>智能指针（Smart Pointers）</strong>：Boost 提供了各种智能指针，如 <code>shared_ptr</code>、<code>unique_ptr</code> 和 <code>weak_ptr</code>，用于管理动态分配的内存，以避免内存泄漏和提高代码安全性。</p>
</li>
<li><p><strong>容器和数据结构</strong>：Boost 包括许多增强的容器和数据结构，如 <code>unordered_map</code>、<code>unordered_set</code>、<code>multi_index</code>、<code>variant</code> 和 <code>any</code>，用于更有效地管理数据。</p>
</li>
<li><p><strong>多线程支持</strong>：Boost 提供了一套多线程库，包括线程、锁、条件变量和原子操作，以便于编写并发程序。</p>
</li>
<li><p><strong>正则表达式</strong>：Boost.Regex 提供了强大的正则表达式库，使您可以进行高级文本匹配和处理。</p>
</li>
<li><p><strong>文件系统</strong>：Boost 文件系统库允许您进行文件和目录的操作，包括文件检查、复制、移动和删除。</p>
</li>
<li><p><strong>日期时间和时间戳</strong>：Boost.Date_Time 库提供了日期、时间和时间戳处理的功能，可用于处理时间相关的任务。</p>
</li>
<li><p><strong>图形学库</strong>：Boost.Graph 库用于图形算法和数据结构，支持图形遍历、搜索和分析。</p>
</li>
<li><p><strong>泛型编程和元编程</strong>：Boost 具有强大的泛型编程和元编程工具，包括预处理器宏、类型萃取和模板元编程，用于创建通用、高效的代码。</p>
</li>
<li><p><strong>库之间的交互性</strong>：Boost 库之间通常能够很好地协同工作，因此您可以轻松地将它们组合在一起，以满足特定需求。</p>
</li>
<li><p><strong>跨平台性</strong>：Boost 在多种操作系统和编译器上都能正常工作，因此它具有很强的跨平台性。</p>
</li>
<li><p><strong>社区支持</strong>：Boost 是一个由社区驱动的项目，拥有广泛的用户和开发者社区，因此您可以在社区中获得支持和解答问题。</p>
</li>
<li><p><strong>C++标准化贡献</strong>：Boost 库中的一些功能已被采纳并成为 C++ 标准库的一部分，如智能指针 (<code>std::shared_ptr</code>、<code>std::unique_ptr</code>) 和正则表达式 (<code>std::regex</code>)。</p>
</li>
</ol>
<p>要使用 Boost 库，通常需要将其源代码包括头文件和库链接到您的项目中。您可以在 Boost 官方网站上找到详细的文档和教程，以帮助您入门和使用 Boost 库的各个组件。Boost 提供了广泛的文档和示例代码，以便您更好地理解和使用这些功能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/2024-05-22-1_3_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/2024-05-22-1_3_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">1_3_编程技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>BOOST常用编程技巧</li>
</ul>
<h2 id="boost-filesystem-path-转-std-string"><a href="#boost-filesystem-path-转-std-string" class="headerlink" title="boost::filesystem::path 转 std::string"></a>boost::filesystem::path 转 std::string</h2><p>要将 <code>boost::filesystem::path</code> 转换为 <code>std::string</code>，你可以使用 <code>boost::filesystem::path</code> 对象的 <code>string()</code> 成员函数。这个函数返回一个表示路径的 <code>std::string</code>。以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::<span class="function">filesystem::path <span class="title">filePath</span><span class="params">(<span class="string">&quot;/path/to/your/file.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 boost::filesystem::path 转换为 std::string</span></span><br><span class="line">    std::string filePathString = filePath.<span class="built_in">string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印转换后的 std::string</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;File path as string: &quot;</span> &lt;&lt; filePathString &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>filePath.string()</code> 函数将 <code>boost::filesystem::path</code> 对象 <code>filePath</code> 转换为一个 <code>std::string</code>，然后我们将其打印出来。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/2024-05-22-1_0_boost_%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/2024-05-22-1_0_boost_%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">1_0_boost_概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Boost 库概述</li>
</ul>
<h2 id="cmake配置boost"><a href="#cmake配置boost" class="headerlink" title="cmake配置boost"></a>cmake配置boost</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Boost <span class="number">1.86</span> REQUIRED COMPONENTS system filesystem PATHS <span class="string">&quot;$&#123;BaseDIR&#125;/packages/boost_1_86_0/lib/cmake/Boost-1.86.0/&quot;</span> )</span><br><span class="line"><span class="keyword">if</span>(Boost_FOUND)</span><br><span class="line">    <span class="keyword">include_directories</span>(<span class="variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">MESSAGE</span>( STATUS <span class="string">&quot;Boost_INCLUDE_DIRS = $&#123;Boost_INCLUDE_DIRS&#125;.&quot;</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span>( STATUS <span class="string">&quot;Boost_LIBRARIES = $&#123;Boost_LIBRARIES&#125;.&quot;</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span>( STATUS <span class="string">&quot;Boost_LIB_VERSION = $&#123;Boost_LIB_VERSION&#125;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">add_executable</span>(foo foo.cpp)</span><br><span class="line">    <span class="keyword">target_link_libraries</span> (foo <span class="variable">$&#123;Boost_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h2 id="C-boost库是什么"><a href="#C-boost库是什么" class="headerlink" title="C++ boost库是什么"></a>C++ boost库是什么</h2><p><strong>Boost</strong> 是一个功能强大的 C++ 库集合，为开发者提供广泛的、可移植的功能扩展。它被设计为标准库（STL）的补充，是现代 C++ 编程的重要工具。Boost 提供了许多高质量的库，涵盖了文件系统操作、多线程处理、智能指针、正则表达式、图算法等多个领域。</p>
<hr>
<h3 id="Boost-的主要特点"><a href="#Boost-的主要特点" class="headerlink" title="Boost 的主要特点"></a><strong>Boost 的主要特点</strong></h3><ol>
<li><strong>跨平台支持</strong>：Boost 的库可以在不同操作系统和编译器之间无缝工作。</li>
<li><strong>标准化来源</strong>：Boost 的许多功能后来被采纳进了 C++ 标准库，例如 <code>std::shared_ptr</code> 和正则表达式。</li>
<li><strong>模块化设计</strong>：Boost 包含了 100 多个模块，开发者可以按需使用特定的库，而不需要加载整个库集合。</li>
<li><strong>高性能和可靠性</strong>：Boost 提供的功能经过社区的广泛测试和优化，性能优异且稳定。</li>
</ol>
<hr>
<h3 id="Boost-的常用模块"><a href="#Boost-的常用模块" class="headerlink" title="Boost 的常用模块"></a><strong>Boost 的常用模块</strong></h3><p>以下是一些常用的 Boost 模块及其功能：</p>
<ol>
<li><p><strong>Boost.SmartPtr</strong><br>提供智能指针（如 <code>shared_ptr</code>, <code>weak_ptr</code>），简化内存管理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="function">boost::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Boost.Regex</strong><br>提供强大的正则表达式功能，类似于 <code>std::regex</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/regex.hpp&gt;</span></span></span><br><span class="line"><span class="function">boost::regex <span class="title">expr</span><span class="params">(<span class="string">&quot;(\\w+)@(\\w+\\.\\w+)&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Boost.Thread</strong><br>实现多线程编程，包括线程同步工具（如 <code>mutex</code> 和 <code>condition_variable</code>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="function">boost::thread <span class="title">t</span><span class="params">([] &#123; std::cout &lt;&lt; <span class="string">&quot;Hello from Boost.Thread!&quot;</span> &lt;&lt; std::endl; &#125;)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Boost.Filesystem</strong><br>提供跨平台的文件和目录操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line">boost::<span class="function">filesystem::path <span class="title">p</span><span class="params">(<span class="string">&quot;/path/to/file&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Boost.Asio</strong><br>支持异步输入输出（I&#x2F;O）操作，用于网络编程和异步任务管理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line">boost::asio::io_context io;</span><br><span class="line">boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(io, boost::asio::chrono::seconds(<span class="number">5</span>))</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Boost.Serialization</strong><br>支持对象序列化和反序列化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/archive/text_oarchive.hpp&gt;</span></span></span><br><span class="line">boost::<span class="function">archive::text_oarchive <span class="title">oa</span><span class="params">(std::cout)</span></span>;</span><br><span class="line">oa &lt;&lt; my_object;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Boost.Graph</strong><br>提供图算法和数据结构，用于复杂的图计算。</p>
</li>
</ol>
<hr>
<h3 id="Boost-的安装与使用"><a href="#Boost-的安装与使用" class="headerlink" title="Boost 的安装与使用"></a><strong>Boost 的安装与使用</strong></h3><ol>
<li><p><strong>下载与安装</strong>：</p>
<ul>
<li>从 <a target="_blank" rel="noopener" href="https://www.boost.org/">Boost 官方网站</a> 下载最新版本。</li>
<li>解压后构建必要的库（静态或动态）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bootstrap.sh</span><br><span class="line">./b2</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>项目中使用 Boost</strong>：</p>
<ul>
<li>在编译器中添加 Boost 的头文件路径：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -I /path/to/boost/include -L /path/to/boost/lib -lboost_system</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="Boost-的使用场景"><a href="#Boost-的使用场景" class="headerlink" title="Boost 的使用场景"></a><strong>Boost 的使用场景</strong></h3><ul>
<li><strong>高效的内存管理</strong>：通过智能指针管理动态分配的内存，避免内存泄漏。</li>
<li><strong>跨平台文件操作</strong>：使用 Boost.Filesystem 处理文件路径和文件操作。</li>
<li><strong>异步编程</strong>：Boost.Asio 提供高效的异步任务处理和网络编程支持。</li>
<li><strong>多线程开发</strong>：Boost.Thread 为跨平台线程编程提供一致的接口。</li>
</ul>
<hr>
<h3 id="Boost-的优缺点"><a href="#Boost-的优缺点" class="headerlink" title="Boost 的优缺点"></a><strong>Boost 的优缺点</strong></h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>提供大量实用工具，节省开发时间。</li>
<li>社区活跃，文档详尽。</li>
<li>与 C++ 标准库深度结合，部分功能已纳入 C++ 标准。</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>有些模块的学习曲线较陡。</li>
<li>部分库构建耗时较长。</li>
<li>在某些情况下，库的体积较大。</li>
</ul>
<hr>
<h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a><strong>相关资源</strong></h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.boost.org/">Boost 官方网站</a></li>
<li><a target="_blank" rel="noopener" href="https://zhboost.readthedocs.io/">Boost 中文教程</a><br>如果需要更详细的代码示例或使用指导，请告诉我！</li>
</ul>
<h2 id="BOOST库-有哪些模块-详解"><a href="#BOOST库-有哪些模块-详解" class="headerlink" title="BOOST库 有哪些模块 详解"></a>BOOST库 有哪些模块 详解</h2><p>Boost 库是一个流行的 C++ 库集合，提供了各种各样的模块和功能，涵盖了多个领域，包括但不限于数据结构、算法、多线程、文件系统、网络编程、数学计算等。下面是一些主要的 Boost 模块：</p>
<ol>
<li><p><strong>Boost.Asio</strong>：提供异步 I&#x2F;O 和网络编程功能，包括套接字、TCP、UDP、定时器、异步任务等，用于构建高性能网络应用程序。</p>
</li>
<li><p><strong>Boost.Beast</strong>：基于 Boost.Asio，提供对 HTTP、WebSocket 和网络通信的支持，简化了处理 HTTP 和 WebSocket 协议的操作。</p>
</li>
<li><p><strong>Boost.Filesystem</strong>：提供了对文件系统操作的抽象接口，包括文件路径操作、文件&#x2F;目录的创建、删除、移动、复制等。</p>
</li>
<li><p><strong>Boost.Thread</strong> 和 <strong>Boost.Atomic</strong>：提供了多线程和原子操作的支持，使得在 C++ 中更容易编写并发代码。</p>
</li>
<li><p><strong>Boost.Container</strong>：提供了一系列 STL 容器的扩展和优化版本，如 flat_map、flat_set、static_vector 等，增强了标准库中的容器功能。</p>
</li>
<li><p><strong>Boost.Graph</strong>：提供了图论相关的数据结构和算法，包括图的表示、遍历、最短路径等操作。</p>
</li>
<li><p><strong>Boost.Math</strong>：提供了数学计算的库，包括数值计算、特殊函数、概率分布、统计函数等，用于处理数学问题。</p>
</li>
<li><p><strong>Boost.Serialization</strong>：提供了用于对象序列化和反序列化的库，可以将对象转换为字节流以便存储或传输，并从字节流恢复为对象。</p>
</li>
<li><p><strong>Boost.Regex</strong>：提供了正则表达式的功能，用于文本匹配和处理。</p>
</li>
<li><p><strong>Boost.Date_Time</strong>：提供了日期和时间处理的库，包括日期时间表示、格式化、时区处理等。</p>
</li>
<li><p><strong>Boost.PropertyTree</strong>：用于处理树状结构的数据，例如 XML、JSON 等格式的数据。</p>
</li>
<li><p><strong>Boost.UUID</strong>：用于生成和操作 UUID（通用唯一标识符）的库。</p>
</li>
<li><p><strong>Boost.Test</strong>：提供了单元测试框架，用于进行 C++ 程序的单元测试。</p>
</li>
<li><p><strong>Boost.Locale</strong>：提供了本地化和国际化支持，包括字符集转换、日期时间格式化、货币格式化等功能。</p>
</li>
<li><p><strong>Boost.Process</strong>：提供了对进程的管理和操作功能。</p>
</li>
</ol>
<p>以上列举的模块只是 Boost 库中的一小部分，Boost 还包含许多其他模块和库，每个模块都专注于不同的领域，为 C++ 开发提供了广泛的工具和功能支持。每个模块都有其自己的文档和用法，开发者可以根据需要选择并使用适合的模块。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Compiler/2024-05-22-gcc_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Compiler/2024-05-22-gcc_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">gcc_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Compiler/" itemprop="url" rel="index"><span itemprop="name">Compiler</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>gcc 编译器相关理论知识</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/Compiler/2024-05-22-gcc_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-1_3_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-1_3_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" class="post-title-link" itemprop="url">1_3_目标检测</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>目标检测相关笔记</li>
<li>除了图像分类，图像生成，图像去噪，目标检测也是计算机视觉领域非常常见的一类问题。其在人脸检测，行人检测，图像检索和视频监控等方面有广泛应用。</li>
</ul>
<h2 id="目标检测是什么"><a href="#目标检测是什么" class="headerlink" title="目标检测是什么"></a>目标检测是什么</h2><ul>
<li>目标检测，英文为Object Detection，有时候也称之为物体检测，物体识别等。简单来讲，目标检测是与计算机视觉和图像处理有关的计算机技术，其涉及在数字图像和视频中检测特定类（例如人，建筑物或汽车）的语义对象的实例。目标检测在人脸检测，行人检测，图像检索和视频监控等计算机视觉领域有广泛的应用。动态物体检测与识别也是自动驾驶中需要攻克的一项关键技术。</li>
<li>目标检测实际上就主要做一件事情。识别图像中指定存在的所有对象及其位置，并标示出来</li>
</ul>
<h2 id="目标检测的前处理"><a href="#目标检测的前处理" class="headerlink" title="目标检测的前处理"></a>目标检测的前处理</h2><ul>
<li><p>目标检测的前处理技术主要包括图像预处理、特征提取、数据增强等。图像预处理包括图像缩放、归一化、旋转、剪裁等操作，这能够对原始图像进行一定的优化和处理，提高模型的鲁棒性和准确率。特征提取是从原始图像中提取目标特征的过程，常用的提取特征的方式有卷积神经网络（CNN）、霍夫变换、边缘检测等方法。数据增强则是通过对原始图像进行变换，如随机裁剪、随机翻转、亮度调节、添加噪声等操作，增加训练数据量，提高模型的泛化能力。</p>
</li>
<li><p>通过OpenCV读取图片，对图片进行缩放</p>
</li>
</ul>
<h2 id="机器学习和深度学习中关于图像数据输入的-Shape"><a href="#机器学习和深度学习中关于图像数据输入的-Shape" class="headerlink" title="机器学习和深度学习中关于图像数据输入的 Shape"></a>机器学习和深度学习中关于图像数据输入的 Shape</h2><ul>
<li><p>在机器学习的图片输入数据中，只需要将图片数据的4维(图片的多少，图片的长，图片的宽，图片的通道数)转换为2维即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_data = train_data.reshape(train_data.shape[0], train_data.shape[1] * train_data.shape[2] * train_data.shape[3])</span><br></pre></td></tr></table></figure>
</li>
<li><p>深度学习，读取图片阶段:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item_image = cv2.imread(img_path)</span><br><span class="line">item_image = cv2.resize(item_image, (224,224), interpolation=cv2.INTER_AREA)</span><br></pre></td></tr></table></figure>
<ul>
<li>cv2.imread()是为了读取图片上的数据，也就是原始图像数据的信息。</li>
<li>在cv2.resize()中，可以指定输出图片的大小，也就是图片的长和宽。</li>
</ul>
</li>
<li><p>把读取到数据转换成ndarray</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_data = np.array(train_data, dtype=&#x27;float32&#x27;)</span><br></pre></td></tr></table></figure></li>
<li><p>此时，如果打印train_data的维度，会显示一个4个维度的数据，(图片的数量，图片的长，图片的宽，图片的通道数)</p>
</li>
<li><p>shape</p>
<ul>
<li>图像形状，行数，列数，通道数</li>
</ul>
</li>
<li><p>size</p>
<ul>
<li>图像大小，行数 * 列数 * 通道数</li>
</ul>
</li>
<li><p>dtype</p>
<ul>
<li>图像数据类型，通常为uint8</li>
</ul>
</li>
</ul>
<h2 id="目标检测的后处理"><a href="#目标检测的后处理" class="headerlink" title="目标检测的后处理"></a>目标检测的后处理</h2><ul>
<li><p>目标检测的后处理技术主要是指对目标检测算法的输出进行调整和优化，以提高检测结果的准确性和稳定性。</p>
</li>
<li><p>后处理技术一般包括非极大值抑制（NMS）、筛选、矫正等方法。</p>
</li>
<li><p>非极大值抑制是指对检测框进行去重和筛选，只保留探测到的目标中得分最高的那一个，并抑制周围高度重叠的框。</p>
</li>
<li><p>筛选技术是指判断目标是否符合检测条件，去掉检测到的误检目标或不符合条件的目标。</p>
</li>
<li><p>矫正技术是指对检测框的位置和倾斜角度进行矫正，使得目标在图像中的位置更为精确，提高识别准确性。这些技术通常在目标检测的训练和测试过程中都会使用。</p>
</li>
<li><p>目标检测并不一定需要后处理，但通常情况下会进行后处理来进一步提高模型的准确性和稳定性。后处理技术能够对目标检测的结果进行优化和调整，例如去除重复检测框、筛选、矫正等等</p>
</li>
<li><p>在目标检测中，由于前景和背景的比例极为不平衡，因此检测框往往会出现大量的误检和漏检。后处理技术能够对这些问题进行针对性的处理，提高最终的检测准确率</p>
</li>
<li><p>常用的后处理技术包括非极大值抑制（NMS）、筛选、矫正等。这些技术不仅可以提高目标检测的准确性，还能够缩短检测时间、减少处理数据的复杂度，从而优化算法的整体性能。因此，目标检测中通常会使用后处理技术来优化模型的表现</p>
</li>
</ul>
<h2 id="NMS-Non-Maximum-Suppression"><a href="#NMS-Non-Maximum-Suppression" class="headerlink" title="NMS(Non-Maximum Suppression)"></a>NMS(Non-Maximum Suppression)</h2><ul>
<li><p>NMS（Non-Maximum Suppression）是目标检测中常用的一种后处理技术，用于去除重复的检测结果，只保留最佳的目标框，从而提高模型精度和效率</p>
</li>
<li><p>NMS的原理是基于阈值和重叠率进行筛选。假设模型输出了多个待筛选的检测框，每个检测框都有一个置信度分数，表示该框中包含目标的概率。NMS需要分别对每个类别的检测框进行处理</p>
</li>
<li><p>详细流程如下</p>
<ul>
<li>首先，按照置信度分数从高到低对检测框进行排序。</li>
<li>取分数最高的检测框A，作为起始框，并从剩余的框里删除A。</li>
<li>按照重叠率的大小判断剩余框中是否与A重叠，若存在则计算它们的IoU值（交并比）。</li>
<li>若IoU值大于预设阈值（一般设为0.5），则将该框从剩余框中删除；若IoU值小于阈值，则保留该框。</li>
<li>重复第2-4步，直到剩余框中没有可删除的框，即所有检测框都被筛选过了。</li>
<li>将剩余的保留框和置信度分数返回。</li>
</ul>
</li>
<li><p>下面是一个简单的Python实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def nms(detections, threshold=0.5):</span><br><span class="line">    # detections: 待筛选的检测框列表，每个元素为(x1, y1, x2, y2, score)</span><br><span class="line">    # threshold: 阈值，设定IoU值小于阈值的框为非极大值框</span><br><span class="line">    </span><br><span class="line">    if len(detections) == 0:</span><br><span class="line">        return []</span><br><span class="line">    </span><br><span class="line">    # 按照置信度分数从高到低排序</span><br><span class="line">    detections = sorted(detections, key=lambda x: x[4], reverse=True)</span><br><span class="line">    </span><br><span class="line">    # 用于保存最终保留下来的检测框</span><br><span class="line">    keep = []</span><br><span class="line">    </span><br><span class="line">    while len(detections) &gt; 0:</span><br><span class="line">        # 取分数最高的框作为起始框</span><br><span class="line">        A = detections[0]</span><br><span class="line">        keep.append(A)</span><br><span class="line">        </span><br><span class="line">        # 计算该起始框和剩余框的IoU值</span><br><span class="line">        B = detections[1:]</span><br><span class="line">        overlaps = [iou(A, b) for b in B]</span><br><span class="line">        </span><br><span class="line">        # 将IoU值大于阈值的框删除</span><br><span class="line">        indices = [i+1 for i, overlap in enumerate(overlaps) if overlap &gt; threshold]</span><br><span class="line">        detections = [b for i, b in enumerate(detections) if i not in indices]</span><br><span class="line">        </span><br><span class="line">    return keep</span><br></pre></td></tr></table></figure></li>
<li><p>其中，iou函数用于计算两个框之间的IoU值。</p>
</li>
<li><p>目前有很多对NMS算法的改进方法。下面是几种常见的NMS改进方法：</p>
<ul>
<li>Soft-NMS：传统的NMS是直接抑制掉重叠框中候选框中分数较低的框，而Soft-NMS通过修改分数的方式，将重叠的框的分数逐渐降低。例如，重叠的框的分数会随着IoU值的增加而逐渐减少，而不是直接变为0。这样做可以让模型更加关注可靠的检测结果，避免错判。</li>
<li>Adaptive NMS：Adaptive NMS主要是为了解决NMS不同的IoU阈值不适用于不同的物体大小和密度的问题。它引入了一个Adaptive Parameter，该参数会根据候选框大小和样例分布自适应地调整IoU阈值，从而更好地适应不同尺寸的物体目标</li>
<li>Soft-NMS with Learnable Weight Scheme：Soft-NMS技术引入了一个权重系数，确定哪些重叠框应该被抑制，而Soft-NMS-LWS则引入了一个学习的权重计算任务，让模型自己学习如何更好地选择重叠框。</li>
</ul>
</li>
<li><p>这种方法通常会在训练期间学习最佳的权重，并且适用于NMS抑制的具有不同尺度粒度的多个检测结果</p>
</li>
<li><p>这些改进方法的核心思想都是为了更好地处理较为复杂的目标检测情况，例如遮挡和噪声干扰等。同时，这些改进方法还可以进一步提高检测精度并减少误检率，相对于传统的NMS方法表现更出色</p>
</li>
<li><p>目标检测算法中，有些方法可以不需要显式的NMS后处理技术，例如YOLO和SSD（Single Shot MultiBox Detector）。这些方法具有以下特点</p>
<ul>
<li>YOLO：YOLO（You Only Look Once）是一种实时的目标检测算法，它的目标检测过程是在单个神经网络中并行进行的。YOLO将整个图像分成多个网格，每个网格预测出N个边界框及它们的置信度，然后根据置信度和类别得分，筛选出最佳的框。在选择框时，YOLO使用了阈值（置信度分数），减少了重叠框的存在，从而取代了传统的NMS技术。这种方式不仅能够实现快速检测，还能避免高阈值造成的误检和低阈值造成的漏检</li>
<li>SSD：SSD（Single Shot MultiBox Detector）也是一种实时目标检测算法，与YOLO类似，它也是将整个图像分成多个网格进行处理。但SSD采用的是先验框机制，通过预设的先验框，让模型更加有效的学到各个物体的形状和大小等特征。在每个网格上，SSD预测出每个先验框的位置和它们所属的类别，然后通过非最大抑制的方式删除一些冗余的框。相比其他的检测算法，SSD是一种速度较快，精度较高的算法。</li>
</ul>
</li>
</ul>
<h2 id="图像处理-维基百科"><a href="#图像处理-维基百科" class="headerlink" title="图像处理(维基百科)"></a>图像处理(维基百科)</h2><ul>
<li><p>图像处理是指对图像进行分析，加工和处理，使其满足视觉，心理或其他要求的技术。图像处理是信号处理在图像领域上的一个应用。目前大多数的图像均是以数字形式存储，因而图像处理很多情况下指数字图像处理。此外，基于光学理论的处理方法依然占有重要的地位。</p>
</li>
<li><p>图像处理是信号处理的子类，另外与计算机科学、人工智能等领域也有密切的关系</p>
</li>
<li><p>传统的一维信号处理的方法和概念很多仍然可以直接应用在图像处理上，比如降噪、量化等。然而，图像属于二维信号，和一维信号相比，它有自己特殊的一面，处理的方式和角度也有所不同</p>
</li>
<li><p>常用的信号处理技术</p>
<ul>
<li>大多数用于一维信号处理的概念都有其在二维图像信号领域的延伸，它们之中的一部分在二维情形下变得十分复杂。 同时图像处理自身也具有一些新的概念， 例如，连通性、旋转不变性，等等。这些概念仅对二维或更高维的情况下才有非平凡的意义。</li>
<li>图像处理中常用到快速傅立叶变换，因为它可以减小数据处理量和处理时间。</li>
</ul>
</li>
<li><p>从一维信号处理扩展来的技术和概念</p>
<ul>
<li>分辨率</li>
<li>动态范围</li>
<li>带宽</li>
<li>滤波器设计</li>
<li>微分算子</li>
<li>边缘检测</li>
<li>Domain modulation</li>
<li>降噪(Noise reduction)</li>
</ul>
</li>
<li><p>专用于二维（或更高维）的技术和概念</p>
<ul>
<li>连通性</li>
<li>旋转不变性</li>
</ul>
</li>
<li><p>典型问题</p>
<ul>
<li>几何变换(geometric transformations): 包括放大，缩小，旋转等</li>
<li>颜色处理(color): 颜色空间的转化，亮度以及对比度的调节，颜色修正等</li>
<li>图像融合(image composite): 多个图像的加，减，组合，拼接等</li>
<li>降噪(image denoising): 研究各种针对二维图像的去噪滤波器或者信号处理技术</li>
<li>边缘检测: 进行边缘或者其他局部特征提取</li>
<li>分割: 依据不同标准，把二维图像分割成不同区域</li>
<li>图像编辑: 和计算机图形学有一定交叉</li>
<li>图像配准: 比较或集成不同条件下获取的图像</li>
<li>图像增强(image enhancement)</li>
<li>图像数字水印: 研究图像域的数据隐藏，加密或者认证</li>
<li>图像压缩: 研究图像压缩</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li>摄影以及印刷</li>
<li>卫星图像处理(Statellite image processing)</li>
<li>医学图像处理(Medical image processing)</li>
<li>面孔识别，特征识别(Face detection, feature detection, face identification)</li>
<li>显微图像处理(Microscope image processing)</li>
<li>汽车障碍识别(Car barrier detection)</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-2_1_NVIDIA_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-2_1_NVIDIA_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">2_1_NVIDIA_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>NVIDIA 硬件平台下深度学习相关的理论基础</li>
</ul>
<h2 id="TensorRT-txtexec-工具"><a href="#TensorRT-txtexec-工具" class="headerlink" title="TensorRT txtexec 工具"></a>TensorRT txtexec 工具</h2><p><code>txtexec</code> 是 NVIDIA TensorRT 中的一个实用工具，用于从文本文件加载和执行优化后的推理引擎（<code>.engine</code> 文件）。这个工具可以用于在命令行中加载和运行已经通过 TensorRT 优化的模型，而无需编写额外的代码。下面我会对 <code>txtexec</code> 进行详细解释：</p>
<ol>
<li><p><strong>加载和执行引擎</strong>：<code>txtexec</code> 工具允许你通过命令行加载和执行优化过的引擎文件（<code>.engine</code> 文件）。这意味着你可以使用这个工具在没有额外编程的情况下运行经过优化的深度学习模型。</p>
</li>
<li><p><strong>命令行语法</strong>：<code>txtexec</code> 的命令行语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txtexec [-h] --loadEngine=&lt;string&gt; [--iterations=&lt;int&gt;] [--avgRuns=&lt;int&gt;]</span><br><span class="line">        [--warmUp=&lt;int&gt;] [--useDLA=&lt;int&gt;] [--useSpinWait] [--threads=&lt;int&gt;]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>--loadEngine</code>：指定要加载的 <code>.engine</code> 文件的路径。</li>
<li><code>--iterations</code>：指定进行推理的迭代次数（默认为 1）。</li>
<li><code>--avgRuns</code>：指定多次推理运行的平均次数（默认为 1）。</li>
<li><code>--warmUp</code>：指定预热运行的次数，这些运行不会计入统计（默认为 0）。</li>
<li><code>--useDLA</code>：指定是否使用深度学习加速器（DLA），0 表示不使用，1 表示使用（默认为 0）。</li>
<li><code>--useSpinWait</code>：指定是否使用自旋等待进行同步。</li>
<li><code>--threads</code>：指定并行线程数（默认为 1）。</li>
</ul>
</li>
<li><p><strong>使用示例</strong>：以下是一个示例命令行使用 <code>txtexec</code> 加载并执行 <code>.engine</code> 文件的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txtexec --loadEngine=my_model.engine --iterations=100 --avgRuns=10 --useDLA=0</span><br></pre></td></tr></table></figure>

<p>这个命令将加载名为 <code>my_model.engine</code> 的引擎文件，进行 100 次迭代的推理，每次推理进行 10 次运行取平均，并且不使用深度学习加速器。</p>
</li>
</ol>
<p>请注意，<code>txtexec</code> 工具是 TensorRT 的一个辅助工具，主要用于快速测试和验证模型的推理性能。对于更复杂的应用和场景，通常需要在代码中使用 TensorRT 的 API 进行推理。详细的用法和配置可以在 NVIDIA 的 TensorRT 文档中找到。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
