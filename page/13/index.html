<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/13/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">1_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>boost库相关的笔记</li>
</ul>
<h2 id="Boost-库-编译-教程-详解"><a href="#Boost-库-编译-教程-详解" class="headerlink" title="Boost 库 编译 教程 详解"></a>Boost 库 编译 教程 详解</h2><p>Boost C++ 库是一个非常强大的 C++ 库，提供了大量的功能和工具，包括智能指针、多线程、正则表达式、容器、图形学等。编译 Boost 库可能会有一些复杂性，因为 Boost 包含了大量的头文件和库，但下面是一个简要的教程，演示如何编译 Boost 库。</p>
<p><strong>步骤 1：下载 Boost 库</strong></p>
<p>首先，您需要下载 Boost 库的源代码。您可以从 Boost 官方网站（<a target="_blank" rel="noopener" href="https://www.boost.org/%EF%BC%89%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84">https://www.boost.org/）下载最新版本的</a> Boost 库。将源代码文件解压到您选择的目录中。</p>
<p><strong>步骤 2：打开终端</strong></p>
<p>在终端中导航到 Boost 库的源代码目录。您可以使用 <code>cd</code> 命令切换到该目录。</p>
<p><strong>步骤 3：运行 Bootstrap 脚本</strong></p>
<p>Boost 提供了一个名为 <code>bootstrap.sh</code>（Linux&#x2F;macOS）或 <code>bootstrap.bat</code>（Windows）的脚本，用于配置编译过程。在终端中运行以下命令：</p>
<p>对于 Linux&#x2F;macOS：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bootstrap.sh</span><br></pre></td></tr></table></figure>

<p>对于 Windows：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.bat</span><br></pre></td></tr></table></figure>

<p>这将为您的系统配置 Boost 库的编译过程。</p>
<p><strong>步骤 4：运行 b2 命令</strong></p>
<p>接下来，您需要运行 <code>b2</code> 命令来编译 Boost 库。您可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./b2</span><br></pre></td></tr></table></figure>

<p>这将默认编译所有 Boost 库的组件。如果您只需要特定的库，您可以在 <code>b2</code> 命令后面添加库名称，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./b2 --prefix=/tmp/boost --with-filesystem --with-system</span><br></pre></td></tr></table></figure>

<p>这将仅编译文件系统和系统库。</p>
<p><strong>步骤 5：等待编译完成</strong></p>
<p>编译 Boost 库可能需要一些时间，具体取决于您的系统性能和所选的库。一旦编译完成，您将在 Boost 源代码目录中找到生成的库文件。</p>
<p><strong>步骤 6：安装 Boost 库</strong></p>
<p>您可以选择将编译后的库文件安装到系统目录中，以便其他项目可以轻松使用它们。运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./b2 install</span><br></pre></td></tr></table></figure>

<p>这将把库文件复制到系统的默认位置。</p>
<p>注意：在 Windows 上，您可能需要使用 Visual Studio 编译工具来编译 Boost 库。您可以在 Boost 官方网站上找到有关使用 Visual Studio 的更多信息。</p>
<p>这是一个简要的 Boost 库编译教程。具体的步骤可能因您的系统和需求而有所不同。为了获得更详细的信息和特定于您的平台的说明，请查阅 Boost 文档或参考 Boost 官方网站上的编译指南。</p>
<h2 id="cmake中引用Boost库"><a href="#cmake中引用Boost库" class="headerlink" title="cmake中引用Boost库"></a>cmake中引用Boost库</h2><ul>
<li><p>通过调用find_package可以找到头文件和所需要的库文件或者是一个CMake打包配置文件</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Boost</span><br><span class="line">  [version] [EXACT]      <span class="comment"># 可选项，最小版本或者确切所需版本</span></span><br><span class="line">  [REQUIRED]             <span class="comment"># 可选项，如果找不到所需库，报错</span></span><br><span class="line">  [COMPONENTS &lt;libs&gt;...] <span class="comment"># 所需的库名称，比如说. &quot;date_time&quot; 代表 &quot;libboost_date_time&quot;</span></span><br><span class="line">  )     </span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Boost <span class="number">1.62</span>.<span class="number">0</span> REQUIRED</span><br><span class="line">             COMPONENTS system filesystem thread)</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行之后可以得到很多变量，下面列了一些主要的:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Boost_FOUND            - 如果找到了所需的库就设为<span class="keyword">true</span></span><br><span class="line">Boost_INCLUDE_DIRS     - Boost头文件搜索路径</span><br><span class="line">Boost_LIBRARY_DIRS     - Boost库的链接路径</span><br><span class="line">Boost_LIBRARIES        - Boost库名，用于链接到目标程序</span><br><span class="line">Boost_VERSION          - 从boost/version.hpp文件获取的版本号</span><br><span class="line">Boost_LIB_VERSION      - 某个库的版本</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果Boost库是自定义安装路径，可以在搜索package之前，通过设置一些变量来帮助boost库查找</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOST_ROOT             - 首选的Boost安装路径</span><br><span class="line">BOOST_INCLUDEDIR       - 首选的头文件搜索路径 e.g. &lt;prefix&gt;/<span class="keyword">include</span></span><br><span class="line">BOOST_LIBRARYDIR       - 首选的库文件搜索路径 e.g. &lt;prefix&gt;/lib</span><br><span class="line">Boost_NO_SYSTEM_PATHS  - 默认是<span class="keyword">OFF</span>. 如果开启了，则不会搜索用户指定路径之外的路径</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果目标程序foo需要链接Boost库的regex和system，编写如下的CMakeist文件</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">project</span>(tutorial-<span class="number">0</span>)</span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.7</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(BOOST_ROOT /usr/local/<span class="keyword">install</span>/boost_1_62_0) // 设置boost库搜索路径</span><br><span class="line"><span class="keyword">set</span>(Boost_NO_SYSTEM_PATHS <span class="keyword">ON</span>) // 只搜索上语句设置的搜索路径</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Boost COMPONENTS regex system REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Boost_FOUND)</span><br><span class="line">    <span class="keyword">include_directories</span>(<span class="variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">MESSAGE</span>( STATUS <span class="string">&quot;Boost_INCLUDE_DIRS = $&#123;Boost_INCLUDE_DIRS&#125;.&quot;</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span>( STATUS <span class="string">&quot;Boost_LIBRARIES = $&#123;Boost_LIBRARIES&#125;.&quot;</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span>( STATUS <span class="string">&quot;Boost_LIB_VERSION = $&#123;Boost_LIB_VERSION&#125;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">add_executable</span>(foo foo.cpp)</span><br><span class="line">    <span class="keyword">target_link_libraries</span> (foo <span class="variable">$&#123;Boost_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></li>
<li><p>通过设置BOOST_ROOT来设置首选的搜索路径</p>
</li>
<li><p>通过MESSAGE函数把差找的结果都打印出来</p>
</li>
<li><p>Boost动态库链接。如果项目包含多个子模块，且子模块只用到顶层模块find_package找到的部分库，则用下述语句实现只链接子模块需要的Boost动态库</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(foo Boost::regex) // 只使用regex</span><br></pre></td></tr></table></figure>
</li>
<li><p>Boost头文件库链接。在Boost库中有部分库只用头文件实现，并没有响应的动态库，若使用这部分库可以通过以下语句实现</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(foo Boost::boost)</span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Boost-C-库-使用示例-详解"><a href="#Boost-C-库-使用示例-详解" class="headerlink" title="Boost C++ 库 使用示例 详解"></a>Boost C++ 库 使用示例 详解</h2><p>Boost C++ 库包含了众多功能和组件，因此无法在一篇回答中详尽介绍所有。下面将展示一个使用 Boost 库的示例，涵盖智能指针、正则表达式和文件系统三个常用部分。请确保您已经成功编译了 Boost 库并将其包含在项目中。</p>
<p><strong>1. 智能指针（Smart Pointers）示例：</strong></p>
<p>智能指针帮助管理动态分配的内存，防止内存泄漏。以下是一个使用 Boost 智能指针的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">boost::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sharedInt</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared pointer value: &quot;</span> &lt;&lt; *sharedInt &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reference count: &quot;</span> &lt;&lt; sharedInt.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sharedInt 在离开作用域时会自动释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用了 <code>boost::shared_ptr</code> 来创建一个智能指针，它会自动管理整数的内存分配和释放。<code>use_count()</code> 函数用于获取引用计数。</p>
<p><strong>2. 正则表达式示例：</strong></p>
<p>Boost.Regex 提供了强大的正则表达式功能。以下是一个使用 Boost.Regex 的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/regex.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;Boost Libraries are awesome!&quot;</span>;</span><br><span class="line">    <span class="function">boost::regex <span class="title">reg</span><span class="params">(<span class="string">&quot;Boost.*awesome&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (boost::<span class="built_in">regex_search</span>(text, reg)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中，我们使用 <code>boost::regex</code> 创建了一个正则表达式，然后使用 <code>boost::regex_search</code> 检查字符串中是否包含匹配的文本。</p>
<p><strong>3. 文件系统示例：</strong></p>
<p>Boost 文件系统库提供了文件和目录操作功能。以下是一个使用 Boost 文件系统库的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::<span class="function">filesystem::path <span class="title">dirPath</span><span class="params">(<span class="string">&quot;./my_directory&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (boost::filesystem::<span class="built_in">exists</span>(dirPath)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (boost::filesystem::<span class="built_in">is_directory</span>(dirPath)) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Directory exists.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Not a directory.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Directory does not exist.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 <code>boost::filesystem::path</code> 表示目录路径，并使用 <code>boost::filesystem::exists</code> 和 <code>boost::filesystem::is_directory</code> 函数来检查目录是否存在以及是否为目录。</p>
<p>这些示例涵盖了 Boost C++ 库的一小部分功能。要使用 Boost 的其他组件和功能，请查阅 Boost 官方文档，其中包含了详细的教程和示例代码，以帮助您更好地理解和应用 Boost 库的各个组件。</p>
<h2 id="Boost-C-库-详解"><a href="#Boost-C-库-详解" class="headerlink" title="Boost C++ 库 详解"></a>Boost C++ 库 详解</h2><p>Boost C++ 库是一个非常受欢迎的开源 C++ 库集合，提供了各种功能和工具，用于增强 C++ 编程，包括数据结构、算法、多线程、正则表达式、智能指针、文件系统操作等。以下是 Boost C++ 库的一些主要组成部分和功能的详细介绍：</p>
<ol>
<li><p><strong>智能指针（Smart Pointers）</strong>：Boost 提供了各种智能指针，如 <code>shared_ptr</code>、<code>unique_ptr</code> 和 <code>weak_ptr</code>，用于管理动态分配的内存，以避免内存泄漏和提高代码安全性。</p>
</li>
<li><p><strong>容器和数据结构</strong>：Boost 包括许多增强的容器和数据结构，如 <code>unordered_map</code>、<code>unordered_set</code>、<code>multi_index</code>、<code>variant</code> 和 <code>any</code>，用于更有效地管理数据。</p>
</li>
<li><p><strong>多线程支持</strong>：Boost 提供了一套多线程库，包括线程、锁、条件变量和原子操作，以便于编写并发程序。</p>
</li>
<li><p><strong>正则表达式</strong>：Boost.Regex 提供了强大的正则表达式库，使您可以进行高级文本匹配和处理。</p>
</li>
<li><p><strong>文件系统</strong>：Boost 文件系统库允许您进行文件和目录的操作，包括文件检查、复制、移动和删除。</p>
</li>
<li><p><strong>日期时间和时间戳</strong>：Boost.Date_Time 库提供了日期、时间和时间戳处理的功能，可用于处理时间相关的任务。</p>
</li>
<li><p><strong>图形学库</strong>：Boost.Graph 库用于图形算法和数据结构，支持图形遍历、搜索和分析。</p>
</li>
<li><p><strong>泛型编程和元编程</strong>：Boost 具有强大的泛型编程和元编程工具，包括预处理器宏、类型萃取和模板元编程，用于创建通用、高效的代码。</p>
</li>
<li><p><strong>库之间的交互性</strong>：Boost 库之间通常能够很好地协同工作，因此您可以轻松地将它们组合在一起，以满足特定需求。</p>
</li>
<li><p><strong>跨平台性</strong>：Boost 在多种操作系统和编译器上都能正常工作，因此它具有很强的跨平台性。</p>
</li>
<li><p><strong>社区支持</strong>：Boost 是一个由社区驱动的项目，拥有广泛的用户和开发者社区，因此您可以在社区中获得支持和解答问题。</p>
</li>
<li><p><strong>C++标准化贡献</strong>：Boost 库中的一些功能已被采纳并成为 C++ 标准库的一部分，如智能指针 (<code>std::shared_ptr</code>、<code>std::unique_ptr</code>) 和正则表达式 (<code>std::regex</code>)。</p>
</li>
</ol>
<p>要使用 Boost 库，通常需要将其源代码包括头文件和库链接到您的项目中。您可以在 Boost 官方网站上找到详细的文档和教程，以帮助您入门和使用 Boost 库的各个组件。Boost 提供了广泛的文档和示例代码，以便您更好地理解和使用这些功能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/2024-05-22-1_3_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/2024-05-22-1_3_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">1_3_编程技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>BOOST常用编程技巧</li>
</ul>
<h2 id="boost-filesystem-path-转-std-string"><a href="#boost-filesystem-path-转-std-string" class="headerlink" title="boost::filesystem::path 转 std::string"></a>boost::filesystem::path 转 std::string</h2><p>要将 <code>boost::filesystem::path</code> 转换为 <code>std::string</code>，你可以使用 <code>boost::filesystem::path</code> 对象的 <code>string()</code> 成员函数。这个函数返回一个表示路径的 <code>std::string</code>。以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::<span class="function">filesystem::path <span class="title">filePath</span><span class="params">(<span class="string">&quot;/path/to/your/file.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 boost::filesystem::path 转换为 std::string</span></span><br><span class="line">    std::string filePathString = filePath.<span class="built_in">string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印转换后的 std::string</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;File path as string: &quot;</span> &lt;&lt; filePathString &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>filePath.string()</code> 函数将 <code>boost::filesystem::path</code> 对象 <code>filePath</code> 转换为一个 <code>std::string</code>，然后我们将其打印出来。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/2024-05-22-1_0_boost_%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/2024-05-22-1_0_boost_%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">1_0_boost_概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Boost 库概述</li>
</ul>
<h2 id="cmake配置boost"><a href="#cmake配置boost" class="headerlink" title="cmake配置boost"></a>cmake配置boost</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Boost <span class="number">1.86</span> REQUIRED COMPONENTS system filesystem PATHS <span class="string">&quot;$&#123;BaseDIR&#125;/packages/boost_1_86_0/lib/cmake/Boost-1.86.0/&quot;</span> )</span><br><span class="line"><span class="keyword">if</span>(Boost_FOUND)</span><br><span class="line">    <span class="keyword">include_directories</span>(<span class="variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">MESSAGE</span>( STATUS <span class="string">&quot;Boost_INCLUDE_DIRS = $&#123;Boost_INCLUDE_DIRS&#125;.&quot;</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span>( STATUS <span class="string">&quot;Boost_LIBRARIES = $&#123;Boost_LIBRARIES&#125;.&quot;</span>)</span><br><span class="line">    <span class="keyword">MESSAGE</span>( STATUS <span class="string">&quot;Boost_LIB_VERSION = $&#123;Boost_LIB_VERSION&#125;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">add_executable</span>(foo foo.cpp)</span><br><span class="line">    <span class="keyword">target_link_libraries</span> (foo <span class="variable">$&#123;Boost_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h2 id="C-boost库是什么"><a href="#C-boost库是什么" class="headerlink" title="C++ boost库是什么"></a>C++ boost库是什么</h2><p><strong>Boost</strong> 是一个功能强大的 C++ 库集合，为开发者提供广泛的、可移植的功能扩展。它被设计为标准库（STL）的补充，是现代 C++ 编程的重要工具。Boost 提供了许多高质量的库，涵盖了文件系统操作、多线程处理、智能指针、正则表达式、图算法等多个领域。</p>
<hr>
<h3 id="Boost-的主要特点"><a href="#Boost-的主要特点" class="headerlink" title="Boost 的主要特点"></a><strong>Boost 的主要特点</strong></h3><ol>
<li><strong>跨平台支持</strong>：Boost 的库可以在不同操作系统和编译器之间无缝工作。</li>
<li><strong>标准化来源</strong>：Boost 的许多功能后来被采纳进了 C++ 标准库，例如 <code>std::shared_ptr</code> 和正则表达式。</li>
<li><strong>模块化设计</strong>：Boost 包含了 100 多个模块，开发者可以按需使用特定的库，而不需要加载整个库集合。</li>
<li><strong>高性能和可靠性</strong>：Boost 提供的功能经过社区的广泛测试和优化，性能优异且稳定。</li>
</ol>
<hr>
<h3 id="Boost-的常用模块"><a href="#Boost-的常用模块" class="headerlink" title="Boost 的常用模块"></a><strong>Boost 的常用模块</strong></h3><p>以下是一些常用的 Boost 模块及其功能：</p>
<ol>
<li><p><strong>Boost.SmartPtr</strong><br>提供智能指针（如 <code>shared_ptr</code>, <code>weak_ptr</code>），简化内存管理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="function">boost::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Boost.Regex</strong><br>提供强大的正则表达式功能，类似于 <code>std::regex</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/regex.hpp&gt;</span></span></span><br><span class="line"><span class="function">boost::regex <span class="title">expr</span><span class="params">(<span class="string">&quot;(\\w+)@(\\w+\\.\\w+)&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Boost.Thread</strong><br>实现多线程编程，包括线程同步工具（如 <code>mutex</code> 和 <code>condition_variable</code>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="function">boost::thread <span class="title">t</span><span class="params">([] &#123; std::cout &lt;&lt; <span class="string">&quot;Hello from Boost.Thread!&quot;</span> &lt;&lt; std::endl; &#125;)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Boost.Filesystem</strong><br>提供跨平台的文件和目录操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line">boost::<span class="function">filesystem::path <span class="title">p</span><span class="params">(<span class="string">&quot;/path/to/file&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Boost.Asio</strong><br>支持异步输入输出（I&#x2F;O）操作，用于网络编程和异步任务管理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line">boost::asio::io_context io;</span><br><span class="line">boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(io, boost::asio::chrono::seconds(<span class="number">5</span>))</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Boost.Serialization</strong><br>支持对象序列化和反序列化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/archive/text_oarchive.hpp&gt;</span></span></span><br><span class="line">boost::<span class="function">archive::text_oarchive <span class="title">oa</span><span class="params">(std::cout)</span></span>;</span><br><span class="line">oa &lt;&lt; my_object;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Boost.Graph</strong><br>提供图算法和数据结构，用于复杂的图计算。</p>
</li>
</ol>
<hr>
<h3 id="Boost-的安装与使用"><a href="#Boost-的安装与使用" class="headerlink" title="Boost 的安装与使用"></a><strong>Boost 的安装与使用</strong></h3><ol>
<li><p><strong>下载与安装</strong>：</p>
<ul>
<li>从 <a target="_blank" rel="noopener" href="https://www.boost.org/">Boost 官方网站</a> 下载最新版本。</li>
<li>解压后构建必要的库（静态或动态）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bootstrap.sh</span><br><span class="line">./b2</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>项目中使用 Boost</strong>：</p>
<ul>
<li>在编译器中添加 Boost 的头文件路径：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -I /path/to/boost/include -L /path/to/boost/lib -lboost_system</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="Boost-的使用场景"><a href="#Boost-的使用场景" class="headerlink" title="Boost 的使用场景"></a><strong>Boost 的使用场景</strong></h3><ul>
<li><strong>高效的内存管理</strong>：通过智能指针管理动态分配的内存，避免内存泄漏。</li>
<li><strong>跨平台文件操作</strong>：使用 Boost.Filesystem 处理文件路径和文件操作。</li>
<li><strong>异步编程</strong>：Boost.Asio 提供高效的异步任务处理和网络编程支持。</li>
<li><strong>多线程开发</strong>：Boost.Thread 为跨平台线程编程提供一致的接口。</li>
</ul>
<hr>
<h3 id="Boost-的优缺点"><a href="#Boost-的优缺点" class="headerlink" title="Boost 的优缺点"></a><strong>Boost 的优缺点</strong></h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>提供大量实用工具，节省开发时间。</li>
<li>社区活跃，文档详尽。</li>
<li>与 C++ 标准库深度结合，部分功能已纳入 C++ 标准。</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>有些模块的学习曲线较陡。</li>
<li>部分库构建耗时较长。</li>
<li>在某些情况下，库的体积较大。</li>
</ul>
<hr>
<h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a><strong>相关资源</strong></h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.boost.org/">Boost 官方网站</a></li>
<li><a target="_blank" rel="noopener" href="https://zhboost.readthedocs.io/">Boost 中文教程</a><br>如果需要更详细的代码示例或使用指导，请告诉我！</li>
</ul>
<h2 id="BOOST库-有哪些模块-详解"><a href="#BOOST库-有哪些模块-详解" class="headerlink" title="BOOST库 有哪些模块 详解"></a>BOOST库 有哪些模块 详解</h2><p>Boost 库是一个流行的 C++ 库集合，提供了各种各样的模块和功能，涵盖了多个领域，包括但不限于数据结构、算法、多线程、文件系统、网络编程、数学计算等。下面是一些主要的 Boost 模块：</p>
<ol>
<li><p><strong>Boost.Asio</strong>：提供异步 I&#x2F;O 和网络编程功能，包括套接字、TCP、UDP、定时器、异步任务等，用于构建高性能网络应用程序。</p>
</li>
<li><p><strong>Boost.Beast</strong>：基于 Boost.Asio，提供对 HTTP、WebSocket 和网络通信的支持，简化了处理 HTTP 和 WebSocket 协议的操作。</p>
</li>
<li><p><strong>Boost.Filesystem</strong>：提供了对文件系统操作的抽象接口，包括文件路径操作、文件&#x2F;目录的创建、删除、移动、复制等。</p>
</li>
<li><p><strong>Boost.Thread</strong> 和 <strong>Boost.Atomic</strong>：提供了多线程和原子操作的支持，使得在 C++ 中更容易编写并发代码。</p>
</li>
<li><p><strong>Boost.Container</strong>：提供了一系列 STL 容器的扩展和优化版本，如 flat_map、flat_set、static_vector 等，增强了标准库中的容器功能。</p>
</li>
<li><p><strong>Boost.Graph</strong>：提供了图论相关的数据结构和算法，包括图的表示、遍历、最短路径等操作。</p>
</li>
<li><p><strong>Boost.Math</strong>：提供了数学计算的库，包括数值计算、特殊函数、概率分布、统计函数等，用于处理数学问题。</p>
</li>
<li><p><strong>Boost.Serialization</strong>：提供了用于对象序列化和反序列化的库，可以将对象转换为字节流以便存储或传输，并从字节流恢复为对象。</p>
</li>
<li><p><strong>Boost.Regex</strong>：提供了正则表达式的功能，用于文本匹配和处理。</p>
</li>
<li><p><strong>Boost.Date_Time</strong>：提供了日期和时间处理的库，包括日期时间表示、格式化、时区处理等。</p>
</li>
<li><p><strong>Boost.PropertyTree</strong>：用于处理树状结构的数据，例如 XML、JSON 等格式的数据。</p>
</li>
<li><p><strong>Boost.UUID</strong>：用于生成和操作 UUID（通用唯一标识符）的库。</p>
</li>
<li><p><strong>Boost.Test</strong>：提供了单元测试框架，用于进行 C++ 程序的单元测试。</p>
</li>
<li><p><strong>Boost.Locale</strong>：提供了本地化和国际化支持，包括字符集转换、日期时间格式化、货币格式化等功能。</p>
</li>
<li><p><strong>Boost.Process</strong>：提供了对进程的管理和操作功能。</p>
</li>
</ol>
<p>以上列举的模块只是 Boost 库中的一小部分，Boost 还包含许多其他模块和库，每个模块都专注于不同的领域，为 C++ 开发提供了广泛的工具和功能支持。每个模块都有其自己的文档和用法，开发者可以根据需要选择并使用适合的模块。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Compiler/2024-05-22-gcc_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Compiler/2024-05-22-gcc_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">gcc_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Compiler/" itemprop="url" rel="index"><span itemprop="name">Compiler</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>gcc 编译器相关理论知识</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/Compiler/2024-05-22-gcc_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-1_3_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-1_3_%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" class="post-title-link" itemprop="url">1_3_目标检测</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>目标检测相关笔记</li>
<li>除了图像分类，图像生成，图像去噪，目标检测也是计算机视觉领域非常常见的一类问题。其在人脸检测，行人检测，图像检索和视频监控等方面有广泛应用。</li>
</ul>
<h2 id="目标检测是什么"><a href="#目标检测是什么" class="headerlink" title="目标检测是什么"></a>目标检测是什么</h2><ul>
<li>目标检测，英文为Object Detection，有时候也称之为物体检测，物体识别等。简单来讲，目标检测是与计算机视觉和图像处理有关的计算机技术，其涉及在数字图像和视频中检测特定类（例如人，建筑物或汽车）的语义对象的实例。目标检测在人脸检测，行人检测，图像检索和视频监控等计算机视觉领域有广泛的应用。动态物体检测与识别也是自动驾驶中需要攻克的一项关键技术。</li>
<li>目标检测实际上就主要做一件事情。识别图像中指定存在的所有对象及其位置，并标示出来</li>
</ul>
<h2 id="目标检测的前处理"><a href="#目标检测的前处理" class="headerlink" title="目标检测的前处理"></a>目标检测的前处理</h2><ul>
<li><p>目标检测的前处理技术主要包括图像预处理、特征提取、数据增强等。图像预处理包括图像缩放、归一化、旋转、剪裁等操作，这能够对原始图像进行一定的优化和处理，提高模型的鲁棒性和准确率。特征提取是从原始图像中提取目标特征的过程，常用的提取特征的方式有卷积神经网络（CNN）、霍夫变换、边缘检测等方法。数据增强则是通过对原始图像进行变换，如随机裁剪、随机翻转、亮度调节、添加噪声等操作，增加训练数据量，提高模型的泛化能力。</p>
</li>
<li><p>通过OpenCV读取图片，对图片进行缩放</p>
</li>
</ul>
<h2 id="机器学习和深度学习中关于图像数据输入的-Shape"><a href="#机器学习和深度学习中关于图像数据输入的-Shape" class="headerlink" title="机器学习和深度学习中关于图像数据输入的 Shape"></a>机器学习和深度学习中关于图像数据输入的 Shape</h2><ul>
<li><p>在机器学习的图片输入数据中，只需要将图片数据的4维(图片的多少，图片的长，图片的宽，图片的通道数)转换为2维即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_data = train_data.reshape(train_data.shape[0], train_data.shape[1] * train_data.shape[2] * train_data.shape[3])</span><br></pre></td></tr></table></figure>
</li>
<li><p>深度学习，读取图片阶段:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item_image = cv2.imread(img_path)</span><br><span class="line">item_image = cv2.resize(item_image, (224,224), interpolation=cv2.INTER_AREA)</span><br></pre></td></tr></table></figure>
<ul>
<li>cv2.imread()是为了读取图片上的数据，也就是原始图像数据的信息。</li>
<li>在cv2.resize()中，可以指定输出图片的大小，也就是图片的长和宽。</li>
</ul>
</li>
<li><p>把读取到数据转换成ndarray</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_data = np.array(train_data, dtype=&#x27;float32&#x27;)</span><br></pre></td></tr></table></figure></li>
<li><p>此时，如果打印train_data的维度，会显示一个4个维度的数据，(图片的数量，图片的长，图片的宽，图片的通道数)</p>
</li>
<li><p>shape</p>
<ul>
<li>图像形状，行数，列数，通道数</li>
</ul>
</li>
<li><p>size</p>
<ul>
<li>图像大小，行数 * 列数 * 通道数</li>
</ul>
</li>
<li><p>dtype</p>
<ul>
<li>图像数据类型，通常为uint8</li>
</ul>
</li>
</ul>
<h2 id="目标检测的后处理"><a href="#目标检测的后处理" class="headerlink" title="目标检测的后处理"></a>目标检测的后处理</h2><ul>
<li><p>目标检测的后处理技术主要是指对目标检测算法的输出进行调整和优化，以提高检测结果的准确性和稳定性。</p>
</li>
<li><p>后处理技术一般包括非极大值抑制（NMS）、筛选、矫正等方法。</p>
</li>
<li><p>非极大值抑制是指对检测框进行去重和筛选，只保留探测到的目标中得分最高的那一个，并抑制周围高度重叠的框。</p>
</li>
<li><p>筛选技术是指判断目标是否符合检测条件，去掉检测到的误检目标或不符合条件的目标。</p>
</li>
<li><p>矫正技术是指对检测框的位置和倾斜角度进行矫正，使得目标在图像中的位置更为精确，提高识别准确性。这些技术通常在目标检测的训练和测试过程中都会使用。</p>
</li>
<li><p>目标检测并不一定需要后处理，但通常情况下会进行后处理来进一步提高模型的准确性和稳定性。后处理技术能够对目标检测的结果进行优化和调整，例如去除重复检测框、筛选、矫正等等</p>
</li>
<li><p>在目标检测中，由于前景和背景的比例极为不平衡，因此检测框往往会出现大量的误检和漏检。后处理技术能够对这些问题进行针对性的处理，提高最终的检测准确率</p>
</li>
<li><p>常用的后处理技术包括非极大值抑制（NMS）、筛选、矫正等。这些技术不仅可以提高目标检测的准确性，还能够缩短检测时间、减少处理数据的复杂度，从而优化算法的整体性能。因此，目标检测中通常会使用后处理技术来优化模型的表现</p>
</li>
</ul>
<h2 id="NMS-Non-Maximum-Suppression"><a href="#NMS-Non-Maximum-Suppression" class="headerlink" title="NMS(Non-Maximum Suppression)"></a>NMS(Non-Maximum Suppression)</h2><ul>
<li><p>NMS（Non-Maximum Suppression）是目标检测中常用的一种后处理技术，用于去除重复的检测结果，只保留最佳的目标框，从而提高模型精度和效率</p>
</li>
<li><p>NMS的原理是基于阈值和重叠率进行筛选。假设模型输出了多个待筛选的检测框，每个检测框都有一个置信度分数，表示该框中包含目标的概率。NMS需要分别对每个类别的检测框进行处理</p>
</li>
<li><p>详细流程如下</p>
<ul>
<li>首先，按照置信度分数从高到低对检测框进行排序。</li>
<li>取分数最高的检测框A，作为起始框，并从剩余的框里删除A。</li>
<li>按照重叠率的大小判断剩余框中是否与A重叠，若存在则计算它们的IoU值（交并比）。</li>
<li>若IoU值大于预设阈值（一般设为0.5），则将该框从剩余框中删除；若IoU值小于阈值，则保留该框。</li>
<li>重复第2-4步，直到剩余框中没有可删除的框，即所有检测框都被筛选过了。</li>
<li>将剩余的保留框和置信度分数返回。</li>
</ul>
</li>
<li><p>下面是一个简单的Python实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def nms(detections, threshold=0.5):</span><br><span class="line">    # detections: 待筛选的检测框列表，每个元素为(x1, y1, x2, y2, score)</span><br><span class="line">    # threshold: 阈值，设定IoU值小于阈值的框为非极大值框</span><br><span class="line">    </span><br><span class="line">    if len(detections) == 0:</span><br><span class="line">        return []</span><br><span class="line">    </span><br><span class="line">    # 按照置信度分数从高到低排序</span><br><span class="line">    detections = sorted(detections, key=lambda x: x[4], reverse=True)</span><br><span class="line">    </span><br><span class="line">    # 用于保存最终保留下来的检测框</span><br><span class="line">    keep = []</span><br><span class="line">    </span><br><span class="line">    while len(detections) &gt; 0:</span><br><span class="line">        # 取分数最高的框作为起始框</span><br><span class="line">        A = detections[0]</span><br><span class="line">        keep.append(A)</span><br><span class="line">        </span><br><span class="line">        # 计算该起始框和剩余框的IoU值</span><br><span class="line">        B = detections[1:]</span><br><span class="line">        overlaps = [iou(A, b) for b in B]</span><br><span class="line">        </span><br><span class="line">        # 将IoU值大于阈值的框删除</span><br><span class="line">        indices = [i+1 for i, overlap in enumerate(overlaps) if overlap &gt; threshold]</span><br><span class="line">        detections = [b for i, b in enumerate(detections) if i not in indices]</span><br><span class="line">        </span><br><span class="line">    return keep</span><br></pre></td></tr></table></figure></li>
<li><p>其中，iou函数用于计算两个框之间的IoU值。</p>
</li>
<li><p>目前有很多对NMS算法的改进方法。下面是几种常见的NMS改进方法：</p>
<ul>
<li>Soft-NMS：传统的NMS是直接抑制掉重叠框中候选框中分数较低的框，而Soft-NMS通过修改分数的方式，将重叠的框的分数逐渐降低。例如，重叠的框的分数会随着IoU值的增加而逐渐减少，而不是直接变为0。这样做可以让模型更加关注可靠的检测结果，避免错判。</li>
<li>Adaptive NMS：Adaptive NMS主要是为了解决NMS不同的IoU阈值不适用于不同的物体大小和密度的问题。它引入了一个Adaptive Parameter，该参数会根据候选框大小和样例分布自适应地调整IoU阈值，从而更好地适应不同尺寸的物体目标</li>
<li>Soft-NMS with Learnable Weight Scheme：Soft-NMS技术引入了一个权重系数，确定哪些重叠框应该被抑制，而Soft-NMS-LWS则引入了一个学习的权重计算任务，让模型自己学习如何更好地选择重叠框。</li>
</ul>
</li>
<li><p>这种方法通常会在训练期间学习最佳的权重，并且适用于NMS抑制的具有不同尺度粒度的多个检测结果</p>
</li>
<li><p>这些改进方法的核心思想都是为了更好地处理较为复杂的目标检测情况，例如遮挡和噪声干扰等。同时，这些改进方法还可以进一步提高检测精度并减少误检率，相对于传统的NMS方法表现更出色</p>
</li>
<li><p>目标检测算法中，有些方法可以不需要显式的NMS后处理技术，例如YOLO和SSD（Single Shot MultiBox Detector）。这些方法具有以下特点</p>
<ul>
<li>YOLO：YOLO（You Only Look Once）是一种实时的目标检测算法，它的目标检测过程是在单个神经网络中并行进行的。YOLO将整个图像分成多个网格，每个网格预测出N个边界框及它们的置信度，然后根据置信度和类别得分，筛选出最佳的框。在选择框时，YOLO使用了阈值（置信度分数），减少了重叠框的存在，从而取代了传统的NMS技术。这种方式不仅能够实现快速检测，还能避免高阈值造成的误检和低阈值造成的漏检</li>
<li>SSD：SSD（Single Shot MultiBox Detector）也是一种实时目标检测算法，与YOLO类似，它也是将整个图像分成多个网格进行处理。但SSD采用的是先验框机制，通过预设的先验框，让模型更加有效的学到各个物体的形状和大小等特征。在每个网格上，SSD预测出每个先验框的位置和它们所属的类别，然后通过非最大抑制的方式删除一些冗余的框。相比其他的检测算法，SSD是一种速度较快，精度较高的算法。</li>
</ul>
</li>
</ul>
<h2 id="图像处理-维基百科"><a href="#图像处理-维基百科" class="headerlink" title="图像处理(维基百科)"></a>图像处理(维基百科)</h2><ul>
<li><p>图像处理是指对图像进行分析，加工和处理，使其满足视觉，心理或其他要求的技术。图像处理是信号处理在图像领域上的一个应用。目前大多数的图像均是以数字形式存储，因而图像处理很多情况下指数字图像处理。此外，基于光学理论的处理方法依然占有重要的地位。</p>
</li>
<li><p>图像处理是信号处理的子类，另外与计算机科学、人工智能等领域也有密切的关系</p>
</li>
<li><p>传统的一维信号处理的方法和概念很多仍然可以直接应用在图像处理上，比如降噪、量化等。然而，图像属于二维信号，和一维信号相比，它有自己特殊的一面，处理的方式和角度也有所不同</p>
</li>
<li><p>常用的信号处理技术</p>
<ul>
<li>大多数用于一维信号处理的概念都有其在二维图像信号领域的延伸，它们之中的一部分在二维情形下变得十分复杂。 同时图像处理自身也具有一些新的概念， 例如，连通性、旋转不变性，等等。这些概念仅对二维或更高维的情况下才有非平凡的意义。</li>
<li>图像处理中常用到快速傅立叶变换，因为它可以减小数据处理量和处理时间。</li>
</ul>
</li>
<li><p>从一维信号处理扩展来的技术和概念</p>
<ul>
<li>分辨率</li>
<li>动态范围</li>
<li>带宽</li>
<li>滤波器设计</li>
<li>微分算子</li>
<li>边缘检测</li>
<li>Domain modulation</li>
<li>降噪(Noise reduction)</li>
</ul>
</li>
<li><p>专用于二维（或更高维）的技术和概念</p>
<ul>
<li>连通性</li>
<li>旋转不变性</li>
</ul>
</li>
<li><p>典型问题</p>
<ul>
<li>几何变换(geometric transformations): 包括放大，缩小，旋转等</li>
<li>颜色处理(color): 颜色空间的转化，亮度以及对比度的调节，颜色修正等</li>
<li>图像融合(image composite): 多个图像的加，减，组合，拼接等</li>
<li>降噪(image denoising): 研究各种针对二维图像的去噪滤波器或者信号处理技术</li>
<li>边缘检测: 进行边缘或者其他局部特征提取</li>
<li>分割: 依据不同标准，把二维图像分割成不同区域</li>
<li>图像编辑: 和计算机图形学有一定交叉</li>
<li>图像配准: 比较或集成不同条件下获取的图像</li>
<li>图像增强(image enhancement)</li>
<li>图像数字水印: 研究图像域的数据隐藏，加密或者认证</li>
<li>图像压缩: 研究图像压缩</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li>摄影以及印刷</li>
<li>卫星图像处理(Statellite image processing)</li>
<li>医学图像处理(Medical image processing)</li>
<li>面孔识别，特征识别(Face detection, feature detection, face identification)</li>
<li>显微图像处理(Microscope image processing)</li>
<li>汽车障碍识别(Car barrier detection)</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-2_1_NVIDIA_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-2_1_NVIDIA_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">2_1_NVIDIA_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>NVIDIA 硬件平台下深度学习相关的理论基础</li>
</ul>
<h2 id="TensorRT-txtexec-工具"><a href="#TensorRT-txtexec-工具" class="headerlink" title="TensorRT txtexec 工具"></a>TensorRT txtexec 工具</h2><p><code>txtexec</code> 是 NVIDIA TensorRT 中的一个实用工具，用于从文本文件加载和执行优化后的推理引擎（<code>.engine</code> 文件）。这个工具可以用于在命令行中加载和运行已经通过 TensorRT 优化的模型，而无需编写额外的代码。下面我会对 <code>txtexec</code> 进行详细解释：</p>
<ol>
<li><p><strong>加载和执行引擎</strong>：<code>txtexec</code> 工具允许你通过命令行加载和执行优化过的引擎文件（<code>.engine</code> 文件）。这意味着你可以使用这个工具在没有额外编程的情况下运行经过优化的深度学习模型。</p>
</li>
<li><p><strong>命令行语法</strong>：<code>txtexec</code> 的命令行语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">txtexec [-h] --loadEngine=&lt;string&gt; [--iterations=&lt;int&gt;] [--avgRuns=&lt;int&gt;]</span><br><span class="line">        [--warmUp=&lt;int&gt;] [--useDLA=&lt;int&gt;] [--useSpinWait] [--threads=&lt;int&gt;]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>--loadEngine</code>：指定要加载的 <code>.engine</code> 文件的路径。</li>
<li><code>--iterations</code>：指定进行推理的迭代次数（默认为 1）。</li>
<li><code>--avgRuns</code>：指定多次推理运行的平均次数（默认为 1）。</li>
<li><code>--warmUp</code>：指定预热运行的次数，这些运行不会计入统计（默认为 0）。</li>
<li><code>--useDLA</code>：指定是否使用深度学习加速器（DLA），0 表示不使用，1 表示使用（默认为 0）。</li>
<li><code>--useSpinWait</code>：指定是否使用自旋等待进行同步。</li>
<li><code>--threads</code>：指定并行线程数（默认为 1）。</li>
</ul>
</li>
<li><p><strong>使用示例</strong>：以下是一个示例命令行使用 <code>txtexec</code> 加载并执行 <code>.engine</code> 文件的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txtexec --loadEngine=my_model.engine --iterations=100 --avgRuns=10 --useDLA=0</span><br></pre></td></tr></table></figure>

<p>这个命令将加载名为 <code>my_model.engine</code> 的引擎文件，进行 100 次迭代的推理，每次推理进行 10 次运行取平均，并且不使用深度学习加速器。</p>
</li>
</ol>
<p>请注意，<code>txtexec</code> 工具是 TensorRT 的一个辅助工具，主要用于快速测试和验证模型的推理性能。对于更复杂的应用和场景，通常需要在代码中使用 TensorRT 的 API 进行推理。详细的用法和配置可以在 NVIDIA 的 TensorRT 文档中找到。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">1_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-09 14:02:38" itemprop="dateModified" datetime="2025-06-09T14:02:38+08:00">2025-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>深度学习 模型 相关理论基础</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/DeepLearning/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-DL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-DL/" class="post-title-link" itemprop="url">DL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>深度学习（deep learning）是机器学习的分支，是一种以<strong>人工神经网络</strong>为架构，对资料进行<strong>表征学习</strong>的算法。</li>
<li>深度学习的好处是用非监督式或半监督式的特征学习和分层提取高效算法来替代手工获取特征。</li>
<li>表征学习的目标是寻求更好的表示方法并建立更好的模型来从大规模未标记数据中学习这些表示方法。表示方法来自神经科学，并松散地建立在类似神经系统中的信息处理和对通信模式的理解上</li>
<li>至今已有深度学习框架，如<ol>
<li>深度神经网络</li>
<li>卷积神经网络</li>
<li>深度置信网络</li>
<li>循环神经网络</li>
</ol>
</li>
<li>深度学习的基础是机器学习中的<strong>分散表示（distributed representation）</strong>。分散表示假定观测值是由不同因子相互作用生成。在此基础上，深度学习进一步假定这一相互作用的过程可分为多个层次，代表对观测值的多层抽象。不同的层数和层的规模可用于不同程度的抽象。</li>
</ol>
<h1 id="神经网络（西瓜书）"><a href="#神经网络（西瓜书）" class="headerlink" title="神经网络（西瓜书）"></a>神经网络（西瓜书）</h1><ol>
<li>神经元模型<ol>
<li>神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所做出的交互反应。[Kohonen,  1988]</li>
<li>神经网络中最基本的成分是神经元（neuron）模型，即上述定义中的“简单单元”</li>
<li>感知机与多层网络<ol>
<li>感知机（Perceptron）由两层神经元组成，输入层接受外界输入信号后传递给输出层，输出层是M-P神经元，亦称“阈值逻辑单元”（threshold logic unit）</li>
<li>输出层与输入层之间的一层神经元，被称为隐层或隐含层（hidden layer），隐含层和输出层神经元都是拥有激活函数的功能神经元</li>
<li>常见的神经网络，每层神经元与下一层神经元全互连，神经元之间不存在同层连接，也不存在跨层连接，这样的神经网络结构通常称为“多层前馈神经网络”（multi-layer feedforward neural networks）,其中输入层神经元接受外界输入，隐层与输出层神经元对信号进行加工，最终结果由输出层神经元输出；换言之，输入层神经元仅是接受输入，不进行函数处理，隐层与输出层包含功能神经元。<ol>
<li>“前馈”并不意味着网络中信号不能向后传，而是指网络拓扑结构上不存在环或回路</li>
<li>只需要包含隐层，即可称为多层网络。</li>
<li>神经网络的学习过程，就是根据训练数据来调整神经元之间的“连接权”（connection weight）以及每个功能神经元的阈值；换言之，神经网络“学”到的东西，蕴涵在连接权与阈值中。</li>
</ol>
</li>
</ol>
</li>
<li>误差逆传播算法（亦称“反向传播算法”）<ol>
<li>多层网络的学习能力比单层感知机强得多，想要训练多层网络，简单感知机学习规则显然不够，需要更加强大的学习算法，误差逆传播算法（errorBackPropagation, BP）就是其中最杰出的代码，它是迄今为止最成功的神经网络学习算法。</li>
<li>BP算法不仅可用于多层前馈神经网络，还可用于其他类型的神经网路，例如训练递归神经网络，但是通常说“BP网络”时，一般是指用BP算法训练的多层前馈神经网络。</li>
</ol>
</li>
<li>深度学习<ol>
<li>理论上来说，参数越多的模型复杂度越高、容量越大，这意味着它能够完成更复杂的学习任务。但是在一般情形下，复杂模型的训练效率低，易陷入过拟合，因此难以受到人们青睐</li>
<li>我们可以从另外一个角度来理解深度学习。无论是DBN还是CNN，其多隐层堆叠、每层对上一层的输出进行处理的机制，可看作是在对输入信号进行逐层加工，从而把初始的、与输出目标之间联系不太密切的输入表示，转化成与输出目标联系更密切的表示，使得原来仅基于最后一层输出映射难以完成的任务成为可能。换言之，通过多层处理，逐渐将初始的“低层”特征表示转化为“高层”特征表示后，用“简单模型”即可完成复杂的分类等学习任务，由此可将深度学习理解为“特征学习”（feature learning）或“表示学习”(representation learning)</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="深度神经网络（Deep-Neural-Network-DNN）"><a href="#深度神经网络（Deep-Neural-Network-DNN）" class="headerlink" title="深度神经网络（Deep Neural Network, DNN）"></a>深度神经网络（Deep Neural Network, DNN）</h1><ol>
<li>深度神经网络是一种具备至少一个隐层的神经网络。与<strong>浅层神经网络</strong>类似，深度神经网络也能够为复杂非线性系统提供建模，但多出的层次为模型提供了更高的抽象层次，因而提高了模型的能力。深度神经网络通常都是<strong>前馈神经网络</strong>，但也有语言建模方面的研究将其拓展到循环神经网络。卷积神经网络在计算机视觉领域得到了成功的应用。</li>
<li>深度神经网络是一种<strong>判别模型</strong>，可以使用<strong>反向传播算法</strong>进行训练。权重更新可以使用下式进行<strong>随机梯度下降法</strong>求解。</li>
<li>与其它神经网络模型类似，如果仅仅是简单地训练，深度神经网络可能会存在很多问题。常见的两类问题是<strong>过拟合</strong>和<strong>过长的运算时间</strong>。</li>
</ol>
<h1 id="Cmake-VScode"><a href="#Cmake-VScode" class="headerlink" title="Cmake &amp; VScode"></a>Cmake &amp; VScode</h1><h2 id="Create-a-CMake-project"><a href="#Create-a-CMake-project" class="headerlink" title="Create a CMake project"></a>Create a CMake project</h2><ol>
<li>makdir cmakeQuickStart</li>
<li>cd cmakeQuickStart</li>
<li>code .</li>
<li>Open the Command Palette and run the <strong>CMake:Quick Start</strong> command</li>
<li>main.cpp , CMakeLists.txt(which tells the CMake tools how to build your project)</li>
<li>CMake Tools 插件能够给C&#x2F;C++插件提供信息，实现IntelliSense、代码补全、注释浏览、文件跳转等功能</li>
</ol>
<h1 id="Opencv-DNN"><a href="#Opencv-DNN" class="headerlink" title="Opencv DNN"></a>Opencv DNN</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ol>
<li>在深度学习初始阶段，每个深度学习研究者都需要写大量的重复代码。为了提高工作效率，这些研究者就将这些代码写成了一个框架放到网上让所有研究者一起使用。接着，网上就出现了不同的框架。随着时间的推移，最为好用的几个框架被大量的人使用从而流行了起来。全世界最为流行的深度学习框架有<ol>
<li>PaddlePaddle（Baidu）<ol>
<li>PaddlePaddle是Baidu研发的开源开放的深度学习平台，是国内最早开源、也是当前唯一一个功能完备的深度学习平台。</li>
</ol>
</li>
<li>Tensorflow（Google）</li>
<li>Caffe</li>
<li>Theano</li>
<li>MXNet</li>
<li>Torch（NYU&#x2F;Facebook）<ol>
<li>Torch是Facebook的开源机器学习库、科学计算框架和基于Lua编程语言的脚本语言。</li>
</ol>
</li>
<li>PyTorch</li>
</ol>
</li>
</ol>
<h2 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h2><ol>
<li>PyTorch是一个开源的Python机器学习库，基于Torch，用于自然语言处理等应用程序</li>
</ol>
<h2 id="TensorFlow（符号数学系统）"><a href="#TensorFlow（符号数学系统）" class="headerlink" title="TensorFlow（符号数学系统）"></a>TensorFlow（符号数学系统）</h2><ol>
<li>TensorFlow是一个基于数据流变成（dataflow programming）的符号数学系统，被广泛应用于各类机器学习（machine learning）算法的编程实现，其前身是谷歌的神经网络算法库DistBelief。</li>
</ol>
<h2 id="Caffe"><a href="#Caffe" class="headerlink" title="Caffe"></a>Caffe</h2><ol>
<li>Caffe(Convolutional Architecture for Fast Feature Embedding)，卷积神经网络框架，是一个兼具表达性、速度和四维模块化的深度学习框架。</li>
<li>结构：<ol>
<li>简单来讲，Caffe中的数据结构是以Blobs-layers-Net形式存在。其中，Blobs是通过4维向量形式（num, channel, height, width）存储网络中所有权重，激活值以及正向反向的数据。</li>
<li>作为Caffe的标准数据格式，Blob提供了统一内存借口。Layers表示的是神经网络中具体层，例如卷积层等，是Caffe模型的本质内容和执行计算的基本单元。layer层接受底层输入的Blobs，向高层输出Blobs。在每层会实现前向传播，后向传播。Net是由多个层连接在一起，组成的有向无环图。<strong>一个网络讲最初的data数据层加载数据开始到最后的loss层组合为整体</strong>。</li>
</ol>
</li>
</ol>
<h2 id="ONNX"><a href="#ONNX" class="headerlink" title="ONNX"></a>ONNX</h2><ol>
<li>了解Open Neural Network Exchange（ONNX）来帮助优化机器学习模型的推理。推理或模型评分是将部署的模型用于预测（通常针对生产数据）的阶段。</li>
<li>什么是ONNX？<ol>
<li>ONNX（Open Neural Network Exchange），开放神经网络交换，是一种<strong>模型IR</strong>，用于在各种深度学习训练和推理框架转换的一个<strong>中间表示格式</strong>。在实际业务中，可以使用Pytorch或者TensorFlow训练模型，导出ONNX格式，然后在转换成目标设备上支撑的模型格式，比如TensorRT Engine、 NCNN、MNN等格式。ONNX定义了一组和环境、平台均无关的标准格式，来增强各种AI模型的可交互性，开放性较强。</li>
<li>换句话说，无论你使用何种训练框架训练模型（例如TensorFlow&#x2F;Pytorch&#x2F;OneFlow&#x2F;Paddle），在训练完毕后你都可以将这些框架的模型统一转换为ONNX这种统一的格式进行存储，转为ONNX模型，然后就可以放在其他框架上面去推理（inference）。</li>
</ol>
</li>
<li>ProtoBuf简介<ol>
<li>在分析ONNX组织格式前，需要了解Protobuf。ONNX作为一个文件格式，自然需要一定的规则去读取想要的信息或者写入需要保存的信息。ONNX使用的是Protobuf这个序列化数据结构去存储神经网络的圈中信息。熟悉Caffe（深度学习框架）或者Caffe2的应该知道，它们的模型存储数据结构协议也是Protobuf。</li>
<li>Protobuf是一种轻便高校的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了C++、Java、Python三种语言的API</li>
</ol>
</li>
<li>ONNX中最核心的部分是onnx.proto。它定义了ONNX这个数据协议的规则和一些其他信息，其中最核心的几个对象：<ol>
<li>ModelProto<ol>
<li>包含了一些版本信息，生产者信息和一个GraphProto</li>
</ol>
</li>
<li>GraphProto<ol>
<li>包含了四个repeated数组，分别是<ol>
<li>node（NodeProto类型）<ol>
<li>存放模型中所有的计算节点</li>
</ol>
</li>
<li>input（ValueInfoProto类型<ol>
<li>存放模型的输入节点</li>
</ol>
</li>
<li>output（ValueInfoProto类型）<ol>
<li>存放模型中所有的输出节点</li>
</ol>
</li>
<li>initializer（TensorProto类型）<ol>
<li>存放模型的所有权重参数</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>NodeProto</li>
<li>ValueInfoProto</li>
<li>TensorProto</li>
<li>AttributeProto</li>
</ol>
</li>
</ol>
<h2 id="使用Google-inception-5h实现图像分类"><a href="#使用Google-inception-5h实现图像分类" class="headerlink" title="使用Google inception-5h实现图像分类"></a>使用Google inception-5h实现图像分类</h2><ol>
<li>DNN模块介绍：<ol>
<li>OpenCV的DNN模块是在OpenCV3.3合并到OpenCV release中的，它最早是在扩展模块中的，可以导入caffe、tensorflow、pytorch等深度学习框架训练生成的模型文件，从而正向传递实现预测功能</li>
</ol>
</li>
<li>加载模型读取网络信息<ol>
<li>模型可以使用readNet API来加载 <code>Net cv::dnn::readNet(const String&amp; model, const String&amp; config = String(), const String&amp; framework = String());</code><ol>
<li>model是训练好的二进制网络权重文件，支持多种框架训练出来的模型</li>
<li>config是二进制模型的描述文件，不同的框架配置文件有不同的扩展名</li>
<li>framework则声明模型对应框架名称</li>
</ol>
</li>
<li>也可以使用<ol>
<li><code>Net readNetFromTensorflow(const String&amp; model, const String&amp; config = String());</code></li>
<li><code>Net readNetFromCaffe(const String&amp; prototxt, const String&amp; caffeModel = String());</code></li>
<li>其他等API直接加载对应框架训练出来的模型</li>
</ol>
</li>
</ol>
</li>
<li>模型正向传递预测<ol>
<li><p>使用模型实现预测的时候，需要读取图像作为输入，网络模型支持的输入数据是四维的输入，所以要把读取到的Mat对象转换为四维张量，OpenCV提供的API如下</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   Mat blobFromImage(</span><br><span class="line">      InputArray image,</span><br><span class="line">      double scalefactor = 1.0,</span><br><span class="line">      const Size&amp; size = Size(),</span><br><span class="line">      const Scalar&amp; mean = Scalar(),</span><br><span class="line">      bool swapRB = false,</span><br><span class="line">      bool crop = false,</span><br><span class="line">      int ddepth = CV_32F</span><br><span class="line">   )</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ol>
<li>image：输入图像</li>
<li>scalefactor：默认是1.0</li>
<li>size表示网络接受的数据大小</li>
<li>mean表示训练时数据集的均值</li>
<li>swapRB是否互换Red与Blur通道</li>
<li>crop是剪切</li>
<li>ddepth是数据类型</li>
</ol>
</li>
<li><p>模型的输入和正向传递则使用如下两个API</p>
<ol>
<li><code>void setInput(InputArray blob, const String&amp; name = &quot;&quot;);</code></li>
<li><code>Mat forward(const String&amp; outputName = String());</code></li>
</ol>
</li>
</ol>
</li>
<li>输出预测结果<ol>
<li>首先读取标签文件，定义一个读取文件的额函数read_class_names();</li>
</ol>
</li>
</ol>
<h2 id="模块（DNN）的应用–图像分类"><a href="#模块（DNN）的应用–图像分类" class="headerlink" title="模块（DNN）的应用–图像分类"></a>模块（DNN）的应用–图像分类</h2><h2 id="训练（training）和推理（inference）"><a href="#训练（training）和推理（inference）" class="headerlink" title="训练（training）和推理（inference）"></a>训练（training）和推理（inference）</h2><ol>
<li>训练（training）包含了前向传播和后向传播两个阶段，针对的是训练集，训练时通过误差反向传播来不断修改网络权值（weights）<ol>
<li>训练一个神经网络时，训练数据被输入该网络的第一层，同时一个神经元会基于所执行的任务为该输入分配一个权重–即该输入正确与否的程度</li>
<li>在一个用于图像识别的网络中，第一层可能是用来寻找图像的边缘。第二层可能是寻找这些边所构成的形状–矩形或者是圆形。第三层可能是寻找特定的特征–比如闪亮的眼睛或者按钮式的鼻子。每一层都会将图像传递给下一层，直到最后一层；最后的输出由该网络所产生的所有这些权重总体决定。</li>
</ol>
</li>
<li>推理（inference）只包含前向传播一个阶段，针对的是除了训练集之外的新数据。可以是测试机，但不完全是，更多的是整个数据集之外的数据。其实就是针对新数据进行预测，预测时，速度是一个很重要的因素。<ol>
<li>神经网络训练好了，已经为推理做好了准备</li>
<li>准确分配加权了的神经网络本质上是一个笨重的巨型数据库。此前，为了让它学习而准备的各种东西已经远远多余它在完成某一特定任务时所需要的内容</li>
<li>在现实世界中，如果有人想要使用这些训练，真正所需要的是一种可以保持学习并能将其学习成果应用于其从未见过的数据的快速应用，这就是推理：只需要少的多的真实数据，就能快速得出正确答案（实际上是对什么是正确的预测）<ol>
<li>训练是为了让“猫”这个线索得以抽象，推理就是利用这个抽象在应用场景下给出是不是“猫”这个结论。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="数据预处理与名字解释"><a href="#数据预处理与名字解释" class="headerlink" title="数据预处理与名字解释"></a>数据预处理与名字解释</h1><ol>
<li>深度学习中的数据预处理有哪些方式？<ol>
<li>数据归一化。包括高斯归一化、最大最小值归一化等</li>
<li>白化。许多深度学习算法都以来于白化来获得更好的特征。所谓的白化，以PCA白化来说，就是对PCA降维后的数据的每一列除以其特征值的根号。</li>
</ol>
</li>
<li>为什么需要图像预处理？<ol>
<li>图像预处理的主要目的是消除图像中无关的信息，恢复有用的真实信息，增强有关信息的可检测性和最大限度地简化数据，从而改进特征抽取，图像分隔，匹配和识别的可靠性。</li>
</ol>
</li>
<li>为什么需要对数据进行归一化处理，归一化的方式有哪些？<ol>
<li>为了后面数据处理的方便，归一化的确可以避免一些不必要的数值问题</li>
<li>为了程序运行时收敛加快</li>
<li>同一量纲。样本数据的评价标准不一样，需要对其量纲化，统一评价标准。这算是应用层面的需求</li>
<li>避免神经元饱和。当神经元的激活在接近0或者1时会饱和，在这些区域，梯度几乎为0，这样，再反向传播过程中，局部梯度就会接近0，这样会有效地“杀死”梯度</li>
<li>保证输出数据中数值小的不被吞食</li>
<li>归一化的方式主要有：线性归一化、标准差归一化、非线性归一化</li>
</ol>
</li>
<li>数据增强的方式有哪些？<ol>
<li>翻转、旋转、缩放、裁剪、平移、尺度变化、添加噪声、色彩抖动、亮度调整、对比度增强</li>
<li>数据增强可以分为两类：离线增强和在线增强<ol>
<li>离线增强：直接对数据集进行处理，数据的数目会变成增强因子乘以原数据集的数目，这种方法常常用于数据集很小的时候。</li>
<li>在线增强：这种增强的方法用于，获得batch数据之后，对这个batch的数据进行增强，如旋转、平移、翻转等相应的变化，由于有些数据集不能接受线性级别的增长，这种方法用于大的数据集</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h1><p>整体上说,后处理的CPU实现分为三部分:</p>
<ol>
<li>框信息的预处理,类似一个decode过程</li>
<li>NMS过程,实现框的选择和合并<ul>
<li>NMS过程是后处理的重点.基本原理是针对每一个类,每次循环选取这个类中概率最高的框与其他所有框计算IOU.如果某个框与最大概率框的IOU大于nms_thresh.这个框对应的概率被设为-1,表示被过滤掉了.</li>
<li>IOU,为两个框重叠面积与总面积的比值</li>
</ul>
</li>
<li>框排序,当选出的结果框数量大于maxBoxNum时选取score最大的maxBoxNum个</li>
</ol>
<h1 id="吴恩达-深度学习课程"><a href="#吴恩达-深度学习课程" class="headerlink" title="吴恩达 深度学习课程"></a>吴恩达 深度学习课程</h1><ol>
<li>Binary Classification（二分分类）<ol>
<li>在二分分类问题中，目标是训练处一个分类器，它以图片的特征向量x作为输入，预测输出的结果标签y是1还是0，也就是预测图片中是否有猫</li>
</ol>
</li>
<li>logistic regression（logistic 回归）<ol>
<li>它是一个学习算法，用在监督学习问题中输出标签是0还是1时，二元分类问题</li>
</ol>
</li>
</ol>
<h2 id="雷锋网"><a href="#雷锋网" class="headerlink" title="雷锋网"></a>雷锋网</h2><ul>
<li><code>https://www.leiphone.com/category/ai/DZeAwe2qgx8JhbU8.html</code></li>
</ul>
<h2 id="大部分深度学习框架都包含以下五个核心组件"><a href="#大部分深度学习框架都包含以下五个核心组件" class="headerlink" title="大部分深度学习框架都包含以下五个核心组件"></a>大部分深度学习框架都包含以下五个核心组件</h2><ul>
<li>张量 （<code>Tensor</code>）</li>
<li>基于张量的各种操作</li>
<li>计算图（<code>Computation Graph</code>）</li>
<li>自动微分工具（<code>Automatic Differentiation</code>）工具</li>
<li><code>BLAS, cuBLAS, cuDNN</code>等扩展包</li>
</ul>
<h3 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h3><ul>
<li><p>张量是所有深度学习框架中最核心的组件，因为后续的所有运算和优化算法都是基于张量进行的</p>
</li>
<li><p>几何代数中定义的张量是， <strong>基于向量和矩阵的推广</strong>，通俗一点理解的话，可以将标量视为零阶张量，矢量视为一阶张量，那么据栈就是二阶张量</p>
</li>
<li><p>举例来说，可以将任意一张RGB彩色图片表示称一个三阶张量， 三个纬度分别是图片的高度，宽度和色彩数据。</p>
</li>
<li><p>将这一定义进行扩展，我们也可以用四阶张量表示一个包含多张图片的数据集，其中的四个纬度分别是 – 图片在数据集中的编号，图片高度，宽度，以及色彩数据。</p>
</li>
<li><p><strong>将各种各样的数据抽象成张量表示，然后再输入神经网络模型进行后续处理是一种非常必要且高效的策略</strong>。</p>
</li>
<li><p>因为，如果没有这一步骤，我们就需要根据各种不同类型的数据组织形式定义各种不同类型的数据操作，这会浪费大量的开发这精力。更关键的是，当数据处理完成后，我们还可以方便地将张量再转回想要的格式。</p>
</li>
</ul>
<h3 id="基于张量的各种操作"><a href="#基于张量的各种操作" class="headerlink" title="基于张量的各种操作"></a>基于张量的各种操作</h3><ul>
<li><p>整个神经网络都可以简单视为为了达到某种目的，针对输入张量进行的一系列操作过程。而所谓的“学习”就是不断纠正神经网络的实际输出结果和预期结果之间的误差的过程。</p>
</li>
<li><p>这里的一系列操作包含的范围很宽，可以是简单的矩阵乘法，也可以是卷积，池化和LSTM等稍复杂的运算。而且各框架支持的张量操作通常也不尽相同。</p>
</li>
<li><p>需要指出的是，<strong>大部分的张量操作都是基于类实现的（而且是抽象类）</strong>，而并不是函数（这一点可能要归功于大部分的深度学习框架都是用面向对象的编程语言实现的）。</p>
</li>
<li><p>这种实现思路一方面允许开发这将各种类似的操作汇总在一起，方便组织管理。另一方面也保证了整个代码的复用性，扩展性和对外接口的统一。总体上让整个框架更灵活和易于扩展，为将来的发展预留了空间。</p>
</li>
</ul>
<h3 id="计算图-Computation-Graph"><a href="#计算图-Computation-Graph" class="headerlink" title="计算图(Computation Graph)"></a>计算图(Computation Graph)</h3><ul>
<li><p>有了张量和基于张量的各种操作之后，下一步就是将各种操作整合起来，输出需要的结果</p>
</li>
<li><p>但不幸的是，随着操作种类和数量的增多，有可能引发各种意想不到的问题，包括多个操作之间应该并行还是顺次执行，如何协同各种不同的底层设备，以及如何避免各种类型的冗余操作等。这些问题有可能拉低整个深度学习网络的运行效率或者引入不必要的Bug，而计算图正是为解决这一问题产生的。</p>
</li>
<li><p>计算图首次被引入人工智能领域是2009年的论文<code>&lt;Learning Deep Architectures for AI&gt;</code>。作者用不同的占位符构成操作结点，以字母构成变量结点，再以有向线段将这些结点连接起来，组成一个表征运算逻辑关系的清晰明了的图型数据结构，这就是最初的计算图</p>
</li>
<li><p>后来随着技术的不断演进，加上脚本语言和低级语言各自不同的特点（概括地说，脚本语言建模方便但执行缓慢，低级语言正好相反），因此业界逐渐形成了一种开发框架：<strong>前端用Python等脚本语言建模，后端用C++等低级语言执行（这里低级是就应用层而言），以此综合了两者的优点</strong>。</p>
</li>
<li><p>这种开发框架大大降低了传统框架做跨设备计算时的代码耦合度，也避免了每次后端变动都需要修改前端的维护开销。而这里，在前端和后端之间起到的关键耦合作用的就是计算图。</p>
</li>
<li><p>将计算图作为前后端之间的中间表示(Intermediate Representations)可以带来良好的交互性，开发这可以将Tensor对象作为数据结构，函数&#x2F;方法作为操作类型，将特定的操作类型应用于特定的数据结构，从而定义出类似MATLAB的强大建模语言。</p>
</li>
<li><p>因为计算图的引入，开发者得以从宏观上俯瞰整个神经网络的内部结构，就好像编译器可以从整个代码的角度决定如何分配寄存器那样，计算图也可以从宏观上决定代码运行时的GPU内存分配，以及分布式环境中不同底层设备间的相互协作方式。除此之外，现在也有许多深度学习框架将计算图应用于模型调试，可以实时输出当前某一操作类型的文本描述。</p>
</li>
</ul>
<h3 id="自动微分-Automatic-Differentiation-工具"><a href="#自动微分-Automatic-Differentiation-工具" class="headerlink" title="自动微分(Automatic Differentiation)工具"></a>自动微分(Automatic Differentiation)工具</h3><ul>
<li><p>计算图带来的另一个好处是让模型训练阶段的梯度计算变得模块化且更为便捷，也就是自动微分法。</p>
</li>
<li><p><strong>我们可以将神经网络视为由许多非线性过程组成的一个复杂的函数体，而计算图则以模块化的方式完整表征了这一函数体的内部逻辑关系，因此微分这一复杂函数体，即求取模型梯度的方法就变成了在计算图中简单地从输入到输出进行一次完整遍历的过程</strong>。与自动微分对应，业内更传统的做法是符号微分。</p>
</li>
</ul>
<h3 id="BLAS-CUBLAS-CUDNN等扩展包"><a href="#BLAS-CUBLAS-CUDNN等扩展包" class="headerlink" title="BLAS, CUBLAS, CUDNN等扩展包"></a><code>BLAS, CUBLAS, CUDNN</code>等扩展包</h3><ul>
<li><p>通过上述所有模块，已经可以搭建一个全功能的深度学习框架：</p>
<ul>
<li>将待处理数据转换为张量，针对张量施加各种需要的操作，通过自动微分对模型展开训练，然后得到输出结果开始测试</li>
<li>这个时候还缺 – 运算效率</li>
</ul>
</li>
<li><p>由于此前的大部分实现都是基于高级语言的，而即时是执行最简单的操作，高级语言也会比低级语言消耗更多的CPU周期，更何况是结构复杂的深度神经网络，因此运算缓慢就成了高级语言的一个天然的缺陷。</p>
</li>
<li><p>目前针对这一个问题有两种解决方案</p>
<ul>
<li>第一种方法是模拟传统的编译器。就好像传统编译器会把高级语言编译成特定平台的汇编语言实现高效运行一样，这种方法将高级语言转换为C语言，然后在C语言基础上编译，执行。为了实现这种转换，每一种张量操作的实现代码就会预先加入C语言的转换部分，然后由编译器在编译阶段将这些由C语言实现的张量操作综合在一起。目前<code>pyCUDA</code>和<code>Cpython</code>等编译器都已经实现了这一功能</li>
<li>第二种方法就是，利用脚本语言实现前端建模，用低级语言实现后端运行，这意味着高级语言和低级语言之间的交互都发生在框架内部，因此每次的后端变动都不需要修改前端，也不需要完整编译（只需要通过修改编译参数进行部分编译），因此整体速度也就更快</li>
</ul>
</li>
<li><p>除此之外，由于低级语言的最优化编程难度很高，而且大部分的基础操作其实也都有公开的最优解决方案，因此另一个显著的加速手段就是利用现成的扩展包。</p>
</li>
<li><p>例如，最初用<code>Fortran</code>实现的BLAS（基础线形代数子程序）就是一个非常优秀的基本矩阵（张量）运算库，此外，还有英特尔的MKL(<code>Math Kernel Library</code>)等</p>
</li>
<li><p>为了向开发者提供尽量简单的接口，大部分深度学习框架通常都会将普通的概念抽象化，这可能是造成许多用户感知不到上述五点核心组件的重要原因。</p>
</li>
</ul>
<h2 id="sigmoid-归一化"><a href="#sigmoid-归一化" class="headerlink" title="sigmoid 归一化"></a>sigmoid 归一化</h2><ul>
<li><p>The sigmoid function is a mathematical function that has a characteristic that can take any real value and map it to between 0 to 1 shaped like the letter “S”.</p>
</li>
<li><p><code>Sigmoid</code>功能在机器学习中扮演激活函数的作用，该功能用于在机器学习模型中添加非线性。基本上，该函数确定要传递的值作为输出以及不通过输出传递的值。机器学习和深度学习中使用了7种类型的激活功能</p>
</li>
<li><p><code>Sigmoid</code>神经元本质上是深神经网络的基础。这些sigmoid神经元与感知性相似，但是它们恰好被稍微修饰，因此来自Sigmoid神经元的输出比Perceptron的步骤功能输出更光滑</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-YoloV3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-YoloV3/" class="post-title-link" itemprop="url">YoloV3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="yolov3算法思想"><a href="#yolov3算法思想" class="headerlink" title="yolov3算法思想"></a>yolov3算法思想</h3><ul>
<li>yolo的作者将目标检测问题视为回归问题:首先将整幅图划分为<code>S*S</code>的网格,如果目标框的中心店落在这个网格中,那么这个网格就负责预测这个目标</li>
<li>每一个网格都会预测<code>bounding box(边界框)</code>, <code>confidence(置信度)</code>以及<code>class probability map(类概率图)</code><ul>
<li>bounding box, 包含四个值:x, y, w, h其中(x, y)代表预测框的中心点, (w, h)代表预测框的宽和高</li>
<li>confidence, 表示预测框包含目标的可能性,训练时的真值为预测框和真值框的IOU</li>
<li>class probability map, 表明这个目标所属类别的置信度</li>
</ul>
</li>
</ul>
<p>yolov3网络结构</p>
<ul>
<li>yolov3在3个scale的特征图上分别预测不同大小的目标,即在8倍,16倍和32倍的特征图上进行预测,也就是说如果我们的输入为416<em>416,那么yolov3预测时采用的特征图的大小分别为52</em>52, 32<em>32, 13</em>13</li>
<li>总之,yolov3在3中不同尺度的特征图上进行检测,因此如果我们输入416*416大小的图像,它将产生三种不同的输出形状张量: <code>13*13*255, 26*26*255和52*52*255</code></li>
</ul>
<p>残差模块</p>
<ul>
<li>残差模块(Residual module)最显著的特点是使用了一种shortcut机制,以缓解因增加神经网络中的深度而导致的梯度消失的问题,从而使神经网络更易于训练</li>
<li>它主要使用identity mapping在输入和输出之间建立连接</li>
</ul>
<p>特征图分析</p>
<ul>
<li>要详细了解yolo的输出含义,首先需要了解什么是特征图</li>
<li>在讨论CNN网络结构的时候,总经常使用的一个词汇叫做<code>feature map</code>,简单地说,输入图像与卷积核进行卷积操作后就可以获得图像特征.</li>
<li>一般来说,当输入图像经过CNN提取特征时,特征图的数量(卷积核的数量)将增加,同时空间信息将减少,当然提取到的特征也会越来越抽象.随着网络变深,特征图的空间尺寸越来越小,但是通道数目越来越大,这是CNN的特性</li>
<li>当CNN网络自下而上从输入图像中提取特征时,生成的特征图通常在空间尺寸上越来越小,在通道数目上越来越深.这个特性与ROI(感兴趣区)到特征图的映射有关.</li>
<li>将原始图像中的ROI映射到CNN网络空间后,特征图上的空间会变小,甚至成为一个点,但是该点的通道信息会非常丰富.该信息是CNN网络上映射的ROI区域中图像信息的特征表示</li>
<li>由于图像中的像素在空间上紧密相连,这导致了空间上的巨大冗余.因此,通常通过减少空间维度和增加通道维度来消除这种冗余,并尝试在最小维度中获得其最重要的特征.举例:图像的ROI经过CNN映射,在特征图上仅获得一个点,但是该点有85个通道线,因此,ROI的维度已经从原来的[32, 32, 3]变为当前的85维.</li>
<li>这实际上是yolo网络对ROI执行特征提取后获得的85维特征向量.该特征向量的前四个维度表示候选框信息,中间维度表示判断对象是否存在的概率,接下来的80个维度表示80个类别的分类概率信息.</li>
</ul>
<p>理解输出</p>
<ul>
<li>yolov3网络的输入尺寸为(m, 416, 416, 3),其中m代表每个batch中图像数目.m&#x3D;1,代表每个batch处理1张输入图像</li>
<li>yolov3分3个尺度进行预测,3个尺度的特征图的大小依次为13 x 13, 26 x 26, 52 x 52</li>
<li>yolov3中每个cell预测3个bounding box,每个bounding box可以表示为6元组:(tx, ty, yw, th, pc, c)</li>
<li>在COCO数据集中一共有80个类别,此时我们将c扩展成80维向量,这样每个bounding box可以用85维向量进行表示</li>
<li>输入图像尺寸为416*416,将采样缩小32倍,得到特征图的大小为<code>13*13</code>,也就是说,将输入图像划分成<code>13*13</code>的网格,每个cell对应输入图像中对应<code>32*32</code>的区域</li>
<li>如果每个cell在原图中包含物体真实框的中心点时,那么这个cell负责预测该目标,</li>
</ul>
<p>理解bounding box</p>
<ul>
<li>yolov3网络结构中有3个分支(3个不同尺度的特征图)被送到decode函数来进一步进行解析</li>
</ul>
<p>NMS后处理</p>
<ul>
<li>从候选框中选择置信度最高的box</li>
<li>计算当前框和其他框的IOU,如果IOU&gt;iou_threshold,则移除对应的box</li>
<li>重复上述步骤进行迭代,知道剩余框中没有和当前挑选出的box重叠iou大于阈值的框</li>
<li>上述过程主要是为了过滤和当前框具有很大重叠度的框,针对每个目标仅保留网络预测置信度最高的那个框</li>
</ul>
<h3 id="yolov3的输出"><a href="#yolov3的输出" class="headerlink" title="yolov3的输出"></a>yolov3的输出</h3><ul>
<li>9个anchor会被三个输出张量平分,根据大中小三种size各自取自己的anchor</li>
<li>每个输出y在自己的网络上都会输出3个预测框,这三个框是9除以3得到的,这是作者设置的,我们可以从输出张量的维度来看</li>
<li>13 * 13 * 255:<ul>
<li>13 * 13 : 表示网格的数量,将图片分成13 * 13个网格</li>
<li>255 : 3 * (5 + 80)<ul>
<li>80:表示能够识别80个物品类别</li>
<li>5:表示位置信息和置信度(x, y, w, h, confidence)</li>
<li>3:表示要输出3个prediction;从代码上来看,3是由<code>num_anchors</code>得到的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>作者使用了logistics回归来对每个anchor包围的内容进行了一个目标性平分(objectness score),根据目标性平分来选择anchor prior进行predict,而不是所有的anchor prior都会有输出.</p>
<h3 id="yolov3输出张量解码过程"><a href="#yolov3输出张量解码过程" class="headerlink" title="yolov3输出张量解码过程"></a>yolov3输出张量解码过程</h3><ul>
<li>yolo网络输出是一个<strong>元组</strong>,包含三个张量,代表三个不同尺度,大小是<code>1*255*13*13</code>, <code>1*255*26*26</code>和<code>1*255*52*52</code>.(255:表示每个格点输出三个预测框,每个预测框包含85个元素,一共是255个元素)</li>
<li>yolov3解码过程包括五个阶段:<ol>
<li>缩小先验框</li>
<li>生成网格</li>
<li>生成预测框</li>
<li>非极大值抑制</li>
<li>显示预测框</li>
</ol>
</li>
<li>解码过程包含的尺寸变换:<ol>
<li>原尺寸变换为416*416</li>
<li>为了在特征图上确定预测框的大小和位置,将先验框缩小(416&#x2F;13, 416&#x2F;26, 416&#x2F;52)倍</li>
<li>在特征图上生成网格,根据输出张量,确定预测框的位置和大小;然后将坐标和宽高信息放大(416&#x2F;13, 416&#x2F;26, 416&#x2F;52)倍,在原图中显示;最后将原图恢复至原来的大小.</li>
</ol>
</li>
</ul>
<p>opencv预处理:</p>
<ul>
<li>blobFromImage():<ul>
<li>Mat cv::dnn::blobFromImage(+<br>        InputArray image,             &#x2F;&#x2F; 输入图像<br>        double scalefactor &#x3D; 1.0,     &#x2F;&#x2F; 图像值的乘数<br>        const Size&amp;   size &#x3D; Size(),  &#x2F;&#x2F; 输出图像的空间大小<br>        const Scalar&amp; mean &#x3D; Scalar(),&#x2F;&#x2F; 带有从通道中减去的平均值的标量.如果图像具有BGR排序且swapRB为真,则值应按(mean-R, mean-G, mean-B)顺序排列<br>        bool   swapRB &#x3D; false,        &#x2F;&#x2F; 表示需要交换3通道图像中的第一个和最后一个通道的标志<br>        bool   crop &#x3D; false,          &#x2F;&#x2F; 指示调整大小后是否裁剪图像的标志<br>        int ddepth &#x3D; CV_32F           &#x2F;&#x2F; 输出blob的深度.选择CV_32F或者CV_8U<br>        )</li>
<li>返回格式:NCHW</li>
<li>从图像创建4维blob.可选择从中心调整图像大小和裁剪图像,减去平均值,按比例因子缩放值,交换蓝色和红色通道</li>
</ul>
</li>
</ul>
<p>opencv后处理:</p>
<ul>
<li><p>minMaxLoc():</p>
<ul>
<li>void cv::minMaxLoc(<br>    InputArray src,             &#x2F;&#x2F; 输入的单通道数组<br>    double* minVal              &#x2F;&#x2F; 指针返回的最小值的指针;如果不需要,则使用NULL<br>    double* maxVal &#x3D; 0,         &#x2F;&#x2F; 指针返回的最大值的指针,如果不需要,则使用NULL<br>    Point*  minLoc &#x3D; 0,         &#x2F;&#x2F; 指向返回的最小位置的指针(在2D情况下),如果不需要,则使用NULL<br>    Point*  maxLoc &#x3D; 0,         &#x2F;&#x2F; 指向返回的最大位置的指针(在2D情况下),如果不需要,则使用NULL<br>    InputArray mask &#x3D; noArray() &#x2F;&#x2F; 用于选择子数组的可选掩码<br>     )</li>
<li>功能:查找数组中的全局最小值和最大值(和位置).</li>
</ul>
</li>
<li><p>NMSBoxes():</p>
<ul>
<li>void cv::dnn::NMSBoxes(<br>        const std::vector<Rect>&amp; bboxes,  &#x2F;&#x2F; 一组边界框来应用NMS<br>        const std::vector<float>&amp; scores, &#x2F;&#x2F; 一组对应的置信度<br>        const float score_threshold,      &#x2F;&#x2F; 用于按分数过滤的阈值<br>        const float nms_threshold,        &#x2F;&#x2F; 用于非最大抑制的阈值<br>        std::vector<int>&amp; indices,        &#x2F;&#x2F; NMS后保存的bbox索引<br>        const flat eta &#x3D; 1.f,             &#x2F;&#x2F; 自适应阈值公式中的一个系数<br>        const int top_k &#x3D; 0               &#x2F;&#x2F; 如果&gt;0,则最多保留top_k个选择的索引<br>        )</li>
<li>功能:在给定框和相应分数的情况下执行非最大抑制</li>
</ul>
</li>
</ul>
<p>yaml:用来写配置文件的语言</p>
<ul>
<li>YAML,是一个可读性高,用来表达数据序列化的格式</li>
<li>YAML,是<code>YAML Ain&#39;t a Markup Language</code>的递归缩写</li>
<li>使用场景:<ul>
<li>由于实现简单,解析成本很低,YAML特别适合在脚本语言中使用</li>
<li>YAML,比较适合做序列化,因为它是宿主语言数据类型直转的</li>
<li>YAML做配置文件也不错.写YAML要比写XML快得多,无需关注标签或引号,并且比ini文档功能更强</li>
<li></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-Caffe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-Caffe/" class="post-title-link" itemprop="url">Caffe</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Caffe，全称Convolutional Architecture for Fast Feature Embedding。是一种常用的深度学习框架，主要应用在视频、图像处理方面的应用上。</li>
<li>caffe是一个清晰，可读性高，快速的深度学习框架</li>
</ul>
<h2 id="网络结构层参数"><a href="#网络结构层参数" class="headerlink" title="网络结构层参数"></a>网络结构层参数</h2><ul>
<li><p><code>prototxt</code>文件是<code>caffe</code>的配置文件，用于保存CNN的网络结构和配置信息。</p>
</li>
<li><p><code>prototxt</code>文件有三种，分别是<code>deploy.prototxt</code>，<code>train_val.prototxt</code>和<code>solver.prototxt</code></p>
</li>
<li><p><code>solver.prototxt</code></p>
<ul>
<li><code>solver.prototxt</code>是caffe的配置文件。里面定义了网络训练时候的各种参数，比如学习率、权重衰减、迭代次数等等。</li>
<li><code>solver.prototxt</code>文件只在网络进行训练的时候需要载入。是网络训练的一个整体的参数配置文件。</li>
</ul>
</li>
<li><p><code>deploy.prototxt</code>和<code>train_val.prototx</code></p>
<ul>
<li>这两个文件是<code>caffe</code>的网络结构文件。</li>
<li><code>train_val.prototx</code>是训练时候的网络结构，<code>deploy.prototxt</code>用于发布（即测试时候的网络结构）。</li>
<li>这两个文件中内容基本一致，但是存在一些细微区别：<ul>
<li>在<code>train_val.prototx</code>中网络结构的<code>data</code>层有两种，分别为<code>TRAIN</code>和<code>TEST</code>。顾名思义，<code>TRAIN</code>是网络训练时后的数据结构，<code>TEST</code>是网络做验证时候的数据结构。一般来说<code>TRAIN</code>中的<code>batchSize</code>比<code>TEST</code>中的要大一些。</li>
<li>在<code>train_val.prototx</code>中的卷积层（<code>Convolution</code>）中存在学习率和权重衰减的参数，而<code>deploy.prototxt</code>文件中则没有这些参数（有些<code>deploy.prototxt</code>中仍然有这些参数，但是对测试不起任何作用）。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-onnx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-onnx/" class="post-title-link" itemprop="url">onnx</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>onnx相关笔记</li>
</ul>
<h2 id="TensorRT-OpenVino-ONNXRuntime-OpenCV-dnn"><a href="#TensorRT-OpenVino-ONNXRuntime-OpenCV-dnn" class="headerlink" title="TensorRT, OpenVino, ONNXRuntime, OpenCV dnn"></a>TensorRT, OpenVino, ONNXRuntime, OpenCV dnn</h2><ul>
<li>无论用什么框架训练的模型，推荐转为onnx格式，方便部署</li>
<li>支持onnx模型的框架如下<ul>
<li>TensorRT： 英伟达的，用于 GPU 推理加速。注意需要英伟达 GPU 硬件的支持</li>
<li>OpenVino： 英特尔的，用于 CPU 推理加速。注意需要英特尔 CPU 硬件的支持</li>
<li>ONNXRuntime： 微软，亚马逊，Facebook和IBM等公司共同开发的，可用于CPU，GPU</li>
<li>OpenCV dnn： OpenCV的调用模型的模块</li>
</ul>
</li>
<li>pt格式的模型，可以用Pytorch框架部署</li>
<li>推理效率上：TensorRT &gt; OpenVino &gt; ONNXRuntime &gt; OpenCV dnn &gt; Pytorch</li>
</ul>
<h2 id="onnx推理"><a href="#onnx推理" class="headerlink" title="onnx推理"></a>onnx推理</h2><ul>
<li>ONNX的推理分别需要装两种框架<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install onnxruntime       <span class="comment"># CPU 版本</span></span><br><span class="line">pip install onnxruntime-gpu   <span class="comment"># GPU 版本</span></span><br></pre></td></tr></table></figure></li>
<li>而且需要在保存pytorch模型的时候也需要指定cpu和gpu。</li>
<li>这里推理就不需要pytorch框架来支持了，尤其是在容器部署的时候pytorch框架安装包非常大这会导致部署的镜像也很大，如果推理去掉pytorch框架的情况下镜像大小也会减少很多，大大减少部署难度。</li>
</ul>
<h2 id="onnx概述"><a href="#onnx概述" class="headerlink" title="onnx概述"></a>onnx概述</h2><ul>
<li><p>深度学习算法大多通过计算数据流图来完成神经网络的深度学习过程。 一些框架（例如CNTK，Caffe2，Theano和TensorFlow）使用静态图形，而其他框架（例如 PyTorch 和 Chainer）使用动态图形。</p>
</li>
<li><p>但是这些框架都提供了接口，使开发人员可以轻松构建计算图和运行时，以优化的方式处理图。 这些图用作中间表示（IR），捕获开发人员源代码的特定意图，有助于优化和转换在特定设备（CPU，GPU，FPGA等）上运行</p>
</li>
<li><p>ONNX 的本质只是一套开放的 ML 模型标准，模型文件存储的只是网络的拓扑结构和权重（其实每个深度学习框架最后保存的模型都是类似的），脱离开框架是没办法对模型直接进行 inference 的</p>
</li>
<li><p>为什么使用通用IR</p>
<ul>
<li>现在很多的深度学习框架提供的功能都是类似的，但是在 API、计算图和 runtime 方面却是独立的，这就给 AI 开发者在不同平台部署不同模型带来了很多困难和挑战，ONNX 的目的在于提供一个跨框架的模型中间表达框架，用于模型转换和部署。ONNX 提供的计算图是通用的，格式也是开源的。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" class="post-title-link" itemprop="url">计算机视觉</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>计算机视觉相关笔记</li>
</ul>
<h2 id="计算机视觉-维基百科"><a href="#计算机视觉-维基百科" class="headerlink" title="计算机视觉(维基百科)"></a>计算机视觉(维基百科)</h2><ul>
<li><p>计算机视觉（Computer vision）是一门研究如何使机器“看”的科学，更进一步的说，就是指用摄影机和计算机代替人眼对目标进行识别、跟踪和测量等机器视觉，并进一步做图像处理，用计算机处理成为更适合人眼观察或传送给仪器检测的图像</p>
</li>
<li><p>作为一门科学学科，计算机视觉研究相关的理论和技术，试图建立能够从图像或者多维数据中获取“信息”的人工智能系统。这里所指的信息指香农定义的，可以用来帮助做一个“决定”的信息。因为感知可以看作是从感官信号中提取信息，所以计算机视觉也可以看作是研究如何使人工系统从图像或多维数据中“感知”的科学</p>
</li>
<li><p>作为一个工程学科，计算机视觉寻求基于相关理论与模型来建立计算机视觉系统。这类系统的组成部分包括：</p>
<ul>
<li>过程控制（例如工业机器人和无人驾驶汽车）</li>
<li>事件监测（例如图像监测）</li>
<li>信息组织（例如图像数据库和图像序列的索引建立）</li>
<li>物体与环境建模（例如工业检查，医学图像分析和拓扑建模）</li>
<li>交感互动（例如人机互动的输入设备）</li>
</ul>
</li>
<li><p>计算机视觉同样可以被看作是生物视觉的一个补充。在生物视觉领域中，人类和各种动物的视觉都得到了研究，从而建立了这些视觉系统感知信息过程中所使用的物理模型。另一方面，在计算机视觉中，靠软件和硬件实现的人工智能系统得到了研究与描述。生物视觉与计算机视觉进行的学科间交流为彼此都带来了巨大价值。</p>
</li>
<li><p>计算机视觉的发展现状</p>
<ul>
<li>在计算机视觉的大多数实际应用当中，计算机被预设为解决特定的任务，然而基于机器学习的方法正日渐普及，一旦机器学习的研究进一步发展，未来“泛用型”的电脑视觉应用或许可以成真。</li>
<li>人工智能所研究的一个主要问题是：如何让系统具备“计划”和“决策能力”？从而使之完成特定的技术动作（例如：移动一个机器人通过某种特定环境）。这一问题便与计算机视觉问题息息相关。在这里，计算机视觉系统作为一个感知器，为决策提供信息。另外一些研究方向包括模式识别和机器学习（这也隶属于人工智能领域，但与计算机视觉有着重要联系），也由此，计算机视觉时常被看作人工智能与计算机科学的一个分支。</li>
<li>物理是与计算机视觉有着重要联系的另一领域。</li>
<li>计算机视觉关注的目标在于充分理解电磁波——主要是可见光与红外线部分——遇到物体表面被反射所形成的图像，而这一过程便是基于光学物理和固态物理，一些尖端的图像传感器甚至会应用到量子力学理论，来解析影像所表示的真实世界。同时，物理学中的很多测量难题也可以通过计算机视觉得到解决，例如流体运动。也由此，计算机视觉同样可以被看作是物理学的拓展</li>
<li>另一个具有重要意义的领域是神经生物学，尤其是其中生物视觉系统的部分</li>
<li>计算机视觉的另一个相关领域是信号处理。很多有关单元变量信号的处理方法，尤其对是时变信号的处理，都可以很自然的被扩展为计算机视觉中对二元变量信号或者多元变量信号的处理方法。但由于图像数据的特有属性，很多计算机视觉中发展起来的方法，在单元信号的处理方法中却找不到对应版本。这类方法的一个主要特征，便是他们的非线性以及图像信息的多维性，以上二点作为计算机视觉的一部分，在信号处理学中形成了一个特殊的研究方向。</li>
<li>除了上面提到的领域，很多研究课题同样可被当作纯粹的数学问题。例如，计算机视觉中的很多问题，其理论基础便是统计学，最优化理论以及几何学。</li>
<li>如何使既有方法通过各种软硬件实现，或说如何对这些方法加以修改，而使之获得合理的执行速度而又不损失足够精度，是现今计算机视觉领域的主要课题。</li>
</ul>
</li>
<li><p>相邻领域的异同</p>
<ul>
<li>计算机视觉，图像处理，图像分析，机器人视觉和机器视觉是彼此紧密关联的学科。如果你翻开带有上面这些名字的教材，你会发现在技术和应用领域上他们都有着相当大部分的重叠。这表明这些学科的基础理论大致是相同的，甚至让人怀疑他们是同一学科被冠以不同的名称。</li>
<li>计算机视觉的研究对象主要是映射到单幅或多幅图像上的三维场景，例如三维场景的重建。计算机视觉的研究很大程度上针对图像的内容。</li>
<li>图像处理与图像分析的研究对象主要是二维图像，实现图像的转化，尤其针对像素级的操作，例如提高图像对比度，边缘提取，去噪声和几何变换如图像旋转。这一特征表明无论是图像处理还是图像分析其研究内容都和图像的具体内容无关。</li>
<li>机器视觉主要是指工业领域的视觉研究，例如自主机器人的视觉，用于检测和测量的视觉。这表明在这一领域通过软件硬件，图像感知与控制理论往往与图像处理得到紧密结合来实现高效的机器人控制或各种实时操作。</li>
<li>模式识别使用各种方法从信号中提取信息，主要运用统计学的理论。此领域的一个主要方向便是从图像数据中提取信息。</li>
<li>还有一个领域被称为成像技术。这一领域最初的研究内容主要是制作图像，但有时也涉及到图像分析和处理。例如，医学成像就包含大量的医学领域的图像分析。</li>
</ul>
</li>
<li><p>计算机视觉的经典问题</p>
<ul>
<li>几乎在每个计算机视觉技术的具体应用都要解决一系列相同的问题。这些经典的问题包括：</li>
<li>识别<ul>
<li>一个计算机视觉，图像处理和机器视觉所共有的经典问题便是判定一组图像数据中是否包含某个特定的物体，图像特征或运动状态。这一问题通常可以通过机器自动解决，但是到目前为止，还没有某个单一的方法能够广泛的对各种情况进行判定：在任意环境中识别任意物体。现有技术能够也只能够很好地解决特定目标的识别，比如简单几何图形识别，人脸识别，印刷或手写文件识别或者车辆识别。而且这些识别需要在特定的环境中，具有指定的光照，背景和目标姿态要求。</li>
<li>广义的识别在不同的场合又演化成了几个略有差异的概念：<ul>
<li>识别（狭义的）：对一个或多个经过预先定义或学习的物体或物类进行辨识，通常在辨识过程中还要提供他们的二维位置或三维姿态。</li>
<li>鉴别：识别辨认单一物体本身。例如：某一人脸的识别，某一指纹的识别。</li>
<li>监测：从图像中发现特定的情况内容。例如：医学中对细胞或组织不正常技能的发现，交通监视仪器对过往车辆的发现。监测往往是通过简单的图象处理发现图像中的特殊区域，为后继更复杂的操作提供起点</li>
</ul>
</li>
<li>识别的几个具体应用方向：<ul>
<li>基于内容的图像提取：在巨大的图像集合中寻找包含指定内容的所有图片。被指定的内容可以是多种形式，比如一个红色的大致是圆形的图案，或者一辆自行车。在这里对后一种内容的寻找显然要比前一种更复杂，因为前一种描述的是一个低级直观的视觉特征，而后者则涉及一个抽象概念（也可以说是高级的视觉特征），即‘自行车’，显然的一点就是自行车的外观并不是固定的。</li>
<li>姿态评估：对某一物体相对于摄像机的位置或者方向的评估。例如：对机器臂姿态和位置的评估。</li>
<li>光学字符识别对图像中的印刷或手写文字进行识别鉴别，通常的输出是将之转化成易于编辑的文档形式。</li>
</ul>
</li>
</ul>
</li>
<li>运动<ul>
<li>基于序列图像的对物体运动的监测包含多种类型，诸如：<ul>
<li>自体运动：监测摄像机的三维刚性运动</li>
<li>图像跟踪：跟踪运动的物体</li>
</ul>
</li>
</ul>
</li>
<li>场景重建<ul>
<li>给定一个场景的二或多幅图像或者一段录像，场景重建寻求为该场景建立一个三维模型。最简单的情况便是生成一组三维空间中的点。更复杂的情况下会建立起完整的三维表面模型。</li>
</ul>
</li>
<li>图像恢复<ul>
<li>图像恢复的目标在于移除图像中的噪声，例如仪器噪声、动态模糊等</li>
</ul>
</li>
</ul>
</li>
<li><p>计算机视觉系统</p>
<ul>
<li>计算机视觉系统的结构形式很大程度上依赖于其具体应用方向。有些是独立工作的，用于解决具体的测量或检测问题；也有些作为某个大型复杂系统的组成部分出现，比如和机械控制系统，数据库系统，人机接口设备协同工作。计算机视觉系统的具体实现方法同时也由其功能决定——是预先固定的抑或是在运行过程中自动学习调整。尽管如此，有些功能却几乎是每个计算机系统都需要具备的：</li>
<li>图像获取：一幅数字图像是由一个或多个图像传感器产生，这里的传感器可以是各种光敏摄像机，包括遥感设备，X射线断层摄影仪，雷达，超声波接收器等。取决于不同的传感器，产生的图片可以是普通的二维图像，三维图组或者一个图像序列。图片的像素值往往对应于光在一个或多个光谱段上的强度（灰度图或彩色图），但也可以是相关的各种物理数据，如声波，电磁波或核磁共振的深度，吸收度或反射度。</li>
<li>预处理：在对图像实施具体的计算机视觉方法来提取某种特定的信息前，一种或一些预处理往往被采用来使图像满足后继方法的要求。例如：<ul>
<li>二次取样保证图像坐标的正确</li>
<li>平滑去噪来滤除传感器引入的设备噪声</li>
<li>提高对比度来保证实现相关信息可以被检测到</li>
<li>调整尺度空间使图像结构适合局部应用</li>
</ul>
</li>
<li>特征提取：从图像中提取各种复杂度的特征。例如<ul>
<li>线、边缘提取和脊侦测</li>
<li>局部化的特征点检测如边角检测、斑点检测</li>
<li>更复杂的特征可能与图像中的纹理形状或运动有关</li>
</ul>
</li>
<li>检测&#x2F;分割：在图像处理过程中，有时会需要对图像进行分割来提取有价值的用于后继处理的部分，例如：<ul>
<li>筛选特征点</li>
<li>分割一或多幅图片中含有特定目标的部分</li>
</ul>
</li>
<li>高级处理：到了这一步，数据往往具有很小的数量，例如图像中经先前处理被认为含有目标物体的部分。这时的处理包括：<ul>
<li>验证得到的数据是否符合前提要求</li>
<li>估测特定系数，比如目标的姿态、体积</li>
<li>对目标进行分类</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-tensorflow_serving/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-tensorflow_serving/" class="post-title-link" itemprop="url">tensorflow_serving</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>tensorflow serving库相关笔记</li>
</ul>
<h2 id="TensorFlow-Serving是什么"><a href="#TensorFlow-Serving是什么" class="headerlink" title="TensorFlow Serving是什么"></a>TensorFlow Serving是什么</h2><ul>
<li>TensorFlow Serving 是一个适用于机器学习模型的灵活、高性能应用系统，专为生产环境而设计。借助 TensorFlow Serving，您可以轻松部署新算法和实验，同时保留相同的服务器架构和 API。TensorFlow Serving 提供与 TensorFlow 模型的开箱即用型集成，但也可以轻松扩展以应用其他类型的模型和数据。</li>
</ul>
<h2 id="C-tensorflow-serving库-详解"><a href="#C-tensorflow-serving库-详解" class="headerlink" title="C++ tensorflow serving库 详解"></a>C++ tensorflow serving库 详解</h2><p>TensorFlow Serving 是一个用于部署机器学习模型的开源库，它提供了一个高性能、灵活的方式来将训练好的 TensorFlow 模型部署到生产环境中，以便进行实时预测。虽然 TensorFlow Serving 主要是用 C++ 实现的，但它也提供了 Python API 以方便用户使用。</p>
<p>下面是对 TensorFlow Serving C++ 库的详细介绍：</p>
<ol>
<li><p><strong>核心功能</strong>：</p>
<ul>
<li>加载和管理模型：TensorFlow Serving 能够加载和管理训练好的 TensorFlow 模型，包括 SavedModel 格式。</li>
<li>提供预测服务：一旦模型被加载，TensorFlow Serving 可以为客户端提供实时的预测服务，支持单个或批量请求。</li>
<li>高性能和可扩展性：TensorFlow Serving 在设计上注重性能和可扩展性，能够处理高并发的请求并保持低延迟。</li>
</ul>
</li>
<li><p><strong>架构</strong>：</p>
<ul>
<li>TensorFlow Serving 的架构主要由三个组件组成：Servable、Loader 和 Servable Manager。</li>
<li>Servable 是指 TensorFlow 模型的一种抽象，它代表了一个可部署的模型或模型的版本。</li>
<li>Loader 负责加载 Servable，并在需要时将其初始化或卸载。</li>
<li>Servable Manager 负责管理 Servable 的生命周期，包括加载、卸载和路由请求等。</li>
</ul>
</li>
<li><p><strong>部署流程</strong>：</p>
<ul>
<li>准备模型：首先需要使用 TensorFlow 训练模型，并将其保存为 SavedModel 格式。</li>
<li>配置 TensorFlow Serving：创建一个模型配置文件，指定模型的路径、输入和输出等信息。</li>
<li>启动 TensorFlow Serving：运行 TensorFlow Serving 服务器，并指定模型配置文件。</li>
<li>发送请求：客户端向 TensorFlow Serving 发送预测请求，服务器返回预测结果。</li>
</ul>
</li>
<li><p><strong>使用示例</strong>：<br>下面是一个简单的 TensorFlow Serving C++ 应用示例，假设我们已经有一个名为 <code>my_model</code> 的 SavedModel：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;grpcpp/grpcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tensorflow_serving/apis/prediction_service.grpc.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> grpc::Channel;</span><br><span class="line"><span class="keyword">using</span> grpc::ClientContext;</span><br><span class="line"><span class="keyword">using</span> grpc::Status;</span><br><span class="line"><span class="keyword">using</span> tensorflow::serving::PredictRequest;</span><br><span class="line"><span class="keyword">using</span> tensorflow::serving::PredictResponse;</span><br><span class="line"><span class="keyword">using</span> tensorflow::serving::PredictionService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TensorFlowServingClient</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TensorFlowServingClient</span>(std::shared_ptr&lt;Channel&gt; channel)</span><br><span class="line">        : <span class="built_in">stub_</span>(PredictionService::<span class="built_in">NewStub</span>(channel)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送预测请求</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Predict</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PredictRequest request;</span><br><span class="line">        PredictResponse response;</span><br><span class="line">        ClientContext context;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置输入数据</span></span><br><span class="line">        <span class="comment">// request.mutable_model_spec()-&gt;set_name(&quot;my_model&quot;);</span></span><br><span class="line">        <span class="comment">// 添加输入数据</span></span><br><span class="line">        <span class="comment">// request.mutable_inputs()-&gt;...;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送预测请求</span></span><br><span class="line">        Status status = stub_-&gt;<span class="built_in">Predict</span>(&amp;context, request, &amp;response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理预测结果</span></span><br><span class="line">        <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            <span class="comment">// 处理 response 中的输出结果</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;RPC failed: &quot;</span> &lt;&lt; status.<span class="built_in">error_message</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;PredictionService::Stub&gt; stub_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 TensorFlow Serving 客户端</span></span><br><span class="line">    <span class="function">TensorFlowServingClient <span class="title">client</span><span class="params">(grpc::CreateChannel(<span class="string">&quot;localhost:8500&quot;</span>, grpc::InsecureChannelCredentials()))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送预测请求</span></span><br><span class="line">    client.<span class="built_in">Predict</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该示例演示了如何创建一个 TensorFlow Serving 客户端，并发送预测请求。需要注意的是，你需要根据实际情况修改模型的名称、输入数据等信息。</p>
</li>
</ol>
<p>总的来说，TensorFlow Serving 提供了一个功能强大的 C++ 库，用于部署 TensorFlow 模型并提供实时预测服务。通过了解其核心功能、架构和部署流程，你可以更好地使用 TensorFlow Serving 来满足你的部署需求。</p>
<h2 id="SavedModel格式是什么"><a href="#SavedModel格式是什么" class="headerlink" title="SavedModel格式是什么"></a>SavedModel格式是什么</h2><p>SavedModel 是 TensorFlow 中用于保存和加载模型的标准格式。它是一种可移植、可恢复的模型表示形式，可以轻松地在不同的平台上进行部署和共享。SavedModel 以文件夹的形式存储，其中包含了模型的结构、权重参数、计算图以及其他相关的元数据。</p>
<p>SavedModel 主要由两个部分组成：</p>
<ol>
<li><p><strong>模型图（GraphDef）</strong>：模型的计算图以 Protocol Buffers 格式保存在名为 <code>saved_model.pb</code> 的文件中。计算图定义了模型的结构，包括输入、输出、各种操作（如张量运算、变量等）以及操作之间的连接关系。</p>
</li>
<li><p><strong>变量和资源</strong>：模型的权重参数、变量和其他资源以二进制格式保存在名为 <code>variables/</code> 的文件夹中。这些文件包含了模型的具体参数值，用于在加载模型时恢复模型的状态。</p>
</li>
</ol>
<p>除了这两个基本部分之外，SavedModel 还可以包含其他的元数据信息，例如模型的签名信息（用于描述模型的输入和输出）、运行配置、版本信息等。</p>
<p>SavedModel 的优点在于它具有跨平台和版本控制的能力，可以在不同的 TensorFlow 版本和不同的硬件平台上进行部署和加载。这使得 SavedModel 成为了 TensorFlow 模型部署和共享的标准格式，被广泛应用于生产环境中。</p>
<h2 id="C-tensorflow-serving加载onnx模型"><a href="#C-tensorflow-serving加载onnx模型" class="headerlink" title="C++ tensorflow serving加载onnx模型"></a>C++ tensorflow serving加载onnx模型</h2><p>TensorFlow Serving 最初设计用于加载和提供 TensorFlow 模型的预测服务，但它也支持加载其他格式的模型，包括 ONNX（Open Neural Network Exchange）格式的模型。ONNX 是一种开放的标准，用于表示深度学习模型，它允许用户在不同的深度学习框架之间交换模型，并在不同的硬件平台上运行这些模型。</p>
<p>要在 TensorFlow Serving 中加载 ONNX 模型，你需要先将 ONNX 模型转换为 TensorFlow 的 SavedModel 格式，然后再使用 TensorFlow Serving 加载 SavedModel。以下是一个大致的步骤：</p>
<ol>
<li><p><strong>将 ONNX 模型转换为 TensorFlow SavedModel</strong>：</p>
<ul>
<li>使用 ONNX-TensorFlow 或 onnx-tf 工具将 ONNX 模型转换为 TensorFlow 的 SavedModel 格式。这些工具可以帮助你将 ONNX 模型导入到 TensorFlow 中，并将其保存为 SavedModel 格式。</li>
</ul>
</li>
<li><p><strong>使用 TensorFlow Serving 加载 SavedModel</strong>：</p>
<ul>
<li>使用 TensorFlow Serving 的配置文件（通常是 TensorFlow Serving 的 Docker 镜像中的配置文件），将转换后的 SavedModel 添加到配置中。</li>
<li>启动 TensorFlow Serving 服务器，并指定模型配置文件。</li>
</ul>
</li>
</ol>
<p>下面是一个大致的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 将 ONNX 模型转换为 TensorFlow SavedModel</span></span><br><span class="line">onnx-tf convert -i model.onnx -o saved_model/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 配置 TensorFlow Serving</span></span><br><span class="line"><span class="comment"># 创建一个模型配置文件，例如 model_config.json，指定模型的路径和类型</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;model_version_policy&quot;</span>: &#123; <span class="string">&quot;specific&quot;</span>: &#123; <span class="string">&quot;versions&quot;</span>: &#123; <span class="string">&quot;1&quot;</span>: &#123;&#125; &#125; &#125; &#125;,</span><br><span class="line">  <span class="string">&quot;model_platform&quot;</span>: <span class="string">&quot;tensorflow&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;onnx_model&quot;</span>,</span><br><span class="line">  <span class="string">&quot;base_path&quot;</span>: <span class="string">&quot;/path/to/saved_model&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 启动 TensorFlow Serving</span></span><br><span class="line">docker run -p 8500:8500 -p 8501:8501 --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/path/to/model_config.json,target=/models/onnx_model/config.json -t tensorflow/serving</span><br></pre></td></tr></table></figure>

<p>这里的关键步骤是将 ONNX 模型转换为 TensorFlow 的 SavedModel 格式，并通过 TensorFlow Serving 的配置文件将 SavedModel 添加到 TensorFlow Serving 中。这样就可以在 TensorFlow Serving 中加载和提供 ONNX 模型的预测服务了。</p>
<h2 id="docker方式部署-官方示例"><a href="#docker方式部署-官方示例" class="headerlink" title="docker方式部署(官方示例)"></a>docker方式部署(官方示例)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Download the TensorFlow Serving Docker image and repo</span></span><br><span class="line">docker pull tensorflow/serving</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/tensorflow/serving</span><br><span class="line"><span class="comment"># Location of demo models</span></span><br><span class="line">TESTDATA=<span class="string">&quot;<span class="subst">$(pwd)</span>/serving/tensorflow_serving/servables/tensorflow/testdata&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Start TensorFlow Serving container and open the REST API port</span></span><br><span class="line">docker run -t --<span class="built_in">rm</span> -p 8501:8501 \</span><br><span class="line">    -v <span class="string">&quot;<span class="variable">$TESTDATA</span>/saved_model_half_plus_two_cpu:/models/half_plus_two&quot;</span> \</span><br><span class="line">    -e MODEL_NAME=half_plus_two \</span><br><span class="line">    tensorflow/serving &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Query the model using the predict API</span></span><br><span class="line">curl -d <span class="string">&#x27;&#123;&quot;instances&quot;: [1.0, 2.0, 5.0]&#125;&#x27;</span> \</span><br><span class="line">    -X POST http://localhost:8501/v1/models/half_plus_two:predict</span><br><span class="line"></span><br><span class="line"><span class="comment"># Returns =&gt; &#123; &quot;predictions&quot;: [2.5, 3.0, 4.5] &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="拉取serving-docker-image"><a href="#拉取serving-docker-image" class="headerlink" title="拉取serving docker image"></a>拉取serving docker image</h2><ul>
<li><p>运行命令</p>
<ul>
<li>docker pull tensorflow&#x2F;serving</li>
</ul>
</li>
<li><p>tensorflow serving docker历史镜像</p>
<ul>
<li>地址: <a target="_blank" rel="noopener" href="https://hub.docker.com/r/tensorflow/serving/tags/">https://hub.docker.com/r/tensorflow/serving/tags/</a></li>
</ul>
</li>
</ul>
<h2 id="从serving-docker-image-启动一个容器"><a href="#从serving-docker-image-启动一个容器" class="headerlink" title="从serving docker image 启动一个容器"></a>从serving docker image 启动一个容器</h2><ul>
<li>serving images有以下属性<ul>
<li>8500 端口服务于gRPC</li>
<li>8501 端口服务于 REST API</li>
<li>可选的环境变量 MODEL_NAME(默认为 model)</li>
<li>可选的环境变量 MODEL_BASE_PATH(默认为 &#x2F;models)</li>
</ul>
</li>
<li>当 serving image运行一个容器时，其内部实际运行的命令是<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensorflow_model_server --port=8500 --rest_api_port=8501 \</span><br><span class="line">  --model_name=<span class="variable">$&#123;MODEL_NAME&#125;</span> --model_base_path=<span class="variable">$&#123;MODEL_BASE_PATH&#125;</span>/<span class="variable">$&#123;MODEL_NAME&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-pytorch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-pytorch/" class="post-title-link" itemprop="url">pytorch</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>pytorch相关笔记</li>
</ul>
<h2 id="pytorch生态部署方案"><a href="#pytorch生态部署方案" class="headerlink" title="pytorch生态部署方案"></a>pytorch生态部署方案</h2><ul>
<li>Pytorch虽然社区生态好，各种功能模块都是非常好用，但是部署生态一直饱受诟病。</li>
<li>ONNX的规范及代码主要由微软，亚马逊，Facebook和IBM等公司共同开发，也主要是为了来对抗谷歌的Tensorflow框架的部署生态。</li>
</ul>
<h2 id="Pytorch保存模型转化为ONNX模型"><a href="#Pytorch保存模型转化为ONNX模型" class="headerlink" title="Pytorch保存模型转化为ONNX模型"></a>Pytorch保存模型转化为ONNX模型</h2><ul>
<li>通过Pytorch保存下来的模型pth，因为pth部署无法跨平台移植，我们必须将模型转化成通用格式</li>
<li>优化由于推理（或模型评分）的机器学习模型非常困难，因为需要调整模型和推理库，充分利用硬件功能。如果想要在不同类型的平台（云&#x2F;Edge、CPU&#x2F;GPU 等）上获得最佳性能，实现起来会异常困难，因为每个平台都有不同的功能和特性。 如果模型来自需要在各种平台上运行的多种框架，会极大增加复杂性。 优化框架和硬件的所有不同组合非常耗时。此时ONNX的作用就显现出来的，专注于模型推理。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/DeepLearning/2024-05-22-DL__AI-EDU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/DeepLearning/2024-05-22-DL__AI-EDU/" class="post-title-link" itemprop="url">DL__AI-EDU</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DeepLearning/" itemprop="url" rel="index"><span itemprop="name">DeepLearning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>讲解神经网络基本的训练和工作原理</li>
<li>讲解反向传播和梯度下降</li>
<li>梯度下降是神经网络的基本学习方法<br>讲解损失函数</li>
</ul>
<h3 id="人工智能的定义"><a href="#人工智能的定义" class="headerlink" title="人工智能的定义"></a>人工智能的定义</h3><ol>
<li><p>第一个层面,人们对人工智能的期待可以分为:</p>
<ul>
<li>智能地把某件特定的事情做好,在某个领域增强人类的智慧,这种方式又叫做<strong>智能增强</strong>,例如搜索引擎,智能助手等,帮助人类完成某种特定任务,又称为”弱人工智能”,或者”狭义人工智能”.</li>
<li>像人类一样能认知,思考,判断:模拟人类的智能,这样的智能也称为”<strong>通用人工智能</strong>“(Artificial General Intelligence, AGI),或”强人工智能”.</li>
</ul>
</li>
<li><p>第二个层面,从技术的特点来看</p>
<ul>
<li><p>机器学习:如果一个程序解决任务(T)的效能(用P表示)随着经验(E)得到了提高,那么这个程序就能从经验(E)中学到了关于任务(T)的知识,并让衡量值(P)得到提高.</p>
<ol>
<li>选择一个模型结构(例如逻辑回归,决策树等),这就是上面所说的程序</li>
<li>用训练数据(输入和输出) 输入模型,这就是上面的经验(E)</li>
<li>通过不断执行任务(T)并衡量结果(P),让P不断提高,直到达到一个满意的值.</li>
</ol>
</li>
<li><p>机器学习的各种方法是如何从经验中学习?其大致可分为三种类型:</p>
<ol>
<li>监督学习(Supervised Learning)  :通过标注的数据来学习</li>
<li>无监督学习(Unsupervised Learning):通过没有标注的数据来学习,这种算法可以发现数据中自然形成的共同特性(聚类),可以用来发现不同数据之间的联系</li>
<li>强化学习(Reinforcement Learning):让程序选择和它的环境互动,环境给程序反馈</li>
</ol>
</li>
<li><p><strong>机器学习领域出现了各种模型,其中,神经网络模型是一个重要的方法</strong></p>
<ul>
<li>它的原型在1943年就出现了,在生物神经网络中,每个神经元与其他神经元相连,当它兴奋时,就会向相邻的神经元发送化学物质,从而改变这些神经元内的电位;如果某神经元的电位超过了一个阈值,那么它就会被激活(兴奋) ,向其他神经元发送化学物质.</li>
<li><strong>把许多这样的神经元按照一定的层次结构连接起来,我们就构建了一个神经网络</strong></li>
<li>随着数据的丰富和机器算力的增强,人们不断增加神经网络的层次数目,相邻层次之间的输入输出由非线性函数来控制,这就产生了DNN(<strong>深度神经网络</strong>).</li>
<li><strong>随着人们不断的调整网络结构,DNN也演变成许多不同的网络拓扑结构</strong>,例如 CNN(卷积神经网络), RNN(循环神经网络), LSTM(长期短期记忆), GAN(生成对抗网络), Transfer Learning(迁移学习)等,这些模型还在不断演化中</li>
<li><strong>训练AI模型,需要一系列专门的工具,业界有不少成熟的训练平台</strong>(TensorFlow, PyTorch, MXNet等),这些平台也在不断演化,支持新的模型,提高训练的效率,改进易用性等.</li>
</ul>
</li>
</ul>
</li>
<li><p>第三个层面,从应用的角度来看,狭义人工智能在各个领域都取得了很大的成果</p>
<ul>
<li>一种是标杆式的任务,例如ImageNet,考察AI模型能否识别图像的类别</li>
<li>另一种是AI技术和各种其他技术结合,解决政府,企业,个人用户的需求.在政府方面,把所有计算,数据,云端和物联网终端的设备联系起来,搭建一个能支持智能决定的系统,现代社会的城市管理,金融,医疗,物流和交通管理等等都运行在这样的系统上.专家称之为<strong>智能基础建设</strong></li>
</ul>
</li>
</ol>
<h4 id="模型的生成与应用"><a href="#模型的生成与应用" class="headerlink" title="模型的生成与应用"></a>模型的生成与应用</h4><ul>
<li>首先要设计一个模型,然后用已标注过的数据来训练这个模型,在训练过程中,<strong>模型的各个参数在多次训练中不断得到调整,最后得到了一个达到要求的模型</strong>.</li>
<li>这个模型会被用于一个推理模型中,和其他程序模块一起组成一个应用程序或者是服务,能处理新的数据,满足用户的需求.</li>
</ul>
<h3 id="范式的演化"><a href="#范式的演化" class="headerlink" title="范式的演化"></a>范式的演化</h3><p>范式演化的四个阶段:</p>
<ol>
<li><p>第一阶段:经验</p>
<ul>
<li>人类最早的科学研究,主要以记录和描述自然现象为特征,可以称之为”经验归纳”(第一范式)</li>
</ul>
</li>
<li><p>第二阶段:理论</p>
<ul>
<li>科学家们开始明确定义,速度是什么,质量是什么等等</li>
</ul>
</li>
<li><p>第三阶段:计算仿真</p>
<ul>
<li>从二十世纪中期开始,利用电子计算机对科学实验进行模拟仿真的模式得到迅速普及</li>
</ul>
</li>
<li><p>第四阶段:数据探索</p>
<ul>
<li>在这个阶段,科学家收集数据,分析数据,探索新的规律.</li>
<li>在深度学习的浪潮中出现的许多结果就是基于海量数据学习得来的.有些数据并不是从现实世界中收集而来的,而是由计算机程序自己生成的</li>
</ul>
</li>
</ol>
<h4 id="数据探索"><a href="#数据探索" class="headerlink" title="数据探索"></a>数据探索</h4><ul>
<li>当人类探索客观世界的时候,大部分情况下,我们是不了解新环境的运行规则.这个时候,我们可以观察自己的行动和客观世界的反馈,判断得失,再总结出规律.这种学习方法,叫强化学习(Reinforcement Learning),可以使用这种方法来找出适合的策略</li>
</ul>
<h3 id="神经网络的基本工作原理简介"><a href="#神经网络的基本工作原理简介" class="headerlink" title="神经网络的基本工作原理简介"></a>神经网络的基本工作原理简介</h3><p>神经元计算模型:</p>
<ol>
<li><p>输入 input:</p>
<ul>
<li>(x1, x2, x3)是外界输入信号,一般是一个训练数据样本的多个属性. 例如:(x1, x2, x3)分别代表了(红, 绿, 蓝)三种颜色,而此神经元用于识别输入的信号是暖色还是冷色</li>
</ul>
</li>
<li><p>权重 weights:</p>
<ul>
<li>(w1, w2, w3)是每个输入信号的权重值,以上面的(x1, x2, x3)的例子来说,x1的权重可能是0.92, x2的权重可能是0.2, x3的权重可能是0.03. <strong>权重值相加之后可以不是1</strong></li>
</ul>
</li>
<li><p>偏移 bias:</p>
<ul>
<li>一般的书或者博客上会说:那是因为y &#x3D; w*x + b, b是偏移值,使得直线能够沿Y轴上下移动,这是用结果来解释原因,并非b存在的真实原因</li>
<li>从生物学上解释,在脑神经细胞中,一定是输入信号的电平&#x2F;电流大于某个<strong>临界值</strong>时,神经元细胞才会处于兴奋状态,这个b实际就是那个临界值. 即当: w1 * x1 + w2 * x2 + w3 * x3 &gt;&#x3D; t时,该神经 细胞才会兴奋</li>
</ul>
</li>
<li><p>激活函数 activation:</p>
<ul>
<li>求和之后,神经细胞已经处于兴奋状态了,已经决定要向下一个神经元传递信号了,但是要传递多强烈的信号,要由激活函数来确定.</li>
<li>如果激活函数是一个阶跃信号的话,会像继电器开合一样咔咔的开启和闭合; 但是在生物体中是不可能有这种装置的,而是一个渐渐变化的过程.所以激活函数都是有一个渐变的过程,也就是是个<strong>曲线</strong></li>
</ul>
</li>
</ol>
<h4 id="神经网络的主要功能"><a href="#神经网络的主要功能" class="headerlink" title="神经网络的主要功能"></a>神经网络的主要功能</h4><ol>
<li><p>回归(Regression)或者叫做拟合(Fitting)</p>
<ul>
<li>单层的神经网络能够模拟一条二维平面上的直线,从而可以完成线性分割任务</li>
<li>所谓回归或者拟合,其实就是<strong>给出x值输出y值的过程,并且让y值与样本数据形成的曲线的距离可能的小</strong>,可以理解为是对样本数据的一种骨架式的抽象.</li>
</ul>
</li>
<li><p>分类(Classification)</p>
<ul>
<li>使用一个两层的神经网络可以得到一个非常近似的结果,使得分类误差在满意的范围之内.</li>
<li>分类可以理解为对两类或多类样本数据的边界的抽象</li>
<li>对于复杂的函数,一个两层的神经网络是如何做到的?其实从输入层到隐藏层的矩阵计算,就是对输入数据进行了空间变换,使其可以被线性可分,然后在输出层画出一个分界线.而训练的过程,就是确定那个空间变换矩阵的过程.<strong>因此,多层神经网络的本质就是对复杂函数的拟合.</strong></li>
</ul>
</li>
</ol>
<h4 id="激活函数的作用"><a href="#激活函数的作用" class="headerlink" title="激活函数的作用"></a>激活函数的作用</h4><ol>
<li>激活函数相当于人类的关节</li>
<li>如果不运用激活函数,输出信号将仅仅是一个简单的线性函数,线性函数是一个一级多项式.线性方程是很容易解决的,但是它们的复杂性有限,并且从数据中学习复杂函数映射的能力更小.<strong>一个没有激活函数的神经网络将只不过是一个线性回归模型罢了,不能解决现实世界中的大多数非线性问题.</strong></li>
<li>没有激活函数,神经网络将无法学习和模拟其他复杂类型的数据,例如图像,视频,音频,语音等.这就是为什么要使用<strong>人工神经网络技术</strong>,诸如深度学习等来理解一些复杂的事情,一些相互之间具有很多隐藏层的非线性问题</li>
</ol>
<h3 id="神经网络中的三个基本概念-反向传播-梯度下降-损失函数"><a href="#神经网络中的三个基本概念-反向传播-梯度下降-损失函数" class="headerlink" title="神经网络中的三个基本概念:反向传播, 梯度下降, 损失函数"></a>神经网络中的三个基本概念:反向传播, 梯度下降, 损失函数</h3><ul>
<li><p>神经网络训练的最基本的思想就是:先”猜”一个结果,称为预测结果a,看看这个预测结果和事先标记好的训练集中的真是结果y之间的差距,然后调整策略,再试一次,这一次就不是”猜”了,而是有依据地向正确的方向靠近.如此反复多次,一直到预测结果和真实结果之间相差无几,即|a - y| 趋近于 0 ,就结束训练.在神经网络训练中,我们把”猜”叫做初始化,可以随机,也可以根据以前的经验给定初始值</p>
</li>
<li><p>简单总结反向传播和梯度下降的基本工作原理:</p>
<ol>
<li>初始化;</li>
<li>正向计算;</li>
<li>损失函数提供计算损失的方法;</li>
<li>梯度下降是在损失函数基础上向着损失最小的点靠近而指引了网络权重调整的方向;</li>
<li>反向传播把损失值反向传给神经网络的每一层,让每一层都根据损失值反向调整权重;</li>
<li>Go to 2,直到精度足够好</li>
</ol>
</li>
</ul>
<h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><ul>
<li><p>梯度下降三要素:</p>
<ol>
<li>当前点;</li>
<li>方向;</li>
<li>步长.</li>
</ol>
</li>
<li><p>为什么说是”梯度下降”?</p>
<ol>
<li>梯度:函数当前位置的最快上升点</li>
<li>下降:与导数相反的方向,用数学语言描述就是那个减号; 亦即与上升相反的方向运动,就是下降.</li>
</ol>
</li>
</ul>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><ul>
<li><p>概念:</p>
<ul>
<li>在各种材料中经常看到的中英文词汇有:误差,偏差,Error,Cost,Loss,损失,代价等,意思都差不多</li>
<li>使用”损失函数”和”Loss Function”这两个词汇,具体的损失函数符号用J来表示,误差值用loss表示</li>
<li>“损失”就是所有样本的”误差”的总和</li>
<li>在黑盒子的例子中,如果说”某个样本的损失”是不对的,只能说”某个样本的误差”,因为样本是一个一个计算的.</li>
<li>如果我们把神经网络的参数调整到完全满足独立样本的输出误差为0,通常会令其它样本的误差变得更大,这样作为误差之和的损失函数值,就会变得更大.所以,<strong>我们通常会根据某个样本的误差调整权重后,计算一下整体样本的损失函数值,来判定网络是不是已经训练到了可接受的状态</strong>.</li>
</ul>
</li>
<li><p>损失函数的作用:</p>
<ul>
<li>损失函数的作用,就是计算神经网络每次迭代的前向计算结果与真实值的差距,从而指导下一步的训练正确的方向进行.</li>
<li>如何使用损失函数?具体步骤:<ol>
<li>用随机值初始化前向计算公式的参数;</li>
<li>代入样本,计算输出的预测值;</li>
<li>用损失函数计算预测值和标签值(真实值)的误差;</li>
<li>根据损失函数的导数,沿梯度最小方向将误差回传,修正前向计算公式中的各个权重值;</li>
<li>进入第二步重复,指导损失函数值达到一个满意的值就停止迭代</li>
</ol>
</li>
</ul>
</li>
<li><p>神经网络中常用的损失函数:</p>
<ul>
<li>均方差函数,主要用于回归</li>
<li>交叉熵函数,主要用于分类</li>
<li>二者都是非负函数,极值在底部,用梯度下降法可以求解.</li>
</ul>
</li>
</ul>
<h1 id="第二步-线性回归"><a href="#第二步-线性回归" class="headerlink" title="第二步:线性回归"></a>第二步:线性回归</h1><h3 id="神经网络法"><a href="#神经网络法" class="headerlink" title="神经网络法"></a>神经网络法</h3><ul>
<li><p>定义神经网络结构:</p>
<ol>
<li>输入层</li>
<li>权重w,b</li>
<li>输出层</li>
<li>损失函数</li>
</ol>
</li>
<li><p>训练过程:</p>
<ol>
<li>读取一个样本数据</li>
<li>前向计算</li>
<li>反向传播</li>
<li>更新梯度</li>
</ol>
</li>
<li><p>推理预测:</p>
<ul>
<li>推理过程,实际上就是一个<strong>前向计算过程</strong>,把它单独拿出来,方便对外接口的设计,所以这个方法被设计成了公开的方法</li>
</ul>
</li>
</ul>
<h3 id="样本特征数据标准化"><a href="#样本特征数据标准化" class="headerlink" title="样本特征数据标准化"></a>样本特征数据标准化</h3><ul>
<li><p>数据标准化(Normalization),又可以叫做数据归一化</p>
</li>
<li><p>为什么要做标准化?</p>
</li>
<li><p>理论层面上,神经网络是以样本在事件中的统计分布概率为基础进行训练和预测的,所以它对样本数据的要求比较苛刻</p>
<ol>
<li>样本的各个特征的取值要符合概率分布,即[0,1]</li>
<li>样本的度量单位要相同</li>
<li>神经网络假设所有的输入输出数据都是标准差为1,均值为0,包括权重值的初始化,激活函数的选择,以及优化算法的设计</li>
<li>数值问题</li>
<li>梯度更新,如果输出层的数量级很大,会引起损失函数的数量级很大,这样做反向传播时的梯度也就很大,这时会给梯度的更新带来数值问题</li>
<li>学习率</li>
</ol>
</li>
<li><p>标准化的常用方法:</p>
<ul>
<li>Min-Max标准化(离差标准化),将数据映射到[0,1]区间</li>
<li>平均值标准化,将数据映射到[-1,1]区间</li>
<li>对数转换</li>
<li>反正切转换</li>
<li>Z-Score法(标准差标准化&#x2F;零均值标准化):把每个特征值中的所有数据,变成平均值为0,标准差为1的数据,最后正态分布</li>
<li>中心化,平均值为0,无标准差要求</li>
<li>比例法,要求数据全是正值</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>:</p>
<ol>
<li>标准如果不做标准化,网络发散,训练无法进行;</li>
<li>训练样本标准化后,网络训练可以得到结果,但是预测结果有问题;</li>
<li>还原参数值后,预测结果正确,但是此还原方法并不普遍使用;</li>
<li>标准化测试样本,而不需要还原参数值,可以保证普遍使用;</li>
<li>标准化标签纸,可以使得网络训练收敛快,但是在预测时需要把结果反标准化,以便得到真实值.</li>
</ol>
<h1 id="第三步-线性分类"><a href="#第三步-线性分类" class="headerlink" title="第三步:线性分类"></a>第三步:线性分类</h1><h3 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h3><ul>
<li>分类问题在很多资料中都称之为逻辑回归, Logistic Regression, 其原因是使用了线性回归中的线性模型,加上一个Logistic二分类函数,共同构造了一个分类器.</li>
<li>神经网络的一个重要功能就是分类,现实世界中的分类任务复杂多样,但是万变不离其宗,我们都可以用同一种模式的神经网络来处理</li>
</ul>
<h3 id="逻辑回归模型"><a href="#逻辑回归模型" class="headerlink" title="逻辑回归模型"></a>逻辑回归模型</h3><ul>
<li>回归问题可以分为两类:线性回归和逻辑回归<ol>
<li>逻辑回归(Logistic Regression), 回归给出的结果是事件成功或失败的概率.当因变量的类型属于二值(1&#x2F;0, 真&#x2F;假, 是&#x2F;否)变量时,我们就应该使用逻辑回归</li>
<li>线性回归使用一条直线拟合样本数据,而逻辑回归的目标是”拟合”0或1两个数值,而不是具体连续数值,所以成为广义线性模型.</li>
<li>逻辑回归又称Logistic回归分析,常用于数据挖掘,疾病自动诊断,经济预测等领域</li>
<li>逻辑回归的另外一个名字叫做分类器,分为线性分类器和非线性分类器,然后无论是线性还是非线性分类器,又分为两种:二分类问题和多分类问题.</li>
</ol>
</li>
<li>回归问题-&gt;逻辑回归问题-&gt;线性逻辑回归即分类问题-&gt;线性二分类问题</li>
</ul>
<h3 id="二分类函数"><a href="#二分类函数" class="headerlink" title="二分类函数"></a>二分类函数</h3><ul>
<li>对率函数Logistic Function,即可以作为激活函数使用,又可以作为二分类函数使用.在二分类任务中,叫做Logistic函数;在作为激活函数时,叫做Sigmoid函数</li>
</ul>
<h3 id="实现逻辑与或非门"><a href="#实现逻辑与或非门" class="headerlink" title="实现逻辑与或非门"></a>实现逻辑与或非门</h3><ul>
<li>单层神经网络,又叫做感知机,它可以轻松实现逻辑与,或,非门.由于逻辑与,或门,需要有两个变量输入,而逻辑非门只有一个变量输入.但是它们共同的特点是输入为0或1,可以看做是正负两个类别</li>
</ul>
<h1 id="第四步-非线性回归"><a href="#第四步-非线性回归" class="headerlink" title="第四步:非线性回归"></a>第四步:非线性回归</h1><h1 id="第五步-非线性分类"><a href="#第五步-非线性分类" class="headerlink" title="第五步:非线性分类"></a>第五步:非线性分类</h1><h1 id="第六步-模型部署"><a href="#第六步-模型部署" class="headerlink" title="第六步:模型部署"></a>第六步:模型部署</h1><h3 id="摘要-2"><a href="#摘要-2" class="headerlink" title="摘要"></a><strong>摘要</strong></h3><ul>
<li>如果已经用神经网络训练出来了一套权重矩阵,那么在实际生产环境中如何使用这些权重矩阵?</li>
<li>如果需要将训练好的网络用到后台服务中:搭建网络-&gt;加载权重矩阵-&gt;调用前向计算</li>
<li>如果是在桌面端或手机端应用中使用这些权重矩阵,这就是一个跨平台,跨语言的需求.引出了模型文件的概念,后面也直接简称为模型.</li>
<li>模型文件中不仅包含了所有的权重矩阵,还记录了该神经网络的数据流图.这样不同平台,不同语言都可以根据模型文件里的信息构建网络,加载权重矩阵,执行前向计算.</li>
</ul>
<h3 id="模型的推理与部署"><a href="#模型的推理与部署" class="headerlink" title="模型的推理与部署"></a>模型的推理与部署</h3><ul>
<li>在经过几天或者几个月的训练之后,得到了一系列的能够满足需求的权重矩阵.将输入数据按一定的顺序与权重矩阵进行运算,就可以得到对应的输出,<strong>这个过程就是推理的过程</strong>.</li>
<li>如果没有保存这些权重矩阵,那么每次使用之前,需要重新训练,这在计算资源有限的情况下是难以接受的.另外一个选择是将训练好的权重矩阵保存下来,需要使用的时候重新加载权重矩阵.</li>
<li>几乎所有的训练平台都会把<strong>网络结构,权重矩阵等信息</strong>保存在文件中,这就是我们常说的<strong>模型文件</strong>,后面也直接简称为模型.</li>
<li>模型文件快问快答:<ol>
<li>为什么需要模型文件?<ul>
<li>模型,可以想象为一个”黑盒”,输入是需要处理的一张图像,输出是一个它的类别信息或是一些特征,<strong>模型文件也因此保存了能完成这一过程的所有重要信息,并且还能用来再次训练,推理等,方便了模型的传播与发展.</strong></li>
</ul>
</li>
<li>模型文件描述的是什么?<ul>
<li>首先,目前绝大部分的深度学习框架都将整个AI模型的计算过程抽象成<strong>数据流图(Data Flow Graphs)</strong>,用户写的模型构建代码都由框架组建出一个数据流图(也可以简单理解为神经网络的结构),而当程序开始运行时,框架的执行器会根据调度策略一次执行数据流图,完成整个计算.</li>
<li>有了上面的背景知识,很容易想到:为了方便地重用AI模型的计算过程,需要将它运行的数据流图,相应的运行参数(Parameters)和训练出来的权重(Weights)保存下来,这就是AI模型文件主要描述的内容.</li>
</ul>
</li>
<li>AI模型的作用是什么?<ul>
<li>以视觉处理为例,人通过眼睛捕获光线,传递给大脑处理,返回图像的一些信息,例如:这是花,那是动物.AI模型的作用就相当于大脑的处理,能根据输入的数据给予一定的判断.</li>
<li>使用封装好的AI模型,那么设计者只需要考虑把输入的数据处理成合适的格式(类似于感光细胞的作用),然后传递给AI模型(大脑),之后就可以得到一个想要的数据.</li>
</ul>
</li>
<li>模型文件有哪些类型?TensorFlow和其他框架有什么区别?<ul>
<li>由于每个深度学习框架都有自己的设计理念和工具链,对数据流图的定义和粒度都不一样,所以每家的AI模型文件都有些区别,几乎不能通用.</li>
<li>TensorFlow在设计之处,就考虑了从训练,预测,部署等复杂的需求,所以它的数据流图几乎涵盖了整个过程可能涉及到的操作,例如:初始化,后向求导以及优化算法,设备部署(Device Placement)和分布式化,量化压缩等,所以只需要通过TensorFlow的模型文件就能获取模型完整的运行逻辑,所以很容易迁移到各种平台使用.</li>
</ul>
</li>
<li>拿到一个模型文件,自己有一些新的数据,就能继续训练AI吗?如果不能,还需要做什么 ?</li>
</ol>
<ul>
<li>训练模型的时候,除了网络架构和权重,还有训练时所使用的各种超参,比如:使用的优化器(Optimizer),批量大小(Batch size),学习率(Learning rate),冲量(Momentum)等,这些都会影响我们再训练的效果,需要格外注意.</li>
</ul>
<ol start="6">
<li>ONNX文件是什么,如果保存为ONNX文件?<ul>
<li>开放式神经网络交换(Open Neural Network Exchange,简称ONNX),是由微软,FaceBook,亚马逊等多个公司一起推出的,针对机器学习设计的开放式文件格式,可以用来存储训练好的模型.它使得不同的人工智能框架可以采用相同的格式存储模型数据并交互.</li>
<li>目前很多机器学习框架都支持ONNX格式,如Pytorch,Caffe2,CNTK,ML,NET,MXNet等,它们都有专门的export_to_onnx方法,通过遍历它们原生的数据流图,转换为ONNX标准的数据流图.而对于TensorFlow这样并不原生支持ONNX的框架,通常会使用图匹配(Graph Matching)的方法转化数据流图</li>
</ul>
</li>
<li>转化的来的模型文件有什么信息丢失?<ul>
<li>由于模型文件仅仅描述了数据流和和权重,并不包含操作符的具体实现,所以不同框架对于”同名”的操作符理解和实现也会有所不同,最终可能得到不完全一致的推理结果</li>
</ul>
</li>
<li>模型文件是如何与应用程序一起工作的?<ul>
<li>应用程序使用模型文件,本质也是要执行模型文件的数据流图.一般有两种方式实现模型文件和应用程序的协作:<ol>
<li>如果有可以独立执行模型文件的运行时(Runtime),例如:系统级别的CoreML,WinML和软件级别的Caffe,DarkNet等,我们就可以在程序中动态链接直接使用</li>
<li>除此之外,也可以将数据流图和执行数据流图的程序(一般称为Op Kernel)编译在一起,从而脱离运行时,由于单一模型涉及到的操作有限,这样可以极大减少框架所占用的资源.</li>
</ol>
</li>
<li>在将模型集成到应用程序中之前,应该先使用模型查看工具(例如Netron等)查看模型的接口,输入输出的格式和对应的范围,然后对程序中传入模型的输入作对应的预处理工作,否则可能无法得到预期的效果.</li>
</ul>
</li>
<li>本地机器有GPU,在运行推理模型的时候,怎么能利用上GPU资源?<ul>
<li>首先需要安装匹配的显卡驱动,CUDA和GPU版的框架,然后根据框架进行代码调整:</li>
<li>对于TensorFlow这样能够自动做设备部署(Device Placement)的框架,它会尽量把GPU支持的操作自动分配给GPU计算,不太需要额外的适配;</li>
<li>对于PyTorch,MXNet这样不具有自动设备部署功能的框架,可能需要进行一个额外的操作将模型,张量(tensor)从CPU部署到GPU上.</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="ONNX模型文件"><a href="#ONNX模型文件" class="headerlink" title="ONNX模型文件"></a>ONNX模型文件</h3><ul>
<li>ONNX是一个开放式的规范,定义了可扩展的计算图模型,标准数据类型以及内置的运算符.该文件在存储结构上可以理解为是一种层级的结构<ul>
<li>最顶层结构是模型(Model):模型记录了该模型文件的基本数据,例如:使用的ONNX标准的版本,使用的运算符集版本,制造商的名字和版本等信息.除此以外,模型中记录着最主要的信息是图(Graph)</li>
<li>图(Graph):可以理解为是计算图的一种描述,是由输入,输出以及节点(Node)组成的,它们之间通过寻找相同的名字实现连接,也就是说,相同名字的变量会被认为是同一个变量,如果一个节点的输出名字和另一个节点的输入名字相同,这两个节点会被认为是连在一起的</li>
<li>节点(Node):就是要调用的运算符,多个节点(Node)以列表的形式在图(Graph)中存储</li>
</ul>
</li>
</ul>
<h1 id="第七步-深度神经网络"><a href="#第七步-深度神经网络" class="headerlink" title="第七步:深度神经网络"></a>第七步:深度神经网络</h1><h1 id="第八步-卷及神经网络"><a href="#第八步-卷及神经网络" class="headerlink" title="第八步:卷及神经网络"></a>第八步:卷及神经网络</h1><h2 id="卷积神经网络概述"><a href="#卷积神经网络概述" class="headerlink" title="卷积神经网络概述"></a>卷积神经网络概述</h2><ul>
<li><p>卷积神经网络（CNN，Convolutional Neural Net)是神经网络的类型之一，在图像识别和分类领域中取得了非常好的效果，比如识别人脸、物体、交通标识等，这就为机器人、自动驾驶等应用提供了坚实的技术基础。</p>
</li>
<li><p>一个典型的卷积神经网络中，会至少包含以下几个层：</p>
<ul>
<li>卷积层</li>
<li>激活函数层</li>
<li>池化层</li>
<li>全连接分类层</li>
</ul>
</li>
<li><p>卷积核， 就是一个小矩阵， </p>
</li>
<li><p>在卷积层中，我们会用输入数据与卷积核相乘，得到输出数据，就类似全连接层中的Weights一样，所以卷积核里的数值，也是通过反向传播的方法学习到的</p>
</li>
<li><p>各种卷积核的作用</p>
<ul>
<li>锐化(<code>sharpness</code>) ： 如果一个像素点比周围像素点亮，则此算子会令其更亮</li>
<li>检测竖边(<code>vertical edge</code>) ： 检测出了十字线中的竖线，由于是左侧和右侧分别检查一次，所以得到两条颜色不一样的竖线</li>
<li>周边(<code>surround</code>)   ：  把周边增强，把同色的区域变弱，形成大色块</li>
<li>Sobel-Y(<code>sobel y</code>) ：  纵向亮度差分可以检测出横边，与横边检测不同的是，它可以使得两条横线具有相同的颜色，具有分割线的效果</li>
<li>Identity ： 中心为1四周为0的过滤器，卷积后与原图相同</li>
<li>横边检测(<code>horizontal edge</code>)  ： 检测出了十字线中的横线，由于是上侧和下侧分别检查一次，所以得到两条颜色不一样的横线</li>
<li>模糊(<code>blur</code>)  ： 通过把周围的点做平均值计算而“杀富济贫”造成模糊效果</li>
<li>Sobel-X(<code>sobel x</code>)  ： 横向亮度差分可以检测出竖边，与竖边检测不同的是，它可以使得两条竖线具有相同的颜色，具有分割线的效果</li>
<li>浮雕(<code>embossing</code>)    ： 形成大理石浮雕般的效果</li>
</ul>
</li>
<li><p>卷积神经网络通过反向传播而令卷积核自我学习，找到分布在图片中的不同的feature，最后形成的卷积核中的数据。</p>
</li>
<li><p>但是如果想达到这种效果，只有卷积层的话是不够的，还需要激活函数、池化等操作的配合</p>
</li>
<li><p>我们实现的卷积操作不是原始数学含义的卷积，而是工程上的卷积，可以简称为卷积</p>
</li>
<li><p>在实现卷积操作时，并不会反转卷积核</p>
</li>
<li><p>在传统的图像处理中，卷积操作多用来进行滤波，锐化或者边缘检测啥的。我们可以认为<strong>卷积是利用某些设计好的参数组合（卷积核）去提取图像空域上相邻的信息</strong></p>
</li>
<li><p>多入单出的降维卷积</p>
<ul>
<li>一张图片，通常是彩色的，具有红绿蓝三个通道。我们可以有两个选择来处理<ul>
<li>变成灰度的，每个像素只剩下一个值，就可以用二维卷积</li>
<li>对于三个通道，每个通道都使用一个卷积核，分别处理红绿蓝三种颜色的信息</li>
</ul>
</li>
<li>显然第2种方法可以从图中学习到更多的特征，于是出现了三维卷积，即有三个卷积核分别对应输入的三个通道，三个子核的尺寸是一样的，比如都是2x2，这样的话，这三个卷积核就是一个3x2x2的立体核，称为<strong>过滤器Filter</strong>，所以称为三维卷积</li>
</ul>
</li>
<li><p>每一个卷积核对应着左侧相同颜色的输入通道，三个过滤器的值并不一定相同。对三个通道各自做卷积后，得到右侧的三张特征图，然后再按照原始值不加权地相加在一起，得到最右侧的白色特征图，这张图里面已经把三种颜色的特征混在一起了，所以画成了白色，表示没有颜色特征了</p>
</li>
<li><p>虽然输入图片是多个通道的，或者说是三维的，但是在相同数量的过滤器的计算后，相加在一起的结果是一个通道，即2维数据，所以称为<strong>降维</strong>。这当然简化了对多通道数据的计算难度，但同时也会损失多通道数据自带的颜色信息</p>
</li>
<li><p>卷积编程模型， 五个概念</p>
<ul>
<li>输入    – <code>Input Channel</code></li>
<li>卷积核组 – <code>WeightsBias</code></li>
<li>过滤器  – <code>Filter</code></li>
<li>卷积核  – <code>Kernel</code></li>
<li>输出    – <code>Feature Map</code></li>
</ul>
</li>
<li><p>输入是三维数据（3x32x32），经过2x3x5x5的卷积后，输出为三维（2x28x28），维数并没有变化，只是每一维内部的尺寸有了变化，一般都是要向更小的尺寸变化，以便于简化计算</p>
</li>
<li><p>三维卷积的特点：</p>
<ul>
<li>预先定义输出的feature map的数量，而不是根据前向计算自动计算出来</li>
<li>对于每个输出，都有一个对应的过滤器Filter</li>
<li>每个Filter内都有一个或多个卷积核Kernal，对应每个输入通道(Input Channel)，</li>
<li>每个Filter只有一个Bias值，Filter-1对应b1，Filter-2对应b2</li>
<li>卷积核Kernal的大小一般是奇数如：1x1, 3x3, 5x5, 7x7等</li>
</ul>
</li>
<li><p>步长：</p>
<ul>
<li>每次计算后，卷积核会向右或者向下移动一个单元，即步长stride &#x3D; 1</li>
<li>卷积核每次向右或向下移动两个单元，即stride &#x3D; 2</li>
</ul>
</li>
<li><p>一般情况下，我们用正方形的卷积核，且为奇数</p>
</li>
<li><p>如果计算出的输出图片尺寸为小数，则取整，不做四舍五入</p>
</li>
</ul>
<h2 id="卷积神经网络应用"><a href="#卷积神经网络应用" class="headerlink" title="卷积神经网络应用"></a>卷积神经网络应用</h2><ul>
<li><p>卷积神经网络是现在深度学习领域中最有用的网络类型，尤其在计算机视觉领域更是一枝独秀。卷积神经网络从90年代的LeNet开始，沉寂了10年，也孵化了10年，直到2012年AlexNet开始再次崛起，后续的ZF Net、VGG、GoogLeNet、ResNet、DenseNet，网络越来越深，架构越来越复杂，解决反向传播时梯度消失的方法也越来越巧妙。下面让我们一起学习一下这些经典的网络模型</p>
</li>
<li><p>LeNet是卷积神经网络的开创者LeCun在1998年提出，用于解决手写数字识别的视觉任务。自那时起，卷积神经网络的最基本的架构就定下来了：卷积层、池化层、全连接层</p>
</li>
<li></li>
</ul>
<h1 id="第九步-循环神经网络"><a href="#第九步-循环神经网络" class="headerlink" title="第九步:循环神经网络"></a>第九步:循环神经网络</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Debugger/2024-05-22-gdb_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Debugger/2024-05-22-gdb_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">gdb_2_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Debugger/" itemprop="url" rel="index"><span itemprop="name">Debugger</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>gdb工具使用中常见的技巧</li>
</ul>
<h2 id="日志重定向"><a href="#日志重定向" class="headerlink" title="日志重定向"></a>日志重定向</h2><p>在使用GDB进行调试时，您可以将GDB的日志输出重定向到文件中。以下是一种方法：</p>
<ol>
<li><p>打开终端并运行GDB。</p>
</li>
<li><p>在GDB提示符下，输入以下命令以启用日志记录功能并指定输出文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set logging file &lt;file_path&gt;</span><br></pre></td></tr></table></figure>

<p>将<code>&lt;file_path&gt;</code>替换为您想要将日志记录写入的文件路径和文件名。</p>
</li>
<li><p>输入以下命令以开始记录GDB日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set logging on</span><br></pre></td></tr></table></figure>

<p>GDB将开始将日志记录写入指定的文件。</p>
</li>
<li><p>执行您的调试操作，进行需要的步骤和命令。</p>
</li>
<li><p>当您完成调试并想要停止日志记录时，输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set logging off</span><br></pre></td></tr></table></figure>

<p>GDB将停止将日志写入文件。</p>
</li>
</ol>
<p>请注意，这种方法将GDB的整个会话记录到文件中，包括所有输入和输出。这对于调试复杂的问题或追踪程序执行流程非常有用。</p>
<p>希望这可以帮助您将GDB的日志输出到文件中。如有其他问题，请随时提问。</p>
<hr>
<h2 id="启动程序-输入-参数"><a href="#启动程序-输入-参数" class="headerlink" title="启动程序 输入 参数"></a>启动程序 输入 参数</h2><ul>
<li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb --args ./mnc.exe --port=10008 --ip=0.0.0.0</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="gdb-查看断点"><a href="#gdb-查看断点" class="headerlink" title="gdb 查看断点"></a>gdb 查看断点</h2><p>要查看在GDB中设置的所有断点，你可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info breakpoints</span><br></pre></td></tr></table></figure>

<p>该命令会显示当前设置的所有断点的列表，包括断点编号、断点位置和断点条件（如果有设置条件的话）。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info breakpoints</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x000000000040051a in main at example.c:10</span><br><span class="line">2       breakpoint     keep y   0x00000000004004f6 in foo at example.c:5</span><br></pre></td></tr></table></figure>

<p>在这个例子中，有两个断点，编号为1和2。第一个断点位于文件<code>example.c</code>的第10行的<code>main</code>函数处，第二个断点位于第5行的<code>foo</code>函数处。</p>
<p>如果你只想查看某个特定断点的详细信息，你可以使用以下命令，并将<code>&lt;breakpoint&gt;</code>替换为断点的编号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info breakpoints &lt;breakpoint&gt;</span><br></pre></td></tr></table></figure>

<p>例如，要查看断点1的详细信息，可以执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info breakpoints 1</span><br></pre></td></tr></table></figure>

<p>这将显示关于断点1的更多信息，如断点位置、断点条件等。</p>
<hr>
<h2 id="gdb-选项-详解"><a href="#gdb-选项-详解" class="headerlink" title="gdb 选项 详解"></a>gdb 选项 详解</h2><p>GDB（GNU Debugger）是一个功能强大的调试工具，用于在Linux和其他操作系统上调试程序。GDB 9.2版本引入了许多新的选项和功能，以下是一些常用的选项的详解：</p>
<ol>
<li><p><code>-ex &quot;command&quot;</code>：在启动GDB后执行指定的GDB命令。可以使用多个<code>-ex</code>选项来执行多个命令。</p>
</li>
<li><p><code>-tui</code>：启动GDB的文本用户界面（Text User Interface，TUI）模式。TUI模式提供了源代码和程序状态的交互式显示。</p>
</li>
<li><p><code>-batch</code>：以批处理模式运行GDB，不显示交互式命令提示符。适用于自动化脚本或批处理任务。</p>
</li>
<li><p><code>-core &lt;corefile&gt;</code>：指定要调试的核心转储文件。核心转储文件包含程序在崩溃或异常终止时的状态信息。</p>
</li>
<li><p><code>-pid &lt;pid&gt;</code>：调试指定进程标识符（PID）的正在运行的程序。通过此选项，可以附加到正在运行的进程进行调试。</p>
</li>
<li><p><code>-symbols=&lt;path&gt;</code>：指定要加载的调试符号文件的路径。调试符号文件包含程序的符号信息，如变量名、函数名等。</p>
</li>
<li><p><code>-directory=&lt;path&gt;</code>：指定要搜索源代码文件的目录。当源代码文件不在当前目录或GDB默认搜索路径中时，可以使用此选项指定源代码的位置。</p>
</li>
<li><p><code>-quiet</code>：以静默模式运行GDB，不显示任何冗余的信息。</p>
</li>
<li><p><code>-ex=dir=&lt;dir&gt;</code>：指定GDB的工作目录。GDB将在指定的目录中查找程序和其他文件。</p>
</li>
<li><p><code>-command=&lt;script_file&gt;</code>：指定要执行的GDB脚本文件。可以在脚本文件中定义自定义的GDB命令和操作。</p>
</li>
</ol>
<p>这些选项只是GDB 9.2版本中的一部分，还有许多其他选项可供使用。你可以参考GDB的官方文档或运行<code>gdb --help</code>命令获取完整的选项列表和详细说明。通过熟悉和灵活运用这些选项，你可以根据具体需求使用GDB的功能来调试和分析程序。</p>
<hr>
<h2 id="gdb-9-2-保存崩溃时堆栈信息"><a href="#gdb-9-2-保存崩溃时堆栈信息" class="headerlink" title="gdb 9.2 保存崩溃时堆栈信息"></a>gdb 9.2 保存崩溃时堆栈信息</h2><p>在GDB 9.2中，你可以通过使用<code>generate-core-file</code>命令来保存崩溃时的堆栈信息。这个命令会生成一个核心转储文件，其中包含了程序在崩溃时的内存状态和堆栈信息。</p>
<p>以下是保存崩溃时堆栈信息的步骤：</p>
<ol>
<li><p>在命令行中使用以下命令启动GDB并加载可执行文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./my_program</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置断点或者在崩溃发生的地方让程序停下来。你可以使用<code>break</code>命令设置断点，或者通过其他方式确保程序会在崩溃时停下来。</p>
</li>
<li><p>运行程序。在GDB命令行中，使用以下命令运行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run</span><br></pre></td></tr></table></figure>
</li>
<li><p>当程序崩溃时，GDB会自动停在断点处或者崩溃位置。</p>
</li>
<li><p>在GDB命令行中使用以下命令生成核心转储文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">generate-core-file &lt;corefile&gt;</span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;corefile&gt;</code>是你想要保存核心转储文件的路径和文件名。</p>
</li>
<li><p>此时，核心转储文件就保存了程序崩溃时的堆栈信息和内存状态。</p>
</li>
</ol>
<p>通过保存核心转储文件，你可以在后续的调试过程中使用该文件进行分析。你可以加载核心转储文件并使用GDB命令查看堆栈、变量值等信息，以定位崩溃的原因和解决问题。</p>
<p>需要注意的是，生成核心转储文件可能需要对系统进行相应的配置。确保你的系统允许生成核心转储文件，并且具有足够的权限来保存文件。有些系统默认禁用了核心转储文件的生成，你可能需要修改相应的设置。</p>
<p>另外，记住在发布或共享代码时，避免包含核心转储文件，因为它可能包含敏感信息。核心转储文件主要用于调试和分析崩溃问题。</p>
<hr>
<h2 id="gdb-9-2-调试核心转储文件"><a href="#gdb-9-2-调试核心转储文件" class="headerlink" title="gdb 9.2 调试核心转储文件"></a>gdb 9.2 调试核心转储文件</h2><p>在GDB 9.2中，你可以使用核心转储文件进行调试。核心转储文件是程序在崩溃或异常终止时保存的内存状态的快照，它包含了程序崩溃时的堆栈信息和内存数据。以下是使用GDB调试核心转储文件的步骤：</p>
<ol>
<li><p>启动GDB，并加载可执行文件以及核心转储文件。在命令行中使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./my_program &lt;corefile&gt;</span><br></pre></td></tr></table></figure>
<p>其中<code>&lt;corefile&gt;</code>是核心转储文件的路径和文件名。</p>
</li>
<li><p>一旦GDB加载了核心转储文件，它会还原程序崩溃时的内存状态。你可以使用GDB命令来查看堆栈信息、变量值等。</p>
</li>
<li><p>使用<code>backtrace</code>或<code>bt</code>命令查看堆栈跟踪，了解程序崩溃的位置和调用链。</p>
</li>
<li><p>使用其他GDB命令进行调试。你可以使用<code>print</code>或<code>p</code>命令查看变量值，使用<code>step</code>或<code>s</code>命令单步执行程序，使用<code>continue</code>或<code>c</code>命令让程序继续执行等。</p>
</li>
<li><p>分析堆栈信息和变量值，定位问题的原因，并进行修复。</p>
</li>
</ol>
<p>需要注意的是，调试核心转储文件时，可执行文件和核心转储文件必须是对应的，即生成核心转储文件的程序版本与进行调试的程序版本相同。如果可执行文件和核心转储文件不匹配，可能会导致调试结果不准确或无法正常调试。</p>
<p>此外，调试核心转储文件还可以结合其他GDB功能和命令，例如条件断点、内存查看等，以进一步分析问题。GDB提供了丰富的调试功能，可以帮助你定位和解决程序崩溃问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Debugger/2024-05-22-gdbserver_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Debugger/2024-05-22-gdbserver_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">gdbserver_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Debugger/" itemprop="url" rel="index"><span itemprop="name">Debugger</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>gdbserver使用过程中遇到的理论知识</li>
</ul>
<h2 id="gdbserver-常用-选项"><a href="#gdbserver-常用-选项" class="headerlink" title="gdbserver 常用 选项"></a>gdbserver 常用 选项</h2><p>GDBserver是一个用于远程调试的程序，它与GDB一起使用，允许你在目标系统上进行远程调试。以下是一些常用的GDBserver选项的详解：</p>
<ol>
<li><p><code>--multi</code>：启动GDBserver以支持多个GDB客户端连接。这允许多个调试器同时连接到同一个目标系统进行并行调试。</p>
</li>
<li><p><code>--attach &lt;pid&gt;</code>：将GDBserver附加到指定进程的PID上进行调试。通过这个选项，你可以在目标系统上调试正在运行的进程。</p>
</li>
<li><p><code>--once</code>：让GDBserver只调试一个进程，并在该进程退出后自动停止。这对于单次调试会话很有用。</p>
</li>
<li><p><code>--remote-debug</code>：启用远程调试支持，允许GDB通过网络与GDBserver通信进行远程调试。通常与<code>--port</code>选项一起使用。</p>
</li>
<li><p><code>--port &lt;port&gt;</code>：指定GDBserver监听的端口号，以便GDB通过网络连接到GDBserver进行远程调试。</p>
</li>
<li><p><code>--attach-command &lt;command&gt;</code>：在附加到进程时执行指定的GDB命令。这对于在附加时自动执行特定的调试命令非常有用。</p>
</li>
<li><p><code>--wrapper &lt;wrapper&gt;</code>：在启动目标程序之前运行指定的包装器程序。这对于在目标系统上执行额外的初始化步骤或设置环境变量非常有用。</p>
</li>
<li><p><code>--localhost</code>：GDBserver仅允许本地主机连接。这可以增加调试的安全性，限制远程访问。</p>
</li>
<li><p><code>--persistent</code>：使GDBserver保持持久运行，即使GDB客户端断开连接或退出。这样，当GDB客户端重新连接时，调试会话可以继续。</p>
</li>
<li><p><code>--separate</code>：将每个连接的GDB客户端隔离开，使它们无法相互干扰。这在并行调试多个目标时很有用。</p>
</li>
</ol>
<p>这些选项只是GDBserver的一部分，还有其他选项可供使用。你可以参考GDBserver的文档或运行<code>gdbserver --help</code>命令获取完整的选项列表和详细说明。GDBserver是一个强大的工具，可用于在目标系统上进行远程调试，帮助你调试和分析嵌入式系统或其他远程目标。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Debugger/2024-05-22-gdbserver_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Debugger/2024-05-22-gdbserver_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">gdbserver_2_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Debugger/" itemprop="url" rel="index"><span itemprop="name">Debugger</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="gdbserver使用方法，与PC机xxx-gdb搭配使用"><a href="#gdbserver使用方法，与PC机xxx-gdb搭配使用" class="headerlink" title="gdbserver使用方法，与PC机xxx-gdb搭配使用"></a><code>gdbserver</code>使用方法，与PC机xxx-gdb搭配使用</h3><ul>
<li><p>开发板：<code>gdbserver &lt;ip address&gt; &lt;listening port&gt; &lt;program&gt;</code></p>
<ul>
<li>例如：<code>gdbserver 192.167.66.112:9999 demo_02.exe</code></li>
<li>需要注意的一点是：需要调试的程序在编译时记得加上<code>-g</code>参数</li>
</ul>
</li>
<li><p>PC机:在终端中输入<code>aarch64-linux-gnu-gdb</code>之后进入gdb调试模式，然后输入<code>target remote ip-address:port</code>即可连接远程目标</p>
</li>
<li><p>交叉编译，程序的参数是从gdbserver 传进来的，其原理就是将调试信息通过端口发送到远程</p>
</li>
</ul>
<h2 id="比特大陆智能盒子远程调试"><a href="#比特大陆智能盒子远程调试" class="headerlink" title="比特大陆智能盒子远程调试"></a>比特大陆智能盒子远程调试</h2><ul>
<li><p>工具</p>
<ul>
<li>vca里面的交叉编译工具链</li>
<li>gdbserver</li>
<li>VSCode</li>
</ul>
</li>
<li><p>大致流程</p>
<ul>
<li>通过使用vca中的交叉编译工具，在x86主机上编译带有调试符号的可执行程序</li>
<li>将可执行程序拷贝到比特大陆盒子上，通过gdbserver启动程序，监听端口，例如：<code>gdbserver 0.0.0.0:19999  /data/dagger/VideoProcess/bin/ice.exe --multi-task-zmq-listen tcp://*:9100</code></li>
<li>在x86主机上，配置launch.json文件：<ul>
<li><code>&quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/ice.exe&quot;,</code></li>
<li><code>&quot;miDebuggerPath&quot;: &quot;$&#123;workspaceFolder&#125;/toolchains/aarch64-linux-gnu-6.3.1/bin/aarch64-linux-gnu-gdb&quot;,</code></li>
<li><code>&quot;miDebuggerServerAddress&quot;: &quot;192.169.5.46:19999&quot;</code></li>
</ul>
</li>
<li>开始调试</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Docker/2024-05-22-docker_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Docker/2024-05-22-docker_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">docker_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>docker相关的理论基础</li>
</ul>
<h2 id="理解Docker镜像和容器的存储路径"><a href="#理解Docker镜像和容器的存储路径" class="headerlink" title="理解Docker镜像和容器的存储路径"></a>理解Docker镜像和容器的存储路径</h2><ul>
<li><p>执行以下命令可以查看Docker的配置信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure></li>
<li><p>输出内容包含了存储驱动和docker根目录的信息</p>
</li>
<li><p>docker镜像和容器的存储路径</p>
<ul>
<li>Docker容器由网络文件，卷和镜像组成。Docker文件的存储路径取决于你的操作系统。</li>
<li>常用操作系统中的路径如下<ul>
<li>Ubuntu: &#x2F;var&#x2F;lib&#x2F;docker&#x2F;</li>
<li>Fedora: &#x2F;var&#x2F;lib&#x2F;docker</li>
<li>Debian: &#x2F;var&#x2F;lib&#x2F;docker</li>
<li>Windows: C:\ProgramData\DockerDesktop</li>
<li>MacOS: <del>&#x2F;Library&#x2F;Containers&#x2F;com.docker.docker&#x2F;Data&#x2F;vms&#x2F;0&#x2F;</del></li>
</ul>
</li>
<li>在MacOS和Windows系统中，Docker在一个虚拟机中运行Linux容器</li>
</ul>
</li>
<li><p>查看常规镜像的信息，会得到linux系统中的路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker insepct nginx</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;UpperDir&quot;</span>:<span class="string">&quot;/var/lib/docker/overlay2/585...9eb/diff&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>Docker镜像。最大的文件通常是镜像。如果使用默认的overlay2存储驱动，Docker镜像会保存在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2目录</p>
</li>
<li><p>LowerDir包含镜像的只读层，表示变更的读写层包含在UpperDir中。</p>
</li>
<li><p>MergeDir表示UppeDir和LowerDir合并的结果，Docker用它来运行容器</p>
</li>
<li><p>WorkDir是overlay2的内部目录，应该是空的</p>
</li>
</ul>
<h2 id="docker-一般使用什么方式设置自启动服务"><a href="#docker-一般使用什么方式设置自启动服务" class="headerlink" title="docker 一般使用什么方式设置自启动服务"></a>docker 一般使用什么方式设置自启动服务</h2><p>在 Docker 中，通常使用以下两种方式之一来设置容器的自启动服务：</p>
<ol>
<li><p>使用 Docker Compose：<br>Docker Compose 是一个用于定义和管理多容器应用程序的工具。在 Docker Compose 配置文件中，你可以定义容器的启动顺序和依赖关系。当使用 <code>docker-compose up</code> 启动容器组时，它们将按照定义的顺序自动启动，并在 Docker 守护进程启动时自动启动。</p>
<p>在 Docker Compose 配置文件中，可以使用 <code>restart</code> 字段来设置容器的自启动行为。以下是一个示例 Docker Compose 配置文件的部分内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>restart: always</code> 指示 Docker 在容器退出时自动重新启动该容器。</p>
</li>
<li><p>使用 systemd 或其他宿主机的服务管理工具：<br>如果你的 Docker 容器运行在一个宿主机上，并且宿主机使用 systemd 或其他服务管理工具（如 Upstart 或 SysV init），你可以在宿主机上创建一个服务单元文件来管理 Docker 容器的启动和自启动行为。</p>
<p>在宿主机上，你可以创建一个自定义的 systemd 服务单元文件（通常位于 <code>/etc/systemd/system/</code> 目录下），并使用 <code>docker run</code> 命令来启动容器。然后，通过配置 systemd 服务单元文件，将 Docker 容器与宿主机的服务管理工具集成在一起，以实现容器的自启动。</p>
<p>以下是一个示例 systemd 服务单元文件的部分内容：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Docker Container: My Service</span><br><span class="line"><span class="attr">Requires</span>=docker.service</span><br><span class="line"><span class="attr">After</span>=docker.service</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/docker run --name my-container my-image</span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=default.target</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>ExecStart</code> 字段指定了启动容器的命令。<code>Restart=always</code> 字段指示 systemd 在容器退出时自动重新启动。</p>
</li>
</ol>
<p>无论你选择使用 Docker Compose 还是宿主机的服务管理工具，都可以根据具体需求来设置容器的自启动服务。请注意，在设置自启动服务时，要确保 Docker 服务已经正确安装和启动，并且容器的镜像已经准备好。</p>
<hr>
<h2 id="docker-systemctl-无效"><a href="#docker-systemctl-无效" class="headerlink" title="docker systemctl 无效"></a>docker systemctl 无效</h2><p>在 Docker 容器中，<code>systemctl</code> 命令无效，因为容器中并没有运行 Systemd 进程，而 <code>systemctl</code> 命令是 Systemd 的服务管理工具。</p>
<p>Docker 容器是基于轻量级的容器化技术构建的，它们通常以单个进程运行，并不包含完整的操作系统。因此，与在主机操作系统上一样使用 <code>systemctl</code> 命令是不可行的。</p>
<p>在 Docker 中，你可以通过以下方式来管理容器内的服务或进程：</p>
<ol>
<li><p>启动和停止容器：使用 <code>docker start</code> 和 <code>docker stop</code> 命令来启动和停止容器，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker start container_name</span><br><span class="line">docker stop container_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行服务进程：在容器中直接运行服务进程，可以通过 Dockerfile 或者启动容器时指定要运行的命令。</p>
</li>
<li><p>使用 Docker Compose：如果你在 Docker Compose 中定义了服务，可以使用 <code>docker-compose up</code> 和 <code>docker-compose down</code> 命令来启动和停止整个服务组。</p>
</li>
</ol>
<p>请记住，Docker 容器是设计用于运行单个进程或服务的，而不是一个完整的操作系统环境。因此，与在传统的虚拟机或物理机上管理服务的方式有所不同。你可以通过容器的启动命令和配置来管理容器内的服务和进程。</p>
<hr>
<h2 id="目录映射"><a href="#目录映射" class="headerlink" title="目录映射"></a>目录映射</h2><ul>
<li><code>-p</code>:指定端口映射，格式为：主机（宿主）端口：容器端口</li>
<li><code>--privileged=true</code>:关闭安全权限，否则容器操作文件没有权限</li>
<li><code>-v</code>:挂在目录为：主机目录：容器目录，在创建前容器是没有指定目录时，docker容器会自己创建</li>
<li>端口映射:<code>-p 8083:8083 -p 5678:5678</code></li>
<li>目录映射以宿主机为主，换句话说，容器中原本存在的文件一旦进过挂载，就一定会被宿主机覆盖</li>
</ul>
<hr>
<h2 id="如何处理overlay2"><a href="#如何处理overlay2" class="headerlink" title="如何处理overlay2"></a>如何处理overlay2</h2><ul>
<li>真正要处理的不是这两个文件，是要检查正在跑的容器内的服务，有没有往容器本地写文件的行为，如果有，则要把写文件的路径挂载出来，或者直接在容器中删除文件</li>
</ul>
<hr>
<h2 id="docker-语言支持"><a href="#docker-语言支持" class="headerlink" title="docker 语言支持"></a>docker 语言支持</h2><ul>
<li>node.js</li>
<li>python</li>
<li>java</li>
<li>go</li>
<li>c#</li>
</ul>
<hr>
<h2 id="docker中的overlay2"><a href="#docker中的overlay2" class="headerlink" title="docker中的overlay2"></a>docker中的overlay2</h2><ul>
<li>在安装的docker系统中，删除了容器和镜像，但是docker&#x2F;overlay2还是占用很大的磁盘空间</li>
</ul>
<hr>
<h2 id="docker-overlay2下的文件都是些什么"><a href="#docker-overlay2下的文件都是些什么" class="headerlink" title="docker&#x2F;overlay2下的文件都是些什么"></a>docker&#x2F;overlay2下的文件都是些什么</h2><ul>
<li>docker&#x2F;overlay2目录下的文件名基本都是md5编码</li>
<li>overlay2是docker使用的文件存储驱动，也就是说，该目录下的文件都是docker使用的存储<ul>
<li>overlay2是分层存储，每一层通过本层的md5作为文件夹名来命名，如果要存储的两个东西，例如两个镜像的底层中的几层内容是一样的，那么它们的md5也就是一样的，通过md5检验，确认它们这几层是一样的，那么在overlay2实际存储的时候，这几层就可以只存储一份，然后由这两个镜像共同使用，来达到节省空间的目的</li>
</ul>
</li>
</ul>
<hr>
<h2 id="docker底层原理"><a href="#docker底层原理" class="headerlink" title="docker底层原理"></a>docker底层原理</h2><ul>
<li><p>第一次接触docker概念，都会见到或者听见一句话：<strong>docker技术比虚拟技术更为方便，快捷，docker容器本质上是进程</strong></p>
</li>
<li><p>所有容器共享宿主机的cpu，磁盘，网络，内存等：</p>
<ul>
<li><strong>实现了进程隔离</strong>，每个服务独立运行</li>
<li><strong>文件系统隔离</strong>，容器目录修改不影响主机目录</li>
<li><strong>资源隔离</strong>，CPU内存，磁盘，网络资源相互独立</li>
</ul>
</li>
<li><p>Docker容器的实现原理就是通过Namespace命名空间进行进程隔离，Unionfilesystem联合文件系统实现文件系统隔离，ControlGroups控制组实现资源隔离。</p>
</li>
<li><p>其底层原理涉及到<code>linux namespace</code>，Linux Namespace 是Linux提供的一种内核级别环境隔离的方法。 Unix有<code>chroot</code>，提供了一种简单的模式：<code>chroot</code>内部的文件系统无法访问外部的内容。<code>Linux Namespace</code>在此基础上，提供了对<code>UTS, IPC, mount, PID, network, User</code>等的隔离机制</p>
<ul>
<li><code>https://lwn.net/Articles/531114/</code></li>
</ul>
</li>
<li><p>Linux Namespace, 有几个种类：<code>Mount namespaces</code>, <code>UTS namespaces</code>, <code>IPC namespaces</code>, <code>PID namespaces</code>, <code>Network namespaces</code>, <code>User namespaces</code></p>
</li>
<li><p>主要是三个系统调用：</p>
<ul>
<li><code>clone()</code>, 实现线程的系统调用，用来创建一个新的进程，并且可以通过设计上述参数达到隔离</li>
<li><code>unshare()</code>, 使某个进程脱离某个<code>namespace</code></li>
<li><code>setns()</code>, 把某进程加入到某个<code>namespace</code></li>
</ul>
</li>
</ul>
<h2 id="Docker-exec-的实现原理"><a href="#Docker-exec-的实现原理" class="headerlink" title="Docker exec 的实现原理"></a>Docker exec 的实现原理</h2><ul>
<li><code>Linux Namespace</code>创建的隔离空间是虚拟的，一个进程的<code>Namespace</code>信息在宿主机上是真实存在的，并且是以一个文件的方式存在。</li>
<li>一个进程，可以选择加入到某个进程已有的<code>Namespace</code>当中，从而达到“进入”这个进程所在容器的目的，这正是<code>docker exec</code>的实现原理</li>
<li>通过<code>setns()</code>可以将当前进程加入到已有的<code>namespace</code>中。</li>
</ul>
<h2 id="镜像启动容器的本质"><a href="#镜像启动容器的本质" class="headerlink" title="镜像启动容器的本质"></a>镜像启动容器的本质</h2><ul>
<li>首先，需要明确Docker内的文件系统是如何工作的，Docker镜像被存储在一系列的<strong>只读层</strong>。</li>
<li><strong>Docker镜像是由多个文件系统（只读层）叠加而成，当启动一个容器的时候，Docker会加载只读层并在其上（镜像栈顶部）添加一个读写层</strong></li>
<li>如果运行中的容器修改了现有的一个已经存在的文件，那么该文件将会从读写层下面的只读层复制到读写层，该文件的只读版本仍然存在，只是已经被读写层中该文件的副本所隐藏。当删除Docker容器，并通过该镜像重启的时候，之前的修改将会丢失</li>
<li>在Docker中，只读层和顶部的读写层的组合被称为<strong>联合文件系统(Union File System)</strong></li>
<li>Docker镜像可以理解成多个只读文件叠加而成，因此镜像是只读的，<strong>当镜像运行起来时，就相当于在只读的镜像外面包裹了一层读写层变成了容器。</strong></li>
<li>当删除容器之后，使用镜像重新创建一个容器时，此时的镜像的只读层和原来一样，只是在读写层的修改会全部丢失</li>
<li>所以，docker的数据持久化说的就是：<strong>数据不随容器的删除而消失。</strong></li>
</ul>
<h2 id="数据卷Volume"><a href="#数据卷Volume" class="headerlink" title="数据卷Volume"></a>数据卷Volume</h2><ul>
<li>Docker的数据卷Volume能够让容器从宿主机中读取文件或持久化数据到宿主机内，让容器与容器产生的数据分离开来。</li>
<li>可以简单的把Volume理解为Linux服务器上的挂载点，一个容器可以挂载多个不同的目录</li>
<li>Volume的生命周期是独立于容器的声明周期之外的，即使容器删除，Volume也会保留下来，Docker也不会因为这个Volume没有被容器使用而回收。在容器中，添加或修改这个文件夹中的文件也不会影响容器的联合文件系统。</li>
<li>Volume数据卷不是用分层文件系统，这对经常读取和写入的数据很有用。在开发过程中，可以将代码目录挂载到容器中，这样如果更改代码容器会实时地得到文件修改的返回文件。</li>
</ul>
<h2 id="Docker数据管理-数据库容器化并持久化：数据卷概念，创建数据卷的两种方式，docker-volume用法"><a href="#Docker数据管理-数据库容器化并持久化：数据卷概念，创建数据卷的两种方式，docker-volume用法" class="headerlink" title="Docker数据管理-数据库容器化并持久化：数据卷概念，创建数据卷的两种方式，docker volume用法"></a>Docker数据管理-数据库容器化并持久化：数据卷概念，创建数据卷的两种方式，docker volume用法</h2><h2 id="Docker数据管理"><a href="#Docker数据管理" class="headerlink" title="Docker数据管理"></a>Docker数据管理</h2><ul>
<li>在生产环境中使用Docker的过程，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作</li>
<li>所谓Docker的数据持久化，即：数据不随着容器的结束而结束。在Docker中，要想实现数据的持久化，需要将数据从宿主机挂载到容器中</li>
<li>容器中管理数据主要有两种方式：<ul>
<li>数据卷(Data Volumes)：容器内数据直接映射到本地主机环境</li>
<li>数据卷容器(Data Volume Containers)：使用特定容器维护数据卷</li>
</ul>
</li>
</ul>
<h2 id="Docker核心概念：镜像，容器，仓库，架构核心设计理念"><a href="#Docker核心概念：镜像，容器，仓库，架构核心设计理念" class="headerlink" title="Docker核心概念：镜像，容器，仓库，架构核心设计理念"></a>Docker核心概念：镜像，容器，仓库，架构核心设计理念</h2><h2 id="Docker核心概念"><a href="#Docker核心概念" class="headerlink" title="Docker核心概念"></a>Docker核心概念</h2><ul>
<li><p><strong>镜像</strong>，通俗地讲，<strong>它是一个只读的文件和文件夹组合</strong>。</p>
</li>
<li><p>它包含了容器运行时所需要的所有基础文件和配置信息，是容器启动的基础。所以想启动一个容器，那首先必须要有一个镜像。镜像是Docker容器启动的先决条件</p>
</li>
<li><p>如果想要使用一个镜像，一般有两种方式：</p>
<ul>
<li>自己创建镜像。通常情况下，一个镜像是基于一个基础镜像构建的，可以在基础镜像上添加一些用户自定义的内容。形成业务镜像。</li>
<li>从功能镜像仓库拉取别人制作好的镜像</li>
</ul>
</li>
<li><p><strong>容器</strong>，是Docker的另一个核心概念。</p>
</li>
<li><p>通俗地讲，容器是镜像的运行实体。镜像是静态的只读文件，而容器带有运行时需要的可写文件层，并且容器中的进程属于运行状态。即容器运行着真正的应用进程</p>
</li>
<li><p>虽然容器的本质上是主机上运行的一个进程，但是容器有自己独立的命名空间隔离和资源限制。也就是说，<strong>在容器内部，无法看到主机上的进程，环境变量，网络等信息，这是容器于直接运行在主机上进程的本质区别。</strong></p>
</li>
<li><p><strong>仓库</strong>，Docker的镜像仓库类似于代码仓库，用来存储和分发Docker镜像。</p>
</li>
<li><p>镜像仓库分为公有镜像仓库和私有镜像仓库</p>
</li>
</ul>
<h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><ul>
<li><p><strong>相关背景知识</strong>—-容器的发展史</p>
<ul>
<li>容器技术随着Docker的出现变得炙手可热，所有公司都在积极拥抱容器技术。此时市场上除了有Docker容器，还有很多其他的容器技术，例如：CoresOS的rkt， lxc等。容器技术百花齐放是好事，但是也出现了很多问题，比如容器技术的标准到底是什么？</li>
<li>可能会说，Docker已经成为了事实标准，把Docker作为容器技术的标准不可以吗？事实并没有想象的那么简单。因为那个时候不仅有容器标准之争，编排技术之争也十分激烈。当时的编排技术有三大主力，分别是：<code>Docker Swarm, Kubernetes, Mesos</code>。在这样的背景下，为了形成统一的标准，<strong>OCI应运而生</strong>。</li>
<li>OCI全称为开放容器标准(<code>Open Container Initiative</code>)，它是一个轻量级，开放的治理结构。OCI组织在Linux基金会的大力支持下，于2015年6月分正式注册成立。基金会旨在为用户围绕工业化容器的格式和镜像运行时，制定一个开放的容器标准。目前主要有两个标准文档：**容器运行时标准(<code>runtime spec</code>)和容器镜像标准(<code>image spec</code>)</li>
<li>正是由于容器的战争，才导致Docker不得不改变了一些技术架构。最终，Docker整体架构采用C&#x2F;S（客户端&#x2F;服务器）模式，主要由客户端和服务端两大部分组成。客户端负责发送操作指令，服务端负责接受和处理指令。客户端和服务端通信有多种方式，既可以在通一台机器上通过UNIX套接字通信，也可以通过网络连接远程通信。</li>
</ul>
</li>
<li><p><strong>Docker客户端</strong></p>
<ul>
<li>Docker客户端其实是一种泛称。其中docker命令是Docker用户与Docker服务端交互的主要方式。</li>
<li>除了使用docker命令的方式，还可以使用直接请求REST API的方式与Docker服务端交互，甚至还可以使用各种语言的SDK与Docker服务端交互</li>
</ul>
</li>
<li><p><strong>Docker服务端</strong></p>
<ul>
<li>Docker服务端是Docker所有后台服务的统称。</li>
<li>其中<code>dockerd</code>是一个非常重要的后台管理进程，它负责相应和处理来自Docker客户端的请求，然后将客户端的请求转换为Docker的具体操作。例如镜像，容器，网络和挂载卷等具体对象的管理和操作。</li>
<li>Docker从诞生到现在，服务端经历了多次架构重构。起初，服务端的组件是全部集成在docker二进制里，但是从1.11版本开始，<code>dockerd</code>已经成了独立的二进制，此时的容器也不是直接由<code>dockerd</code>来启动了，而是继承了<code>containerd, runC</code>等多个组件</li>
<li>虽然Docker的架构在不停重构，但是各个模块的基本功能和定位并没有变化。它和一般的C&#x2F;S架构系统一样，Docker服务端模块负责和Docker客户端交互，并管理Docker的容器，镜像，网络等资源。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Docker重要组件</strong><ul>
<li>Docker目前已经有了非常多的组件和工具。Docker的两个至关重要的组件：**<code>runC</code>和<code>containerd</code>**<ul>
<li><code>runC</code>是Docker官方按照OCI容器运行时标准的一个实现。通俗地讲，**<code>runC</code>是一个用来运行容器的轻量级工具，是真正用来运行容器的。**</li>
<li><code>containerd</code>是Docker服务端的一个核心组件，它是从<code>dockerd</code>中剥离出来的，它的诞生完全遵循OCI标准，是容器标准化后的产物。**<code>containerd</code>通过<code>containerd-shim</code>启动并管理<code>runC</code>，可以说<code>containerd</code>真正管理了容器的生命周期**。</li>
</ul>
</li>
<li><code>dockerd</code>通过<code>gRPC</code>与<code>containerd</code>通信，由于<code>dockerd</code>与真正的容器运行时，<code>runC</code>中间有了<code>containerd</code>这一OCI标准层，使的<code>dockerd</code>可以确保接口向下兼容<ul>
<li><code>gRPC</code>是一种远程服务调用</li>
</ul>
</li>
<li><code>containerd-shim</code>的意思是垫片，类似于拧螺丝时夹在螺丝和螺母之间的垫片。<code>containerd-shim</code>的主要作用是：**将<code>containerd</code>和真正的容器进程解耦，使用<code>containerd-shim</code>作为容器进程的父进程，从而实现重启<code>dockerd</code>不影响已经启动的容器进程</li>
<li>事实上，<code>dockerd</code>启动的时候，<code>containerd</code>就随之启动了，<code>dockerd</code>与<code>containerd</code>一直存在。当执行<code>docker run</code>命令时，<code>containerd</code>会创建<code>containerd-shim</code>充当”垫片”进程，然后启动容器的真正进程。（**<code>containerd-shim</code>是真正容器的进程的父进程，这么做为了不让真正的容器进程作为<code>containerd</code>的子进程，从而可以实现重启<code>containerd</code>而不影响已经运行的容器**）</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Debugger/2024-05-22-gdb_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Debugger/2024-05-22-gdb_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">gdb_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Debugger/" itemprop="url" rel="index"><span itemprop="name">Debugger</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>gdb工具的理论知识</li>
</ul>
<h2 id="gdb-常用命令"><a href="#gdb-常用命令" class="headerlink" title="gdb 常用命令"></a>gdb 常用命令</h2><p>GDB（GNU Debugger）是一个功能强大的调试工具，提供了许多命令来帮助程序员进行调试。以下是GDB的全部命令及其详细解释：</p>
<p><strong>常用命令</strong>：</p>
<ol>
<li><strong>run</strong>：运行程序。例如：<code>run arg1 arg2</code>。</li>
<li><strong>break</strong>：设置断点。<ul>
<li><code>break &lt;function&gt;</code>：在指定函数的入口处设置断点。</li>
<li><code>break &lt;line&gt;</code>：在指定行号处设置断点。</li>
<li><code>break &lt;file:line&gt;</code>：在指定文件的指定行号处设置断点。</li>
<li><code>break &lt;address&gt;</code>：在指定地址处设置断点。</li>
</ul>
</li>
<li><strong>continue</strong>：继续执行程序，直到下一个断点或程序结束。</li>
<li><strong>next</strong>：执行下一行代码，但是不会进入函数内部。</li>
<li><strong>step</strong>：执行下一行代码，并进入函数内部。</li>
<li><strong>print</strong>（或者简写为<strong>p</strong>）：打印变量的值。<ul>
<li><code>print &lt;variable&gt;</code>：打印指定变量的值。</li>
<li><code>print &lt;expression&gt;</code>：计算并打印指定表达式的值。</li>
</ul>
</li>
<li><strong>backtrace</strong>（或者简写为<strong>bt</strong>）：显示当前的函数调用堆栈。</li>
<li><strong>info locals</strong>：显示当前函数的局部变量。</li>
<li><strong>info breakpoints</strong>：显示当前设置的所有断点。</li>
<li><strong>delete</strong>：删除指定的断点。</li>
</ol>
<ul>
<li><code>delete &lt;breakpoint&gt;</code>：删除指定编号的断点。</li>
<li><code>delete breakpoints</code>：删除所有断点。</li>
</ul>
<ol start="11">
<li><strong>watch</strong>：设置观察点。</li>
</ol>
<ul>
<li><code>watch &lt;expression&gt;</code>：当指定表达式的值发生变化时中断程序。</li>
</ul>
<ol start="12">
<li><strong>finish</strong>：执行完当前函数并停止。</li>
<li><strong>quit</strong>：退出GDB。</li>
</ol>
<p><strong>其他常用命令</strong>：</p>
<ol>
<li><strong>list</strong>：显示源代码。<ul>
<li><code>list</code>：显示当前位置附近的源代码。</li>
<li><code>list &lt;function&gt;</code>：显示指定函数的源代码。</li>
<li><code>list &lt;line&gt;</code>：显示指定行号附近的源代码。</li>
</ul>
</li>
<li><strong>info registers</strong>：显示寄存器的值。</li>
<li><strong>set</strong>：设置变量的值。<ul>
<li><code>set &lt;variable&gt;=&lt;value&gt;</code>：将指定变量的值设置为指定值。</li>
</ul>
</li>
<li><strong>display</strong>：持续显示表达式的值。<ul>
<li><code>display &lt;expression&gt;</code>：每次停止时显示指定表达式的值。</li>
</ul>
</li>
<li><strong>x</strong>：显示内存内容。<ul>
<li><code>x/&lt;count&gt;&lt;format&gt; &lt;address&gt;</code>：以指定格式显示指定地址开始的内存内容。</li>
</ul>
</li>
<li><strong>info threads</strong>：显示当前线程信息。</li>
<li>**thread <thread-id>**：切换到指定线程。</li>
<li><strong>set args</strong>：设置运行程序时的命令行参数。</li>
<li><strong>set environment</strong>：设置运行程序时的环境变量。</li>
<li><strong>directory</strong>：指定源代码文件的搜索路径。</li>
<li>**run <args>**：运行程序并传递命令行参数。</li>
</ol>
<p>以上只是GDB命令的一小部分，GDB还有更多的命令和选项可供使用。你可以在GDB的命令行界面中输入<code>help</code>命令来查看完整的命令列表和使用说明。</p>
<hr>
<h2 id="gdb-是什么"><a href="#gdb-是什么" class="headerlink" title="gdb 是什么"></a>gdb 是什么</h2><p>GDB（GNU Debugger）是一个功能强大的调试工具，用于在Linux和其他操作系统上调试程序。它提供了许多功能和命令，用于追踪程序的执行、查看变量的值、检测内存错误等。下面是对GDB的一些详解：</p>
<ol>
<li><p>启动程序：使用<code>gdb</code>命令后跟要调试的可执行文件的路径来启动GDB。例如：<code>gdb ./my_program</code></p>
</li>
<li><p>设置断点：使用<code>break</code>或<code>b</code>命令在代码中设置断点。可以使用行号、函数名或文件名来指定断点的位置。例如：<code>b main</code>、<code>b file.cpp:10</code>。</p>
</li>
<li><p>运行程序：使用<code>run</code>或<code>r</code>命令来运行程序。可以带上命令行参数。例如：<code>r arg1 arg2</code>。</p>
</li>
<li><p>单步执行：使用<code>next</code>或<code>n</code>命令进行逐行单步执行。可以逐过程地执行函数体内部的语句。</p>
</li>
<li><p>进入函数：使用<code>step</code>或<code>s</code>命令进入函数内部并逐语句单步执行。</p>
</li>
<li><p>继续执行：使用<code>continue</code>或<code>c</code>命令继续程序的执行直到下一个断点或程序结束。</p>
</li>
<li><p>打印变量值：使用<code>print</code>或<code>p</code>命令打印变量的值。可以打印局部变量、全局变量、表达式等。例如：<code>p my_var</code>。</p>
</li>
<li><p>查看堆栈：使用<code>backtrace</code>或<code>bt</code>命令查看函数调用的堆栈信息，显示调用链。</p>
</li>
<li><p>查看源代码：使用<code>list</code>或<code>l</code>命令查看源代码，显示当前位置附近的代码片段。</p>
</li>
<li><p>修改变量值：使用<code>set</code>命令修改变量的值。例如：<code>set my_var = 42</code>。</p>
</li>
<li><p>监视变量：使用<code>watch</code>命令设置监视点，当变量的值发生变化时，程序会停在相应的位置。</p>
</li>
<li><p>内存调试：使用GDB的内存调试功能，可以检测和分析内存错误、内存泄漏等问题。</p>
</li>
<li><p>调试核心转储文件：使用<code>core</code>命令调试核心转储文件，用于分析程序崩溃或异常终止的情况。</p>
</li>
<li><p>断点条件和命令：可以在设置断点时指定条件和命令，以控制程序的执行流程。</p>
</li>
<li><p>定义自定义命令：可以使用GDB的Python扩展或GDB脚本语言来定义自定义命令，以实现更复杂的调试操作。</p>
</li>
<li><p>调试多线程程序：GDB支持调试多线程程序，可以追踪和控制每个线程的执行。</p>
</li>
</ol>
<p>这只是GDB的一小部分功能和命令，GDB还有很多</p>
<p>其他强大的功能，如条件断点、反汇编、寄存器查看等。你可以查阅GDB的官方文档或其他资源，深入了解和掌握更多关于GDB的知识和技巧。调试是开发过程中的重要环节，GDB可以帮助你更好地理解程序的执行过程，定位和解决问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
