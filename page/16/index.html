<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/16/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/PointCloud/2024-05-22-PointCloud_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/PointCloud/2024-05-22-PointCloud_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">PointCloud_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PointCloud/" itemprop="url" rel="index"><span itemprop="name">PointCloud</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>点云相关的理论基础笔记</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/PointCloud/2024-05-22-PointCloud_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Qt/2024-05-22-qt_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Qt/2024-05-22-qt_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">qt_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>QT 应用程序开发 理论基础</li>
</ul>
<h2 id="怎么理解Qt的信号与槽机制"><a href="#怎么理解Qt的信号与槽机制" class="headerlink" title="怎么理解Qt的信号与槽机制"></a>怎么理解Qt的信号与槽机制</h2><p>Qt的信号与槽机制是Qt中最重要的特性之一，它用于实现对象间的通信。在Qt中，信号与槽是事件驱动的核心，允许对象在特定事件发生时，向其他对象发出信号，并触发与之相关的槽函数。理解信号与槽机制可以帮助你更好地掌握Qt框架中的对象交互方式。</p>
<h3 id="1-信号（Signal）"><a href="#1-信号（Signal）" class="headerlink" title="1. 信号（Signal）"></a>1. <strong>信号（Signal）</strong></h3><p>信号是由Qt对象发出的，用于表示某个事件的发生或状态的变化。例如，一个按钮的点击事件就是一个信号。当按钮被点击时，它会发出一个信号。</p>
<p>信号不需要知道谁接收它，也不需要直接与接收者沟通。它只负责“发出”事件通知，告诉其它对象事件已经发生。</p>
<h3 id="2-槽（Slot）"><a href="#2-槽（Slot）" class="headerlink" title="2. 槽（Slot）"></a>2. <strong>槽（Slot）</strong></h3><p>槽是一个普通的成员函数，用于响应信号。当某个信号发出时，与该信号相关联的槽函数会被自动调用。槽可以是任何符合函数签名的普通成员函数，也可以是全局函数或lambda表达式。</p>
<p>槽的作用是处理信号发出的事件，并做出响应。</p>
<h3 id="3-连接信号与槽"><a href="#3-连接信号与槽" class="headerlink" title="3. 连接信号与槽"></a>3. <strong>连接信号与槽</strong></h3><p>信号与槽之间通过<code>QObject::connect()</code>函数进行连接。当信号发出时，Qt框架会自动找到连接的槽并执行它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), receiver, <span class="built_in">SLOT</span>(<span class="built_in">onButtonClick</span>()));</span><br></pre></td></tr></table></figure>
<p>在这个例子中，当<code>sender</code>（例如一个按钮）发出<code>clicked</code>信号时，<code>receiver</code>的<code>onButtonClick()</code>槽函数会被调用。</p>
<h3 id="4-自动连接"><a href="#4-自动连接" class="headerlink" title="4. 自动连接"></a>4. <strong>自动连接</strong></h3><p>在Qt中，如果信号和槽的参数类型匹配，Qt会自动进行信号和槽的连接，而不需要显式调用<code>connect()</code>。例如，<code>QPushButton</code>有一个<code>clicked()</code>信号，它和<code>QDialog</code>中的<code>accept()</code>槽可以自动连接。</p>
<h3 id="5-信号与槽的参数"><a href="#5-信号与槽的参数" class="headerlink" title="5. 信号与槽的参数"></a>5. <strong>信号与槽的参数</strong></h3><p>信号和槽可以传递参数。信号的参数会传递给槽，槽函数的参数类型必须与信号的参数类型匹配。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sender, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)), receiver, <span class="built_in">SLOT</span>(<span class="built_in">updateValue</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure>
<p>在这个例子中，当<code>sender</code>的<code>valueChanged</code>信号发出时，<code>int</code>类型的参数会传递给<code>receiver</code>的<code>updateValue(int)</code>槽。</p>
<h3 id="6-信号与槽的特性"><a href="#6-信号与槽的特性" class="headerlink" title="6. 信号与槽的特性"></a>6. <strong>信号与槽的特性</strong></h3><ul>
<li><strong>类型安全</strong>：Qt的信号与槽机制是类型安全的，即只有信号和槽参数类型匹配时，连接才会成功。</li>
<li><strong>异步</strong>：信号和槽的调用是异步的，槽函数会在信号发出时被自动调用，线程间通信时也可以使用信号与槽机制。</li>
<li><strong>多个连接</strong>：一个信号可以连接多个槽，多个信号可以连接到同一个槽。</li>
</ul>
<h3 id="7-应用场景"><a href="#7-应用场景" class="headerlink" title="7. 应用场景"></a>7. <strong>应用场景</strong></h3><ul>
<li><strong>UI响应</strong>：比如按钮点击、鼠标事件等。</li>
<li><strong>跨线程通信</strong>：信号与槽机制可以跨线程传递消息，帮助你在不同线程间传递数据或通知。</li>
<li><strong>自定义事件</strong>：在开发中自定义信号与槽，处理特殊的业务逻辑。</li>
</ul>
<p>总结来说，Qt的信号与槽机制是一种松耦合的通信方式，使得对象之间的交互变得更加灵活和可维护。通过这种机制，不同的对象之间能够相互传递信息而无需了解彼此的具体实现。</p>
<h2 id="QT按钮组件"><a href="#QT按钮组件" class="headerlink" title="QT按钮组件"></a>QT按钮组件</h2><ul>
<li>QT中有六种按钮组件，分别是按压按钮QPushButton、工具按钮QToolButton、单选按钮QRadioButton、多选按钮QCheckBox、命令链接按钮QCommandLinkButton、按钮盒QButtonBox</li>
</ul>
<h2 id="QPushButton"><a href="#QPushButton" class="headerlink" title="QPushButton"></a>QPushButton</h2><h3 id="QPushButton组件简介"><a href="#QPushButton组件简介" class="headerlink" title="QPushButton组件简介"></a>QPushButton组件简介</h3><ul>
<li>QPushButton组件用于接受用户点击事件，能够显示提示字符串，是功能性组件，需要父组件作为容器，能够在父组件中进行定位，用于执行命令或触发事件。</li>
<li>QPushButton的类继承如下：<ul>
<li>QPushButton ：public QAbstractButton ：pubic QWidget ：public QObject, public QPaintDevice</li>
</ul>
</li>
</ul>
<h3 id="QPushButton组件属性"><a href="#QPushButton组件属性" class="headerlink" title="QPushButton组件属性"></a>QPushButton组件属性</h3><ul>
<li>QPushButton 组件属性设置选项：<ul>
<li>A、name：组件对应源代码中的名字。</li>
<li>B、text：组件对应图形界面中显示的名字。</li>
<li>C、font：设置text的字体。</li>
<li>D、enabled：组件是否可用。</li>
</ul>
</li>
</ul>
<h3 id="QPushButton组件常用成员函数"><a href="#QPushButton组件常用成员函数" class="headerlink" title="QPushButton组件常用成员函数"></a>QPushButton组件常用成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton：：QPushButton（<span class="type">const</span> QString &amp;text，QWidget *parent，<span class="type">const</span> <span class="type">char</span> *name = <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>构造一个名称为name，父对象为parent并且文本为text的按压按钮。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> QAbstractButton：：setText（<span class="type">const</span> QString &amp;）</span><br></pre></td></tr></table></figure>
<ul>
<li>设置按钮上显示的文本。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString QAbstractButton：：text（）<span class="type">const</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回按钮上显示的文本。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> QAbstractButton：：pressed（）[signal]</span><br></pre></td></tr></table></figure>
<ul>
<li>当按下按钮时，发射信号。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> QAbstractButton：：clicked（）[signal]</span><br></pre></td></tr></table></figure>
<ul>
<li>当单击按钮时，发射信号。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ <span class="type">void</span> QAbstractButton：：released（）[signal]</span><br></pre></td></tr></table></figure>
<ul>
<li>当释放按钮时，发射信号。</li>
</ul>
<h2 id="Qt程序需要配置那些内容"><a href="#Qt程序需要配置那些内容" class="headerlink" title="Qt程序需要配置那些内容"></a>Qt程序需要配置那些内容</h2><ul>
<li>Qt的几个编译工具: moc, uic, rcc.这几个工具在Qt Assistant中都可以直接搜索到介绍界面，下面简单说一下各自的功能<ul>
<li>moc: 元对象编译器(Meta Object Compiler)，用来处理带有Q_OBJECT宏的类。我们在声明class的时候，继承QObject，再私有声明Q_OBJECT宏就可以使用Qt的信号和槽了，实际上是Qt利用moc将各个类所需要的元对象代码(meta-object code)补充好了。(moc读取一个头文件，补充其中带有Q_OBJECT宏类的元对象代码，一般生成一个moc_ClassName.cpp文件)</li>
<li>uic: 用户界面编译器(User Interface Compiler)，用来编译ui界面文件的</li>
<li>rcc: 资源编译器(Resource Compiler)，把qrc文件编译成对应的C++代码</li>
</ul>
</li>
<li>所以在CMake工程中使用Qt首先要搞明白如何调用这些工具</li>
</ul>
<h3 id="moc-uic-rcc-自动调用"><a href="#moc-uic-rcc-自动调用" class="headerlink" title="moc uic rcc 自动调用"></a>moc uic rcc 自动调用</h3><ul>
<li><p>首先对于 moc uic rcc处理的方法</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>设置了这几个变量之后，会在需要时自动调用这几个编译器。</p>
</li>
<li><p>在添加 exe 时的语法:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(TestQtCMake WIN32 src/main.cpp src/mainWindow.cpp src/mainwindow.h src/mainwindow.ui)</span><br></pre></td></tr></table></figure></li>
<li><p>其中 WIN32 的参数可能需要提示一下</p>
<ul>
<li>如果提供了 WIN32，则将设置WIN32_EXECUTABLE变量为ON，此时将生成一个界面程序而不是控制台程序。</li>
</ul>
</li>
</ul>
<h3 id="添加Qt模块和生成执行文件"><a href="#添加Qt模块和生成执行文件" class="headerlink" title="添加Qt模块和生成执行文件"></a>添加Qt模块和生成执行文件</h3><ul>
<li><p>添加库，使用了 find_package()函数，示例如下</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Qt5 COMPONENTS Widgets REQUIRED)</span><br></pre></td></tr></table></figure></li>
<li><p>首先，要使用find_package()函数，需要提供一个.cmake文件，如何让CMake知道这个文件，可以采用两个方法</p>
<ul>
<li>设置环境变量CMAKE_PREFIX_PATH为Qt5安装位置，这是官方Qt-CMake教程中的推荐做法</li>
<li>设置CMake中Qt5_DIR变量，值为QT5Config.cmake文件的位置。示例如下<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(Qt5_DIR D:\Qt514\<span class="number">5.14</span>.<span class="number">0</span>\msvc2017_64\lib\cmake\Qt5)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>从上方目录可以看出来，这个.cmake文件是不同Qt版本和不同编译平台都有一套，所以对于官方推荐做法笔者并不是很推荐，难不成当需要换平台的时候还需要去改环境变量</p>
</li>
<li><p>将Qt库链接到可执行文件</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(TestQtCMake Qt5::Widgets)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="运行时依赖处理"><a href="#运行时依赖处理" class="headerlink" title="运行时依赖处理"></a>运行时依赖处理</h3><ul>
<li>对于缺少dll文件，可以在环境变量中是设置Path，把Qt的bin目录添加进来</li>
<li>在windows平台使用官方的 windeployqt 工具，就在上述的bin目录下，传入exe文件路径就可以将该exe依赖的Qt文件全部打包到目录下，命令示例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windeployqt.exe TestQtCMake.exe</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>要在CMake中使用Qt，需要以下几步<ul>
<li>设置变量CMAKE_AUTO***为ON以启动 rcc uic moc编译器</li>
<li>设置变量QT5_DIR变量定位.cmake文件，使用find_package()函数定位Qt的库文件，使用target_link_libraries()函数链接Qt库</li>
<li>使用windeployqt工具打包依赖项</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Qt/2024-09-05-qt_5_quick_designer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Qt/2024-09-05-qt_5_quick_designer/" class="post-title-link" itemprop="url">quick designer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Qt/" itemprop="url" rel="index"><span itemprop="name">Qt</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>quick designer 使用笔记</li>
</ul>
<h2 id="Qt项目界面文件-ui-及其作用"><a href="#Qt项目界面文件-ui-及其作用" class="headerlink" title="Qt项目界面文件(.ui)及其作用"></a>Qt项目界面文件(.ui)及其作用</h2><ul>
<li><p>Qt项目中，后缀为.ui的文件是可视化设计的窗体的定义文件，例如widget.ui。双击项目文件目录树中的文件widget.ui，会打开一个集成在Qt Creator中的Qt Designer对窗体进行可视化设计。</p>
</li>
<li><p>widget.ui文件，是窗体界面定义文件，是一个XML文件，定义了窗口上的所有组件的属性设置，布局，及其信号与槽函数的关联等。用UI设计器可视化设计的界面都由Qt自动解析，并以XML文件的形式保存下来。在设计界面时，只需在UI设计器里进行可视化设计即可。</p>
</li>
<li><p>ui_widget.h文件，是对widget.ui文件编译后生成的一个文件，ui_widget.h会出现在编译后的目录下，或与widget.ui同目录</p>
</li>
<li><p>ui_widget.h并不会出现在QtCreator的项目文件目录树里，当然可以手动将ui_widget.h添加到项目中</p>
</li>
<li><p>注意，ui_widget.h是对widget.ui文件编译后自动生成的,widget.ui又是通过UI设计器可视化设计生成的。所有，对ui_widget.h手动进行修改没有什么意义，所有涉及界面的修改都应该直接在UI设计器里进行。</p>
</li>
<li><p>查看ui_widget.h文件的内容，发现它主要做了以下的一些工作</p>
<ul>
<li>定义了一个类Ui_Widget，用于封装可视化设计的界面</li>
<li>自动生成了界面各个组件的类成员变量定义。在public部分为界面上每个组件定义了一个指针变量，变量的名称就是设置的objectName。例如，在窗体上放置了一个QLable和一个QPushButton并命名后，自动生成的定义是: QLabel *LabDemo; QPushButton *btnClose;</li>
<li>定义了setupUi()函数，这个函数用于创建各个界面组件，并设置其位置，大小，文字内容，字体等属性，设置信号与槽的关联。setupUi()函数体的第一部分是根据可视化设计的界面内容，用C++代码创建界面上各组件，并设置其属性<ul>
<li>接下来，setupUi()调用了函数retranslateUi(Widget)，用来设置界面各组件的文字内容属性，例如标签的问题，按键的文字，窗体的标题等。将界面上的文字设置的内容独立出来作为一个函数retranslateUi()，在设计多语言界面时会用到这个函数</li>
<li>setupUi()函数的第三部分是设置信号与槽的关联。</li>
<li>所以，在Widget的构造函数里调用ui-&gt;setupUi(this),就实现了窗体上组件的创建，属性设置，信号与槽的关联。</li>
</ul>
</li>
<li>定义namespace Ui,并定义一个从Ui_Widget继承的类Widget<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Ui</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Widget</span>::<span class="keyword">public</span> Ui_Widget&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>提示，ui_widget.h文件里实现界面功能的类是Ui_Widget。再定义一个类Widget从Ui_Widget继承而来，并定义在namespace Ui里，这样Ui::Widget与widget.h里的类Widget同名，但是用namespace区分开来。所以，界面的Ui::Widget类与文件widget.h里定义的Widget类实际上是两个类，但是Qt的处理让用户感觉不到Ui::Widget类的存在，只需要直到在Widget类里用ui指针可以访问可视化设计的界面组件就可以了。</p>
</li>
</ul>
<h2 id="把Qt的界面文件-ui文件-生成源文件-h或-cpp"><a href="#把Qt的界面文件-ui文件-生成源文件-h或-cpp" class="headerlink" title="把Qt的界面文件(.ui文件)生成源文件(.h或.cpp)"></a>把Qt的界面文件(.ui文件)生成源文件(.h或.cpp)</h2><ul>
<li>在用Qt做开发时，为了方便快速，一般都使用Qt设计师界面类来做界面相关的布局，这个类在当前工程中是没有.cpp或.h文件的，但主类又有引入了这个头文件，点开转到定义或声明时，时打不开的。</li>
<li>下面的一种办法<ul>
<li>新建一个工程，包含ui文件，然后打开ui文件拖入想要的控件，保存，编译ui文件</li>
<li>在qt安装路径下找到 uic.exe 文件，使用这个工具将ui文件生成.h或.cpp文件。例如<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uic.exe test.ui -o test.h</span><br><span class="line">uic.exe test.ui -o test.cpp</span><br></pre></td></tr></table></figure></li>
<li>.h或.cpp这两个文件只要一个就可以了</li>
<li>把刚才生成的.h文件导入当前工程，然后打开刚刚生成的源码，可以看到整个类的所有属性和所有成员函数</li>
</ul>
</li>
</ul>
<h2 id="Qt-quick-designer-详解"><a href="#Qt-quick-designer-详解" class="headerlink" title="Qt quick designer 详解"></a>Qt quick designer 详解</h2><h1 id="Qt-Quick-Designer-详解"><a href="#Qt-Quick-Designer-详解" class="headerlink" title="Qt Quick Designer 详解"></a>Qt Quick Designer 详解</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><strong>Qt Quick Designer</strong> 是 Qt Creator 集成开发环境（IDE）中的一个可视化设计工具，专用于设计和开发基于 <strong>Qt Quick（QML）</strong> 的用户界面。它提供了所见即所得（WYSIWYG）的编辑环境，使开发者能够通过拖放组件、调整属性等方式，快速构建现代化、响应式的用户界面，而无需手动编写大量的 QML 代码。</p>
<hr>
<h2 id="二、Qt-Quick-和-QML-简介"><a href="#二、Qt-Quick-和-QML-简介" class="headerlink" title="二、Qt Quick 和 QML 简介"></a>二、Qt Quick 和 QML 简介</h2><p>在深入了解 Qt Quick Designer 之前，先简单回顾一下 Qt Quick 和 QML：</p>
<ul>
<li><p><strong>Qt Quick</strong>：是 Qt 框架中用于创建动态用户界面的技术，特别适用于触摸屏和移动设备应用。它结合了 QML 和 JavaScript，实现了高性能的界面渲染和丰富的动画效果。</p>
</li>
<li><p><strong>QML（Qt Modeling Language）</strong>：是一种基于 JavaScript 的声明式语言，专门用于设计用户界面。通过 QML，可以以简洁直观的方式描述界面元素、布局和交互行为。</p>
</li>
</ul>
<hr>
<h2 id="三、Qt-Quick-Designer-的主要功能"><a href="#三、Qt-Quick-Designer-的主要功能" class="headerlink" title="三、Qt Quick Designer 的主要功能"></a>三、Qt Quick Designer 的主要功能</h2><h3 id="1-拖放式界面设计"><a href="#1-拖放式界面设计" class="headerlink" title="1. 拖放式界面设计"></a>1. 拖放式界面设计</h3><ul>
<li><strong>组件面板</strong>：提供了丰富的预定义 UI 组件，如按钮、文本、图像、列表等。</li>
<li><strong>拖放操作</strong>：直接将组件从面板拖拽到设计区域，快速构建界面布局。</li>
</ul>
<h3 id="2-属性编辑器"><a href="#2-属性编辑器" class="headerlink" title="2. 属性编辑器"></a>2. 属性编辑器</h3><ul>
<li><strong>实时调整</strong>：选中组件后，可以在属性编辑器中修改其属性，如大小、位置、颜色等。</li>
<li><strong>绑定支持</strong>：支持属性绑定，可以将组件的属性与数据模型或其他组件属性关联。</li>
</ul>
<h3 id="3-层次结构视图"><a href="#3-层次结构视图" class="headerlink" title="3. 层次结构视图"></a>3. 层次结构视图</h3><ul>
<li><strong>组件管理</strong>：展示当前界面中所有组件的层次关系，方便组织和管理。</li>
<li><strong>快速导航</strong>：通过层次结构视图，快速定位并选中特定的界面元素。</li>
</ul>
<h3 id="4-动画和过渡"><a href="#4-动画和过渡" class="headerlink" title="4. 动画和过渡"></a>4. 动画和过渡</h3><ul>
<li><strong>动画编辑器</strong>：可视化地创建和调整动画效果，支持时间轴和关键帧。</li>
<li><strong>状态和过渡</strong>：定义组件的不同状态，并设置状态之间的过渡动画。</li>
</ul>
<h3 id="5-实时预览"><a href="#5-实时预览" class="headerlink" title="5. 实时预览"></a>5. 实时预览</h3><ul>
<li><strong>即时反馈</strong>：无需编译，即可在设计器中实时查看界面效果。</li>
<li><strong>多设备预览</strong>：支持模拟不同设备的屏幕尺寸和分辨率，确保界面自适应性。</li>
</ul>
<h3 id="6-代码与设计视图同步"><a href="#6-代码与设计视图同步" class="headerlink" title="6. 代码与设计视图同步"></a>6. 代码与设计视图同步</h3><ul>
<li><strong>双向编辑</strong>：在设计视图和代码视图之间切换，所有更改都会同步更新。</li>
<li><strong>代码提示</strong>：在代码视图中提供智能提示和自动补全，加速手动编码过程。</li>
</ul>
<hr>
<h2 id="四、使用-Qt-Quick-Designer-的步骤"><a href="#四、使用-Qt-Quick-Designer-的步骤" class="headerlink" title="四、使用 Qt Quick Designer 的步骤"></a>四、使用 Qt Quick Designer 的步骤</h2><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h3><ul>
<li><strong>新建项目</strong>：在 Qt Creator 中，选择“新建项目”，并选择“Qt Quick 应用程序”模板。</li>
<li><strong>配置项目</strong>：按照向导提示，设置项目名称、位置和其他配置。</li>
</ul>
<h3 id="2-设计界面"><a href="#2-设计界面" class="headerlink" title="2. 设计界面"></a>2. 设计界面</h3><ul>
<li><strong>打开主 QML 文件</strong>：在项目导航器中，找到 <code>Main.qml</code> 文件，双击打开。</li>
<li><strong>切换到设计视图</strong>：在编辑器窗口顶部，选择“设计”选项卡。</li>
</ul>
<h3 id="3-添加和配置组件"><a href="#3-添加和配置组件" class="headerlink" title="3. 添加和配置组件"></a>3. 添加和配置组件</h3><ul>
<li><strong>添加组件</strong>：从组件面板中拖放所需的组件到设计区域。</li>
<li><strong>设置属性</strong>：选中组件，在属性编辑器中调整其属性，如位置、大小、样式等。</li>
</ul>
<h3 id="4-管理组件层次"><a href="#4-管理组件层次" class="headerlink" title="4. 管理组件层次"></a>4. 管理组件层次</h3><ul>
<li><strong>调整层次结构</strong>：在层次结构视图中，通过拖放改变组件的父子关系。</li>
<li><strong>命名组件</strong>：为组件设置 <code>id</code>，方便在代码中引用。</li>
</ul>
<h3 id="5-添加交互和动画"><a href="#5-添加交互和动画" class="headerlink" title="5. 添加交互和动画"></a>5. 添加交互和动画</h3><ul>
<li><strong>定义状态</strong>：在状态编辑器中添加新的状态，描述组件在不同情况下的表现。</li>
<li><strong>创建动画</strong>：使用动画编辑器，为属性变化添加动画效果。</li>
</ul>
<h3 id="6-预览和测试"><a href="#6-预览和测试" class="headerlink" title="6. 预览和测试"></a>6. 预览和测试</h3><ul>
<li><strong>实时预览</strong>：点击预览按钮，查看界面的实时效果。</li>
<li><strong>调试</strong>：使用 Qt Creator 的调试工具，检测和解决潜在的问题。</li>
</ul>
<hr>
<h2 id="五、与代码编辑的结合"><a href="#五、与代码编辑的结合" class="headerlink" title="五、与代码编辑的结合"></a>五、与代码编辑的结合</h2><h3 id="1-代码视图"><a href="#1-代码视图" class="headerlink" title="1. 代码视图"></a>1. 代码视图</h3><ul>
<li><strong>查看代码</strong>：在设计器中，随时切换到代码视图，查看生成的 QML 代码。</li>
<li><strong>手动编辑</strong>：直接在代码中添加逻辑或自定义组件。</li>
</ul>
<h3 id="2-双向同步"><a href="#2-双向同步" class="headerlink" title="2. 双向同步"></a>2. 双向同步</h3><ul>
<li><strong>设计与代码一致性</strong>：所有在设计视图中的更改都会反映到代码视图中，反之亦然。</li>
<li><strong>冲突解决</strong>：当手动编辑的代码无法在设计视图中解析时，设计器会给出提示。</li>
</ul>
<hr>
<h2 id="六、优势与应用场景"><a href="#六、优势与应用场景" class="headerlink" title="六、优势与应用场景"></a>六、优势与应用场景</h2><h3 id="1-提高开发效率"><a href="#1-提高开发效率" class="headerlink" title="1. 提高开发效率"></a>1. 提高开发效率</h3><ul>
<li><strong>快速构建</strong>：拖放式设计减少了手动编码的时间，加快了界面开发速度。</li>
<li><strong>直观性</strong>：所见即所得的编辑方式，使得界面设计更直观。</li>
</ul>
<h3 id="2-降低学习难度"><a href="#2-降低学习难度" class="headerlink" title="2. 降低学习难度"></a>2. 降低学习难度</h3><ul>
<li><strong>适合初学者</strong>：对于不熟悉 QML 或编程的新手，Qt Quick Designer 提供了友好的入门途径。</li>
<li><strong>丰富的组件库</strong>：预定义的组件和样式，降低了设计复杂界面的门槛。</li>
</ul>
<h3 id="3-促进团队协作"><a href="#3-促进团队协作" class="headerlink" title="3. 促进团队协作"></a>3. 促进团队协作</h3><ul>
<li><strong>设计师参与</strong>：界面设计师可以直接使用 Qt Quick Designer 进行原型设计和界面布局。</li>
<li><strong>开发与设计分离</strong>：开发者和设计师可以各自专注于逻辑实现和界面美化。</li>
</ul>
<hr>
<h2 id="七、注意事项"><a href="#七、注意事项" class="headerlink" title="七、注意事项"></a>七、注意事项</h2><h3 id="1-理解生成的代码"><a href="#1-理解生成的代码" class="headerlink" title="1. 理解生成的代码"></a>1. 理解生成的代码</h3><ul>
<li><strong>代码质量</strong>：尽管设计器生成的代码可用，但手动检查和优化代码有助于提高应用性能。</li>
<li><strong>学习 QML</strong>：深入理解 QML 语言，有助于更好地利用 Qt Quick Designer。</li>
</ul>
<h3 id="2-兼容性问题"><a href="#2-兼容性问题" class="headerlink" title="2. 兼容性问题"></a>2. 兼容性问题</h3><ul>
<li><strong>Qt 版本</strong>：确保使用的 Qt Creator 和 Qt 版本与项目需求一致，避免兼容性问题。</li>
<li><strong>平台差异</strong>：在不同平台上测试界面，确保跨平台一致性。</li>
</ul>
<h3 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="3. 性能优化"></a>3. 性能优化</h3><ul>
<li><strong>避免过度嵌套</strong>：过深的组件嵌套可能影响性能，需合理组织界面结构。</li>
<li><strong>谨慎使用动画</strong>：大量或复杂的动画效果可能导致性能问题，应适度使用。</li>
</ul>
<hr>
<h2 id="八、结论"><a href="#八、结论" class="headerlink" title="八、结论"></a>八、结论</h2><p>Qt Quick Designer 是开发 Qt Quick 应用程序的强大工具，提供了高效、直观的界面设计方式。通过结合拖放式设计、属性编辑、动画创建和代码同步等功能，它简化了用户界面的开发流程，适合从初学者到资深开发者的各种需求。熟练掌握 Qt Quick Designer，将有助于快速构建高质量的跨平台应用程序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Robotics/2024-05-22-robotics_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Robotics/2024-05-22-robotics_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">robotics_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Robotics/" itemprop="url" rel="index"><span itemprop="name">Robotics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>机器人学相关理论基础</li>
</ul>
<h2 id="手眼标定中移动相机的标定是相机坐标系与末端坐标系吗？"><a href="#手眼标定中移动相机的标定是相机坐标系与末端坐标系吗？" class="headerlink" title="手眼标定中移动相机的标定是相机坐标系与末端坐标系吗？"></a>手眼标定中移动相机的标定是相机坐标系与末端坐标系吗？</h2><p>是的，在<strong>移动相机（Eye-in-Hand）</strong>的手眼标定中，<strong>标定的是相机坐标系相对于末端坐标系的变换矩阵</strong>。  </p>
<hr>
<h2 id="1-变换矩阵的定义"><a href="#1-变换矩阵的定义" class="headerlink" title="1. 变换矩阵的定义"></a><strong>1. 变换矩阵的定义</strong></h2><p>在<strong>Eye-in-Hand</strong>（移动相机）手眼标定中，通常涉及以下坐标系：</p>
<ul>
<li><strong>基地坐标系 ( B )</strong>（Base Frame）：固定在机械臂的底座上。</li>
<li><strong>末端坐标系 ( E )</strong>（End-Effector Frame）：固定在机械臂末端（即法兰盘或工具的坐标系）。</li>
<li><strong>相机坐标系 ( C )</strong>（Camera Frame）：相机安装在机械臂末端，与机械臂一起运动。</li>
<li><strong>标定板坐标系 ( W )</strong>（World Frame）：标定板的坐标系，通常固定在环境中的某个已知位置。</li>
</ul>
<p>在手眼标定中，我们要求解：<br>[<br>{}^E T_C<br>]<br>其中：</p>
<ul>
<li><strong>( {}^E T_C )</strong>：<strong>相机坐标系相对于末端坐标系的变换矩阵</strong>，用于描述相机相对于机械臂末端的固定安装位置。</li>
</ul>
<hr>
<h2 id="2-变换关系推导"><a href="#2-变换关系推导" class="headerlink" title="2. 变换关系推导"></a><strong>2. 变换关系推导</strong></h2><p>在<strong>Eye-in-Hand</strong>系统中，物体坐标 ( P_W ) 在不同坐标系中的变换关系如下：<br>[<br>P_B &#x3D; {}^B T_E \cdot {}^E T_C \cdot {}^C T_W \cdot P_W<br>]<br>其中：</p>
<ul>
<li><strong>( {}^B T_E )</strong>：基地坐标系到末端坐标系的变换（已知，来自机械臂的运动学计算）。</li>
<li><strong>( {}^E T_C )</strong>：末端坐标系到相机坐标系的变换（<strong>未知，需要标定</strong>）。</li>
<li><strong>( {}^C T_W )</strong>：相机坐标系到标定板坐标系的变换（可通过相机拍摄标定板计算得出）。</li>
<li><strong>( {}^B T_W )</strong>：基地坐标系到标定板坐标系的变换（已知，通过标定板的固定位置确定）。</li>
</ul>
<p>为了求解<strong>相机相对于末端的安装位姿</strong> ( {}^E T_C )，可以通过以下公式：<br>[<br>{}^E T_C &#x3D; ({}^B T_E)^{-1} \cdot {}^B T_W \cdot ({}^C T_W)^{-1}<br>]</p>
<ul>
<li>机械臂运动提供 ( {}^B T_E )（来自机械臂的位姿反馈）。</li>
<li>视觉检测提供 ( {}^C T_W )（通过相机检测标定板获取）。</li>
<li>物理测量提供 ( {}^B T_W )（标定板位置相对于机械臂基地）。</li>
</ul>
<hr>
<h2 id="3-手眼标定的实现流程"><a href="#3-手眼标定的实现流程" class="headerlink" title="3. 手眼标定的实现流程"></a><strong>3. 手眼标定的实现流程</strong></h2><h3 id="步骤-1：数据采集"><a href="#步骤-1：数据采集" class="headerlink" title="步骤 1：数据采集"></a><strong>步骤 1：数据采集</strong></h3><ul>
<li>让机械臂的末端移动到多个不同的已知姿态 ( {}^B T_E )。</li>
<li>每个姿态下，相机拍摄标定板，获取标定板在相机坐标系下的位姿 ( {}^C T_W )。</li>
</ul>
<h3 id="步骤-2：计算变换矩阵"><a href="#步骤-2：计算变换矩阵" class="headerlink" title="步骤 2：计算变换矩阵"></a><strong>步骤 2：计算变换矩阵</strong></h3><ul>
<li>通过 Tsai-Lenz 方法或最小二乘优化方法，解算 ( {}^E T_C )。</li>
</ul>
<h3 id="步骤-3：验证精度"><a href="#步骤-3：验证精度" class="headerlink" title="步骤 3：验证精度"></a><strong>步骤 3：验证精度</strong></h3><ul>
<li>使用已知的物体位置，验证手眼标定结果是否准确。</li>
</ul>
<hr>
<h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a><strong>4. 结论</strong></h2><p>在<strong>移动相机（Eye-in-Hand）</strong>的手眼标定中，最终求解的是<strong>相机坐标系相对于末端坐标系的变换矩阵 ( {}^E T_C )</strong>，它用于描述相机相对于机械臂末端的固定位置，并用于视觉引导、抓取等任务。</p>
<h2 id="机械臂种的世界坐标系的作用"><a href="#机械臂种的世界坐标系的作用" class="headerlink" title="机械臂种的世界坐标系的作用"></a>机械臂种的世界坐标系的作用</h2><h3 id="机械臂中的世界坐标系的作用"><a href="#机械臂中的世界坐标系的作用" class="headerlink" title="机械臂中的世界坐标系的作用"></a><strong>机械臂中的世界坐标系的作用</strong></h3><p>在机器人学中，<strong>世界坐标系（World Coordinate System, W）</strong>是一个全局参考坐标系，它在机械臂的应用中起着至关重要的作用，主要用于<strong>统一不同坐标系、任务规划、视觉定位</strong>等。  </p>
<hr>
<h2 id="1-世界坐标系的定义"><a href="#1-世界坐标系的定义" class="headerlink" title="1. 世界坐标系的定义"></a><strong>1. 世界坐标系的定义</strong></h2><ul>
<li>世界坐标系 ( W ) 是整个机械臂工作环境中的一个<strong>固定</strong>的全局参考坐标系。</li>
<li>其原点、方向通常根据任务需求确定，例如：<ul>
<li>设定在<strong>机械臂基地坐标系 ( B )</strong> 处，方便对齐机器人本体。</li>
<li>设定在<strong>生产线的某个固定点</strong>，便于多个机器人协作。</li>
<li>设定在<strong>视觉系统的标定板</strong>，以便对接视觉坐标信息。</li>
</ul>
</li>
</ul>
<p>世界坐标系可以通过<strong>齐次变换矩阵</strong> ( {}^W T_X ) 来表示<strong>任何其他坐标系</strong>（如基地坐标系、末端坐标系等）相对于世界坐标系的变换关系。</p>
<hr>
<h2 id="2-世界坐标系的主要作用"><a href="#2-世界坐标系的主要作用" class="headerlink" title="2. 世界坐标系的主要作用"></a><strong>2. 世界坐标系的主要作用</strong></h2><h3 id="2-1-统一不同坐标系"><a href="#2-1-统一不同坐标系" class="headerlink" title="2.1 统一不同坐标系"></a><strong>2.1 统一不同坐标系</strong></h3><p>机械臂系统涉及多个坐标系，如：</p>
<ul>
<li><strong>基地坐标系（Base Frame, B）</strong></li>
<li><strong>末端坐标系（End-Effector Frame, E）</strong></li>
<li><strong>工具坐标系（Tool Frame, T）</strong></li>
<li><strong>相机坐标系（Camera Frame, C）</strong></li>
<li><strong>物体坐标系（Object Frame, O）</strong></li>
</ul>
<p>世界坐标系作为一个全局基准，可以将所有坐标系转换到同一基准下，使它们相互配合。例如：<br>[<br>P_W &#x3D; {}^W T_B \cdot {}^B T_E \cdot {}^E T_T \cdot P_T<br>]<br>这个公式表示：工具坐标系中的某个点 ( P_T ) 经过多次变换后，最终转换到世界坐标系下的点 ( P_W )。</p>
<hr>
<h3 id="2-2-机器人任务规划"><a href="#2-2-机器人任务规划" class="headerlink" title="2.2 机器人任务规划"></a><strong>2.2 机器人任务规划</strong></h3><ul>
<li>在工业应用中，任务点通常在世界坐标系下定义，比如：<ul>
<li>机械臂要在<strong>流水线上某个固定点抓取物体</strong>，该点通常用世界坐标系表示。</li>
<li>焊接任务中的焊点坐标、喷涂任务中的轨迹，都是基于世界坐标系设定的。</li>
</ul>
</li>
<li>通过设定目标点在世界坐标系下的位置 ( P_W )，机械臂可以通过逆运动学计算合适的关节角度去执行任务。</li>
</ul>
<hr>
<h3 id="2-3-视觉引导（手眼协调）"><a href="#2-3-视觉引导（手眼协调）" class="headerlink" title="2.3 视觉引导（手眼协调）"></a><strong>2.3 视觉引导（手眼协调）</strong></h3><ul>
<li><strong>固定相机（Eye-to-Hand）</strong>：相机通常固定在环境中（例如装在一个架子上），它的坐标系需要转换到世界坐标系，以便机械臂理解物体位置。</li>
<li><strong>运动相机（Eye-in-Hand）</strong>：相机安装在机械臂末端，检测到的物体坐标首先是相机坐标系下的，必须转换到世界坐标系，才能进行全局路径规划。</li>
<li>例如，物体在相机坐标系下的位置 ( P_C ) 需要转换到世界坐标系：<br>[<br>P_W &#x3D; {}^W T_C \cdot P_C<br>]<br>这样机械臂就能在世界坐标系中理解目标物体的位置，并进行抓取。</li>
</ul>
<hr>
<h3 id="2-4-多机器人协作"><a href="#2-4-多机器人协作" class="headerlink" title="2.4 多机器人协作"></a><strong>2.4 多机器人协作</strong></h3><ul>
<li>在多机器人协作场景中，每个机械臂通常有自己的<strong>基地坐标系</strong>，但为了让它们协作，需要有一个公共的<strong>世界坐标系</strong>。</li>
<li>例如，两个机械臂协作搬运物体：<ul>
<li>机械臂 A 需要将物体放置到某个世界坐标点 ( P_W )。</li>
<li>机械臂 B 需要从 ( P_W ) 处接住物体。</li>
</ul>
</li>
<li>这种情况下，世界坐标系可以作为统一参考，使两个机械臂的操作无缝对接。</li>
</ul>
<hr>
<h3 id="2-5-机器人路径规划"><a href="#2-5-机器人路径规划" class="headerlink" title="2.5 机器人路径规划"></a><strong>2.5 机器人路径规划</strong></h3><ul>
<li>机器人路径通常是在世界坐标系下定义的，比如：<ul>
<li>让机械臂按照某条轨迹（如直线、圆弧）移动。</li>
<li>进行避障计算，确保路径不会与环境发生碰撞。</li>
</ul>
</li>
<li>通过世界坐标系，机械臂可以从当前姿态 ( {}^W T_E ) 规划一条到达目标位姿 ( {}^W T_{E,goal} ) 的路径。</li>
</ul>
<hr>
<h2 id="3-世界坐标系与其他坐标系的关系"><a href="#3-世界坐标系与其他坐标系的关系" class="headerlink" title="3. 世界坐标系与其他坐标系的关系"></a><strong>3. 世界坐标系与其他坐标系的关系</strong></h2><table>
<thead>
<tr>
<th>坐标系</th>
<th>作用</th>
<th>典型变换</th>
</tr>
</thead>
<tbody><tr>
<td><strong>世界坐标系（W）</strong></td>
<td>统一多个坐标系，定义全局任务</td>
<td>( {}^W T_B ), ( {}^W T_O )</td>
</tr>
<tr>
<td><strong>基地坐标系（B）</strong></td>
<td>机械臂的固定参考点</td>
<td>( {}^B T_E )</td>
</tr>
<tr>
<td><strong>末端坐标系（E）</strong></td>
<td>机械臂末端工具的姿态</td>
<td>( {}^E T_T )</td>
</tr>
<tr>
<td><strong>工具坐标系（T）</strong></td>
<td>机械臂安装的工具（如夹爪）</td>
<td>( {}^T T_O )</td>
</tr>
<tr>
<td><strong>相机坐标系（C）</strong></td>
<td>视觉检测目标的坐标系</td>
<td>( {}^C T_O )</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h2><ul>
<li><strong>世界坐标系是整个机械臂系统的全局参考坐标系</strong>，用于统一不同的局部坐标系。</li>
<li>在<strong>任务规划、视觉定位、多机器人协作、路径规划</strong>等场景中，世界坐标系起到了核心作用。</li>
<li><strong>所有坐标系之间的转换</strong>（如基地、末端、工具、相机）最终都可以统一到世界坐标系，以实现复杂的机器人任务。</li>
</ul>
<p>如果你有具体的应用场景（如视觉引导、机器人抓取等），可以提供更多细节，我可以帮助你进一步优化计算和实现方案！ 🚀</p>
<h2 id="详细解释关节空间和笛卡尔空间"><a href="#详细解释关节空间和笛卡尔空间" class="headerlink" title="详细解释关节空间和笛卡尔空间"></a>详细解释关节空间和笛卡尔空间</h2><h3 id="关节空间（Joint-Space）与笛卡尔空间（Cartesian-Space）详解"><a href="#关节空间（Joint-Space）与笛卡尔空间（Cartesian-Space）详解" class="headerlink" title="关节空间（Joint Space）与笛卡尔空间（Cartesian Space）详解"></a><strong>关节空间（Joint Space）与笛卡尔空间（Cartesian Space）详解</strong></h3><p>在机器人运动学中，机械臂的运动可以用两种不同的方式来描述：<strong>关节空间（Joint Space）</strong>和<strong>笛卡尔空间（Cartesian Space）</strong>。这两种表示方式各有优缺点，适用于不同的运动控制方法。</p>
<hr>
<h2 id="1-关节空间（Joint-Space）"><a href="#1-关节空间（Joint-Space）" class="headerlink" title="1. 关节空间（Joint Space）"></a><strong>1. 关节空间（Joint Space）</strong></h2><p>关节空间是用<strong>机械臂各个关节的角度或位移</strong>来表示机械臂的姿态和位置的方式。</p>
<h3 id="1-1-关节空间的定义"><a href="#1-1-关节空间的定义" class="headerlink" title="1.1 关节空间的定义"></a><strong>1.1 关节空间的定义</strong></h3><p>对于一个具有 ( n ) 个自由度（DOF, Degrees of Freedom）的机械臂，关节空间的状态可以表示为一个 ( n ) 维向量：<br>[<br>\mathbf{q} &#x3D; [q_1, q_2, …, q_n]^T<br>]<br>其中：</p>
<ul>
<li>( q_i ) 是第 ( i ) 个关节的角度（如果是旋转关节）或线性位移（如果是滑动关节）。</li>
<li>这个向量完全描述了机械臂当前的配置。</li>
</ul>
<h3 id="1-2-关节空间的特点"><a href="#1-2-关节空间的特点" class="headerlink" title="1.2 关节空间的特点"></a><strong>1.2 关节空间的特点</strong></h3><ul>
<li>关节空间中的点表示<strong>每个关节的角度或位移</strong>，而不是机械臂末端的物理位置。</li>
<li>机械臂的运动通常由<strong>关节角度插值</strong>控制，而不是直接在三维空间内进行规划。</li>
<li>机械臂的运动受<strong>关节约束</strong>，如角度范围、速度限制、加速度限制等。</li>
</ul>
<h3 id="1-3-关节空间的优缺点"><a href="#1-3-关节空间的优缺点" class="headerlink" title="1.3 关节空间的优缺点"></a><strong>1.3 关节空间的优缺点</strong></h3><p>✅ <strong>优点：</strong></p>
<ul>
<li>直接对应于<strong>机器人驱动系统</strong>，可以更直接地控制关节电机。</li>
<li>运动规划计算简单，关节插值可以平稳执行。</li>
<li>易于避免关节角度限制、奇异点等问题。</li>
</ul>
<p>❌ <strong>缺点：</strong></p>
<ul>
<li>不直观，无法直接确定末端在三维空间中的位置。</li>
<li>可能会导致非直线运动，路径不一定最优。</li>
</ul>
<h3 id="1-4-关节空间的应用"><a href="#1-4-关节空间的应用" class="headerlink" title="1.4 关节空间的应用"></a><strong>1.4 关节空间的应用</strong></h3><ul>
<li><strong>逆运动学（Inverse Kinematics, IK）计算</strong>：给定末端位置，求解对应的关节角度。</li>
<li><strong>关节空间路径规划</strong>：如关节插值运动（Joint Interpolation）。</li>
<li><strong>关节级控制</strong>：如PID控制、力控制等。</li>
</ul>
<hr>
<h2 id="2-笛卡尔空间（Cartesian-Space）"><a href="#2-笛卡尔空间（Cartesian-Space）" class="headerlink" title="2. 笛卡尔空间（Cartesian Space）"></a><strong>2. 笛卡尔空间（Cartesian Space）</strong></h2><p>笛卡尔空间是用<strong>末端执行器的位姿（位置 + 方向）</strong>来描述机械臂的状态的方式。</p>
<h3 id="2-1-笛卡尔空间的定义"><a href="#2-1-笛卡尔空间的定义" class="headerlink" title="2.1 笛卡尔空间的定义"></a><strong>2.1 笛卡尔空间的定义</strong></h3><p>机械臂的末端位姿通常由<strong>位置（Position）</strong>和<strong>方向（Orientation）</strong>两部分组成：<br>[<br>\mathbf{X} &#x3D; [x, y, z, \alpha, \beta, \gamma]^T<br>]<br>其中：</p>
<ul>
<li>( (x, y, z) ) 是末端执行器在世界坐标系或基地坐标系中的三维位置。</li>
<li>( (\alpha, \beta, \gamma) ) 是末端的<strong>欧拉角</strong>（或四元数表示的旋转方向）。</li>
<li>也可以用<strong>齐次变换矩阵（Homogeneous Transformation Matrix）</strong>表示：<br>[<br>T &#x3D;<br>\begin{bmatrix}<br>R &amp; t \<br>0 &amp; 1<br>\end{bmatrix}<br>]<br>其中：<ul>
<li>( R ) 是 ( 3 \times 3 ) 旋转矩阵</li>
<li>( t ) 是 ( 3 \times 1 ) 位置向量</li>
</ul>
</li>
</ul>
<h3 id="2-2-笛卡尔空间的特点"><a href="#2-2-笛卡尔空间的特点" class="headerlink" title="2.2 笛卡尔空间的特点"></a><strong>2.2 笛卡尔空间的特点</strong></h3><ul>
<li><strong>直观</strong>，描述的是机械臂<strong>末端</strong>在三维空间中的实际位置。</li>
<li>机械臂的运动规划可以直接在工作空间中进行。</li>
<li>需要通过<strong>逆运动学（IK）</strong>求解关节角度。</li>
</ul>
<h3 id="2-3-笛卡尔空间的优缺点"><a href="#2-3-笛卡尔空间的优缺点" class="headerlink" title="2.3 笛卡尔空间的优缺点"></a><strong>2.3 笛卡尔空间的优缺点</strong></h3><p>✅ <strong>优点：</strong></p>
<ul>
<li>直观，易于规划路径，例如直线运动、圆弧运动等。</li>
<li>适用于<strong>末端伺服控制</strong>（如视觉伺服）。</li>
<li>可以直接与<strong>外部坐标系（如世界坐标系）</strong>关联，适用于机器人协作。</li>
</ul>
<p>❌ <strong>缺点：</strong></p>
<ul>
<li>机械臂的运动需要求解<strong>逆运动学</strong>（IK），可能导致计算复杂或无解（如奇异点问题）。</li>
<li>可能无法保证运动的可行性（如超出关节运动范围）。</li>
<li>计算复杂度较高，控制上不如关节空间直接。</li>
</ul>
<h3 id="2-4-笛卡尔空间的应用"><a href="#2-4-笛卡尔空间的应用" class="headerlink" title="2.4 笛卡尔空间的应用"></a><strong>2.4 笛卡尔空间的应用</strong></h3><ul>
<li><strong>机器人视觉伺服</strong>（Vision-Based Servoing）</li>
<li><strong>笛卡尔路径规划</strong>（直线运动、插值）</li>
<li><strong>手眼标定</strong>（Hand-Eye Calibration）</li>
<li><strong>力控制任务</strong>（例如焊接、打磨、装配等）</li>
</ul>
<hr>
<h2 id="3-关节空间-vs-笛卡尔空间的对比"><a href="#3-关节空间-vs-笛卡尔空间的对比" class="headerlink" title="3. 关节空间 vs 笛卡尔空间的对比"></a><strong>3. 关节空间 vs 笛卡尔空间的对比</strong></h2><table>
<thead>
<tr>
<th><strong>比较项</strong></th>
<th><strong>关节空间（Joint Space）</strong></th>
<th><strong>笛卡尔空间（Cartesian Space）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>关节角度&#x2F;位移</td>
<td>末端执行器的位置和方向</td>
</tr>
<tr>
<td><strong>描述方式</strong></td>
<td>( q &#x3D; [q_1, q_2, …, q_n]^T )</td>
<td>( X &#x3D; [x, y, z, \alpha, \beta, \gamma]^T )</td>
</tr>
<tr>
<td><strong>计算难度</strong></td>
<td>低（直接控制关节）</td>
<td>高（需要逆运动学求解）</td>
</tr>
<tr>
<td><strong>直观性</strong></td>
<td>低（需要关节角度计算）</td>
<td>高（直接表示末端位置）</td>
</tr>
<tr>
<td><strong>路径控制</strong></td>
<td>关节插值（可能产生曲线）</td>
<td>笛卡尔插值（可以精确控制直线、圆弧）</td>
</tr>
<tr>
<td><strong>控制方式</strong></td>
<td>关节级控制</td>
<td>末端级控制</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>机器人关节运动控制</td>
<td>视觉伺服、直线插值运动</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-关节空间到笛卡尔空间的转换"><a href="#4-关节空间到笛卡尔空间的转换" class="headerlink" title="4. 关节空间到笛卡尔空间的转换"></a><strong>4. 关节空间到笛卡尔空间的转换</strong></h2><p>由于机器人通常接受<strong>关节空间指令</strong>，但任务多在<strong>笛卡尔空间</strong>定义，因此两者之间的转换十分重要。</p>
<h3 id="4-1-关节空间-→-笛卡尔空间（正运动学，FK）"><a href="#4-1-关节空间-→-笛卡尔空间（正运动学，FK）" class="headerlink" title="4.1 关节空间 → 笛卡尔空间（正运动学，FK）"></a><strong>4.1 关节空间 → 笛卡尔空间（正运动学，FK）</strong></h3><p>已知关节角度 ( \mathbf{q} )，求出末端位姿 ( \mathbf{X} )：<br>[<br>\mathbf{X} &#x3D; FK(\mathbf{q})<br>]<br>使用 <strong>Denavit-Hartenberg（DH）参数</strong> 或 <strong>数值计算</strong>方法求解。</p>
<h3 id="4-2-笛卡尔空间-→-关节空间（逆运动学，IK）"><a href="#4-2-笛卡尔空间-→-关节空间（逆运动学，IK）" class="headerlink" title="4.2 笛卡尔空间 → 关节空间（逆运动学，IK）"></a><strong>4.2 笛卡尔空间 → 关节空间（逆运动学，IK）</strong></h3><p>已知末端位姿 ( \mathbf{X} )，求出关节角度 ( \mathbf{q} )：<br>[<br>\mathbf{q} &#x3D; IK(\mathbf{X})<br>]<br>需要求解 <strong>逆运动学（IK）</strong>，可能存在多解、无解或奇异点。</p>
<hr>
<h2 id="5-典型应用案例"><a href="#5-典型应用案例" class="headerlink" title="5. 典型应用案例"></a><strong>5. 典型应用案例</strong></h2><h3 id="案例-1：机器人抓取"><a href="#案例-1：机器人抓取" class="headerlink" title="案例 1：机器人抓取"></a><strong>案例 1：机器人抓取</strong></h3><ul>
<li>目标点通常在<strong>笛卡尔空间</strong>（如相机检测的物体位置）。</li>
<li>需要转换到<strong>关节空间</strong>执行运动。</li>
</ul>
<h3 id="案例-2：机器人焊接"><a href="#案例-2：机器人焊接" class="headerlink" title="案例 2：机器人焊接"></a><strong>案例 2：机器人焊接</strong></h3><ul>
<li>需要沿着直线或曲线焊接（笛卡尔空间路径）。</li>
<li>需要求解逆运动学，将路径转换为关节角度。</li>
</ul>
<hr>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h2><ul>
<li><strong>关节空间（Joint Space）</strong>：直接控制关节角度，计算简单但路径不直观。</li>
<li><strong>笛卡尔空间（Cartesian Space）</strong>：描述末端位置，直观但需要逆运动学计算。</li>
<li><strong>路径规划通常在笛卡尔空间进行</strong>，但最终需要转换到关节空间执行。</li>
<li><strong>两者相互转换是机器人控制的核心技术</strong>。</li>
</ul>
<p>如果你有具体的应用场景（如机器人抓取、焊接等），可以提供更详细的规划和代码示例！ 🚀</p>
<h2 id="详细解释-机械臂末端坐标系与基地坐标系"><a href="#详细解释-机械臂末端坐标系与基地坐标系" class="headerlink" title="详细解释 机械臂末端坐标系与基地坐标系"></a>详细解释 机械臂末端坐标系与基地坐标系</h2><h3 id="机械臂末端坐标系与基地坐标系的详细解释"><a href="#机械臂末端坐标系与基地坐标系的详细解释" class="headerlink" title="机械臂末端坐标系与基地坐标系的详细解释"></a><strong>机械臂末端坐标系与基地坐标系的详细解释</strong></h3><p>在机器人学中，坐标系的定义对于精确控制机械臂的运动至关重要。通常，机械臂涉及多个坐标系，其中<strong>基地坐标系（Base Frame）</strong>和<strong>末端坐标系（End-Effector Frame）</strong>是最重要的两个坐标系，它们用于描述机械臂在空间中的姿态和位置。</p>
<hr>
<h2 id="1-机械臂坐标系的定义"><a href="#1-机械臂坐标系的定义" class="headerlink" title="1. 机械臂坐标系的定义"></a><strong>1. 机械臂坐标系的定义</strong></h2><p>在工业机器人或机械臂系统中，常见的坐标系有：</p>
<ul>
<li><strong>基地坐标系（Base Frame）</strong>：固定在机械臂的底座上，用于定义整个机械臂的参考坐标系。</li>
<li><strong>关节坐标系（Joint Frames）</strong>：每个关节都有一个局部坐标系，跟随关节运动。</li>
<li><strong>末端执行器坐标系（End-Effector Frame）</strong>：固定在机械臂末端（如机械爪、焊枪、相机等）上，描述末端执行器的位置和方向。</li>
<li><strong>世界坐标系（World Frame）</strong>（可选）：如果多个机器人或传送带协作，可能还会定义一个全局的世界坐标系。</li>
</ul>
<p>本次主要讨论 <strong>基地坐标系与末端坐标系</strong>。</p>
<hr>
<h2 id="2-机械臂基地坐标系（Base-Frame）"><a href="#2-机械臂基地坐标系（Base-Frame）" class="headerlink" title="2. 机械臂基地坐标系（Base Frame）"></a><strong>2. 机械臂基地坐标系（Base Frame）</strong></h2><p><strong>基地坐标系（Base Frame）</strong>是整个机械臂的全局参考坐标系，它通常<strong>固定在机械臂的底座上</strong>，不会随关节或末端运动而改变。</p>
<h3 id="基地坐标系的特点："><a href="#基地坐标系的特点：" class="headerlink" title="基地坐标系的特点："></a><strong>基地坐标系的特点：</strong></h3><ul>
<li>是整个机械臂的参考坐标系，所有关节、末端坐标系都基于它进行计算。</li>
<li><strong>固定不动</strong>，不会随机械臂的运动而改变。</li>
<li>通常定义在机械臂的底部，以便有一个稳定的参考点。</li>
<li>用于计算机械臂的正运动学（Forward Kinematics, FK）和逆运动学（Inverse Kinematics, IK）。</li>
</ul>
<h3 id="基地坐标系的定义方式"><a href="#基地坐标系的定义方式" class="headerlink" title="基地坐标系的定义方式"></a><strong>基地坐标系的定义方式</strong></h3><p>通常，基地坐标系的原点设定在机械臂底座的中心，Z 轴朝上或垂直于地面，X 轴和 Y 轴平行于地面，如下所示：</p>
<h4 id="常见的基地坐标系定义（右手坐标系）："><a href="#常见的基地坐标系定义（右手坐标系）：" class="headerlink" title="常见的基地坐标系定义（右手坐标系）："></a><strong>常见的基地坐标系定义（右手坐标系）：</strong></h4><p>[<br>O_b &#x3D; (x_b, y_b, z_b)<br>]</p>
<ul>
<li><strong>X 轴</strong>：向前或沿传送带方向。</li>
<li><strong>Y 轴</strong>：向左或侧向。</li>
<li><strong>Z 轴</strong>：垂直向上，与重力方向相反。</li>
</ul>
<hr>
<h2 id="3-机械臂末端执行器坐标系（End-Effector-Frame）"><a href="#3-机械臂末端执行器坐标系（End-Effector-Frame）" class="headerlink" title="3. 机械臂末端执行器坐标系（End-Effector Frame）"></a><strong>3. 机械臂末端执行器坐标系（End-Effector Frame）</strong></h2><p><strong>末端坐标系（End-Effector Frame）</strong>定义在<strong>机械臂末端（End-Effector）上</strong>，并随机械臂的运动而改变位置和方向。</p>
<h3 id="末端坐标系的特点："><a href="#末端坐标系的特点：" class="headerlink" title="末端坐标系的特点："></a><strong>末端坐标系的特点：</strong></h3><ul>
<li><strong>随机械臂末端运动而变化</strong>，在不同关节角度时，末端坐标系的相对位置和方向也不同。</li>
<li><strong>用于描述机械臂末端工具的位置和姿态</strong>，通常用于编写路径规划、抓取任务等。</li>
<li><strong>需要标定</strong>，特别是安装了焊枪、吸盘、摄像头等工具时，需要知道工具相对于末端坐标系的位置偏移（TCP：Tool Center Point，工具中心点）。</li>
</ul>
<h3 id="末端坐标系的定义方式"><a href="#末端坐标系的定义方式" class="headerlink" title="末端坐标系的定义方式"></a><strong>末端坐标系的定义方式</strong></h3><p>一般情况下，末端坐标系的原点可以放置在：</p>
<ul>
<li>机械爪的中心点（抓取任务）</li>
<li>焊枪的喷嘴位置（焊接任务）</li>
<li>吸盘的中心（搬运任务）</li>
<li>相机的光轴中心（视觉任务）</li>
</ul>
<h4 id="常见的末端坐标系定义："><a href="#常见的末端坐标系定义：" class="headerlink" title="常见的末端坐标系定义："></a><strong>常见的末端坐标系定义：</strong></h4><p>[<br>O_e &#x3D; (x_e, y_e, z_e)<br>]</p>
<ul>
<li><strong>X 轴</strong>：通常指向工具的前方（沿机械爪闭合方向）。</li>
<li><strong>Y 轴</strong>：垂直于X轴，指向左侧或右侧。</li>
<li><strong>Z 轴</strong>：沿着工具的操作方向（通常是指向工具伸出的方向）。</li>
</ul>
<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a><strong>举例：</strong></h3><p>如果是 <strong>Eye-in-Hand（相机安装在机械臂末端）</strong>：</p>
<ul>
<li>末端坐标系的原点可以放在相机光学中心，Z 轴指向相机拍摄方向。</li>
</ul>
<p>如果是 <strong>机械爪（Gripper）</strong>：</p>
<ul>
<li>末端坐标系的原点通常设在两指机械爪的中心，Z 轴指向机械爪开合方向。</li>
</ul>
<hr>
<h2 id="4-末端坐标系与基地坐标系的关系"><a href="#4-末端坐标系与基地坐标系的关系" class="headerlink" title="4. 末端坐标系与基地坐标系的关系"></a><strong>4. 末端坐标系与基地坐标系的关系</strong></h2><p>要描述末端执行器在空间中的位置，我们需要一个从基地坐标系到末端坐标系的变换矩阵，通常表示为：</p>
<p>[<br>{}^B T_E &#x3D;<br>\begin{bmatrix}<br>R &amp; t \<br>0 &amp; 1<br>\end{bmatrix}<br>]</p>
<p>其中：</p>
<ul>
<li><strong>( {}^B T_E )</strong>：基地坐标系到末端坐标系的齐次变换矩阵</li>
<li><strong>( R )</strong>：( 3 \times 3 ) 的旋转矩阵，描述末端相对于基地的旋转</li>
<li><strong>( t )</strong>：( 3 \times 1 ) 的平移向量，描述末端在基地坐标系下的位置</li>
</ul>
<p>[<br>t &#x3D;<br>\begin{bmatrix}<br>x \<br>y \<br>z<br>\end{bmatrix}<br>]</p>
<p>其中：</p>
<ul>
<li>( x, y, z ) 是末端坐标系相对于基地坐标系的平移量（位置）。</li>
<li>( R ) 是描述末端相对于基地的旋转（通常以欧拉角、四元数或旋转矩阵表示）。</li>
</ul>
<hr>
<h2 id="5-如何计算末端坐标系在基地坐标系下的位置？"><a href="#5-如何计算末端坐标系在基地坐标系下的位置？" class="headerlink" title="5. 如何计算末端坐标系在基地坐标系下的位置？"></a><strong>5. 如何计算末端坐标系在基地坐标系下的位置？</strong></h2><p>通常，我们通过<strong>正运动学（Forward Kinematics, FK）</strong>计算末端坐标系在基地坐标系下的位姿：</p>
<h3 id="计算步骤："><a href="#计算步骤：" class="headerlink" title="计算步骤："></a><strong>计算步骤：</strong></h3><ol>
<li>获取<strong>机械臂的DH参数</strong>（Denavit-Hartenberg参数），用于描述各个关节的旋转和平移。</li>
<li>计算每个关节的<strong>变换矩阵 ( T_i )</strong>，从基座到第 ( i ) 号关节。</li>
<li>通过连乘所有变换矩阵，得到末端相对于基座的最终变换：</li>
</ol>
<p>[<br>{}^B T_E &#x3D; T_1 T_2 T_3 … T_n<br>]</p>
<p>其中：</p>
<ul>
<li>( T_1, T_2, …, T_n ) 是各个关节的变换矩阵。</li>
<li>( {}^B T_E ) 是末端执行器在基地坐标系下的位置和姿态。</li>
</ul>
<hr>
<h2 id="6-末端坐标系与基地坐标系的应用"><a href="#6-末端坐标系与基地坐标系的应用" class="headerlink" title="6. 末端坐标系与基地坐标系的应用"></a><strong>6. 末端坐标系与基地坐标系的应用</strong></h2><ul>
<li><strong>机器人路径规划</strong>：在基地坐标系下规划轨迹，再转换到末端坐标系执行。</li>
<li><strong>手眼标定（Hand-Eye Calibration）</strong>：确定相机坐标系与末端坐标系的关系。</li>
<li><strong>机器人视觉伺服</strong>：相机获取目标物体坐标，并转换到基地坐标系指导机械臂运动。</li>
<li><strong>离线编程</strong>：用CAD软件编写路径，在基地坐标系下转换成末端坐标系的指令。</li>
</ul>
<hr>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h2><ul>
<li><strong>基地坐标系（Base Frame）</strong>：固定在机械臂底座上，是所有关节和末端的参考系。</li>
<li><strong>末端坐标系（End-Effector Frame）</strong>：固定在机械臂的末端执行器上，随机械臂运动而变化。</li>
<li><strong>两者之间的关系</strong>可以通过<strong>正运动学</strong>计算，从而确定末端在基地坐标系下的位姿。</li>
</ul>
<p>如果你有具体的应用场景（如抓取、视觉对位等），可以进一步优化末端坐标系的设置！🚀</p>
<h2 id="机械臂行业"><a href="#机械臂行业" class="headerlink" title="机械臂行业"></a>机械臂行业</h2><ul>
<li><p>机械手臂是一种固定或移动式的机器，其构造通常由一系列互相链接或相对滑动的零件组成，工作方式主要通过沿着X，Y，Z轴上做线性运动以到达目标位置，从而实现物体的抓取或者移动，能够实现自动控制，可重复程序设计，多自由度(轴)</p>
</li>
<li><p>国际企业</p>
<ul>
<li>ABB</li>
<li>发那科</li>
<li>安川电机</li>
<li>ADEPT Technology</li>
<li>UR</li>
</ul>
</li>
<li><p>本土企业</p>
<ul>
<li>新松机器人</li>
<li>埃斯顿</li>
<li>大族激光</li>
<li>越疆科技</li>
<li>埃夫特</li>
<li>汇川技术</li>
<li>新时达</li>
</ul>
</li>
<li><p>机械臂的应用领域</p>
<ul>
<li>工业制造</li>
<li>医疗保健</li>
<li>军事</li>
<li>物流仓储</li>
<li>农业</li>
<li>家庭服务</li>
</ul>
</li>
</ul>
<h2 id="机器人领域-推荐著作"><a href="#机器人领域-推荐著作" class="headerlink" title="机器人领域 推荐著作"></a>机器人领域 推荐著作</h2><ul>
<li><p>机器人学导论</p>
<ul>
<li>综合性入门教材，内容涉及正&#x2F;逆运动学、静力变换、操作臂动力学、轨迹规划、机械设计、控制等。</li>
</ul>
</li>
<li><p>机器人学，机器视觉与控制-MATLAB算法基础</p>
<ul>
<li>Peter Corke编写的机器人入门教材，书中的实例很多，都使用机器人工具箱编写，配合Matlab可以边看边试！</li>
</ul>
</li>
<li><p>Principles of Robot Motion：Theory, Algorithms, and Implementations</p>
<ul>
<li>主要讲解基于传感器的规划、概率规划、定位与映射、动态与非完整系统的运动规划。</li>
</ul>
</li>
<li><p>Planning Algorithms</p>
<ul>
<li>这本书提出了多种不同规划算法的统一处理。运动规划、离散规划、不确定性规划、基于传感器的规划、可见性、决策理论规划、博弈论、信息空间、强化学习、非线性系统、轨迹规划、非完整规划和动态规划</li>
</ul>
</li>
<li><p>Rigid Body Dynamics Algorithms</p>
<ul>
<li>最佳刚体动力学算法的综合集合，Github上也拥有很多不错的资源。</li>
</ul>
</li>
<li><p>机器人操作的数学导论</p>
<ul>
<li>从数学的角度系统地介绍了机器人操作的运动学、动力学、控制及运动规划内容，主要包含旋量理论、指数积建模，机器人动力学等内容</li>
</ul>
</li>
<li><p>机器人学-建模、规划与控制</p>
<ul>
<li>深入讲解机器人的建模、轨迹运动、运动控制等内容。基础入门强烈推荐！</li>
</ul>
</li>
<li><p>机器人技术手册</p>
<ul>
<li>日本机器人学会出品，一本超全的百科全书类型。特别适合作为工具查漏翻查</li>
</ul>
</li>
<li><p>Springer Handbook of Roboticsd</p>
<ul>
<li>机器人研究人员、该领域新人和相关学科学者的权威参考</li>
</ul>
</li>
</ul>
<h2 id="机械臂中的正解FK和逆解IK是什么"><a href="#机械臂中的正解FK和逆解IK是什么" class="headerlink" title="机械臂中的正解FK和逆解IK是什么"></a>机械臂中的正解FK和逆解IK是什么</h2><p>在机械臂控制中，正解（Forward Kinematics，FK）和逆解（Inverse Kinematics，IK）是两个重要的概念。</p>
<ol>
<li><p>正解（Forward Kinematics，FK）：<br>正解是指根据机械臂的关节角度或长度等参数，推导出末端执行器（例如机械臂末端的位置和姿态）的运动学表达式或方程式的过程。FK描述了输入到机械臂关节的位置、速度或加速度等参数，从而计算出末端执行器的位置和姿态。FK用于确定机械臂末端在给定关节参数下的运动轨迹，通常是一个从关节空间到工作空间的映射。</p>
</li>
<li><p>逆解（Inverse Kinematics，IK）：<br>逆解是指根据已知末端执行器的位置和姿态，确定使机械臂末端达到这个位置和姿态所需的关节角度或长度等参数的过程。IK可以被用来解决给定目标位置和姿态时，计算出机械臂关节参数的问题。在实际应用中，逆解通常是更为复杂和困难的问题，因为一个末端位置和姿态通常对应着多个可能的解。</p>
</li>
</ol>
<p>FK和IK在机器人学和机械臂控制中扮演着重要的角色，FK用于描述机械臂的运动学特性，而IK则允许机械臂在空间中实现特定的末端目标。这些概念对于控制和规划机械臂的运动非常重要，特别是在自动化生产线、工业机器人和虚拟仿真等领域中。</p>
<h2 id="机器人-目标坐标系-末端坐标系-基底坐标系"><a href="#机器人-目标坐标系-末端坐标系-基底坐标系" class="headerlink" title="机器人 目标坐标系 末端坐标系 基底坐标系"></a>机器人 目标坐标系 末端坐标系 基底坐标系</h2><p>在机器人学中，通常使用三种坐标系来描述机器人的运动和位置：目标坐标系、末端坐标系和基底坐标系。</p>
<ol>
<li><p><strong>目标坐标系（Target Coordinate System）：</strong> 这是机器人执行任务时所需达到的目标位置的坐标系。在目标坐标系中定义了机器人需要完成的具体任务的坐标和方向信息。机器人的动作控制通常是根据目标坐标系来规划和执行的。</p>
</li>
<li><p><strong>末端坐标系（End-Effector Coordinate System）：</strong> 这是机器人末端执行器（通常是机械手、夹爪等）的坐标系。末端坐标系描述了末端执行器的位置和方向，是机器人进行具体操作时的参考坐标系。机器人执行任务时，末端坐标系的变化反映了机器人末端执行器的运动和姿态。</p>
</li>
<li><p><strong>基底坐标系（Base Coordinate System）：</strong> 这是机器人整体结构的参考坐标系。基底坐标系通常与机器人的固定部分（例如机器人底座）相关联，用于描述机器人整体的位置和方向。基底坐标系的选择对机器人运动的规划和控制起着重要的作用。</p>
</li>
</ol>
<p>这三个坐标系之间的关系和转换是机器人控制和规划中的关键问题。通过准确描述这些坐标系之间的变换关系，可以更有效地控制机器人的运动，使其在工作空间内完成任务。</p>
<h2 id="机器人-世界坐标系-基底坐标系"><a href="#机器人-世界坐标系-基底坐标系" class="headerlink" title="机器人 世界坐标系 基底坐标系"></a>机器人 世界坐标系 基底坐标系</h2><p>在机器人学中，世界坐标系和基底坐标系是两个相关但不同的概念。</p>
<ol>
<li><p><strong>世界坐标系（World Coordinate System）：</strong> 世界坐标系是一个全局坐标系，通常被用作机器人工作空间中的参考坐标系。它是一个固定的坐标系，用于描述整个机器人系统在其运动范围内的位置和方向。世界坐标系的选择通常取决于特定应用的需要，以提供方便的参考点。</p>
</li>
<li><p><strong>基底坐标系（Base Coordinate System）：</strong> 基底坐标系是机器人本身固有的坐标系，通常与机器人底座或底部连接的结构相关联。这是机器人运动的起点和参考点。机器人的关节和执行器运动通常是相对于基底坐标系进行描述的。基底坐标系的选择对机器人的运动规划和控制非常重要。</p>
</li>
</ol>
<p>在一般情况下，机器人控制和规划涉及到将基底坐标系中的运动转换到世界坐标系中，或者反之。这涉及到位姿变换，包括平移和旋转。</p>
<p>例如，如果你想让机器人执行一个在世界坐标系中指定的任务，你可能需要将任务的坐标转换为机器人基底坐标系中的坐标，以便机器人能够正确执行任务。反之，如果你想获取机器人当前的位置和方向，你可能需要将机器人基底坐标系中的信息转换为世界坐标系中的信息，以便提供一个全局的参考框架。</p>
<p>这种坐标系的变换在机器人学和自动化控制中是非常常见的，因为它允许机器人在不同坐标系中进行运动和交互。</p>
<h2 id="机器人-轨迹规划是什么"><a href="#机器人-轨迹规划是什么" class="headerlink" title="机器人 轨迹规划是什么"></a>机器人 轨迹规划是什么</h2><p>在机器人学和自动化领域，轨迹规划是指通过一系列的动作，规划出机器人从一个起始点到达目标点或完成任务的路径。这个路径通常被称为轨迹，而规划这样的轨迹则需要考虑一系列的因素，如避障、动力学、工作空间限制等。</p>
<p>轨迹规划的目标是使机器人能够在给定的环境中，以安全、有效、并且可能最优的方式达到目标。以下是轨迹规划的一些关键概念：</p>
<ol>
<li><p><strong>起始点和目标点：</strong> 轨迹规划通常始于机器人当前的位置（起始点）并以某个目标位置为终点。</p>
</li>
<li><p><strong>运动约束：</strong> 考虑到机器人的动力学、速度、加速度等方面的限制，确保规划出的轨迹是机器人能够执行的。</p>
</li>
<li><p><strong>避障：</strong> 考虑到环境中的障碍物，确保规划的轨迹不会碰撞到障碍物。这可能涉及到路径规划算法，例如 A*、Dijkstra、RRT（Rapidly Exploring Random Trees）等。</p>
</li>
<li><p><strong>工作空间：</strong> 考虑到机器人工作的空间限制，确保规划的轨迹在工作空间内。</p>
</li>
<li><p><strong>优化：</strong> 有时候，除了满足上述条件，还希望规划出的轨迹是最优的，例如最短路径或最短时间。</p>
</li>
<li><p><strong>实时性：</strong> 在某些情况下，轨迹规划需要在实时性要求下执行，以适应不断变化的环境。</p>
</li>
</ol>
<p>轨迹规划可以应用于各种类型的机器人，包括工业机械臂、移动机器人、飞行器等。不同类型的机器人可能需要不同的轨迹规划方法，因为它们的动力学和环境条件可能有很大的差异。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Robotics/2024-05-22-robotics_2_%E4%BB%BF%E7%9C%9F%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Robotics/2024-05-22-robotics_2_%E4%BB%BF%E7%9C%9F%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">robotics_2_仿真工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Robotics/" itemprop="url" rel="index"><span itemprop="name">Robotics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>机器人学的仿真工具</li>
</ul>
<h2 id="机器人仿真-robodk是什么"><a href="#机器人仿真-robodk是什么" class="headerlink" title="机器人仿真 robodk是什么"></a>机器人仿真 robodk是什么</h2><p>RoboDK（Robot Development Kit）是一种用于机器人仿真和离线编程的软件平台。它允许用户在虚拟环境中模拟和测试工业机器人的运动，以及为这些机器人生成程序代码。RoboDK支持多种不同类型的工业机器人，包括ABB、Fanuc、KUKA、Universal Robots等。</p>
<p>主要功能包括：</p>
<ol>
<li><p><strong>机器人仿真：</strong> 用户可以在RoboDK中创建一个虚拟环境，包括工作台、机器人和其他相关设备。通过仿真，用户可以预先测试和优化机器人的运动，避免在实际生产中出现问题。</p>
</li>
<li><p><strong>离线编程：</strong> RoboDK允许用户在虚拟环境中为机器人生成程序代码，然后将这些代码直接应用到实际的机器人系统中。这种离线编程的方法可以减少生产线的停机时间，提高生产效率。</p>
</li>
<li><p><strong>支持多种机器人品牌：</strong> RoboDK具有广泛的机器人品牌支持，使其适用于多种不同类型的工业机器人。用户可以选择并模拟其特定品牌和型号的机器人。</p>
</li>
<li><p><strong>路径规划和碰撞检测：</strong> RoboDK能够进行路径规划和碰撞检测，确保生成的机器人程序在实际操作中是安全和有效的。</p>
</li>
</ol>
<p>总的来说，RoboDK是一个用于机器人系统仿真和离线编程的强大工具，可帮助用户优化他们的制造流程，提高生产效率。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-Postgresql_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-Postgresql_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Postgresql_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>PostgresQL 关系型数据库</li>
</ul>
<h2 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h2><ul>
<li>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</li>
<li>每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。</li>
<li>我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。</li>
<li>所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数+ 据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</li>
<li>ORDBMS（对象关系数据库系统）是面向对象技术与传统的关系数据库相结合的产物，查询处理是 ORDBMS 的重要组成部分，它的性能+ 优劣将直接影响到DBMS 的性能。</li>
<li>ORDBMS在原来关系数据库的基础上，增加了一些新的特性。</li>
<li>RDBMS 是关系数据库管理系统，是建立实体之间的联系，最后得到的是关系表。</li>
<li>OODBMS 面向对象数据库管理系统，将所有实体都看成对象，并将这些对象类进行封装，对象之间的通信通过消息 OODBMS 对象关系数据库在实质上还是关系数据库</li>
</ul>
<h2 id="ORDBMS-术语"><a href="#ORDBMS-术语" class="headerlink" title="ORDBMS 术语"></a>ORDBMS 术语</h2><ul>
<li>在我们开始学习 PostgreSQL 数据库前，让我们先了解下 ORDBMS 的一些术语：<ul>
<li>数据库: 数据库是一些关联表的集合。</li>
<li>数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li>
<li>列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</li>
<li>行：一行（&#x3D;元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li>
<li>冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li>
<li>主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li>
<li>外键：外键用于关联两个表。</li>
<li>复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li>
<li>索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li>
<li>参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数+ 据的一致性。</li>
</ul>
</li>
</ul>
<h2 id="PostgreSQL-特征"><a href="#PostgreSQL-特征" class="headerlink" title="PostgreSQL 特征"></a>PostgreSQL 特征</h2><ul>
<li>函数：通过函数，可以在数据库服务器端执行指令程序。</li>
<li>索引：用户可以自定义索引方法，或使用内置的 B 树，哈希表与 GiST 索引。</li>
<li>触发器：触发器是由SQL语句查询所触发的事件。如：一个INSERT语句可能触发一个检查数据完整性的触发器。触发器通常由INSERT或UPDATE语句触发。 多版本并发控制：PostgreSQL使用多版本并发控制（MVCC，Multiversion concurrency control）系统进行并发控制，该系统向每个用户提供了一个数据库的”快照”，用户在事务内所作的每个修改，对于其他的用户都不可见，直到该事务成功提交。</li>
<li>规则：规则（RULE）允许一个查询能被重写，通常用来实现对视图（VIEW）的操作，如插入（INSERT）、更新（UPDATE）、删除（DELETE）。</li>
<li>数据类型：包括文本、任意精度的数值数组、JSON 数据、枚举类型、XML 数据等。</li>
<li>全文检索：通过 Tsearch2 或 OpenFTS，8.3版本中内嵌 Tsearch2。</li>
<li>NoSQL：JSON，JSONB，XML，HStore 原生支持，至 NoSQL 数据库的外部数据包装器。</li>
<li>数据仓库：能平滑迁移至同属 PostgreSQL 生态的 GreenPlum，DeepGreen，HAWK 等，使用 FDW 进行 ETL。</li>
</ul>
<h2 id="Linux-上安装-PostgreSQL-Ubuntu-安装-PostgreSQL"><a href="#Linux-上安装-PostgreSQL-Ubuntu-安装-PostgreSQL" class="headerlink" title="Linux 上安装 PostgreSQL (Ubuntu 安装 PostgreSQL)"></a>Linux 上安装 PostgreSQL (Ubuntu 安装 PostgreSQL)</h2><ul>
<li><p>Ubuntu 可以使用 apt-get 安装 PostgreSQL：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install postgresql postgresql-client</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完毕后，系统会创建一个数据库超级用户 postgres，密码为空。</p>
<ul>
<li><h1 id="sudo-i-u-postgres"><a href="#sudo-i-u-postgres" class="headerlink" title="sudo -i -u postgres"></a>sudo -i -u postgres</h1></li>
</ul>
</li>
<li><p>这时使用以下命令进入 postgres，输出以下信息，说明安装成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~$ psql</span><br><span class="line">psql (9.5.17)</span><br><span class="line">Type <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">postgres=# </span><br></pre></td></tr></table></figure></li>
<li><p>输入以下命令退出 PostgreSQL 提示符：</p>
<ul>
<li>\q</li>
</ul>
</li>
<li><p>PostgreSQL 安装完成后默认是已经启动的，但是也可以通过下面的方式来手动启动服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> /etc/init.d/postgresql start   <span class="comment"># 开启</span></span><br><span class="line"><span class="built_in">sudo</span> /etc/init.d/postgresql stop    <span class="comment"># 关闭</span></span><br><span class="line"><span class="built_in">sudo</span> /etc/init.d/postgresql restart <span class="comment"># 重启</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sql_2_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sql_2_%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">sql_2_基本语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>sql编程语言的基本语法</li>
</ul>
<h2 id="1-3-SQL-SELECT语句"><a href="#1-3-SQL-SELECT语句" class="headerlink" title="1.3 SQL SELECT语句"></a>1.3 SQL SELECT语句</h2><ul>
<li><p>SELECT 语句用于从数据库中选取数据。结果被存储在一个结果表中，称为结果集。</p>
</li>
<li><p>SQL SELECT 语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>SELECT * FROM table_name;</code></li>
</ul>
</li>
<li><p>参数说明：</p>
<ul>
<li>column1, column2, …：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。</li>
<li>table_name：要查询的表名称。</li>
</ul>
</li>
<li><p>大多数数据库软件系统都允许使用编程函数在结果集中进行导航，比如：Move-To-First-Record、Get-Record-Content、Move-To-Next-Record 等等。</p>
</li>
<li><p>类似这些编程函数不在本教程讲解之列。如需学习通过函数调用访问数据的知识，请访问我们的 ADO 教程 或者 PHP 教程。</p>
</li>
</ul>
<h2 id="1-3-SQL-SELECT-DISTINCT-语句"><a href="#1-3-SQL-SELECT-DISTINCT-语句" class="headerlink" title="1.3 SQL SELECT DISTINCT 语句"></a>1.3 SQL SELECT DISTINCT 语句</h2><ul>
<li><p>SELECT DISTINCT 语句用于返回唯一不同的值。</p>
</li>
<li><p>在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。DISTINCT 关键词用于返回唯一不同的值。</p>
</li>
<li><p>SQL SELECT DISTINCT 语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure></li>
<li><p>参数说明：</p>
<ul>
<li>column1, column2, …：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。</li>
<li>table_name：要查询的表名称。</li>
</ul>
</li>
<li><p>SELECT DISTINCT 实例</p>
<ul>
<li>下面的 SQL 语句仅从 “Websites” 表的 “country” 列中选取唯一不同的值，也就是去掉 “country” 列重复值：</li>
<li><code>SELECT DISTINCT country FROM Websites;</code></li>
</ul>
</li>
</ul>
<h2 id="1-3-SQL-WHERE-子句"><a href="#1-3-SQL-WHERE-子句" class="headerlink" title="1.3 SQL WHERE 子句"></a>1.3 SQL WHERE 子句</h2><ul>
<li><p>WHERE 子句用于过滤记录。</p>
</li>
<li><p>WHERE 子句用于提取那些满足指定条件的记录。</p>
</li>
<li><p>SQL WHERE 语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>参数说明：</p>
<ul>
<li>column1, column2, …：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。</li>
<li>table_name：要查询的表名称。</li>
</ul>
</li>
<li><p>WHERE 子句实例</p>
<ul>
<li>下面的 SQL 语句从 “Websites” 表中选取国家为 “CN” 的所有网站：</li>
<li><code>SELECT * FROM Websites WHERE country=&#39;CN&#39;;</code></li>
</ul>
</li>
</ul>
<h2 id="1-4-SQL-AND-OR-运算符"><a href="#1-4-SQL-AND-OR-运算符" class="headerlink" title="1.4 SQL AND &amp; OR 运算符"></a>1.4 SQL AND &amp; OR 运算符</h2><ul>
<li><p>AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。</p>
</li>
<li><p>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</p>
</li>
<li><p>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p>
</li>
<li><p>AND 运算符实例</p>
<ul>
<li>下面的 SQL 语句从 “Websites” 表中选取国家为 “CN” 且alexa排名大于 “50” 的所有网站：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> country<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> alexa <span class="operator">&gt;</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>OR 运算符实例</p>
<ul>
<li>下面的 SQL 语句从 “Websites” 表中选取国家为 “USA” 或者 “CN” 的所有客户：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> country<span class="operator">=</span><span class="string">&#x27;USA&#x27;</span></span><br><span class="line"><span class="keyword">OR</span> country<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>结合 AND &amp; OR</p>
<ul>
<li>您也可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式）。</li>
<li>下面的 SQL 语句从 “Websites” 表中选取 alexa 排名大于 “15” 且国家为 “CN” 或 “USA” 的所有网站：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> alexa <span class="operator">&gt;</span> <span class="number">15</span></span><br><span class="line"><span class="keyword">AND</span> (country<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span> <span class="keyword">OR</span> country<span class="operator">=</span><span class="string">&#x27;USA&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1-5-SQL-ORDER-BY-关键字"><a href="#1-5-SQL-ORDER-BY-关键字" class="headerlink" title="1.5 SQL ORDER BY 关键字"></a>1.5 SQL ORDER BY 关键字</h2><ul>
<li><p>ORDER BY 关键字用于对结果集进行排序。</p>
</li>
<li><p>ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。</p>
</li>
<li><p>ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。</p>
</li>
<li><p>SQL ORDER BY 语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2, ... <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>参数解析：</p>
<ul>
<li>column1, column2, …：要排序的字段名称，可以为多个字段。</li>
<li>ASC：表示按升序排序。</li>
<li>DESC：表示按降序排序。</li>
</ul>
</li>
<li><p>ORDER BY 实例</p>
<ul>
<li>下面的 SQL 语句从 “Websites” 表中选取所有网站，并按照 “alexa” 列排序：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> alexa;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>ORDER BY DESC 实例</p>
<ul>
<li>下面的 SQL 语句从 “Websites” 表中选取所有网站，并按照 “alexa” 列降序排序：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> alexa <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>ORDER BY 多列</p>
<ul>
<li>下面的 SQL 语句从 “Websites” 表中选取所有网站，并按照 “country” 和 “alexa” 列排序：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> country,alexa;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1-5-SQL-INSERT-INTO-语句"><a href="#1-5-SQL-INSERT-INTO-语句" class="headerlink" title="1.5 SQL INSERT INTO 语句"></a>1.5 SQL INSERT INTO 语句</h2><ul>
<li><p>INSERT INTO 语句用于向表中插入新记录。</p>
</li>
<li><p>INSERT INTO 语句可以有两种编写形式。</p>
<ul>
<li>第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> table_name</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure></li>
<li>第二种形式需要指定列名及被插入的值：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> table_name (column1,column2,column3,...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>参数说明：</p>
<ul>
<li>table_name：需要插入新记录的表名。</li>
<li>column1, column2, …：需要插入的字段名。</li>
<li>value1, value2, …：需要插入的字段值。</li>
</ul>
</li>
<li><p>INSERT INTO 实例</p>
<ul>
<li>假设我们要向 “Websites” 表中插入一个新行。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> Websites (name, url, alexa, country)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;百度&#x27;</span>,<span class="string">&#x27;https://www.baidu.com/&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;CN&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>在指定的列插入数据</li>
<li>下面的 SQL 语句将插入一个新行，但是只在 “name”、”url” 和 “country” 列插入数据（id 字段会自动更新）：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> Websites (name, url, country)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;stackoverflow&#x27;</span>, <span class="string">&#x27;http://stackoverflow.com/&#x27;</span>, <span class="string">&#x27;IND&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1-6-SQL-UPDATE-语句"><a href="#1-6-SQL-UPDATE-语句" class="headerlink" title="1.6 SQL UPDATE 语句"></a>1.6 SQL UPDATE 语句</h2><ul>
<li><p>UPDATE 语句用于更新表中的记录。</p>
</li>
<li><p>UPDATE 语句用于更新表中已存在的记录。</p>
</li>
<li><p>SQL UPDATE 语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line">SET column1 = value1, column2 = value2, ...</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure></li>
<li><p>参数说明：</p>
<ul>
<li>table_name：要修改的表名称。</li>
<li>column1, column2, …：要修改的字段名称，可以为多个字段。</li>
<li>value1, value2, …：要修改的值，可以为多个值。</li>
<li>condition：修改条件，用于指定哪些数据要修改</li>
</ul>
</li>
<li><p>请注意 SQL UPDATE 语句中的 WHERE 子句！</p>
</li>
<li><p>WHERE 子句规定哪条记录或者哪些记录需要更新。如果您省略了 WHERE 子句，所有的记录都将被更新！</p>
</li>
<li><p>SQL UPDATE 实例</p>
<ul>
<li>假设我们要把 “菜鸟教程” 的 alexa 排名更新为 5000，country 改为 USA。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Websites </span><br><span class="line"><span class="keyword">SET</span> alexa<span class="operator">=</span><span class="string">&#x27;5000&#x27;</span>, country<span class="operator">=</span><span class="string">&#x27;USA&#x27;</span> </span><br><span class="line"><span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;菜鸟教程&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1-7-SQL-DELETE-语句"><a href="#1-7-SQL-DELETE-语句" class="headerlink" title="1.7 SQL DELETE 语句"></a>1.7 SQL DELETE 语句</h2><ul>
<li><p>DELETE 语句用于删除表中的记录。</p>
</li>
<li><p>DELETE 语句用于删除表中的行。</p>
</li>
<li><p>SQL DELETE 语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>参数说明：</p>
<ul>
<li>table_name：要删除的表名称。</li>
<li>condition：删除条件，用于指定哪些数据要删除</li>
</ul>
</li>
<li><p>SQL DELETE 实例</p>
<ul>
<li>假设我们要从 “Websites” 表中删除网站名为 “Facebook” 且国家为 USA 的网站。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;Facebook&#x27;</span> <span class="keyword">AND</span> country<span class="operator">=</span><span class="string">&#x27;USA&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>删除所有数据</p>
<ul>
<li>您可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：</li>
<li><code>DELETE FROM table_name;</code></li>
</ul>
</li>
</ul>
<h2 id="sql-常用语句"><a href="#sql-常用语句" class="headerlink" title="sql 常用语句"></a>sql 常用语句</h2><p>SQL（Structured Query Language）是一种用于管理关系型数据库的编程语言。下面是一些SQL编程语言中常用的语句：</p>
<ol>
<li><p>数据库操作语句：</p>
<ul>
<li>创建数据库：<code>CREATE DATABASE database_name;</code></li>
<li>删除数据库：<code>DROP DATABASE database_name;</code></li>
<li>切换数据库：<code>USE database_name;</code></li>
</ul>
</li>
<li><p>表操作语句：</p>
<ul>
<li>创建表：<code>CREATE TABLE table_name (column1 datatype, column2 datatype, ...);</code></li>
<li>删除表：<code>DROP TABLE table_name;</code></li>
<li>修改表结构：<code>ALTER TABLE table_name ADD column_name datatype;</code></li>
</ul>
</li>
<li><p>数据操作语句：</p>
<ul>
<li>插入数据：<code>INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);</code></li>
<li>更新数据：<code>UPDATE table_name SET column1 = value1, column2 = value2 WHERE condition;</code></li>
<li>删除数据：<code>DELETE FROM table_name WHERE condition;</code></li>
<li>查询数据：<code>SELECT column1, column2, ... FROM table_name WHERE condition;</code></li>
</ul>
</li>
<li><p>数据过滤语句：</p>
<ul>
<li>条件过滤：使用WHERE子句进行条件筛选，例如：<code>WHERE column_name = value</code>。</li>
<li>范围过滤：使用BETWEEN和IN进行范围筛选，例如：<code>WHERE column_name BETWEEN value1 AND value2</code>。</li>
<li>模糊搜索：使用LIKE进行模糊匹配，例如：<code>WHERE column_name LIKE &#39;%value%&#39;</code>。</li>
</ul>
</li>
<li><p>数据排序和限制语句：</p>
<ul>
<li>排序数据：使用ORDER BY子句对结果进行排序，例如：<code>ORDER BY column_name ASC/DESC</code>。</li>
<li>限制结果：使用LIMIT子句限制结果集的数量，例如：<code>LIMIT n</code>。</li>
</ul>
</li>
<li><p>数据聚合和统计语句：</p>
<ul>
<li>聚合函数：使用聚合函数对数据进行计算，如COUNT、SUM、AVG、MIN、MAX等，例如：<code>SELECT COUNT(*) FROM table_name</code>。</li>
<li>分组数据：使用GROUP BY子句对结果进行分组，例如：<code>GROUP BY column_name</code>。</li>
<li>过滤分组：使用HAVING子句对分组结果进行过滤，例如：<code>HAVING condition</code>。</li>
</ul>
</li>
</ol>
<p>这些是SQL编程语言中常用的一些语句，可以用于创建和管理数据库、操作数据、查询数据和进行数据分析。具体的语法和用法可能会根据数据库管理系统的不同而有所差异，因此在实际使用时需要参考相应的数据库文档和语法规范。</p>
<hr>
<h2 id="ORDER-详解"><a href="#ORDER-详解" class="headerlink" title="ORDER 详解"></a>ORDER 详解</h2><p>在SQL中，ORDER BY子句用于对查询结果进行排序。它可以按照一个或多个列的值进行升序（ASC）或降序（DESC）排序。以下是ORDER BY子句的详细解释：</p>
<p>基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], column2 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...;</span><br></pre></td></tr></table></figure>

<ul>
<li>SELECT：用于指定要查询的列。</li>
<li>FROM：用于指定要查询的表名。</li>
<li>ORDER BY：用于指定排序规则。</li>
<li>column1, column2, …：要按照其值进行排序的列名。</li>
<li>ASC：升序排列（默认值）。</li>
<li>DESC：降序排列。</li>
</ul>
<p>示例：<br>假设有一个名为”employees”的表，包含以下列：id、name和salary。我们将使用该表作为示例来说明ORDER BY的使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>上述示例将返回按照salary列的值降序排列的结果集。结果集中的记录将按照salary的值从高到低排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> name <span class="keyword">ASC</span>, salary <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>上述示例将返回首先按照name列的值升序排列，如果name相同，则按照salary列的值降序排列的结果集。</p>
<p>需要注意的是，ORDER BY子句的位置应该位于查询语句的最后，以便在执行排序之前获取查询结果。</p>
<p>ORDER BY子句在SQL中非常有用，它使我们能够按照特定的列或多个列对查询结果进行排序，以满足特定的排序需求。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sql_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sql_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">sql_3_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>sql语法常用技巧</li>
</ul>
<h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><p>在SQL中，您可以使用<code>DELETE</code>语句来删除数据。要实现批量删除，您可以使用<code>DELETE</code>语句结合适当的条件或子查询来删除符合特定条件的多个记录。以下是一些示例：</p>
<ol>
<li><p>删除符合条件的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>
<p>将<code>table_name</code>替换为要删除记录的表名，<code>condition</code>替换为符合删除条件的条件表达式。</p>
</li>
<li><p>删除来自另一个查询的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (<span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> another_table <span class="keyword">WHERE</span> <span class="keyword">condition</span>);</span><br></pre></td></tr></table></figure>
<p>这将删除从另一个查询结果中选择的记录。将<code>table_name</code>替换为要删除记录的表名，<code>column_name</code>替换为要匹配的列名，<code>another_table</code>替换为另一个查询的表名，<code>condition</code>替换为适当的条件。</p>
</li>
<li><p>删除所有记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<p>这将删除指定表中的所有记录。将<code>table_name</code>替换为要删除记录的表名。</p>
</li>
</ol>
<p>请注意，在执行批量删除操作时要谨慎。确保您理解删除操作的影响，并在执行之前备份重要数据。</p>
<p>希望这些示例能帮助您理解如何在SQL中进行批量删除。如有其他问题，请随时提问。</p>
<h2 id="查询某个表单有多少条记录"><a href="#查询某个表单有多少条记录" class="headerlink" title="查询某个表单有多少条记录"></a>查询某个表单有多少条记录</h2><ul>
<li><code>select count(*) from table_name;</code></li>
</ul>
<h3 id="mysql-5-7-不用密码也能登录的问题"><a href="#mysql-5-7-不用密码也能登录的问题" class="headerlink" title="mysql 5.7 不用密码也能登录的问题"></a>mysql 5.7 不用密码也能登录的问题</h3><ul>
<li>在ubuntu下载mysql后，用mysql命令就可以直接登录数据库了，这是因为在mysql.user表里有个plugin的字段，root这个用户的值是auth_socket, 需要把它改成mysql_native_password。</li>
<li>具体步骤如下：<ul>
<li><code>use mysql;</code></li>
<li><code>update user set authentication_string=PASSWORD(&quot;密码&quot;) where user=‘root‘;</code></li>
<li><code>update user set plugin=&quot;mysql_native_password&quot;; </code></li>
<li><code>flush privileges;</code></li>
<li><code>quit;</code></li>
</ul>
</li>
</ul>
<h2 id="SQL-脚本"><a href="#SQL-脚本" class="headerlink" title="SQL 脚本"></a>SQL 脚本</h2><ul>
<li>像编写shell脚本一样，只不过语句换成了SQL语句</li>
<li>编写完成之后，通过mysql -u root -p password 进入到sql命令窗口，执行指令<code>source /sql.sh</code>执行sql脚本</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sqlite3_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sqlite3_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">sqlite3_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>sqlite3 理论知识相关笔记</li>
</ul>
<h2 id="SQLite-简介"><a href="#SQLite-简介" class="headerlink" title="SQLite 简介"></a>SQLite 简介</h2><ul>
<li><p>SQLite是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite是一个增长最快的数据库引擎，这是在普及方面的增长，与它的尺寸大小无关。SQLite 源代码不受版权限制</p>
</li>
<li><p>什么是SQLite</p>
<ul>
<li>SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库不一样，您不需要在系统中配置。</li>
<li>就像其他数据库，SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件</li>
</ul>
</li>
<li><p>为什么要用SQLite</p>
<ul>
<li>不需要一个单独的服务器进程或操作的系统（无服务器的）。</li>
<li>SQLite 不需要配置，这意味着不需要安装或管理。</li>
<li>一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。</li>
<li>SQLite 是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于250KiB。</li>
<li>SQLite 是自给自足的，这意味着不需要任何外部的依赖。</li>
<li>SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。</li>
<li>SQLite 支持 SQL92（SQL2）标准的大多数查询语言的功能。</li>
<li>SQLite 使用 ANSI-C 编写的，并提供了简单和易于使用的 API。</li>
<li>SQLite 可在 UNIX（Linux, Mac OS-X, Android, iOS）和 Windows（Win32, WinCE, WinRT）中运行。</li>
</ul>
</li>
<li><p>SQLite 命令</p>
<ul>
<li>与关系数据库进行交互的标准 SQLite 命令类似于 SQL。命令包括 CREATE、SELECT、INSERT、UPDATE、DELETE 和 DROP。这些命令基于它们的操作性质可分为以下几种：</li>
<li>DDL - 数据定义语言<ul>
<li>CREATE : 创建一个新的表，一个表的视图，或者数据库中的其他对象。</li>
<li>ALERT  : 修改数据库中的某个已有的数据库对象，比如一个表。</li>
<li>DROP   : 删除整个表，或者表的视图，或者数据库中的其他对象。</li>
</ul>
</li>
<li>DML - 数据操作语言<ul>
<li>INSERT : 创建一条记录</li>
<li>UPDATE : 修改记录</li>
<li>DELETE : 删除记录</li>
</ul>
</li>
<li>DQL - 数据查询语言<ul>
<li>SELECT : 从一个或多个表中检索某些记录</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SQLite-命令"><a href="#SQLite-命令" class="headerlink" title="SQLite 命令"></a>SQLite 命令</h2><ul>
<li>本章将向您讲解 SQLite 编程人员所使用的简单却有用的命令。这些命令被称为 SQLite 的点命令，这些命令的不同之处在于它们不以分号 ; 结束。</li>
<li>如需获取可用的点命令的清单，可以在任何时候输入 “.help”。例如：<ul>
<li>sqlite&gt;.help</li>
</ul>
</li>
<li>.backup ?DB? FILE	<ul>
<li>备份 DB 数据库（默认是 “main”）到 FILE 文件。</li>
</ul>
</li>
<li>.bail ON|<ul>
<li>OFF	</li>
<li>发生错误后停止。默认为 OFF。</li>
</ul>
</li>
<li>.databases	<ul>
<li>列出数据库的名称及其所依附的文件。</li>
</ul>
</li>
<li>.dump ?TABLE?	<ul>
<li>以 SQL 文本格式转储数据库。如果指定了 TABLE 表，则只转储匹配 LIKE 模式的 TABLE 表。</li>
</ul>
</li>
<li>.echo ON|OFF	<ul>
<li>开启或关闭 echo 命令。</li>
</ul>
</li>
<li>.exit	<ul>
<li>退出 SQLite 提示符。</li>
</ul>
</li>
<li>.explain ON|OFF	<ul>
<li>开启或关闭适合于 EXPLAIN 的输出模式。如果没有带参数，则为 EXPLAIN on，即开启 EXPLAIN。</li>
</ul>
</li>
<li>.header(s) ON|OFF	<ul>
<li>开启或关闭头部显示。</li>
</ul>
</li>
<li>.help	<ul>
<li>显示消息。</li>
</ul>
</li>
<li>.import FILE TABLE	<ul>
<li>导入来自 FILE 文件的数据到 TABLE 表中。</li>
</ul>
</li>
<li>.indices ?TABLE?	<ul>
<li>显示所有索引的名称。如果指定了 TABLE 表，则只显示匹配 LIKE 模式的 TABLE 表的索引。</li>
</ul>
</li>
<li>.load FILE ?ENTRY?	<ul>
<li>加载一个扩展库。</li>
</ul>
</li>
<li>.log FILE|off	<ul>
<li>开启或关闭日志。FILE 文件可以是 stderr（标准错误）&#x2F;stdout（标准输出）。</li>
</ul>
</li>
<li>.mode MODE	<ul>
<li>设置输出模式，MODE 可以是下列之一：<ul>
<li>csv 逗号分隔的值</li>
<li>column 左对齐的列</li>
<li>html HTML 的 <table> 代码</li>
<li>insert TABLE 表的 SQL 插入（insert）语句</li>
<li>line 每行一个值</li>
<li>list 由 .separator 字符串分隔的值</li>
<li>tabs 由 Tab 分隔的值</li>
<li>tcl TCL 列表元素</li>
</ul>
</li>
</ul>
</li>
<li>.nullvalue STRING	<ul>
<li>在 NULL 值的地方输出 STRING 字符串。</li>
</ul>
</li>
<li>.output FILENAME	<ul>
<li>发送输出到 FILENAME 文件。</li>
</ul>
</li>
<li>.output stdout	<ul>
<li>发送输出到屏幕。</li>
</ul>
</li>
<li>.print STRING…	<ul>
<li>逐字地输出 STRING 字符串。</li>
</ul>
</li>
<li>.prompt MAIN CONTINUE	<ul>
<li>替换标准提示符。</li>
</ul>
</li>
<li>.quit	<ul>
<li>退出 SQLite 提示符。</li>
</ul>
</li>
<li>.read FILENAME	<ul>
<li>执行 FILENAME 文件中的 SQL。</li>
</ul>
</li>
<li>.schema ?TABLE?	<ul>
<li>显示 CREATE 语句。如果指定了 TABLE 表，则只显示匹配 LIKE 模式的 TABLE 表。</li>
</ul>
</li>
<li>.separator STRING	<ul>
<li>改变输出模式和 .import 所使用的分隔符。</li>
</ul>
</li>
<li>.show	<ul>
<li>显示各种设置的当前值。</li>
</ul>
</li>
<li>.stats ON|OFF	<ul>
<li>开启或关闭统计。</li>
</ul>
</li>
<li>.tables ?PATTERN?	<ul>
<li>列出匹配 LIKE 模式的表的名称。</li>
</ul>
</li>
<li>.timeout MS	<ul>
<li>尝试打开锁定的表 MS 毫秒。</li>
</ul>
</li>
<li>.width NUM NUM	<ul>
<li>为 “column” 模式设置列宽度。</li>
</ul>
</li>
<li>.timer ON|OFF	<ul>
<li>开启或关闭 CPU 定时器。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-语法"><a href="#SQLite-语法" class="headerlink" title="SQLite 语法"></a>SQLite 语法</h2><ul>
<li><p>SQLite 是遵循一套独特的称为语法的规则和准则。</p>
</li>
<li><p>大小写敏感性</p>
<ul>
<li>有个重要的点值得注意，SQLite 是不区分大小写的，但也有一些命令是大小写敏感的，比如 GLOB 和 glob 在 SQLite 的语句中有不同的含义。</li>
</ul>
</li>
<li><p>注释</p>
<ul>
<li>SQLite 注释是附加的注释，可以在 SQLite 代码中添加注释以增加其可读性，他们可以出现在任何空白处，包括在表达式内和其他 SQL 语句的中间，但它们不能嵌套。</li>
<li>SQL 注释以两个连续的 “-“ 字符（ASCII 0x2d）开始，并扩展至下一个换行符（ASCII 0x0a）或直到输入结束，以先到者为准。</li>
<li>您也可以使用 C 风格的注释，以 “&#x2F;<em>“ 开始，并扩展至下一个 “</em>&#x2F;“ 字符对或直到输入结束，以先到者为准。SQLite的注释可以跨越多行。</li>
<li>sqlite&gt;.help – 这是一个简单的注释</li>
</ul>
</li>
<li><p>SQLite 语句</p>
<ul>
<li>所有的 SQLite 语句可以以任何关键字开始，如 SELECT、INSERT、UPDATE、DELETE、ALTER、DROP 等，所有的语句以分号 ; 结束。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-数据类型"><a href="#SQLite-数据类型" class="headerlink" title="SQLite 数据类型"></a>SQLite 数据类型</h2><ul>
<li><p>SQLite 数据类型是一个用来指定任何对象的数据类型的属性。SQLite 中的每一列，每个变量和表达式都有相关的数据类型。</p>
</li>
<li><p>您可以在创建表的同时使用这些数据类型。SQLite 使用一个更普遍的动态类型系统。在 SQLite 中，值的数据类型与值本身是相关的，而不是与它的容器相关。</p>
</li>
<li><p>SQLite存储类</p>
<ul>
<li>每个存储在 SQLite 数据库中的值都具有以下存储类之一：</li>
<li>NULL	: 值是一个 NULL 值。</li>
<li>INTEGER	: 值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中。</li>
<li>REAL	: 值是一个浮点值，存储为 8 字节的 IEEE 浮点数字。</li>
<li>TEXT	: 值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储。</li>
<li>BLOB	: 值是一个 blob 数据，完全根据它的输入存储。</li>
</ul>
</li>
<li><p>Date与Time数据类型</p>
<ul>
<li>SQLite 没有一个单独的用于存储日期和&#x2F;或时间的存储类，但 SQLite 能够把日期和时间存储为 TEXT、REAL 或 INTEGER 值。</li>
<li>TEXT	: 格式为 “YYYY-MM-DD HH:MM:SS.SSS” 的日期。</li>
<li>REAL	: 从公元前 4714 年 11 月 24 日格林尼治时间的正午开始算起的天数。</li>
<li>INTEGER	: 从 1970-01-01 00:00:00 UTC 算起的秒数。</li>
<li>您可以以任何上述格式来存储日期和时间，并且可以使用内置的日期和时间函数来自由转换不同格式。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-创建数据库"><a href="#SQLite-创建数据库" class="headerlink" title="SQLite 创建数据库"></a>SQLite 创建数据库</h2><ul>
<li><p>SQLite 的 sqlite3 命令被用来创建新的 SQLite 数据库。您不需要任何特殊的权限即可创建一个数据。</p>
</li>
<li><p>语法</p>
<ul>
<li>sqlite3 命令的基本语法如下：<ul>
<li><code>$ sqlite3 DatabaseName.db</code></li>
</ul>
</li>
<li>通常情况下，数据库名称在 RDBMS 内应该是唯一的。</li>
<li>另外我们也可以使用 .open 来建立新的数据库文件：<ul>
<li><code>sqlite&gt;.open test.db</code></li>
</ul>
</li>
<li>上面的命令创建了数据库文件 test.db，位于 sqlite3 命令同一目录下。</li>
<li>打开已存在数据库也是用 .open 命令，以上命令如果 test.db 存在则直接会打开，不存在就创建它。</li>
</ul>
</li>
<li><p>.dump 命令</p>
<ul>
<li>您可以在命令提示符中使用 SQLite .dump 点命令来导出完整的数据库在一个文本文件中，如下所示：<ul>
<li><code>$sqlite3 testDB.db .dump &gt; testDB.sql</code></li>
</ul>
</li>
<li>上面的命令将转换整个 testDB.db 数据库的内容到 SQLite 的语句中，并将其转储到 ASCII 文本文件 testDB.sql 中。您可以通过简单的方式从生成的 testDB.sql 恢复，如下所示：<ul>
<li><code>$sqlite3 testDB.db &lt; testDB.sql</code></li>
</ul>
</li>
<li>此时的数据库是空的，一旦数据库中有表和数据，您可以尝试上述两个程序。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-附加数据库"><a href="#SQLite-附加数据库" class="headerlink" title="SQLite 附加数据库"></a>SQLite 附加数据库</h2><ul>
<li><p>假设这样一种情况，当在同一时间有多个数据库可用，您想使用其中的任何一个。SQLite 的 ATTACH DATABASE 语句是用来选择一个特定的数据库，使用该命令后，所有的 SQLite 语句将在附加的数据库下执行。</p>
</li>
<li><p>语法</p>
<ul>
<li>SQLite 的 ATTACH DATABASE 语句的基本语法如下：<ul>
<li><code>ATTACH DATABASE file_name AS database_name;</code></li>
</ul>
</li>
<li>如果数据库尚未被创建，上面的命令将创建一个数据库，如果数据库已存在，则把数据库文件名称与逻辑数据库 ‘Alias-Name’ 绑定在一起。</li>
<li>打开的数据库和使用 ATTACH附加进来的数据库的必须位于同一文件夹下。</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>如果想附加一个现有的数据库 testDB.db，则 ATTACH DATABASE 语句将如下所示：<ul>
<li><code>sqlite&gt; ATTACH DATABASE &#39;testDB.db&#39; as &#39;TEST&#39;;</code></li>
</ul>
</li>
<li>使用 SQLite .database 命令来显示附加的数据库。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> .database</span><br><span class="line">seq  name             file</span><br><span class="line"><span class="comment">---  ---------------  ----------------------</span></span><br><span class="line"><span class="number">0</span>    main             <span class="operator">/</span>home<span class="operator">/</span>sqlite<span class="operator">/</span>testDB.db</span><br><span class="line"><span class="number">2</span>    test             <span class="operator">/</span>home<span class="operator">/</span>sqlite<span class="operator">/</span>testDB.db</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数据库名称 main 和 temp 被保留用于主数据库和存储临时表及其他临时数据对象的数据库。这两个数据库名称可用于每个数据库连接，且不应该被用于附加，否则将得到一个警告消息，如下所示</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span>  ATTACH DATABASE <span class="string">&#x27;testDB.db&#x27;</span> <span class="keyword">as</span> <span class="string">&#x27;TEMP&#x27;</span>;</span><br><span class="line">Error: database TEMP <span class="keyword">is</span> already <span class="keyword">in</span> use</span><br><span class="line">sqlite<span class="operator">&gt;</span>  ATTACH DATABASE <span class="string">&#x27;testDB.db&#x27;</span> <span class="keyword">as</span> <span class="string">&#x27;main&#x27;</span>;</span><br><span class="line">Error: database main <span class="keyword">is</span> already <span class="keyword">in</span> use；</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="SQLite-分离数据库"><a href="#SQLite-分离数据库" class="headerlink" title="SQLite 分离数据库"></a>SQLite 分离数据库</h2><ul>
<li><p>SQLite 的 DETACH DATABASE 语句是用来把命名数据库从一个数据库连接分离和游离出来，连接是之前使用 ATTACH 语句附加的。如果同一个数据库文件已经被附加上多个别名，DETACH 命令将只断开给定名称的连接，而其余的仍然有效。您无法分离 main 或 temp 数据库。</p>
</li>
<li><p>如果数据库是在内存中或者是临时数据库，则该数据库将被摧毁，且内容将会丢失。</p>
</li>
<li><p>语法</p>
<ul>
<li>SQLite 的 DETACH DATABASE ‘Alias-Name’ 语句的基本语法如下：<ul>
<li><code>DETACH DATABASE &#39;Alias-Name&#39;;</code></li>
</ul>
</li>
<li>在这里，’Alias-Name’ 与您之前使用 ATTACH 语句附加数据库时所用到的别名相同。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-创建表"><a href="#SQLite-创建表" class="headerlink" title="SQLite 创建表"></a>SQLite 创建表</h2><ul>
<li><p>SQLite 的 CREATE TABLE 语句用于在任何给定的数据库创建一个新表。创建基本表，涉及到命名表、定义列及每一列的数据类型。</p>
</li>
<li><p>语法</p>
<ul>
<li>CREATE TABLE 语句的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> database_name.table_name(</span><br><span class="line">   column1 datatype  <span class="keyword">PRIMARY KEY</span>(<span class="keyword">one</span> <span class="keyword">or</span> more columns),</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>CREATE TABLE 是告诉数据库系统创建一个新表的关键字。CREATE TABLE 语句后跟着表的唯一的名称或标识。您也可以选择指定带有 table_name 的 database_name。</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>下面是一个实例，它创建了一个 COMPANY 表，ID 作为主键，NOT NULL 的约束表示在表中创建纪录时这些字段不能为 NULL：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">CREATE TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>让我们再创建一个表，我们将在随后章节的练习中使用：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">CREATE TABLE</span> DEPARTMENT(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>      <span class="keyword">NOT NULL</span>,</span><br><span class="line">   DEPT           <span class="type">CHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">   EMP_ID         <span class="type">INT</span>      <span class="keyword">NOT NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>您可以使用 SQLIte 命令中的 .tables 命令来验证表是否已成功创建，该命令用于列出附加数据库中的所有表。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt;.tables</span><br><span class="line">COMPANY     DEPARTMENT</span><br></pre></td></tr></table></figure></li>
<li>您可以使用 SQLite .schema 命令得到表的完整信息，如下所示：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span>.schema COMPANY</span><br><span class="line"><span class="keyword">CREATE TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-删除表"><a href="#SQLite-删除表" class="headerlink" title="SQLite 删除表"></a>SQLite 删除表</h2><ul>
<li><p>SQLite 的 DROP TABLE 语句用来删除表定义及其所有相关数据、索引、触发器、约束和该表的权限规范。</p>
</li>
<li><p>使用此命令时要特别注意，因为一旦一个表被删除，表中所有信息也将永远丢失。</p>
</li>
<li><p>语法</p>
<ul>
<li>DROP TABLE 语句的基本语法如下。您可以选择指定带有表名的数据库名称，如下所示<ul>
<li><code>DROP TABLE database_name.table_name;</code></li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SQLite-Insert-语句"><a href="#SQLite-Insert-语句" class="headerlink" title="SQLite Insert 语句"></a>SQLite Insert 语句</h2><ul>
<li><p>SQLite 的 INSERT INTO 语句用于向数据库的某个表中添加新的数据行。</p>
</li>
<li><p>语法</p>
<ul>
<li>INSERT INTO 语句有两种基本语法，如下所示：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> TABLE_NAME [(column1, column2, column3,...columnN)]  </span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, value3,...valueN);</span><br></pre></td></tr></table></figure></li>
<li>在这里，column1, column2,…columnN 是要插入数据的表中的列的名称。</li>
<li>如果要为表中的所有列添加值，您也可以不需要在 SQLite 查询中指定列名称。但要确保值的顺序与列在表中的顺序一致。SQLite 的 INSERT INTO 语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> TABLE_NAME <span class="keyword">VALUES</span> (value1,value2,value3,...valueN);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用一个表来填充另一个表</p>
<ul>
<li>您可以通过在一个有一组字段的表上使用 select 语句，填充数据到另一个表中。下面是语法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> first_table_name [(column1, column2, ... columnN)] </span><br><span class="line">   <span class="keyword">SELECT</span> column1, column2, ...columnN </span><br><span class="line">   <span class="keyword">FROM</span> second_table_name</span><br><span class="line">   [<span class="keyword">WHERE</span> <span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Select-语句"><a href="#SQLite-Select-语句" class="headerlink" title="SQLite Select 语句"></a>SQLite Select 语句</h2><ul>
<li><p>SQLite 的 SELECT 语句用于从 SQLite 数据库表中获取数据，以结果表的形式返回数据。这些结果表也被称为结果集。</p>
</li>
<li><p>语法</p>
<ul>
<li>SQLite 的 SELECT 语句的基本语法如下：<ul>
<li><code>SELECT column1, column2, columnN FROM table_name;</code></li>
</ul>
</li>
<li>在这里，column1, column2…是表的字段，他们的值即是您要获取的。如果您想获取所有可用的字段，那么可以使用下面的语法：<ul>
<li><code>SELECT * FROM table_name;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SQLite-运算符"><a href="#SQLite-运算符" class="headerlink" title="SQLite 运算符"></a>SQLite 运算符</h2><ul>
<li><p>SQLite 运算符是什么？</p>
<ul>
<li>运算符是一个保留字或字符，主要用于 SQLite 语句的 WHERE 子句中执行操作，如比较和算术运算。</li>
<li>运算符用于指定 SQLite 语句中的条件，并在语句中连接多个条件。<ul>
<li>算术运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
</ul>
</li>
</ul>
</li>
<li><p>SQLite 算术运算符</p>
<ul>
<li>假设变量 a&#x3D;10，变量 b&#x3D;20，则：</li>
<li><code>+</code>	 : 加法 :  把运算符两边的值相加	a + b 将得到 30</li>
<li><code>-</code>	 : 减法 :  左操作数减去右操作数	a - b 将得到 -10</li>
<li><code>*</code>	 : 乘法 :  把运算符两边的值相乘	a * b 将得到 200</li>
<li><code>/</code>	 : 除法 :  左操作数除以右操作数	b &#x2F; a 将得到 2</li>
<li><code>%</code>	 : 取模 :  左操作数除以右操作数后得到的余数	b % a 将得到 0</li>
</ul>
</li>
<li><p>SQLite 比较运算符</p>
<ul>
<li>假设变量 a&#x3D;10，变量 b&#x3D;20，则：</li>
<li><code>==</code>	检查两个操作数的值是否相等，如果相等则条件为真。	(a &#x3D;&#x3D; b) 不为真。</li>
<li><code>=</code> 	检查两个操作数的值是否相等，如果相等则条件为真。	(a &#x3D; b) 不为真。</li>
<li><code>!=</code>	检查两个操作数的值是否相等，如果不相等则条件为真。	(a !&#x3D; b) 为真。</li>
<li><code>&lt;&gt;</code>	检查两个操作数的值是否相等，如果不相等则条件为真。	(a &lt;&gt; b) 为真。</li>
<li><code>&gt;</code>	    检查左操作数的值是否大于右操作数的值，如果是则条件为真。	(a &gt; b) 不为真。</li>
<li><code>&lt;</code>	    检查左操作数的值是否小于右操作数的值，如果是则条件为真。	(a &lt; b) 为真。</li>
<li><code>&gt;=</code>	检查左操作数的值是否大于等于右操作数的值，如果是则条件为真。	(a &gt;&#x3D; b) 不为真。</li>
<li><code>&lt;=</code>	检查左操作数的值是否小于等于右操作数的值，如果是则条件为真。	(a &lt;&#x3D; b) 为真。</li>
<li><code>!&lt;</code>	检查左操作数的值是否不小于右操作数的值，如果是则条件为真。	(a !&lt; b) 为假。</li>
<li><code>!&gt;</code>	检查左操作数的值是否不大于右操作数的值，如果是则条件为真。	(a !&gt; b) 为真。</li>
</ul>
</li>
<li><p>SQLite 逻辑运算符</p>
<ul>
<li>下面是 SQLite 中所有的逻辑运算符列表。</li>
<li>AND	AND  : 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。</li>
<li>BETWEEN	 : BETWEEN 运算符用于在给定最小值和最大值范围内的一系列值中搜索值。</li>
<li>EXISTS	 : EXISTS 运算符用于在满足一定条件的指定表中搜索行的存在。</li>
<li>IN	     : IN 运算符用于把某个值与一系列指定列表的值进行比较。</li>
<li>NOT IN	 : IN 运算符的对立面，用于把某个值与不在一系列指定列表的值进行比较。</li>
<li>LIKE	 : LIKE 运算符用于把某个值与使用通配符运算符的相似值进行比较。</li>
<li>GLOB	 : GLOB 运算符用于把某个值与使用通配符运算符的相似值进行比较。GLOB 与 LIKE 不同之处在于，它是大小写敏感的。</li>
<li>NOT	     : NOT 运算符是所用的逻辑运算符的对立面。比如 NOT EXISTS、NOT BETWEEN、NOT IN，等等。它是否定运算符。</li>
<li>OR	     : OR 运算符用于结合一个 SQL 语句的 WHERE 子句中的多个条件。</li>
<li>IS NULL	 : NULL 运算符用于把某个值与 NULL 值进行比较。</li>
<li>IS	     : IS 运算符与 &#x3D; 相似。</li>
<li>IS NOT	 : IS NOT 运算符与 !&#x3D; 相似。</li>
<li>||	     : 连接两个不同的字符串，得到一个新的字符串。</li>
<li>UNIQUE	 : UNIQUE 运算符搜索指定表中的每一行，确保唯一性（无重复）。</li>
</ul>
</li>
<li><p>SQLite 位运算符</p>
<ul>
<li>下表中列出了 SQLite 语言支持的位运算符。假设变量 A&#x3D;60，变量 B&#x3D;13，则：</li>
<li><code>&amp;</code>	    : 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。	     (A &amp; B) 将得到 12，即为 0000 1100</li>
<li><code>|</code>	    : 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。	        (A | B) 将得到 61，即为 0011 1101</li>
<li><code>~</code>	    : 二进制补码运算符是一元运算符，具有”翻转”位效应，即0变成1，1变成0。	 (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</li>
<li><code>&lt;&lt;</code>	: 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。	         A &lt;&lt; 2 将得到 240，即为 1111 0000</li>
<li><code>&gt;&gt;</code>	: 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。	         A &gt;&gt; 2 将得到 15，即为 0000 1111</li>
</ul>
</li>
</ul>
<h2 id="SQLite-表达式"><a href="#SQLite-表达式" class="headerlink" title="SQLite 表达式"></a>SQLite 表达式</h2><ul>
<li><p>表达式是一个或多个值、运算符和计算值的SQL函数的组合。</p>
</li>
<li><p>SQL 表达式与公式类似，都写在查询语言中。您还可以使用特定的数据集来查询数据库。</p>
</li>
<li><p>语法</p>
<ul>
<li>假设 SELECT 语句的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">CONDITION</span> <span class="operator">|</span> EXPRESSION];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>SQLite - 布尔表达式</p>
<ul>
<li>SQLite 的布尔表达式在匹配单个值的基础上获取数据。语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">WHERE</span> SINGLE <span class="keyword">VALUE</span> MATCHING EXPRESSION;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>SQLite - 数值表达式</p>
<ul>
<li>这些表达式用来执行查询中的任何数学运算。语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> numerical_expression <span class="keyword">as</span>  OPERATION_NAME</span><br><span class="line">[<span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">CONDITION</span>] ;</span><br></pre></td></tr></table></figure></li>
<li>在这里，numerical_expression 用于数学表达式或任何公式。下面的实例演示了 SQLite 数值表达式的用法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> (<span class="number">15</span> <span class="operator">+</span> <span class="number">6</span>) <span class="keyword">AS</span> ADDITION</span><br><span class="line">ADDITION <span class="operator">=</span> <span class="number">21</span></span><br></pre></td></tr></table></figure></li>
<li>有几个内置的函数，比如 avg()、sum()、count()，等等，执行被称为对一个表或一个特定的表列的汇总数据计算。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> &quot;RECORDS&quot; <span class="keyword">FROM</span> COMPANY; </span><br><span class="line">RECORDS <span class="operator">=</span> <span class="number">7</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>SQLite - 日期表达式</p>
<ul>
<li>日期表达式返回当前系统日期和时间值，这些表达式将被用于各种数据操作。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span>  <span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIMESTAMP</span>;</span><br><span class="line"><span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">=</span> <span class="number">2013</span><span class="number">-03</span><span class="number">-17</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">35</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Where-子句"><a href="#SQLite-Where-子句" class="headerlink" title="SQLite Where 子句"></a>SQLite Where 子句</h2><ul>
<li><p>SQLite的 WHERE 子句用于指定从一个表或多个表中获取数据的条件。</p>
</li>
<li><p>如果满足给定的条件，即为真（true）时，则从表中返回特定的值。您可以使用 WHERE 子句来过滤记录，只获取需要的记录。</p>
</li>
<li><p>WHERE 子句不仅可用在 SELECT 语句中，它也可用在 UPDATE、DELETE 语句中，等等，这些我们将在随后的章节中学习到。</p>
</li>
<li><p>语法：</p>
<ul>
<li>SQLite 的带有 WHERE 子句的 SELECT 语句的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure></li>
<li>您还可以使用比较或逻辑运算符指定条件，比如 &gt;、&lt;、&#x3D;、LIKE、NOT，等等</li>
</ul>
</li>
<li><p>下面的 SELECT 语句列出了 NAME 以 ‘Ki’ 开始的所有记录，’Ki’ 之后的字符不做限制</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;Ki%&#x27;</span>;</span><br><span class="line">ID          NAME        AGE         ADDRESS     SALARY</span><br><span class="line"><span class="comment">----------  ----------  ----------  ----------  ----------</span></span><br><span class="line"><span class="number">6</span>           Kim         <span class="number">22</span>          South<span class="operator">-</span>Hall  <span class="number">45000.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的 SELECT 语句列出了 NAME 以 ‘Ki’ 开始的所有记录，’Ki’ 之后的字符不做限制：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> NAME GLOB <span class="string">&#x27;Ki*&#x27;</span>;</span><br><span class="line">ID          NAME        AGE         ADDRESS     SALARY</span><br><span class="line"><span class="comment">----------  ----------  ----------  ----------  ----------</span></span><br><span class="line"><span class="number">6</span>           Kim         <span class="number">22</span>          South<span class="operator">-</span>Hall  <span class="number">45000.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的 SELECT 语句列出了 AGE 的值为 25 或 27 的所有记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> AGE <span class="keyword">IN</span> ( <span class="number">25</span>, <span class="number">27</span> );</span><br><span class="line">ID          NAME        AGE         ADDRESS     SALARY</span><br><span class="line"><span class="comment">----------  ----------  ----------  ----------  ----------</span></span><br><span class="line"><span class="number">2</span>           Allen       <span class="number">25</span>          Texas       <span class="number">15000.0</span></span><br><span class="line"><span class="number">4</span>           Mark        <span class="number">25</span>          Rich<span class="operator">-</span>Mond   <span class="number">65000.0</span></span><br><span class="line"><span class="number">5</span>           David       <span class="number">27</span>          Texas       <span class="number">85000.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的 SELECT 语句列出了 AGE 的值既不是 25 也不是 27 的所有记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> AGE <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="number">25</span>, <span class="number">27</span> );</span><br><span class="line">ID          NAME        AGE         ADDRESS     SALARY</span><br><span class="line"><span class="comment">----------  ----------  ----------  ----------  ----------</span></span><br><span class="line"><span class="number">1</span>           Paul        <span class="number">32</span>          California  <span class="number">20000.0</span></span><br><span class="line"><span class="number">3</span>           Teddy       <span class="number">23</span>          Norway      <span class="number">20000.0</span></span><br><span class="line"><span class="number">6</span>           Kim         <span class="number">22</span>          South<span class="operator">-</span>Hall  <span class="number">45000.0</span></span><br><span class="line"><span class="number">7</span>           James       <span class="number">24</span>          Houston     <span class="number">10000.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的 SELECT 语句列出了 AGE 的值在 25 与 27 之间的所有记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> AGE <span class="keyword">BETWEEN</span> <span class="number">25</span> <span class="keyword">AND</span> <span class="number">27</span>;</span><br><span class="line">ID          NAME        AGE         ADDRESS     SALARY</span><br><span class="line"><span class="comment">----------  ----------  ----------  ----------  ----------</span></span><br><span class="line"><span class="number">2</span>           Allen       <span class="number">25</span>          Texas       <span class="number">15000.0</span></span><br><span class="line"><span class="number">4</span>           Mark        <span class="number">25</span>          Rich<span class="operator">-</span>Mond   <span class="number">65000.0</span></span><br><span class="line"><span class="number">5</span>           David       <span class="number">27</span>          Texas       <span class="number">85000.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的 SELECT 语句使用 SQL 子查询，子查询查找 SALARY &gt; 65000 的带有 AGE 字段的所有记录，后边的 WHERE 子句与 EXISTS 运算符一起使用，列出了外查询中的 AGE 存在于子查询返回的结果中的所有记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> AGE <span class="keyword">FROM</span> COMPANY </span><br><span class="line">        <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> AGE <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> SALARY <span class="operator">&gt;</span> <span class="number">65000</span>);</span><br><span class="line">AGE</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的 SELECT 语句使用 SQL 子查询，子查询查找 SALARY &gt; 65000 的带有 AGE 字段的所有记录，后边的 WHERE 子句与 &gt; 运算符一起使用，列出了外查询中的 AGE 大于子查询返回的结果中的年龄的所有记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> COMPANY </span><br><span class="line">        <span class="keyword">WHERE</span> AGE <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> AGE <span class="keyword">FROM</span> COMPANY <span class="keyword">WHERE</span> SALARY <span class="operator">&gt;</span> <span class="number">65000</span>);</span><br><span class="line">ID          NAME        AGE         ADDRESS     SALARY</span><br><span class="line"><span class="comment">----------  ----------  ----------  ----------  ----------</span></span><br><span class="line"><span class="number">1</span>           Paul        <span class="number">32</span>          California  <span class="number">20000.0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="SQLite-AND-OR-运算符"><a href="#SQLite-AND-OR-运算符" class="headerlink" title="SQLite AND&#x2F;OR 运算符"></a>SQLite AND&#x2F;OR 运算符</h2><ul>
<li><p>SQLite 的 AND 和 OR 运算符用于编译多个条件来缩小在 SQLite 语句中所选的数据。这两个运算符被称为连接运算符。</p>
</li>
<li><p>这些运算符为同一个 SQLite 语句中不同的运算符之间的多个比较提供了可能。</p>
</li>
<li><p>AND 运算符</p>
<ul>
<li>AND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。使用 AND 运算符时，只有当所有条件都为真（true）时，整个条件为真（true）。</li>
<li>例如，只有当 condition1 和 condition2 都为真（true）时，[condition1] AND [condition2] 为真（true）。</li>
</ul>
</li>
<li><p>语法</p>
<ul>
<li>带有 WHERE 子句的 AND 运算符的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [condition1] <span class="keyword">AND</span> [condition2]...<span class="keyword">AND</span> [conditionN];</span><br></pre></td></tr></table></figure></li>
<li>您可以使用 AND 运算符来结合 N 个数量的条件。SQLite 语句需要执行的动作是，无论是事务或查询，所有由 AND 分隔的条件都必须为真（TRUE）。</li>
</ul>
</li>
<li><p>OR 运算符</p>
<ul>
<li>OR 运算符也用于结合一个 SQL 语句的 WHERE 子句中的多个条件。使用 OR 运算符时，只要当条件中任何一个为真（true）时，整个条件为真（true）。</li>
<li>例如，只要当 condition1 或 condition2 有一个为真（true）时，[condition1] OR [condition2] 为真（true）。</li>
</ul>
</li>
<li><p>语法</p>
<ul>
<li>带有 WHERE 子句的 OR 运算符的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [condition1] <span class="keyword">OR</span> [condition2]...<span class="keyword">OR</span> [conditionN]</span><br></pre></td></tr></table></figure></li>
<li>您可以使用 OR 运算符来结合 N 个数量的条件。SQLite 语句需要执行的动作是，无论是事务或查询，只要任何一个由 OR 分隔的条件为真（TRUE）即可。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-Update-语句"><a href="#SQLite-Update-语句" class="headerlink" title="SQLite Update 语句"></a>SQLite Update 语句</h2><ul>
<li><p>SQLite 的 UPDATE 查询用于修改表中已有的记录。可以使用带有 WHERE 子句的 UPDATE 查询来更新选定行，否则所有的行都会被更新。</p>
</li>
<li><p>语法</p>
<ul>
<li>带有 WHERE 子句的 UPDATE 查询的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2...., columnN <span class="operator">=</span> valueN</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure></li>
<li>您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。</li>
</ul>
</li>
<li><p>如果您想修改 COMPANY 表中 ADDRESS 和 SALARY 列的所有值，则不需要使用 WHERE 子句，UPDATE 查询如下：</p>
<ul>
<li><code>sqlite&gt; UPDATE COMPANY SET ADDRESS = &#39;Texas&#39;, SALARY = 20000.00;</code></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Delete-语句"><a href="#SQLite-Delete-语句" class="headerlink" title="SQLite Delete 语句"></a>SQLite Delete 语句</h2><ul>
<li><p>SQLite 的 DELETE 查询用于删除表中已有的记录。可以使用带有 WHERE 子句的 DELETE 查询来删除选定行，否则所有的记录都会被删除。</p>
</li>
<li><p>语法</p>
<ul>
<li>带有 WHERE 子句的 DELETE 查询的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure></li>
<li>您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-Like-子句"><a href="#SQLite-Like-子句" class="headerlink" title="SQLite Like 子句"></a>SQLite Like 子句</h2><ul>
<li><p>SQLite 的 LIKE 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。这里有两个通配符与 LIKE 运算符一起使用：</p>
<ul>
<li>百分号 （%）</li>
<li>下划线 （_）</li>
</ul>
</li>
<li><p>百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用。</p>
</li>
<li><p>语法</p>
<ul>
<li>% 和 _ 的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_list </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">LIKE</span> <span class="string">&#x27;XXXX%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> column_list </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%XXXX%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> column_list </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">LIKE</span> <span class="string">&#x27;XXXX_&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> column_list </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">LIKE</span> <span class="string">&#x27;_XXXX&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> column_list </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">LIKE</span> <span class="string">&#x27;_XXXX_&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。在这里，XXXX 可以是任何数字或字符串值。</p>
</li>
<li><p>实例</p>
<ul>
<li>下面一些实例演示了 带有 ‘%’ 和 ‘_’ 运算符的 LIKE 子句不同的地方：</li>
<li><code>WHERE SALARY LIKE &#39;200%&#39;</code>	查找以 200 开头的任意值</li>
<li><code>WHERE SALARY LIKE &#39;%200%&#39;</code>	查找任意位置包含 200 的任意值</li>
<li><code>WHERE SALARY LIKE &#39;_00%&#39;</code>	查找第二位和第三位为 00 的任意值</li>
<li><code>WHERE SALARY LIKE &#39;2_%_%&#39;</code>	查找以 2 开头，且长度至少为 3 个字符的任意值</li>
<li><code>WHERE SALARY LIKE &#39;%2&#39;</code>	查找以 2 结尾的任意值</li>
<li><code>WHERE SALARY LIKE &#39;_2%3&#39;</code>	查找第二位为 2，且以 3 结尾的任意值</li>
<li><code>WHERE SALARY LIKE &#39;2___3&#39;</code>	查找长度为 5 位数，且以 2 开头以 3 结尾的任意值</li>
</ul>
</li>
<li><p>下面是一个实例，它显示 COMPANY 表中 AGE 以 2 开头的所有记录：</p>
<ul>
<li><code>sqlite&gt; SELECT * FROM COMPANY WHERE AGE  LIKE &#39;2%&#39;;</code></li>
</ul>
</li>
<li><p>下面是一个实例，它显示 COMPANY 表中 ADDRESS 文本里包含一个连字符（-）的所有记录：</p>
<ul>
<li><code>sqlite&gt; SELECT * FROM COMPANY WHERE ADDRESS  LIKE &#39;%-%&#39;;</code></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Glob-子句"><a href="#SQLite-Glob-子句" class="headerlink" title="SQLite Glob 子句"></a>SQLite Glob 子句</h2><ul>
<li><p>SQLite 的 GLOB 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。与 LIKE 运算符不同的是，GLOB 是大小写敏感的，对于下面的通配符，它遵循 UNIX 的语法。</p>
<ul>
<li><code>*</code>      ：匹配零个、一个或多个数字或字符。</li>
<li><code>?</code>      ：代表一个单一的数字或字符。</li>
<li><code>[...]</code>  ：匹配方括号内指定的字符之一。例如，[abc] 匹配 “a”、”b” 或 “c” 中的任何一个字符。</li>
<li><code>[^...]</code> ：匹配不在方括号内指定的字符之一。例如，[^abc] 匹配不是 “a”、”b” 或 “c” 中的任何一个字符的字符。</li>
</ul>
</li>
<li><p>以上这些符号可以被组合使用</p>
</li>
<li><p>语法</p>
<ul>
<li><ul>
<li>和 ? 的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> GLOB <span class="string">&#x27;XXXX*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> GLOB <span class="string">&#x27;*XXXX*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> GLOB <span class="string">&#x27;XXXX?&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> GLOB <span class="string">&#x27;?XXXX&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> GLOB <span class="string">&#x27;?XXXX?&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> GLOB <span class="string">&#x27;????&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。在这里，XXXX 可以是任何数字或字符串值。</p>
</li>
<li><p>实例</p>
<ul>
<li>下面一些实例演示了 带有 ‘*’ 和 ‘?’ 运算符的 GLOB 子句不同的地方：<ul>
<li><code>WHERE SALARY GLOB &#39;200*&#39;</code>	查找以 200 开头的任意值</li>
<li><code>WHERE SALARY GLOB &#39;*200*&#39;</code>	查找任意位置包含 200 的任意值</li>
<li><code>WHERE SALARY GLOB &#39;?00*&#39;</code>	查找第二位和第三位为 00 的任意值</li>
<li><code>WHERE SALARY GLOB &#39;2??&#39;</code>	    查找以 2 开头，且长度为 3 个字符的任意值，例如，它可能匹配 “200”、”2A1”、”2B2” 等值。</li>
<li><code>WHERE SALARY GLOB &#39;*2&#39;</code>	    查找以 2 结尾的任意值</li>
<li><code>WHERE SALARY GLOB &#39;?2*3&#39;</code>	查找第二位为 2，且以 3 结尾的任意值</li>
<li><code>WHERE SALARY GLOB &#39;2???3&#39;</code>	查找长度为 5 位数，且以 2 开头以 3 结尾的任意值</li>
</ul>
</li>
</ul>
</li>
<li><p><code>[...]</code> 通配符</p>
<ul>
<li><code>[...]</code> 表达式用于匹配方括号内指定的字符集中的任何一个字符。</li>
</ul>
</li>
<li><p>实例 1：匹配以 “A” 或 “B” 开头的产品名称。</p>
<ul>
<li><code>SELECT * FROM products WHERE product_name LIKE &#39;[AB]%&#39;;</code></li>
</ul>
</li>
<li><p>这将匹配以 “A” 或 “B” 开头的产品名称。</p>
</li>
<li><p>实例 2：匹配以 “1”、”2” 或 “3” 开头的电话号码。</p>
<ul>
<li><code>SELECT * FROM customers WHERE phone_number LIKE &#39;[123]%&#39;;</code></li>
</ul>
</li>
<li><p>这将匹配以 “1”、”2” 或 “3” 开头的电话号码。</p>
</li>
<li><p><code>[^...]</code> 通配符</p>
<ul>
<li><code>[^...]</code> 表达式用于匹配不在方括号内指定的字符集中的任何字符。</li>
</ul>
</li>
<li><p>实例 1：匹配不以 “X” 或 “Y” 开头的产品代码。</p>
<ul>
<li><code>SELECT * FROM products WHERE product_code LIKE &#39;[^XY]%&#39;;</code></li>
</ul>
</li>
<li><p>这将匹配不以 “X” 或 “Y” 开头的产品</p>
</li>
<li><p>实例 2：匹配不包含数字字符的用户名。</p>
<ul>
<li><code>SELECT * FROM users WHERE username LIKE &#39;[^0-9]%&#39;;</code></li>
</ul>
</li>
<li><p>这将匹配不以数字字符开头的用户名。</p>
</li>
</ul>
<h2 id="SQLite-Limit-子句"><a href="#SQLite-Limit-子句" class="headerlink" title="SQLite Limit 子句"></a>SQLite Limit 子句</h2><ul>
<li><p>SQLite 的 LIMIT 子句用于限制由 SELECT 语句返回的数据数量。</p>
</li>
<li><p>语法</p>
<ul>
<li>带有 LIMIT 子句的 SELECT 语句的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">LIMIT [<span class="keyword">no</span> <span class="keyword">of</span> <span class="keyword">rows</span>]</span><br></pre></td></tr></table></figure></li>
<li>下面是 LIMIT 子句与 OFFSET 子句一起使用时的语法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">LIMIT [<span class="keyword">no</span> <span class="keyword">of</span> <span class="keyword">rows</span>] <span class="keyword">OFFSET</span> [<span class="type">row</span> num]</span><br></pre></td></tr></table></figure></li>
<li>SQLite 引擎将返回从下一行开始直到给定的 OFFSET 为止的所有行，如下面的最后一个实例所示</li>
</ul>
</li>
<li><p>但是，在某些情况下，可能需要从一个特定的偏移开始提取记录。下面是一个实例，从第三位开始提取 3 个记录：</p>
<ul>
<li><code>sqlite&gt; SELECT * FROM COMPANY LIMIT 3 OFFSET 2;</code></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Order-By"><a href="#SQLite-Order-By" class="headerlink" title="SQLite Order By"></a>SQLite Order By</h2><ul>
<li><p>SQLite 的 ORDER BY 子句是用来基于一个或多个列按升序或降序顺序排列数据。</p>
</li>
<li><p>语法</p>
<ul>
<li>ORDER BY 子句的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span><span class="operator">-</span>list </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>] </span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2, .. columnN] [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>];</span><br></pre></td></tr></table></figure></li>
<li>ASC 默认值，从小到大，升序排列</li>
<li>DESC 从大到小，降序排列</li>
</ul>
</li>
<li><p>您可以在 ORDER BY 子句中使用多个列，确保您使用的排序列在列清单中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">   select_list</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">   <span class="keyword">table</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    column_1 <span class="keyword">ASC</span>,</span><br><span class="line">    column_2 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>column_1 与 column_2 如果后面不指定排序规则，默认为 ASC 升序，以上语句按 column_1 升序，column_2 降序读取，等价如下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">   select_list</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">   <span class="keyword">table</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    column_1,</span><br><span class="line">    column_2 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面是一个实例，它会将结果按 NAME 和 SALARY 升序排序：</p>
<ul>
<li><code>sqlite&gt; SELECT * FROM COMPANY ORDER BY NAME, SALARY ASC;</code></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Group-By"><a href="#SQLite-Group-By" class="headerlink" title="SQLite Group By"></a>SQLite Group By</h2><ul>
<li><p>SQLite 的 GROUP BY 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。</p>
</li>
<li><p>在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。</p>
</li>
<li><p>语法</p>
<ul>
<li>下面给出了 GROUP BY 子句的基本语法。GROUP BY 子句必须放在 WHERE 子句中的条件之后，必须放在 ORDER BY 子句之前。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span><span class="operator">-</span>list</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [ conditions ]</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2....columnN</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2....columnN</span><br></pre></td></tr></table></figure></li>
<li>您可以在 GROUP BY 子句中使用多个列。确保您使用的分组列在列清单中。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-Having-子句"><a href="#SQLite-Having-子句" class="headerlink" title="SQLite Having 子句"></a>SQLite Having 子句</h2><ul>
<li><p>HAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。</p>
</li>
<li><p>WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。</p>
</li>
<li><p>语法</p>
<ul>
<li>下面是 HAVING 子句在 SELECT 查询中的位置：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br></pre></td></tr></table></figure></li>
<li>在一个查询中，HAVING 子句必须放在 GROUP BY 子句之后，必须放在 ORDER BY 子句之前。下面是包含 HAVING 子句的 SELECT 语句的语法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2</span><br><span class="line"><span class="keyword">FROM</span> table1, table2</span><br><span class="line"><span class="keyword">WHERE</span> [ conditions ]</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2</span><br><span class="line"><span class="keyword">HAVING</span> [ conditions ]</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1, column2</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>下面是一个实例，它将显示名称计数大于 2 的所有记录：</p>
<ul>
<li><code>sqlite &gt; SELECT * FROM COMPANY GROUP BY name HAVING count(name) &gt; 2;</code></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Distinct-关键字"><a href="#SQLite-Distinct-关键字" class="headerlink" title="SQLite Distinct 关键字"></a>SQLite Distinct 关键字</h2><ul>
<li><p>SQLite 的 DISTINCT 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。</p>
</li>
<li><p>有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得特别有意义，它只获取唯一一次记录，而不是获取重复记录。</p>
</li>
<li><p>语法</p>
<ul>
<li>用于消除重复记录的 DISTINCT 关键字的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column1, column2,.....columnN </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>现在，让我们在上述的 SELECT 查询中使用 DISTINCT 关键字：</p>
<ul>
<li><code>sqlite&gt; SELECT DISTINCT name FROM COMPANY;</code></li>
</ul>
</li>
</ul>
<h2 id="SQLite-约束"><a href="#SQLite-约束" class="headerlink" title="SQLite 约束"></a>SQLite 约束</h2><ul>
<li><p>约束是在表的数据列上强制执行的规则。这些是用来限制可以插入到表中的数据类型。这确保了数据库中数据的准确性和可靠性。</p>
</li>
<li><p>约束可以是列级或表级。列级约束仅适用于列，表级约束被应用到整个表。</p>
</li>
<li><p>以下是在 SQLite 中常用的约束</p>
<ul>
<li>NOT NULL 约束：确保某列不能有 NULL 值。</li>
<li>DEFAULT 约束：当某列没有指定值时，为该列提供默认值。</li>
<li>UNIQUE 约束：确保某列中的所有值是不同的。</li>
<li>PRIMARY Key 约束：唯一标识数据库表中的各行&#x2F;记录。</li>
<li>CHECK 约束：CHECK 约束确保某列中的所有值满足一定条件。</li>
</ul>
</li>
<li><p>NOT NULL 约束</p>
<ul>
<li>默认情况下，列可以保存 NULL 值。如果您不想某列有 NULL 值，那么需要在该列上定义此约束，指定在该列上不允许 NULL 值。</li>
<li>NULL 与没有数据是不一样的，它代表着未知的数据。</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>例如，下面的 SQLite 语句创建一个新的表 COMPANY，并增加了五列，其中 ID、NAME 和 AGE 三列指定不接受 NULL 值：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>DEFAULT 约束</p>
<ul>
<li>DEFAULT 约束在 INSERT INTO 语句没有提供一个特定的值时，为列提供一个默认值</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>例如，下面的 SQLite 语句创建一个新的表 COMPANY，并增加了五列。在这里，SALARY 列默认设置为 5000.00。所以当 INSERT INTO 语句没有为该列提供值时，该列将被设置为 5000.00。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span>    <span class="keyword">DEFAULT</span> <span class="number">50000.00</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>UNIQUE 约束</p>
<ul>
<li>UNIQUE 约束防止在一个特定的列存在两个记录具有相同的值。在 COMPANY 表中，例如，您可能要防止两个或两个以上的人具有相同的年龄。</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>例如，下面的 SQLite 语句创建一个新的表 COMPANY，并增加了五列。在这里，AGE 列设置为 UNIQUE，所以不能有两个相同年龄的记录：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span>    <span class="keyword">DEFAULT</span> <span class="number">50000.00</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>PRIMARY KEY 约束</p>
<ul>
<li>PRIMARY KEY 约束唯一标识数据库表中的每个记录。在一个表中可以有多个 UNIQUE 列，但只能有一个主键。在设计数据库表时，主键是很重要的。主键是唯一的 ID。</li>
<li>我们使用主键来引用表中的行。可通过把主键设置为其他表的外键，来创建表之间的关系。由于”长期存在编码监督”，在 SQLite 中，主键可以是 NULL，这是与其他数据库不同的地方。</li>
<li>主键是表中的一个字段，唯一标识数据库表中的各行&#x2F;记录。主键必须包含唯一值。主键列不能有 NULL 值。</li>
<li>一个表只能有一个主键，它可以由一个或多个字段组成。当多个字段作为主键，它们被称为复合键。</li>
<li>如果一个表在任何字段上定义了一个主键，那么在这些字段上不能有两个记录具有相同的值。</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>已经看到了我们创建以 ID 作为主键的 COMAPNY 表的各种实例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>CHECK 约束</p>
<ul>
<li>CHECK 约束启用输入一条记录要检查值的条件。如果条件值为 false，则记录违反了约束，且不能输入到表</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>例如，下面的 SQLite 创建一个新的表 COMPANY，并增加了五列。在这里，我们为 SALARY 列添加 CHECK，所以工资不能为零<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> COMPANY3(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span>    <span class="keyword">CHECK</span>(SALARY <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>删除约束</p>
<ul>
<li>SQLite 支持 ALTER TABLE 的有限子集。在 SQLite 中，ALTER TABLE 命令允许用户重命名表，或向现有表添加一个新的列。重命名列，删除一列，或从一个表中添加或删除约束都是不可能的。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-Join"><a href="#SQLite-Join" class="headerlink" title="SQLite Join"></a>SQLite Join</h2><ul>
<li><p>SQLite 的 Join 子句用于结合两个或多个数据库中表的记录。JOIN 是一种通过共同值来结合两个表中字段的手段。</p>
</li>
<li><p>SQL 定义了三种主要类型的连接：</p>
<ul>
<li>交叉连接 - CROSS JOIN</li>
<li>内连接 - INNER JOIN</li>
<li>外连接 - OUTER JOIN</li>
</ul>
</li>
<li><p>交叉连接 - CROSS JOIN</p>
<ul>
<li>交叉连接（CROSS JOIN）把第一个表的每一行与第二个表的每一行进行匹配。如果两个输入表分别有 x 和 y 行，则结果表有 x*y 行。由于交叉连接（CROSS JOIN）有可能产生非常大的表，使用时必须谨慎，只在适当的时候使用它们。</li>
<li>交叉连接的操作，它们都返回被连接的两个表所有数据行的笛卡尔积，返回到的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。</li>
<li>下面是交叉连接（CROSS JOIN）的语法：<ul>
<li><code>SELECT ... FROM table1 CROSS JOIN table2 ...</code></li>
</ul>
</li>
<li>基于上面的表，我们可以写一个交叉连接（CROSS JOIN），如下所示：<ul>
<li><code>sqlite&gt; SELECT EMP_ID, NAME, DEPT FROM COMPANY CROSS JOIN DEPARTMENT;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>内连接 - INNER JOIN</p>
<ul>
<li>内连接（INNER JOIN）根据连接谓词结合两个表（table1 和 table2）的列值来创建一个新的结果表。查询会把 table1 中的每一行与 table2 中的每一行进行比较，找到所有满足连接谓词的行的匹配对。当满足连接谓词时，A 和 B 行的每个匹配对的列值会合并成一个结果行。</li>
<li>内连接（INNER JOIN）是最常见的连接类型，是默认的连接类型。INNER 关键字是可选的。</li>
<li>下面是内连接（INNER JOIN）的语法：<ul>
<li><code>SELECT ... FROM table1 [INNER] JOIN table2 ON conditional_expression ...</code></li>
</ul>
</li>
<li>为了避免冗余，并保持较短的措辞，可以使用 USING 表达式声明内连接（INNER JOIN）条件。这个表达式指定一个或多个列的列表：<ul>
<li><code>SELECT ... FROM table1 JOIN table2 USING ( column1 ,... ) ...</code></li>
</ul>
</li>
<li>自然连接（NATURAL JOIN）类似于 JOIN…USING，只是它会自动测试存在两个表中的每一列的值之间相等值：<ul>
<li><code>SELECT ... FROM table1 NATURAL JOIN table2...</code></li>
</ul>
</li>
<li>基于上面的表，我们可以写一个内连接（INNER JOIN），如下所示：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="keyword">FROM</span> COMPANY <span class="keyword">INNER</span> <span class="keyword">JOIN</span> DEPARTMENT</span><br><span class="line">        <span class="keyword">ON</span> COMPANY.ID <span class="operator">=</span> DEPARTMENT.EMP_ID;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>外连接 - OUTER JOIN</p>
<ul>
<li>外连接（OUTER JOIN）是内连接（INNER JOIN）的扩展。虽然 SQL 标准定义了三种类型的外连接：LEFT、RIGHT、FULL，但 SQLite 只支持 左外连接（LEFT OUTER JOIN）。</li>
<li>外连接（OUTER JOIN）声明条件的方法与内连接（INNER JOIN）是相同的，使用 ON、USING 或 NATURAL 关键字来表达。最初的结果表以相同的方式进行计算。一旦主连接计算完成，外连接（OUTER JOIN）将从一个或两个表中任何未连接的行合并进来，外连接的列使用 NULL 值，将它们附加到结果表中。</li>
<li>下面是左外连接（LEFT OUTER JOIN）的语法：<ul>
<li><code>SELECT ... FROM table1 LEFT OUTER JOIN table2 ON conditional_expression ...</code></li>
</ul>
</li>
<li>为了避免冗余，并保持较短的措辞，可以使用 USING 表达式声明外连接（OUTER JOIN）条件。这个表达式指定一个或多个列的列表：<ul>
<li><code>SELECT ... FROM table1 LEFT OUTER JOIN table2 USING ( column1 ,... ) ...</code></li>
</ul>
</li>
<li>基于上面的表，我们可以写一个外连接（OUTER JOIN），如下所示：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> EMP_ID, NAME, DEPT <span class="keyword">FROM</span> COMPANY <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> DEPARTMENT</span><br><span class="line">        <span class="keyword">ON</span> COMPANY.ID <span class="operator">=</span> DEPARTMENT.EMP_ID;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Unions-子句"><a href="#SQLite-Unions-子句" class="headerlink" title="SQLite Unions 子句"></a>SQLite Unions 子句</h2><ul>
<li><p>SQLite的 UNION 子句&#x2F;运算符用于合并两个或多个 SELECT 语句的结果，不返回任何重复的行。</p>
</li>
<li><p>为了使用 UNION，每个 SELECT 被选择的列数必须是相同的，相同数目的列表达式，相同的数据类型，并确保它们有相同的顺序，但它们不必具有相同的长度</p>
</li>
<li><p>语法</p>
<ul>
<li>UNION 的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 [, column2 ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> column1 [, column2 ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure></li>
<li>这里给定的条件根据需要可以是任何表达式。</li>
</ul>
</li>
<li><p>UNION ALL 子句</p>
<ul>
<li>UNION ALL 运算符用于结合两个 SELECT 语句的结果，包括重复行。</li>
<li>适用于 UNION 的规则同样适用于 UNION ALL 运算符。</li>
<li>UNION ALL 的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 [, column2 ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> column1 [, column2 ]</span><br><span class="line"><span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure></li>
<li>这里给定的条件根据需要可以是任何表达式。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-NULL-值"><a href="#SQLite-NULL-值" class="headerlink" title="SQLite NULL 值"></a>SQLite NULL 值</h2><ul>
<li><p>SQLite 的 NULL 是用来表示一个缺失值的项。表中的一个 NULL 值是在字段中显示为空白的一个值。</p>
</li>
<li><p>带有 NULL 值的字段是一个不带有值的字段。NULL 值与零值或包含空格的字段是不同的，理解这点是非常重要的。</p>
</li>
<li><p>语法</p>
<ul>
<li>创建表时使用 NULL 的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQLite<span class="operator">&gt;</span> <span class="keyword">CREATE TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   NAME           TEXT    <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>     <span class="keyword">NOT NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>在这里，NOT NULL 表示列总是接受给定数据类型的显式值。这里有两个列我们没有使用 NOT NULL，这意味着这两个列可以为 NULL。</li>
<li>带有 NULL 值的字段在记录创建的时候可以保留为空。</li>
</ul>
</li>
<li><p>NULL 值在选择数据时会引起问题，因为当把一个未知的值与另一个值进行比较时，结果总是未知的，且不会包含在最后的结果中。</p>
</li>
<li><p>实例</p>
<ul>
<li>让我们使用 UPDATE 语句来设置一些允许空值的值为 NULL，如下所示：<ul>
<li><code>sqlite&gt; UPDATE COMPANY SET ADDRESS = NULL, SALARY = NULL where ID IN(6,7);</code></li>
</ul>
</li>
<li>接下来，让我们看看 IS NOT NULL 运算符的用法，它用来列出所有 SALARY 不为 NULL 的记录：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span>  ID, NAME, AGE, ADDRESS, SALARY</span><br><span class="line">        <span class="keyword">FROM</span> COMPANY</span><br><span class="line">        <span class="keyword">WHERE</span> SALARY <span class="keyword">IS</span> <span class="keyword">NOT NULL</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-别名"><a href="#SQLite-别名" class="headerlink" title="SQLite 别名"></a>SQLite 别名</h2><ul>
<li><p>您可以暂时把表或列重命名为另一个名字，这被称为别名。使用表别名是指在一个特定的 SQLite 语句中重命名表。重命名是临时的改变，在数据库中实际的表的名称不会改变。</p>
</li>
<li><p>列别名用来为某个特定的 SQLite 语句重命名表中的列。</p>
</li>
<li><p>语法</p>
<ul>
<li>表 别名的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2....</span><br><span class="line"><span class="keyword">FROM</span> table_name <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure></li>
<li>列 别名的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">AS</span> alias_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-触发器-Trigger"><a href="#SQLite-触发器-Trigger" class="headerlink" title="SQLite 触发器(Trigger)"></a>SQLite 触发器(Trigger)</h2><ul>
<li><p>SQLite 触发器（Trigger）是数据库的回调函数，它会在指定的数据库事件发生时自动执行&#x2F;调用。以下是关于 SQLite 的触发器（Trigger）的要点：</p>
<ul>
<li>SQLite 的触发器（Trigger）可以指定在特定的数据库表发生 DELETE、INSERT 或 UPDATE 时触发，或在一个或多个指定表的列发生更新时触发。</li>
<li>SQLite 只支持 FOR EACH ROW 触发器（Trigger），没有 FOR EACH STATEMENT 触发器（Trigger）。因此，明确指定 FOR EACH ROW 是可选的。</li>
<li>WHEN 子句和触发器（Trigger）动作可能访问使用表单 NEW.column-name 和 OLD.column-name 的引用插入、删除或更新的行元素，其中 column-name 是从与触发器关联的表的列的名称。</li>
<li>如果提供 WHEN 子句，则只针对 WHEN 子句为真的指定行执行 SQL 语句。如果没有提供 WHEN 子句，则针对所有行执行 SQL 语句。</li>
<li>BEFORE 或 AFTER 关键字决定何时执行触发器动作，决定是在关联行的插入、修改或删除之前或者之后执行触发器动作。</li>
<li>当触发器相关联的表删除时，自动删除触发器（Trigger）。</li>
<li>要修改的表必须存在于同一数据库中，作为触发器被附加的表或视图，且必须只使用 tablename，而不是 database.tablename。</li>
<li>一个特殊的 SQL 函数 RAISE() 可用于触发器程序内抛出异常。</li>
</ul>
</li>
<li><p>语法</p>
<ul>
<li>创建 触发器（Trigger） 的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TRIGGER</span> trigger_name [BEFORE<span class="operator">|</span>AFTER] event_name </span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="comment">-- 触发器逻辑....</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li>
<li>在这里，event_name 可以是在所提到的表 table_name 上的 INSERT、DELETE 和 UPDATE 数据库操作。您可以在表名后选择指定 FOR EACH ROW。</li>
<li>以下是在 UPDATE 操作上在表的一个或多个指定列上创建触发器（Trigger）的语法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">TRIGGER</span> trigger_name [BEFORE<span class="operator">|</span>AFTER] <span class="keyword">UPDATE</span> <span class="keyword">OF</span> column_name </span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="comment">-- 触发器逻辑....</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>列出触发器（TRIGGERS）</p>
<ul>
<li>您可以从 sqlite_master 表中列出所有触发器，如下所示：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name <span class="keyword">FROM</span> sqlite_master</span><br><span class="line"><span class="keyword">WHERE</span> type <span class="operator">=</span> <span class="string">&#x27;trigger&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>删除触发器（TRIGGERS）</p>
<ul>
<li>下面是 DROP 命令，可用于删除已有的触发器：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> trigger_name;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-索引-Index"><a href="#SQLite-索引-Index" class="headerlink" title="SQLite 索引(Index)"></a>SQLite 索引(Index)</h2><ul>
<li><p>索引（Index）是一种特殊的查找表，数据库搜索引擎用来加快数据检索。简单地说，索引是一个指向表中数据的指针。一个数据库中的索引与一本书的索引目录是非常相似的。</p>
</li>
<li><p>拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。</p>
</li>
<li><p>索引有助于加快 SELECT 查询和 WHERE 子句，但它会减慢使用 UPDATE 和 INSERT 语句时的数据输入。索引可以创建或删除，但不会影响数据。</p>
</li>
<li><p>使用 CREATE INDEX 语句创建索引，它允许命名索引，指定表及要索引的一列或多列，并指示索引是升序排列还是降序排列。</p>
</li>
<li><p>索引也可以是唯一的，与 UNIQUE 约束类似，在列上或列组合上防止重复条目。</p>
</li>
<li><p>CREATE INDEX 命令</p>
<ul>
<li>CREATE INDEX 的基本语法如下：</li>
<li><code>CREATE INDEX index_name ON table_name;</code></li>
</ul>
</li>
<li><p>单列索引</p>
<ul>
<li>单列索引是一个只基于表的一个列上创建的索引。基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>唯一索引</p>
<ul>
<li>使用唯一索引不仅是为了性能，同时也为了数据的完整性。唯一索引不允许任何重复的值插入到表中。基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name</span><br><span class="line"><span class="keyword">on</span> table_name (column_name);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>组合索引</p>
<ul>
<li>组合索引是基于一个表的两个或多个列上创建的索引。基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">on</span> table_name (column1, column2);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>是否要创建一个单列索引还是组合索引，要考虑到您在作为查询过滤条件的 WHERE 子句中使用非常频繁的列。</p>
</li>
<li><p>如果只使用到一个列，则选择使用单列索引。如果在作为过滤的 WHERE 子句中有两个或多个列经常使用，则选择使用组合索引。</p>
</li>
<li><p>隐式索引</p>
<ul>
<li>隐式索引是在创建对象时，由数据库服务器自动创建的索引。索引自动创建为主键约束和唯一约束。</li>
</ul>
</li>
<li><p>DROP INDEX 命令</p>
<ul>
<li>一个索引可以使用 SQLite 的 DROP 命令删除。当删除索引时应特别注意，因为性能可能会下降或提高。</li>
<li>基本语法如下：<ul>
<li><code>DROP INDEX index_name;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>什么情况下要避免使用索引？</p>
<ul>
<li>虽然索引的目的在于提高数据库的性能，但这里有几个情况需要避免使用索引。使用索引时，应重新考虑下列准则：<ul>
<li>索引不应该使用在较小的表上。</li>
<li>索引不应该使用在有频繁的大批量的更新或插入操作的表上。</li>
<li>索引不应该使用在含有大量的 NULL 值的列上。</li>
<li>索引不应该使用在频繁操作的列上。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SQLite-Indexed-By"><a href="#SQLite-Indexed-By" class="headerlink" title="SQLite Indexed By"></a>SQLite Indexed By</h2><ul>
<li><p>“INDEXED BY index-name” 子句规定必须需要命名的索引来查找前面表中值。</p>
</li>
<li><p>如果索引名 index-name 不存在或不能用于查询，然后 SQLite 语句的准备失败。</p>
</li>
<li><p>“NOT INDEXED” 子句规定当访问前面的表（包括由 UNIQUE 和 PRIMARY KEY 约束创建的隐式索引）时，没有使用索引。</p>
</li>
<li><p>然而，即使指定了 “NOT INDEXED”，INTEGER PRIMARY KEY 仍然可以被用于查找条目。</p>
</li>
<li><p>语法</p>
<ul>
<li>下面是 INDEXED BY 子句的语法，它可以与 DELETE、UPDATE 或 SELECT 语句一起使用：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span><span class="operator">|</span><span class="keyword">DELETE</span><span class="operator">|</span><span class="keyword">UPDATE</span> column1, column2...</span><br><span class="line">INDEXED <span class="keyword">BY</span> (index_name)</span><br><span class="line">table_name</span><br><span class="line"><span class="keyword">WHERE</span> (<span class="keyword">CONDITION</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Alter-命令"><a href="#SQLite-Alter-命令" class="headerlink" title="SQLite Alter 命令"></a>SQLite Alter 命令</h2><ul>
<li><p>SQLite 的 ALTER TABLE 命令不通过执行一个完整的转储和数据的重载来修改已有的表。您可以使用 ALTER TABLE 语句重命名表，使用 ALTER TABLE 语句还可以在已有的表中添加额外的列。</p>
</li>
<li><p>在 SQLite 中，除了重命名表和在已有的表中添加列，ALTER TABLE 命令不支持其他操作。</p>
</li>
<li><p>语法</p>
<ul>
<li>用来重命名已有的表的 ALTER TABLE 的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> database_name.table_name RENAME <span class="keyword">TO</span> new_table_name;</span><br></pre></td></tr></table></figure></li>
<li>用来在已有的表中添加一个新的列的 ALTER TABLE 的基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> database_name.table_name <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> column_def...;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Truncate-Table"><a href="#SQLite-Truncate-Table" class="headerlink" title="SQLite Truncate Table"></a>SQLite Truncate Table</h2><ul>
<li><p>在 SQLite 中，并没有 TRUNCATE TABLE 命令，但可以使用 SQLite 的 DELETE 命令从已有的表中删除全部的数据。</p>
</li>
<li><p>语法</p>
<ul>
<li>DELETE 命令的基本语法如下：<ul>
<li><code>sqlite&gt; DELETE FROM table_name;</code></li>
</ul>
</li>
<li>但这种方法无法将递增数归零。</li>
<li>如果要将递增数归零，可以使用以下方法：<ul>
<li><code>sqlite&gt; DELETE FROM sqlite_sequence WHERE name = &#39;table_name&#39;;</code></li>
</ul>
</li>
<li>当 SQLite 数据库中包含自增列时，会自动建立一个名为 sqlite_sequence 的表。这个表包含两个列：name 和 seq。name 记录自增列所在的表，seq 记录当前序号（下一条记录的编号就是当前序号加 1）。如果想把某个自增列的序号归零，只需要修改 sqlite_sequence 表就可以了。</li>
</ul>
</li>
</ul>
<h2 id="SQLite-视图-View"><a href="#SQLite-视图-View" class="headerlink" title="SQLite 视图(View)"></a>SQLite 视图(View)</h2><ul>
<li>视图（View）只不过是通过相关的名称存储在数据库中的一个 SQLite 语句。视图（View）实际上是一个以预定义的 SQLite 查询形式存在的表的组合。</li>
<li>视图（View）可以包含一个表的所有行或从一个或多个表选定行。视图（View）可以从一个或多个表创建，这取决于要创建视图的 SQLite 查询。</li>
<li>视图（View）是一种虚表，允许用户实现以下几点：<ul>
<li>用户或用户组查找结构数据的方式更自然或直观。</li>
<li>限制数据访问，用户只能看到有限的数据，而不是完整的表。</li>
<li>汇总各种表中的数据，用于生成报告。</li>
</ul>
</li>
<li>SQLite 视图是只读的，因此可能无法在视图上执行 DELETE、INSERT 或 UPDATE 语句。但是可以在视图上创建一个触发器，当尝试 DELETE、INSERT 或 UPDATE 视图时触发，需要做的动作在触发器内容中定义。</li>
</ul>
<h2 id="SQLite-事务-Transaction"><a href="#SQLite-事务-Transaction" class="headerlink" title="SQLite 事务(Transaction)"></a>SQLite 事务(Transaction)</h2><ul>
<li><p>事务（Transaction）是一个对数据库执行工作单元。事务（Transaction）是以逻辑顺序完成的工作单位或序列，可以是由用户手动操作完成，也可以是由某种数据库程序自动完成。</p>
</li>
<li><p>事务（Transaction）是指一个或多个更改数据库的扩展。例如，如果您正在创建一个记录或者更新一个记录或者从表中删除一个记录，那么您正在该表上执行事务。重要的是要控制事务以确保数据的完整性和处理数据库错误。</p>
</li>
<li><p>实际上，您可以把许多的 SQLite 查询联合成一组，把所有这些放在一起作为事务的一部分进行执行。</p>
</li>
<li><p>事务的属性</p>
<ul>
<li>事务（Transaction）具有以下四个标准属性，通常根据首字母缩写为 ACID：<ul>
<li>原子性（Atomicity）：确保工作单位内的所有操作都成功完成，否则，事务会在出现故障时终止，之前的操作也会回滚到以前的状态。</li>
<li>一致性（Consistency）：确保数据库在成功提交的事务上正确地改变状态。</li>
<li>隔离性（Isolation）：使事务操作相互独立和透明。</li>
<li>持久性（Durability）：确保已提交事务的结果或效果在系统发生故障的情况下仍然存在。</li>
</ul>
</li>
</ul>
</li>
<li><p>事务控制</p>
<ul>
<li>使用下面的命令来控制事务：<ul>
<li>BEGIN TRANSACTION：开始事务处理。</li>
<li>COMMIT：保存更改，或者可以使用 END TRANSACTION 命令。</li>
<li>ROLLBACK：回滚所做的更改。</li>
</ul>
</li>
<li>事务控制命令只与 DML 命令 INSERT、UPDATE 和 DELETE 一起使用。他们不能在创建表或删除表时使用，因为这些操作在数据库中是自动提交的。</li>
</ul>
</li>
<li><p>BEGIN TRANSACTION 命令</p>
<ul>
<li>事务（Transaction）可以使用 BEGIN TRANSACTION 命令或简单的 BEGIN 命令来启动。此类事务通常会持续执行下去，直到遇到下一个 COMMIT 或 ROLLBACK 命令。不过在数据库关闭或发生错误时，事务处理也会回滚。以下是启动一个事务的简单语法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>COMMIT 命令</p>
<ul>
<li>COMMIT 命令是用于把事务调用的更改保存到数据库中的事务命令。</li>
<li>COMMIT 命令把自上次 COMMIT 或 ROLLBACK 命令以来的所有事务保存到数据库。</li>
<li>COMMIT 命令的语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> TRANSACTION;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>ROLLBACK 命令</p>
<ul>
<li>ROLLBACK 命令是用于撤消尚未保存到数据库的事务的事务命令。</li>
<li>ROLLBACK 命令只能用于撤销自上次发出 COMMIT 或 ROLLBACK 命令以来的事务。</li>
<li>ROLLBACK 命令的语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-子查询"><a href="#SQLite-子查询" class="headerlink" title="SQLite 子查询"></a>SQLite 子查询</h2><ul>
<li><p>子查询或称为内部查询、嵌套查询，指的是在 SQLite 查询中的 WHERE 子句中嵌入查询语句。</p>
</li>
<li><p>一个 SELECT 语句的查询结果能够作为另一个语句的输入值。</p>
</li>
<li><p>子查询可以与 SELECT、INSERT、UPDATE 和 DELETE 语句一起使用，可伴随着使用运算符如 &#x3D;、&lt;、&gt;、&gt;&#x3D;、&lt;&#x3D;、IN、BETWEEN 等。</p>
</li>
<li><p>以下是子查询必须遵循的几个规则：</p>
<ul>
<li>子查询必须用括号括起来。</li>
<li>子查询在 SELECT 子句中只能有一个列，除非在主查询中有多列，与子查询的所选列进行比较。</li>
<li>ORDER BY 不能用在子查询中，虽然主查询可以使用 ORDER BY。可以在子查询中使用 GROUP BY，功能与 ORDER BY 相同。</li>
<li>子查询返回多于一行，只能与多值运算符一起使用，如 IN 运算符。</li>
<li>BETWEEN 运算符不能与子查询一起使用，但是，BETWEEN 可在子查询内使用。</li>
</ul>
</li>
<li><p>SELECT 语句中的子查询使用</p>
<ul>
<li>子查询通常与 SELECT 语句一起使用。基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name [, column_name ]</span><br><span class="line"><span class="keyword">FROM</span>   table1 [, table2 ]</span><br><span class="line"><span class="keyword">WHERE</span>  column_name OPERATOR</span><br><span class="line">      (<span class="keyword">SELECT</span> column_name [, column_name ]</span><br><span class="line">      <span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">      [<span class="keyword">WHERE</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>INSERT 语句中的子查询使用</p>
<ul>
<li>子查询也可以与 INSERT 语句一起使用。INSERT 语句使用子查询返回的数据插入到另一个表中。在子查询中所选择的数据可以用任何字符、日期或数字函数修改。</li>
<li>基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> table_name [ (column1 [, column2 ]) ]</span><br><span class="line">           <span class="keyword">SELECT</span> [ <span class="operator">*</span><span class="operator">|</span>column1 [, column2 ]</span><br><span class="line">           <span class="keyword">FROM</span> table1 [, table2 ]</span><br><span class="line">           [ <span class="keyword">WHERE</span> <span class="keyword">VALUE</span> OPERATOR ]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>UPDATE 语句中的子查询使用</p>
<ul>
<li>子查询可以与 UPDATE 语句结合使用。当通过 UPDATE 语句使用子查询时，表中单个或多个列被更新</li>
<li>基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">SET</span> column_name <span class="operator">=</span> new_value</span><br><span class="line">[ <span class="keyword">WHERE</span> OPERATOR [ <span class="keyword">VALUE</span> ]</span><br><span class="line">   (<span class="keyword">SELECT</span> COLUMN_NAME</span><br><span class="line">   <span class="keyword">FROM</span> TABLE_NAME)</span><br><span class="line">   [ <span class="keyword">WHERE</span>) ]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>DELETE 语句中的子查询使用</p>
<ul>
<li>子查询可以与 DELETE 语句结合使用，就像上面提到的其他语句一样。</li>
<li>基本语法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> TABLE_NAME</span><br><span class="line">[ <span class="keyword">WHERE</span> OPERATOR [ <span class="keyword">VALUE</span> ]</span><br><span class="line">   (<span class="keyword">SELECT</span> COLUMN_NAME</span><br><span class="line">   <span class="keyword">FROM</span> TABLE_NAME)</span><br><span class="line">   [ <span class="keyword">WHERE</span>) ]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Autoincrement-自动递增"><a href="#SQLite-Autoincrement-自动递增" class="headerlink" title="SQLite Autoincrement (自动递增)"></a>SQLite Autoincrement (自动递增)</h2><ul>
<li><p>SQLite 的 AUTOINCREMENT 是一个关键字，用于表中的字段值自动递增。我们可以在创建表时在特定的列名称上使用 AUTOINCREMENT 关键字实现该字段值的自动增加。</p>
</li>
<li><p>关键字 AUTOINCREMENT 只能用于整型（INTEGER）字段。</p>
</li>
<li><p>语法</p>
<ul>
<li>AUTOINCREMENT 关键字的基本用法如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> table_name(</span><br><span class="line">   column1 <span class="type">INTEGER</span> AUTOINCREMENT,</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>假设要创建的 COMPANY 表如下所示：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">CREATE TABLE</span> COMPANY(</span><br><span class="line">   ID <span class="type">INTEGER</span> <span class="keyword">PRIMARY KEY</span>   AUTOINCREMENT,</span><br><span class="line">   NAME           TEXT      <span class="keyword">NOT NULL</span>,</span><br><span class="line">   AGE            <span class="type">INT</span>       <span class="keyword">NOT NULL</span>,</span><br><span class="line">   ADDRESS        <span class="type">CHAR</span>(<span class="number">50</span>),</span><br><span class="line">   SALARY         <span class="type">REAL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-Explain-解释"><a href="#SQLite-Explain-解释" class="headerlink" title="SQLite Explain (解释)"></a>SQLite Explain (解释)</h2><ul>
<li><p>在 SQLite 语句之前，可以使用 “EXPLAIN” 关键字或 “EXPLAIN QUERY PLAN” 短语，用于描述表的细节。</p>
</li>
<li><p>如果省略了 EXPLAIN 关键字或短语，任何的修改都会引起 SQLite 语句的查询行为，并返回有关 SQLite 语句如何操作的信息。</p>
<ul>
<li>来自 EXPLAIN 和 EXPLAIN QUERY PLAN 的输出只用于交互式分析和排除故障。</li>
<li>输出格式的细节可能会随着 SQLite 版本的不同而有所变化。</li>
<li>应用程序不应该使用 EXPLAIN 或 EXPLAIN QUERY PLAN，因为其确切的行为是可变的且只有部分会被记录。</li>
</ul>
</li>
<li><p>语法</p>
<ul>
<li>EXPLAIN 的语法如下：<ul>
<li><code>EXPLAIN [SQLite Query]</code></li>
</ul>
</li>
<li>EXPLAIN QUERY PLAN 的语法如下：<ul>
<li><code>EXPLAIN  QUERY PLAN [SQLite Query]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="SQLite-Vacuum"><a href="#SQLite-Vacuum" class="headerlink" title="SQLite Vacuum"></a>SQLite Vacuum</h2><ul>
<li>VACUUM 命令通过复制主数据库中的内容到一个临时数据库文件，然后清空主数据库，并从副本中重新载入原始的数据库文件。这消除了空闲页，把表中的数据排列为连续的，另外会清理数据库文件结构。</li>
<li>如果表中没有明确的整型主键（INTEGER PRIMARY KEY），VACUUM 命令可能会改变表中条目的行 ID（ROWID）。VACUUM 命令只适用于主数据库，附加的数据库文件是不可能使用 VACUUM 命令。</li>
<li>如果有一个活动的事务，VACUUM 命令就会失败。VACUUM 命令是一个用于内存数据库的任何操作。由于 VACUUM 命令从头开始重新创建数据库文件，所以 VACUUM 也可以用于修改许多数据库特定的配置参数。</li>
</ul>
<h2 id="SQLite-日期-时间"><a href="#SQLite-日期-时间" class="headerlink" title="SQLite 日期 &amp; 时间"></a>SQLite 日期 &amp; 时间</h2><ul>
<li><p>SQLite 支持以下五个日期和时间函数：</p>
</li>
<li><p><code>date(timestring, modifier, modifier, ...)</code>	                以 YYYY-MM-DD 格式返回日期。</p>
</li>
<li><p>   <code>time(timestring, modifier, modifier, ...)</code>	                以 HH:MM:SS 格式返回时间。</p>
</li>
<li><p>   <code>datetime(timestring, modifier, modifier, ...)</code>	            以 YYYY-MM-DD HH:MM:SS 格式返回。</p>
</li>
<li><p>   <code>julianday(timestring, modifier, modifier, ...)</code>	          这将返回从格林尼治时间的公元前 4714 年 11 月 24 日正午算起的天数。</p>
</li>
<li><p>   <code>strftime(format, timestring, modifier, modifier, ...)</code>	    这将根据第一个参数指定的格式字符串返回格式化的日期。具体格式见下边讲解。</p>
</li>
<li><p>上述五个日期和时间函数把时间字符串作为参数。时间字符串后跟零个或多个 modifier 修饰符。strftime() 函数也可以把格式字符串 format 作为其第一个参数。下面将为您详细讲解不同类型的时间字符串和修饰符。</p>
</li>
<li><p>时间字符串</p>
<ul>
<li>一个时间字符串可以采用下面任何一种格式：<ul>
<li>YYYY-MM-DD	                2010-12-30</li>
<li>YYYY-MM-DD HH:MM	          2010-12-30 12:10</li>
<li>YYYY-MM-DD HH:MM:SS.SSS	    2010-12-30 12:10:04.100</li>
<li>MM-DD-YYYY HH:MM	          12-30-2010 12:10</li>
<li>HH:MM	                      12:10</li>
<li>YYYY-MM-DDTHH:MM	          2010-12-30 12:10</li>
<li>HH:MM:SS	                  12:10:01</li>
<li>YYYYMMDD HHMMSS	            20101230 121001</li>
<li>now	                        2013-05-07</li>
</ul>
</li>
<li>您可以使用 “T” 作为分隔日期和时间的文字字符。</li>
</ul>
</li>
<li><p>修饰符（Modifier）</p>
<ul>
<li>时间字符串后边可跟着零个或多个的修饰符，这将改变有上述五个函数返回的日期和&#x2F;或时间。任何上述五大功能返回时间。修饰符应从左到右使用，下面列出了可在 SQLite 中使用的修饰符：<ul>
<li>NNN days</li>
<li>NNN hours</li>
<li>NNN minutes</li>
<li>NNN.NNNN seconds</li>
<li>NNN months</li>
<li>NNN years</li>
<li>start of month</li>
<li>start of year</li>
<li>start of day</li>
<li>weekday N</li>
<li>unixepoch</li>
<li>localtime</li>
<li>utc</li>
</ul>
</li>
</ul>
</li>
<li><p>格式化</p>
<ul>
<li>SQLite 提供了非常方便的函数 strftime() 来格式化任何日期和时间。您可以使用以下的替换来格式化日期和时间：</li>
<li>%d	一月中的第几天，01-31</li>
<li>%f	带小数部分的秒，SS.SSS</li>
<li>%H	小时，00-23</li>
<li>%j	一年中的第几天，001-366</li>
<li>%J	儒略日数，DDDD.DDDD</li>
<li>%m	月，00-12</li>
<li>%M	分，00-59</li>
<li>%s	从 1970-01-01 算起的秒数</li>
<li>%S	秒，00-59</li>
<li>%w	一周中的第几天，0-6 (0 is Sunday)</li>
<li>%W	一年中的第几周，01-53</li>
<li>%Y	年，YYYY</li>
<li>%%	% symbol</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>现在让我们使用 SQLite 提示符尝试不同的实例。下面是计算当前日期：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="type">date</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line"><span class="number">2013</span><span class="number">-05</span><span class="number">-07</span></span><br></pre></td></tr></table></figure></li>
<li>下面是计算当前月份的最后一天：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="type">date</span>(<span class="string">&#x27;now&#x27;</span>,<span class="string">&#x27;start of month&#x27;</span>,<span class="string">&#x27;+1 month&#x27;</span>,<span class="string">&#x27;-1 day&#x27;</span>);</span><br><span class="line"><span class="number">2013</span><span class="number">-05</span><span class="number">-31</span></span><br></pre></td></tr></table></figure></li>
<li>下面是计算给定 UNIX 时间戳 1092941466 的日期和时间：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> datetime(<span class="number">1092941466</span>, <span class="string">&#x27;unixepoch&#x27;</span>);</span><br><span class="line"><span class="number">2004</span><span class="number">-08</span><span class="number">-19</span> <span class="number">18</span>:<span class="number">51</span>:<span class="number">06</span></span><br></pre></td></tr></table></figure></li>
<li>下面是计算给定 UNIX 时间戳 1092941466 相对本地时区的日期和时间：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> datetime(<span class="number">1092941466</span>, <span class="string">&#x27;unixepoch&#x27;</span>, <span class="string">&#x27;localtime&#x27;</span>);</span><br><span class="line"><span class="number">2004</span><span class="number">-08</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">51</span>:<span class="number">06</span></span><br></pre></td></tr></table></figure></li>
<li>下面是计算当前的 UNIX 时间戳：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> strftime(<span class="string">&#x27;%s&#x27;</span>,<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line"><span class="number">1367926057</span></span><br></pre></td></tr></table></figure></li>
<li>下面是计算美国”独立宣言”签署以来的天数：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> julianday(<span class="string">&#x27;now&#x27;</span>) <span class="operator">-</span> julianday(<span class="string">&#x27;1776-07-04&#x27;</span>);</span><br><span class="line"><span class="number">86504.4775830326</span></span><br></pre></td></tr></table></figure></li>
<li>下面是计算从 2004 年某一特定时刻以来的秒数：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> strftime(<span class="string">&#x27;%s&#x27;</span>,<span class="string">&#x27;now&#x27;</span>) <span class="operator">-</span> strftime(<span class="string">&#x27;%s&#x27;</span>,<span class="string">&#x27;2004-01-01 02:34:56&#x27;</span>);</span><br><span class="line"><span class="number">295001572</span></span><br></pre></td></tr></table></figure></li>
<li>下面是计算当年 10 月的第一个星期二的日期：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="type">date</span>(<span class="string">&#x27;now&#x27;</span>,<span class="string">&#x27;start of year&#x27;</span>,<span class="string">&#x27;+9 months&#x27;</span>,<span class="string">&#x27;weekday 2&#x27;</span>);</span><br><span class="line"><span class="number">2013</span><span class="number">-10</span><span class="number">-01</span></span><br></pre></td></tr></table></figure></li>
<li>下面是计算从 UNIX 纪元算起的以秒为单位的时间（类似 strftime(‘%s’,’now’) ，不同的是这里有包括小数部分）：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> (julianday(<span class="string">&#x27;now&#x27;</span>) <span class="operator">-</span> <span class="number">2440587.5</span>)<span class="operator">*</span><span class="number">86400.0</span>;</span><br><span class="line"><span class="number">1367926077.12598</span></span><br></pre></td></tr></table></figure></li>
<li>在 UTC 与本地时间值之间进行转换，当格式化日期时，使用 utc 或 localtime 修饰符，如下所示：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="type">time</span>(<span class="string">&#x27;12:00&#x27;</span>, <span class="string">&#x27;localtime&#x27;</span>);</span><br><span class="line"><span class="number">05</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">sqlite<span class="operator">&gt;</span>  <span class="keyword">SELECT</span> <span class="type">time</span>(<span class="string">&#x27;12:00&#x27;</span>, <span class="string">&#x27;utc&#x27;</span>);</span><br><span class="line"><span class="number">19</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="SQLite-常用函数"><a href="#SQLite-常用函数" class="headerlink" title="SQLite 常用函数"></a>SQLite 常用函数</h2><ul>
<li><p>SQLite 有许多内置函数用于处理字符串或数字数据。下面列出了一些有用的 SQLite 内置函数，且所有函数都是大小写不敏感，这意味着您可以使用这些函数的小写形式或大写形式或混合形式。欲了解更多详情，请查看 SQLite 的官方文档：</p>
</li>
<li><p>SQLite COUNT 函数</p>
<ul>
<li>SQLite COUNT 聚集函数是用来计算一个数据库表中的行数。</li>
</ul>
</li>
<li><p>SQLite MAX 函数</p>
<ul>
<li>SQLite MAX 聚合函数允许我们选择某列的最大值。</li>
</ul>
</li>
<li><p>SQLite MIN 函数</p>
<ul>
<li>SQLite MIN 聚合函数允许我们选择某列的最小值。</li>
</ul>
</li>
<li><p>SQLite AVG 函数</p>
<ul>
<li>SQLite AVG 聚合函数计算某列的平均值。</li>
</ul>
</li>
<li><p>SQLite SUM 函数</p>
<ul>
<li>SQLite SUM 聚合函数允许为一个数值列计算总和。</li>
</ul>
</li>
<li><p>SQLite RANDOM 函数</p>
<ul>
<li>SQLite RANDOM 函数返回一个介于 -9223372036854775808 和 +9223372036854775807 之间的伪随机整数。</li>
</ul>
</li>
<li><p>SQLite ABS 函数</p>
<ul>
<li>SQLite ABS 函数返回数值参数的绝对值。</li>
</ul>
</li>
<li><p>SQLite UPPER 函数</p>
<ul>
<li>SQLite UPPER 函数把字符串转换为大写字母。</li>
</ul>
</li>
<li><p>SQLite LOWER 函数</p>
<ul>
<li>SQLite LOWER 函数把字符串转换为小写字母。</li>
</ul>
</li>
<li><p>SQLite LENGTH 函数</p>
<ul>
<li>SQLite LENGTH 函数返回字符串的长度。</li>
</ul>
</li>
<li><p>SQLite sqlite_version 函数</p>
<ul>
<li>SQLite sqlite_version 函数返回 SQLite 库的版本。</li>
</ul>
</li>
<li><p>实例</p>
<ul>
<li>SQLite COUNT 函数</li>
<li>SQLite COUNT 聚集函数是用来计算一个数据库表中的行数。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure></li>
<li>SQLite MAX 函数</li>
<li>SQLite MAX 聚合函数允许我们选择某列的最大值。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">max</span>(salary) <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure></li>
<li>SQLite MIN 函数</li>
<li>SQLite MIN 聚合函数允许我们选择某列的最小值。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">min</span>(salary) <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure></li>
<li>SQLite AVG 函数</li>
<li>SQLite AVG 聚合函数计算某列的平均值。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">avg</span>(salary) <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure></li>
<li>SQLite SUM 函数</li>
<li>SQLite SUM 聚合函数允许为一个数值列计算总和。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">sum</span>(salary) <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure></li>
<li>SQLite RANDOM 函数</li>
<li>SQLite RANDOM 函数返回一个介于 -9223372036854775808 和 +9223372036854775807 之间的伪随机整数。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> random() <span class="keyword">AS</span> Random;</span><br></pre></td></tr></table></figure></li>
<li>SQLite ABS 函数</li>
<li>SQLite ABS 函数返回数值参数的绝对值。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">abs</span>(<span class="number">5</span>), <span class="built_in">abs</span>(<span class="number">-15</span>), <span class="built_in">abs</span>(<span class="keyword">NULL</span>), <span class="built_in">abs</span>(<span class="number">0</span>), <span class="built_in">abs</span>(&quot;ABC&quot;);</span><br></pre></td></tr></table></figure></li>
<li>SQLite UPPER 函数</li>
<li>SQLite UPPER 函数把字符串转换为大写字母。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">upper</span>(name) <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure></li>
<li>SQLite LOWER 函数</li>
<li>SQLite LOWER 函数把字符串转换为小写字母。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">lower</span>(name) <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure></li>
<li>SQLite LENGTH 函数</li>
<li>SQLite LENGTH 函数返回字符串的长度。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name, length(name) <span class="keyword">FROM</span> COMPANY;</span><br></pre></td></tr></table></figure></li>
<li>SQLite sqlite_version 函数</li>
<li>SQLite sqlite_version 函数返回 SQLite 库的版本。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> sqlite_version() <span class="keyword">AS</span> <span class="string">&#x27;SQLite Version&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sql_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sql_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">sql_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>sql的相关理论知识</li>
</ul>
<h2 id="ODB-详解"><a href="#ODB-详解" class="headerlink" title="ODB 详解"></a>ODB 详解</h2><p>ODB（Object-Relational Mapping Database）是一个开源的 C++ 对象关系映射（ORM）工具，用于将 C++ 对象和数据库之间进行映射。它提供了一个简洁的接口和代码生成工具，用于自动生成和维护数据库访问代码。以下是关于 ODB 的一些详解：</p>
<ol>
<li><p><strong>定义数据模型</strong>：使用 ODB，你可以使用 C++ 类来定义数据模型。通过在类声明中添加 ODB 注解，你可以指定类和成员变量与数据库表格和字段的映射关系。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// ODB 表格声明</span></span><br><span class="line">        <span class="meta">#<span class="keyword">pragma</span> db table(<span class="string">&quot;people&quot;</span>)</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">DbTable</span> &#123;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="comment">// ODB 字段声明</span></span><br><span class="line">                <span class="meta">#<span class="keyword">pragma</span> db id</span></span><br><span class="line">                <span class="type">int</span> id;</span><br><span class="line">                std::string name;</span><br><span class="line">                <span class="type">int</span> age;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 成员变量与表格字段的映射</span></span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        std::string name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>代码生成工具</strong>：ODB 提供了一个代码生成工具，用于根据定义的数据模型自动生成数据库访问代码。你可以使用 ODB 编译器来处理类定义文件，并生成与数据库交互的代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">odb --std c++14 --database sqlite --generate-query --generate-schema Person.hpp</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询和持久化</strong>：使用 ODB，你可以通过简单的 C++ 语法进行数据库查询和持久化操作。ODB 提供了类型安全的查询接口，支持复杂的查询条件和结果集的处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">odb::query&lt;Person&gt; <span class="title">q</span><span class="params">(odb::query&lt;Person&gt;::name == <span class="string">&quot;John&quot;</span> &amp;&amp; odb::query&lt;Person&gt;::age &gt; <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">odb::result&lt;Person&gt; <span class="title">result</span><span class="params">(db.query&lt;Person&gt;(q))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; person : result) &#123;</span><br><span class="line">    <span class="comment">// 处理查询结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person;</span><br><span class="line">person.name = <span class="string">&quot;Jane&quot;</span>;</span><br><span class="line">person.age = <span class="number">25</span>;</span><br><span class="line">db.<span class="built_in">persist</span>(person);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事务处理</strong>：ODB 支持事务操作，你可以使用 <code>odb::transaction</code> 对象来管理一系列数据库操作的原子性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">odb::transaction <span class="title">txn</span><span class="params">(db)</span></span>;</span><br><span class="line">    <span class="comment">// 执行一系列的数据库操作</span></span><br><span class="line">    txn.<span class="built_in">commit</span>(); <span class="comment">// 提交事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理</strong>：ODB 使用异常来处理错误情况。当出现错误时，它会抛出异常，你可以使用 try-catch 块来捕获并处理这些异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> odb::exception&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>ODB 提供了详细的文档和示例代码，以帮助你更深入地了解和使用它。你可以在 ODB 的官方网站上找到更多信息：<a target="_blank" rel="noopener" href="https://www.codesynthesis.com/products/odb/">https://www.codesynthesis.com/products/odb/</a></p>
<p>需要注意的是，ODB 是一个功能强大且全面的 C++ ORM 工具，它提供了许多高级特性和灵活性。使用 ODB 需要一些学习和配置的成本，但它能够显著简化和加速与数据库的交互。</p>
<p>希望这些详解能够帮助你更好地理解和使用 ODB！如果你有更多问题，请随时提问。</p>
<h2 id="ORMpp-详解"><a href="#ORMpp-详解" class="headerlink" title="ORMpp 详解"></a>ORMpp 详解</h2><p>ORMpp 是一个轻量级的 C++ ORM（对象关系映射）库，专为 SQLite3 数据库设计。它提供了简单的接口和注解，用于定义数据模型和数据库关系。以下是关于 ORMpp 的一些详解：</p>
<ol>
<li><p><strong>定义数据模型</strong>：使用 ORMpp，你可以使用 C++ 结构体或类来定义数据模型。你可以使用注解来标记成员变量，指定表格名称、字段名称、字段类型和约束等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="built_in">ORMPP_ENTITY</span>(Person) <span class="comment">// 声明实体</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ORMPP_ID</span>(<span class="type">int</span>, id) <span class="comment">// 主键字段</span></span><br><span class="line">    <span class="built_in">ORMPP_FIELD</span>(std::string, name) <span class="comment">// 字符串字段</span></span><br><span class="line">    <span class="built_in">ORMPP_FIELD</span>(<span class="type">int</span>, age) <span class="comment">// 整数字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据库迁移</strong>：ORMpp 支持数据库迁移，可以自动创建和更新数据库表格结构。你可以使用 <code>ormpp::data_migration</code> 对象来定义表格的创建、修改和删除操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ormpp::data_migration dm;</span><br><span class="line">dm.<span class="built_in">create_table</span>&lt;Person&gt;(); <span class="comment">// 创建表格</span></span><br><span class="line">dm.<span class="built_in">add_column</span>&lt;Person&gt;(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;TEXT&quot;</span>); <span class="comment">// 添加字段</span></span><br><span class="line">dm.<span class="built_in">drop_table</span>&lt;Person&gt;(); <span class="comment">// 删除表格</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询构建器</strong>：ORMpp 提供了查询构建器，使得构建 SQL 查询变得更加简单。你可以使用链式方法来构建查询条件、排序和限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ormpp::sql_query query;</span><br><span class="line">query.<span class="built_in">select</span>(<span class="string">&quot;*&quot;</span>).<span class="built_in">from</span>&lt;Person&gt;().<span class="built_in">where</span>(ormpp::<span class="built_in">c</span>(&amp;Person::age) &gt; <span class="number">18</span>).<span class="built_in">order_by</span>(<span class="string">&quot;name&quot;</span>).<span class="built_in">limit</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> results = db.<span class="built_in">query</span>(query);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事务处理</strong>：ORMpp 支持事务操作，你可以使用 <code>ormpp::transaction</code> 对象来管理一系列数据库操作的原子性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">ormpp::transaction <span class="title">txn</span><span class="params">(db)</span></span>;</span><br><span class="line">    <span class="comment">// 执行一系列的数据库操作</span></span><br><span class="line">    txn.<span class="built_in">commit</span>(); <span class="comment">// 提交事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理</strong>：ORMpp 使用异常来处理错误情况。当出现错误时，它会抛出异常，你可以使用 try-catch 块来捕获并处理这些异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>ORMpp 提供了清晰的文档和示例代码，以帮助你更详细地了解和使用它。你可以在 ORMpp 的 GitHub 页面上找到更多信息：<a target="_blank" rel="noopener" href="https://github.com/qicosmos/ormpp">https://github.com/qicosmos/ormpp</a></p>
<p>需要注意的是，ORMpp 是一个轻量级的 C++ ORM 库，它在简化 SQLite3 数据库的使用过程中提供了便捷的接口和功能。但在使用之前，你仍然需要熟悉 SQL 查询语句和 SQLite3 数据库的概念。</p>
<p>希望这些详解能够帮助你更好地理解和使用 ORMpp！如果你有更多问题，请随时提问。</p>
<h2 id="SQLite-Modern-C-详解"><a href="#SQLite-Modern-C-详解" class="headerlink" title="SQLite Modern C++ 详解"></a>SQLite Modern C++ 详解</h2><p>SQLite Modern C++ 是一个基于 C++11 的轻量级 SQLite3 封装库，提供了简单而直观的接口，使在 C++ 项目中使用 SQLite3 数据库更加便捷。以下是关于 SQLite Modern C++ 的一些详解：</p>
<ol>
<li><p><strong>面向对象接口</strong>：SQLite Modern C++ 提供了面向对象的接口，使用类和方法来操作数据库。你可以创建表格类来表示数据库表格，使用成员变量和方法来操作表格中的数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义表格类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据</span></span><br><span class="line">Person person&#123;<span class="number">1</span>, <span class="string">&quot;John Doe&quot;</span>, <span class="number">25</span>&#125;;</span><br><span class="line">db.<span class="built_in">insert</span>(person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line"><span class="keyword">auto</span> results = db.<span class="built_in">select</span>&lt;Person&gt;(<span class="string">&quot;SELECT * FROM people&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; person : results) &#123;</span><br><span class="line">    <span class="comment">// 处理查询结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类型安全</strong>：SQLite Modern C++ 在运行时执行类型检查，确保查询和绑定的类型正确。这可以避免在 SQL 查询中出现类型不匹配的错误。</p>
</li>
<li><p><strong>查询构建器</strong>：SQLite Modern C++ 提供了查询构建器，允许你以链式方式构建 SQL 查询，而不需要手动拼接 SQL 语句。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> query = db</span><br><span class="line">    .<span class="built_in">select</span>(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>)</span><br><span class="line">    .<span class="built_in">from</span>(<span class="string">&quot;people&quot;</span>)</span><br><span class="line">    .<span class="built_in">where</span>(<span class="string">&quot;age &gt; ?&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    .<span class="built_in">order_by</span>(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    .<span class="built_in">limit</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> results = query.<span class="built_in">execute</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事务处理</strong>：SQLite Modern C++ 支持事务操作，你可以使用 <code>transaction</code> 对象来管理一系列数据库操作的原子性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">transaction <span class="title">txn</span><span class="params">(db)</span></span>;</span><br><span class="line">    <span class="comment">// 执行一系列的数据库操作</span></span><br><span class="line">    txn.<span class="built_in">commit</span>(); <span class="comment">// 提交事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理</strong>：SQLite Modern C++ 使用异常来处理错误情况。当出现错误时，它会抛出异常，你可以使用 try-catch 块来捕获并处理这些异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>SQLite Modern C++ 提供了清晰的文档和示例代码，以帮助你更详细地了解和使用它。你可以在 SQLite Modern C++ 的 GitHub 页面上找到更多信息：<a target="_blank" rel="noopener" href="https://github.com/SqliteModernCpp/sqlite_modern_cpp">https://github.com/SqliteModernCpp/sqlite_modern_cpp</a></p>
<p>需要注意的是，SQLite Modern C++ 是一个轻量级的封装库，它在简化 SQLite3 数据库的使用过程中提供了便捷的接口，但在使用之前，你仍然需要熟悉 SQL 查询语句和 SQLite3 数据库的概念。</p>
<p>希望这些详解能够帮助你更好地理解和使用 SQLite Modern C++！如果你有更多问题，请随时提问。</p>
<h2 id="SQLite3-ORM-常用第三方库"><a href="#SQLite3-ORM-常用第三方库" class="headerlink" title="SQLite3 ORM 常用第三方库"></a>SQLite3 ORM 常用第三方库</h2><p>在 C++ 中，有几个常用的第三方库可用于提供 SQLite3 ORM（对象关系映射）功能。以下是一些常用的 C++ SQLite3 ORM 第三方库：</p>
<ol>
<li><p>**SQLite Modern C++**：SQLite Modern C++ 是一个轻量级的 C++ 封装库，提供了简单而直观的接口，使得在 C++ 项目中使用 SQLite3 数据库更加便捷。它支持对象关系映射和查询构建器，并提供了对数据库的增删改查操作的封装。</p>
<p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/SqliteModernCpp/sqlite_modern_cpp">https://github.com/SqliteModernCpp/sqlite_modern_cpp</a></p>
</li>
<li><p><strong>SQLiteCpp</strong>：SQLiteCpp 是一个基于 C++11 的 SQLite3 封装库，提供了面向对象的接口，使得在 C++ 项目中使用 SQLite3 更加简单和方便。它支持对象关系映射和事务处理，并提供了简洁的 API 来进行数据库操作。</p>
<p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/SRombauts/SQLiteCpp">https://github.com/SRombauts/SQLiteCpp</a></p>
</li>
<li><p><strong>ORMpp</strong>：ORMpp 是一个轻量级的 C++ ORM 库，专为 SQLite3 数据库设计。它提供了简单的接口和注解，用于定义数据模型和数据库关系。ORMpp 支持数据库迁移、查询构建器和事务处理等功能。</p>
<p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/iansimon/ormpp">https://github.com/iansimon/ormpp</a></p>
</li>
<li><p><strong>Qt SQL</strong>：Qt 是一个功能强大的 C++ 框架，其中的 Qt SQL 模块提供了对各种数据库的访问功能，包括 SQLite3。使用 Qt SQL，你可以通过对象关系映射和查询构建器来操作 SQLite3 数据库。</p>
<p>官方网站：<a target="_blank" rel="noopener" href="https://www.qt.io/">https://www.qt.io/</a></p>
</li>
</ol>
<p>这些库都可以帮助你在 C++ 中使用 SQLite3 数据库，并提供了不同程度的 ORM 功能。你可以根据项目需求、库的易用性和适配性来选择最适合的库。</p>
<p>需要注意的是，这些库都是第三方工具，你需要根据你的项目要求和预期的功能选择适合的库，并仔细阅读它们的文档和示例代码以了解如何使用它们。</p>
<p>希望这些信息对你有帮助！如有更多问题，请随时提问。</p>
<h2 id="C-REST-SDK-详解"><a href="#C-REST-SDK-详解" class="headerlink" title="C++ REST SDK 详解"></a>C++ REST SDK 详解</h2><p>C++ REST SDK（又称为 Casablanca）是一个功能强大的 C++ 库，用于构建基于 HTTP 的客户端和服务器应用程序。它提供了一组丰富的功能和工具，用于处理网络请求、JSON 解析、异步任务等。以下是关于 C++ REST SDK 的一些详解：</p>
<ol>
<li><p><strong>HTTP 客户端</strong>：C++ REST SDK 提供了一个强大的 HTTP 客户端库，用于发送和接收 HTTP 请求和响应。你可以通过创建 <code>http_client</code> 对象，指定请求的 URI、方法、头部、消息正文等来发起 HTTP 请求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">web::http::<span class="function">client::http_client <span class="title">client</span><span class="params">(U(<span class="string">&quot;http://example.com&quot;</span>))</span></span>;</span><br><span class="line">web::http::http_response response = client.<span class="built_in">request</span>(web::http::methods::GET).<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>HTTP 服务器</strong>：C++ REST SDK 允许你创建基于 HTTP 的服务器应用程序。你可以创建一个 <code>http_listener</code> 对象，并为特定的 URI 和方法注册处理程序来处理传入的请求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">web::http::experimental::<span class="function">listener::http_listener <span class="title">listener</span><span class="params">(U(<span class="string">&quot;http://localhost:8080&quot;</span>))</span></span>;</span><br><span class="line">listener.<span class="built_in">support</span>(web::http::methods::GET, [](web::http::http_request request) &#123;</span><br><span class="line">    <span class="comment">// 处理 GET 请求</span></span><br><span class="line">&#125;);</span><br><span class="line">listener.<span class="built_in">open</span>().<span class="built_in">wait</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异步任务和并发</strong>：C++ REST SDK 使用异步任务模型来处理并发操作。它提供了 <code>pplx::task</code> 类，用于处理异步操作和等待任务完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pplx::task&lt;std::string&gt; task = client.<span class="built_in">request</span>(web::http::methods::GET).<span class="built_in">then</span>([](web::http::http_response response) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="built_in">extract_string</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">task.<span class="built_in">then</span>([](<span class="type">const</span> std::string&amp; content) &#123;</span><br><span class="line">    <span class="comment">// 处理异步任务结果</span></span><br><span class="line">&#125;).<span class="built_in">wait</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>JSON 解析和序列化</strong>：C++ REST SDK 提供了用于解析和序列化 JSON 数据的工具。你可以使用 <code>web::json::value</code> 类来表示和操作 JSON 对象和数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">web::json::value json;</span><br><span class="line">json[<span class="built_in">U</span>(<span class="string">&quot;name&quot;</span>)] = web::json::value::<span class="built_in">string</span>(<span class="built_in">U</span>(<span class="string">&quot;John&quot;</span>));</span><br><span class="line">json[<span class="built_in">U</span>(<span class="string">&quot;age&quot;</span>)] = web::json::value::<span class="built_in">number</span>(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">web::json::value::<span class="type">string_t</span> name = json[<span class="built_in">U</span>(<span class="string">&quot;name&quot;</span>)].<span class="built_in">as_string</span>();</span><br><span class="line"><span class="type">int</span> age = json[<span class="built_in">U</span>(<span class="string">&quot;age&quot;</span>)].<span class="built_in">as_integer</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>其他功能</strong>：C++ REST SDK 还提供了许多其他功能，如支持 HTTPS、网络代理、cookie 管理、身份验证等。</p>
</li>
</ol>
<p>C++ REST SDK 的 GitHub 页面提供了详细的文档和示例代码，以帮助你更深入地了解和使用它：<a target="_blank" rel="noopener" href="https://github.com/microsoft/cpprestsdk">https://github.com/microsoft/cpprestsdk</a></p>
<p>C++ REST SDK 是一个强大而全面的库，适用于构建基于 HTTP 的客户端和服务器应用程序。它可以帮助你轻松处理网络请求、JSON 数据和异步操作。</p>
<p>希望这些详解能够帮助你更好地理解和使用 C++ REST SDK！如果你有更多问题，请随时提问。</p>
<h2 id="OTL-详解"><a href="#OTL-详解" class="headerlink" title="OTL 详解"></a>OTL 详解</h2><p>OTL（OCCI Template Library）是一个用于 C++ 的通用数据库访问库，它提供了高性能和灵活的接口，用于访问多种数据库。以下是关于 OTL 的一些详解：</p>
<ol>
<li><p><strong>支持多种数据库</strong>：OTL 支持多种常见的数据库系统，包括 Oracle、Microsoft SQL Server、IBM DB2、MySQL、PostgreSQL 等。你可以使用相同的接口和代码来访问不同类型的数据库，而不需要学习和使用特定数据库的 API。</p>
</li>
<li><p><strong>面向对象接口</strong>：OTL 提供了面向对象的接口，通过类和方法来操作数据库。它使用了现代 C++ 特性，如模板和 RAII（资源获取即初始化），使得代码更加清晰和易于维护。</p>
</li>
<li><p><strong>连接管理</strong>：使用 OTL，你可以通过提供连接字符串来建立和管理与数据库的连接。连接字符串包括数据库类型、主机名、端口号、用户名、密码等信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">otl_connect db;</span><br><span class="line">db.<span class="built_in">rlogon</span>(<span class="string">&quot;username/password@tnsname&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询执行</strong>：使用 OTL，你可以通过编写 SQL 查询语句来与数据库进行交互。你可以直接执行原始的 SQL 语句，也可以使用绑定变量和查询构建器来构建和执行查询。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">otl_stream stream;</span><br><span class="line">stream.<span class="built_in">open</span>(<span class="number">1</span>, <span class="string">&quot;SELECT name, age FROM users WHERE age &gt; :age&quot;</span>, db);</span><br><span class="line">stream &lt;&lt; <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stream.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    stream &gt;&gt; name &gt;&gt; age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理查询结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事务处理</strong>：OTL 支持事务操作，你可以使用事务对象来管理一系列数据库操作的原子性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">otl_trans <span class="title">transaction</span><span class="params">(db)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行一系列的数据库操作</span></span><br><span class="line"></span><br><span class="line">transaction.<span class="built_in">commit</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理</strong>：OTL 使用异常来处理错误情况。当出现错误时，它会抛出相应的异常，你可以使用 try-catch 块来捕获并处理这些异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (otl_exception&amp; ex) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>灵活性和可扩展性</strong>：OTL 具有灵活和可扩展的架构，你可以通过编写自定义的 OTL 数据库后端适配器来支持其他数据库系统。</p>
</li>
</ol>
<p>OTL 提供了详细的文档和示例代码，以帮助你更深入地了解和使用它。你可以在 OTL 的官方网站上找到更多信息：<a target="_blank" rel="noopener" href="http://otl.sourceforge.net/">http://otl.sourceforge.net/</a></p>
<p>需要注意的是，OTL 是一个相对底层的库，使用它需要对 SQL 查询语句和数据库概念有一定的了解。</p>
<p>希望这些详解能够帮助你更好地理解和使用 OTL！如果你有更多问题，请随时提问。</p>
<h2 id="SOCI-详解"><a href="#SOCI-详解" class="headerlink" title="SOCI 详解"></a>SOCI 详解</h2><p>SOCI（The C++ Database Access Library）是一个通用的数据库访问库，它提供了简单和一致的接口，用于在 C++ 中访问多种不同类型的数据库。下面是关于 SOCI 的一些详解：</p>
<ol>
<li><p><strong>支持多种数据库</strong>：SOCI 支持多种常见的数据库系统，包括 SQLite、MySQL、PostgreSQL、Oracle、ODBC 等。你可以使用相同的接口和代码来访问不同类型的数据库，而不需要学习和使用特定数据库的 API。</p>
</li>
<li><p><strong>面向对象接口</strong>：SOCI 提供了面向对象的接口，通过类和方法来操作数据库。它使用了现代 C++ 特性，如模板和 RAII（资源获取即初始化），使得代码更加清晰和易于维护。</p>
</li>
<li><p><strong>连接管理</strong>：使用 SOCI，你可以通过提供连接字符串来建立和管理与数据库的连接。连接字符串包括数据库类型、主机名、端口号、用户名、密码等信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">soci::session <span class="title">sql</span><span class="params">(<span class="string">&quot;mysql://user:password@localhost/mydatabase&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询执行</strong>：使用 SOCI，你可以通过编写 SQL 查询语句来与数据库进行交互。你可以直接执行原始的 SQL 语句，也可以使用绑定变量和查询构建器来构建和执行查询。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">soci::rowset&lt;row&gt; rs = (sql.prepare &lt;&lt; <span class="string">&quot;SELECT name, age FROM users WHERE age &gt; :age&quot;</span>, soci::<span class="built_in">use</span>(<span class="number">18</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; r : rs) &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    r.<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(name);</span><br><span class="line">    r.<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(age);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理查询结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事务处理</strong>：SOCI 支持事务操作，你可以使用事务对象来管理一系列数据库操作的原子性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">soci::transaction <span class="title">tr</span><span class="params">(sql)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行一系列的数据库操作</span></span><br><span class="line"></span><br><span class="line">tr.<span class="built_in">commit</span>(); <span class="comment">// 提交事务</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理</strong>：SOCI 使用异常来处理错误情况。当出现错误时，它会抛出相应的异常，你可以使用 try-catch 块来捕获并处理这些异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> soci::soci_error&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>灵活性和可扩展性</strong>：SOCI 具有灵活和可扩展的架构，你可以通过编写自定义后端适配器来支持其他数据库系统。</p>
</li>
</ol>
<p>SOCI 提供了丰富的文档和示例代码，以帮助你更详细地了解和使用它。你可以在 SOCI 的官方网站上找到更多信息：<a target="_blank" rel="noopener" href="http://soci.sourceforge.net/">http://soci.sourceforge.net/</a></p>
<p>需要注意的是，SOCI 是一个相对底层的库，使用它需要对 SQL 查询语句和数据库概念有一定的了解。</p>
<p>希望这些详解能够帮助你更好地理解和使用 SOCI！如果你有更多问题，请随时提问。</p>
<h2 id="sqlitecpp-详解"><a href="#sqlitecpp-详解" class="headerlink" title="sqlitecpp 详解"></a>sqlitecpp 详解</h2><p>SQLiteCpp 是一个在 C++ 中使用 SQLite 数据库的轻量级封装库。它提供了简单且直观的面向对象的接口，使得在 C++ 项目中使用 SQLite 数据库更加便捷。</p>
<p>以下是 SQLiteCpp 的一些主要特点和用法的详解：</p>
<ol>
<li><p><strong>面向对象接口</strong>：SQLiteCpp 提供了一个面向对象的接口，通过类和方法来操作数据库。它使用了现代 C++ 特性，如 RAII（资源获取即初始化）和异常处理，使得代码更加清晰和易于维护。</p>
</li>
<li><p><strong>数据库连接</strong>：使用 SQLite::Database 类可以创建和管理与 SQLite 数据库的连接。你可以通过指定数据库文件的路径来打开数据库连接，也可以使用内存数据库。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SQLite::Database <span class="title">db</span><span class="params">(<span class="string">&quot;example.db&quot;</span>)</span></span>; <span class="comment">// 打开名为 &quot;example.db&quot; 的数据库文件连接</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询执行</strong>：你可以使用 SQLite::Statement 类执行 SQL 查询语句，并通过绑定参数和读取结果集来与数据库交互。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SQLite::Statement <span class="title">query</span><span class="params">(db, <span class="string">&quot;SELECT * FROM users WHERE age &gt; ?&quot;</span>)</span></span>;</span><br><span class="line">query.<span class="built_in">bind</span>(<span class="number">1</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (query.<span class="built_in">executeStep</span>()) &#123;</span><br><span class="line">    std::string name = query.<span class="built_in">getColumn</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> age = query.<span class="built_in">getColumn</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理查询结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事务处理</strong>：SQLiteCpp 支持事务操作，通过 SQLite::Transaction 类可以实现简单的事务控制，保证一系列的数据库操作的原子性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SQLite::Transaction <span class="title">transaction</span><span class="params">(db)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行一系列的数据库操作</span></span><br><span class="line"></span><br><span class="line">transaction.<span class="built_in">commit</span>(); <span class="comment">// 提交事务</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据库操作</strong>：SQLiteCpp 提供了许多便捷的方法来执行数据库操作，包括插入、更新、删除等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SQLite::Statement <span class="title">insert</span><span class="params">(db, <span class="string">&quot;INSERT INTO users (name, age) VALUES (?, ?)&quot;</span>)</span></span>;</span><br><span class="line">insert.<span class="built_in">bind</span>(<span class="number">1</span>, <span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">insert.<span class="built_in">bind</span>(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line">insert.<span class="built_in">exec</span>(); <span class="comment">// 执行插入操作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>错误处理</strong>：SQLiteCpp 在出现错误时会抛出异常，你可以使用 try-catch 块来捕获并处理这些异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据库操作</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>SQLiteCpp 提供了丰富的文档和示例代码，以帮助你更详细地了解和使用它。你可以在它的 GitHub 页面上找到更多信息：<a target="_blank" rel="noopener" href="https://github.com/SRombauts/SQLiteCpp">https://github.com/SRombauts/SQLiteCpp</a></p>
<p>需要注意的是，尽管 SQLiteCpp 简化了在 C++ 中使用 SQLite 数据库的过程，你仍然需要熟悉 SQL 查询语句和 SQLite 数据库的概念。</p>
<p>希望这些详解能够帮助你更好地理解和使用 SQLiteCpp！如果你有更多问题，请随时提问。</p>
<h2 id="sqlite3-orm-第三方工具-推荐"><a href="#sqlite3-orm-第三方工具-推荐" class="headerlink" title="sqlite3 orm 第三方工具 推荐"></a>sqlite3 orm 第三方工具 推荐</h2><p>在 C++ 中，有几个流行的第三方工具可用于提供 SQLite3 ORM（对象关系映射）功能。以下是一些常用的 C++ SQLite3 ORM 第三方库：</p>
<ol>
<li><p>SQLiteCpp：SQLiteCpp 是一个轻量级的 C++ 封装库，提供了对 SQLite 数据库的面向对象访问接口。它使用现代 C++ 特性，简化了与 SQLite 数据库的交互，支持查询构建、事务处理等功能。</p>
<p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/SRombauts/SQLiteCpp">https://github.com/SRombauts/SQLiteCpp</a></p>
</li>
<li><p>SOCI：SOCI 是一个通用的数据库访问库，支持多种数据库，包括 SQLite。它提供了面向对象的接口，可以简化数据库操作，包括查询、插入、更新等。</p>
<p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/SOCI/soci">https://github.com/SOCI/soci</a></p>
</li>
<li><p>OTL：OTL（OCCI Template Library）是一个通用的数据库访问库，也支持 SQLite 数据库。它提供了面向对象的接口，支持事务处理、预编译语句等功能。</p>
<p>官方网站：<a target="_blank" rel="noopener" href="http://otl.sourceforge.net/">http://otl.sourceforge.net/</a></p>
</li>
<li><p>C++ REST SDK：C++ REST SDK 是一个功能强大的 C++ 库，提供了丰富的功能，包括 HTTP 客户端&#x2F;服务器、JSON 解析、异步任务等。它也提供了对 SQLite 数据库的支持，可以用作 ORM。</p>
<p>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/microsoft/cpprestsdk">https://github.com/microsoft/cpprestsdk</a></p>
</li>
</ol>
<p>这些库都可以帮助你在 C++ 中使用 SQLite3 数据库，并提供了不同程度的 ORM 功能。你可以根据项目的需求、库的易用性和适配性来选择最适合的库。</p>
<p>需要注意的是，这些库都是第三方工具，你需要根据你的项目要求和预期的功能选择适合的库，并仔细阅读它们的文档和示例代码以了解如何使用它们。</p>
<p>希望这些推荐对你有所帮助！如有更多问题，请随时提问。</p>
<h2 id="sql语法和mysql-关系"><a href="#sql语法和mysql-关系" class="headerlink" title="sql语法和mysql 关系"></a>sql语法和mysql 关系</h2><p>SQL（Structured Query Language）是一种用于管理关系型数据库系统的编程语言。它提供了一套标准化的语法和操作，用于查询、操作和管理数据库中的数据。MySQL是一个开源的关系型数据库管理系统（RDBMS），它支持使用SQL语言进行数据库操作。</p>
<p>SQL语法定义了一组规则和约定，用于编写查询和操作数据库的语句。它包括以下几个主要方面：</p>
<ol>
<li><p>数据定义语言（DDL）：DDL用于定义数据库的结构和模式。它包括创建数据库、创建表、定义表的列和约束等操作。例如，使用DDL语句可以创建一个名为”employees”的表，定义其列和数据类型：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> employees (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    age <span class="type">INT</span>,</span><br><span class="line">    salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据操作语言（DML）：DML用于插入、更新和删除数据库中的数据。它包括INSERT、UPDATE和DELETE语句，用于执行相应的操作。例如，使用DML语句可以向”employees”表中插入一条新记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> employees (id, name, age, salary)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;John Doe&#x27;</span>, <span class="number">30</span>, <span class="number">50000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据查询语言（DQL）：DQL用于从数据库中检索数据。它包括SELECT语句，用于查询和过滤数据。例如，使用DQL语句可以查询”employees”表中年龄大于等于25岁的员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> age <span class="operator">&gt;=</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据控制语言（DCL）：DCL用于控制数据库用户的访问权限和安全性。它包括GRANT和REVOKE语句，用于授予和撤销用户的权限。例如，使用DCL语句可以授予用户”john”对”employees”表的SELECT权限：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> employees <span class="keyword">TO</span> john;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>MySQL是一个流行的关系型数据库管理系统，它实现了SQL语言标准，并提供了额外的功能和扩展。MySQL支持大多数SQL语法的标准化操作，如DDL、DML、DQL和DCL。通过MySQL，你可以创建和管理数据库，创建表和索引，执行查询和数据操作，以及控制用户的权限。</p>
<p>总而言之，SQL是一种用于管理关系型数据库的标准化语言，而MySQL是一个实现了SQL标准的关系型数据库管理系统。通过使用SQL语法，你可以在MySQL数据库中执行各种操作，包括创建和定义数据库结构、插入、更新和删除数据，以及查询和检索数据。</p>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ul>
<li>SQL 是用于访问和处理数据库的标准的计算机语言。</li>
<li>在本教程中，您将学到如何使用 SQL 访问和处理数据系统中的数据，这类数据库包括：MySQL、SQL Server、Access、Oracle、Sybase、DB2 等等。</li>
</ul>
<h2 id="1-1-SQL-简介"><a href="#1-1-SQL-简介" class="headerlink" title="1.1 SQL 简介"></a>1.1 SQL 简介</h2><ul>
<li>SQL (Structured Query Language:结构化查询语言) 是用于管理关系数据库管理系统（RDBMS）。 </li>
<li>SQL 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。</li>
</ul>
<h3 id="1-1-1-SQL-是什么"><a href="#1-1-1-SQL-是什么" class="headerlink" title="1.1.1 SQL 是什么"></a>1.1.1 SQL 是什么</h3><ul>
<li>SQL 指结构化查询语言，全称是 Structured Query Language。</li>
<li>SQL 让您可以访问和处理数据库，包括数据插入、查询、更新和删除。</li>
<li>SQL 在1986年成为 ANSI（American National Standards Institute 美国国家标准化组织）的一项标准，在 1987 年成为国际标准化组织（ISO）标准。</li>
</ul>
<h3 id="1-1-2-SQL-能做什么"><a href="#1-1-2-SQL-能做什么" class="headerlink" title="1.1.2 SQL 能做什么"></a>1.1.2 SQL 能做什么</h3><ul>
<li>SQL 面向数据库执行查询</li>
<li>SQL 可从数据库取回数据</li>
<li>SQL 可在数据库中插入新的记录</li>
<li>SQL 可更新数据库中的数据</li>
<li>SQL 可从数据库删除记录</li>
<li>SQL 可创建新数据库</li>
<li>SQL 可在数据库中创建新表</li>
<li>SQL 可在数据库中创建存储过程</li>
<li>SQL 可在数据库中创建视图</li>
<li>SQL 可以设置表、存储过程和视图的权限</li>
</ul>
<h3 id="1-1-3-SQL-是一种标准-但是…"><a href="#1-1-3-SQL-是一种标准-但是…" class="headerlink" title="1.1.3 SQL 是一种标准 - 但是…"></a>1.1.3 SQL 是一种标准 - 但是…</h3><ul>
<li><p>虽然 SQL 是一门 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言，但是仍然存在着多种不同版本的 SQL 语言。</p>
</li>
<li><p>然而，为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的命令（比如 SELECT、UPDATE、DELETE、INSERT、WHERE 等等）。</p>
</li>
<li><p>注释：除了 SQL 标准之外，大部分 SQL 数据库程序都拥有它们自己的专有扩展！</p>
</li>
</ul>
<h3 id="1-1-4-RDBMS"><a href="#1-1-4-RDBMS" class="headerlink" title="1.1.4 RDBMS"></a>1.1.4 RDBMS</h3><ul>
<li>RDBMS 指关系型数据库管理系统，全称 Relational Database Management System。</li>
<li>RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础，比如 MS SQL Server、IBM DB2、Oracle、MySQL 以及 Microsoft Access。</li>
<li>RDBMS 中的数据存储在被称为表的数据库对象中。</li>
<li>表是相关的数据项的集合，它由列和行组成。</li>
</ul>
<h2 id="1-2-SQL-语法"><a href="#1-2-SQL-语法" class="headerlink" title="1.2 SQL 语法"></a>1.2 SQL 语法</h2><h3 id="1-2-1-数据库表"><a href="#1-2-1-数据库表" class="headerlink" title="1.2.1 数据库表"></a>1.2.1 数据库表</h3><ul>
<li>一个数据库通常包含一个或多个表。每个表有一个名字标识（例如:”Websites”）,表包含带有数据的记录（行）。</li>
</ul>
<h3 id="1-2-2-SQL-语句"><a href="#1-2-2-SQL-语句" class="headerlink" title="1.2.2 SQL 语句"></a>1.2.2 SQL 语句</h3><ul>
<li><p>SQL 对大小写不敏感：SELECT 与 select 是相同的。</p>
</li>
<li><p>某些数据库系统要求在每条 SQL 语句的末端使用分号。</p>
</li>
<li><p>分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的 SQL 语句。</p>
</li>
</ul>
<h3 id="1-2-3-一些最重要的-SQL-命令"><a href="#1-2-3-一些最重要的-SQL-命令" class="headerlink" title="1.2.3 一些最重要的 SQL 命令"></a>1.2.3 一些最重要的 SQL 命令</h3><ul>
<li>SELECT - 从数据库中提取数据</li>
<li>UPDATE - 更新数据库中的数据</li>
<li>DELETE - 从数据库中删除数据</li>
<li>INSERT INTO - 向数据库中插入新数据</li>
<li>CREATE DATABASE - 创建新数据库</li>
<li>ALTER DATABASE - 修改数据库</li>
<li>CREATE TABLE - 创建新表</li>
<li>ALTER TABLE - 变更（改变）数据库表</li>
<li>DROP TABLE - 删除表</li>
<li>CREATE INDEX - 创建索引（搜索键）</li>
<li>DROP INDEX - 删除索引</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sqlpp11_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sqlpp11_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">sqlpp11_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>sqlpp11 理论基础</li>
</ul>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>sqlpp11 是一个 C++ 编程库，提供了一种类型安全的 SQL 查询构建和执行方式。它使用 C++ 的强类型系统和模板元编程技术，允许开发者以类型安全的方式构建 SQL 查询，同时提供了对多种关系型数据库的支持。</p>
<p>以下是关于 sqlpp11 的一些详细说明：</p>
<p><strong>1. 类型安全的 SQL 查询构建：</strong> sqlpp11 允许开发者使用 C++ 类型和表达式来构建 SQL 查询，这种方式可以在编译时捕获错误和类型不匹配，并提供更好的代码安全性和可维护性。</p>
<p><strong>2. 支持多种关系型数据库：</strong> sqlpp11 支持多种常见的关系型数据库，如 MySQL、PostgreSQL、SQLite 和 Microsoft SQL Server 等，使开发者可以使用相同的接口和查询语法来操作不同的数据库系统。</p>
<p><strong>3. 查询表达式和条件：</strong> sqlpp11 提供了丰富的查询表达式和条件，包括等于、不等于、小于、大于、逻辑运算符等，以及通用函数和聚合函数等，使开发者可以构建复杂的查询条件和数据转换。</p>
<p><strong>4. 插入、更新和删除数据：</strong> sqlpp11 提供了方便的接口和语法来执行插入、更新和删除数据的操作，使开发者可以通过简单的代码调用来完成数据库操作。</p>
<p><strong>5. 事务支持：</strong> sqlpp11 支持数据库事务的操作，允许开发者在事务中执行一系列的数据库操作，并保证数据的一致性和完整性。</p>
<p><strong>6. 数据库迁移支持：</strong> sqlpp11 提供了数据库迁移的支持，允许开发者定义数据库表结构的变化和版本控制，以方便数据库结构的升级和维护。</p>
<p>使用 sqlpp11，开发者可以在 C++ 程序中以一种类型安全的方式构建和执行 SQL 查询，而无需手动编写 SQL 语句。这样可以减少错误和调试的工作量，提高代码的可读性和可维护性。然而，使用 sqlpp11 仍然需要对关系型数据库和 SQL 语法有一定的了解，以便正确地构建查询和操作数据库。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sqlite3_4_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sqlite3_4_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">sqlite3_4_常见问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>sqlite3使用过程中遇到的理论，问题和解决方法</li>
</ul>
<h2 id="database-is-locked"><a href="#database-is-locked" class="headerlink" title="database is locked"></a>database is locked</h2><p>“sqlite3 database is locked” 是指在使用 SQLite 数据库时遇到了并发访问的冲突。当一个进程或连接正在执行写操作（例如插入、更新或删除数据）时，SQLite 会将数据库文件锁定，以防止其他进程同时对同一数据库执行写操作，以维护数据的完整性。</p>
<p>如果在一个进程中对数据库文件执行写操作时，另一个进程或连接也试图执行写操作，就会发生冲突，此时就会出现 “sqlite3 database is locked” 错误。</p>
<p>这种情况通常出现在以下几种情况下：</p>
<ol>
<li>并发访问：多个进程或连接同时尝试对同一个数据库执行写操作。</li>
<li>错误的连接管理：在一个连接中开始了一个事务（transaction），但没有正确地提交或回滚该事务，导致其他连接无法访问数据库。</li>
<li>长时间的写操作：一个进程或连接执行了一个耗时很长的写操作，阻塞了其他进程或连接的写操作。</li>
</ol>
<p>解决 “sqlite3 database is locked” 错误的方法包括：</p>
<ol>
<li>确保正确管理连接和事务：在使用完数据库连接后，应该及时关闭连接或者正确地提交或回滚事务，以释放数据库锁定。</li>
<li>等待并重试：如果出现锁定错误，可以通过等待一段时间后再次尝试执行操作，以便等待其他进程或连接释放数据库锁定。</li>
<li>优化并发访问：如果并发访问是一个常见问题，可以考虑优化数据库结构、调整访问模式或使用锁定机制来避免冲突。</li>
</ol>
<p>需要注意的是，”sqlite3 database is locked” 错误通常是由并发访问引起的，因此在设计和编写应用程序时，应该考虑到数据库并发访问的情况，并采取适当的措施来避免冲突。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sqlite3_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sqlite3_3_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">sqlite3_3_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>sqlite3 常用技巧</li>
</ul>
<h2 id="设置唯一列-约束"><a href="#设置唯一列-约束" class="headerlink" title="设置唯一列 约束"></a>设置唯一列 约束</h2><p>在 SQLite3 中，可以通过添加 <code>UNIQUE</code> 约束来设置唯一列，确保列中的值在表中是唯一的。这意味着您不能在该列中插入重复的值。</p>
<p>以下是在 SQLite3 中设置唯一列的方法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> table_name (</span><br><span class="line">  column1 data_type <span class="keyword">UNIQUE</span>,</span><br><span class="line">  column2 data_type,</span><br><span class="line">  ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>column1</code> 被设置为唯一列。如果在 <code>column1</code> 中插入一个已经存在的值，SQLite3 将会抛出一个错误并拒绝插入。</p>
<p>需要注意的是，唯一约束可以应用于单个列，也可以应用于多个列。如果将多个列一起设置为唯一约束，这些列的组合值在表中将是唯一的。</p>
<p>例如，将多个列设置为唯一：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> table_name (</span><br><span class="line">  column1 data_type,</span><br><span class="line">  column2 data_type,</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">UNIQUE</span>(column1, column2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>column1</code> 和 <code>column2</code> 的组合值将是唯一的。</p>
<p>另外，如果您想在已有的表中添加唯一约束，可以使用 <code>ALTER TABLE</code> 命令。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span> constraint_name <span class="keyword">UNIQUE</span> (column1);</span><br></pre></td></tr></table></figure>

<p>请注意，在添加唯一约束之前，您需要确保列中的数据没有重复值，否则会导致添加约束失败。</p>
<p>总的来说，通过添加 <code>UNIQUE</code> 约束，可以在 SQLite3 中设置唯一列，确保表中的特定列的值是唯一的，避免插入重复的数据。</p>
<h2 id="设置主键和自增"><a href="#设置主键和自增" class="headerlink" title="设置主键和自增"></a>设置主键和自增</h2><p>在 SQLite3 中，设置主键和自增可以通过以下方式实现：</p>
<h3 id="设置主键："><a href="#设置主键：" class="headerlink" title="设置主键："></a>设置主键：</h3><p>在 SQLite3 中，主键可以通过在列定义中添加 <code>PRIMARY KEY</code> 约束来设置。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> table_name (</span><br><span class="line">  column1 data_type <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  column2 data_type,</span><br><span class="line">  ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>column1</code> 被设置为主键。</p>
<h3 id="设置自增："><a href="#设置自增：" class="headerlink" title="设置自增："></a>设置自增：</h3><p>在 SQLite3 中，可以使用 <code>INTEGER</code> 数据类型和 <code>AUTOINCREMENT</code> 关键字来设置自增列。自增列在插入数据时会自动递增，确保数据的唯一性。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> table_name (</span><br><span class="line">  id <span class="type">INTEGER</span> <span class="keyword">PRIMARY KEY</span> AUTOINCREMENT,</span><br><span class="line">  column1 data_type,</span><br><span class="line">  column2 data_type,</span><br><span class="line">  ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>id</code> 列被设置为自增列，并作为主键。需要注意的是，<code>AUTOINCREMENT</code> 关键字只适用于主键列，且如果列设置为自增，插入数据时不需要为该列提供值，数据库会自动为其生成递增的值。</p>
<p>请注意，在 SQLite3 中，如果不显式地指定主键和自增列，SQLite3 会默认为每个表创建一个名为 “rowid” 的隐藏列，它将作为主键并自动递增。因此，如果不特别需要指定主键名称，可以直接使用默认的 “rowid” 列。</p>
<p>总之，以上就是在 SQLite3 中设置主键和自增的方法。根据您的需求，可以选择显式地指定主键和自增列的名称，也可以使用默认的 “rowid” 列来满足自增的需求。</p>
<ul>
<li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">algorithm       camera          task            user            warning_record</span><br><span class="line">sqlite&gt; CREATE TABLE event_subscribers (<span class="built_in">id</span> INT AUTO_INCREMENT PRIMARY KEY,  name TEXT, address TEXT, appKeyId TEXT, appKeySecret TEXT);</span><br><span class="line">sqlite&gt; .schema event_subscribers </span><br><span class="line">CREATE TABLE event_subscribers (<span class="built_in">id</span> INT AUTO_INCREMENT PRIMARY KEY,  name TEXT, address TEXT, appKeyId TEXT, appKeySecret TEXT);</span><br><span class="line">sqlite&gt; insert into event_subscribers (name, address, appKeyId, appKeyScret) values (<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;http://helloworld.cn&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">Parse error: table event_subscribers has no column named appKeyScret</span><br><span class="line">sqlite&gt;  insert into event_subscribers (name, address, appKeyId, appKeySecret) values (<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;http://helloworld.cn&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">sqlite&gt; <span class="keyword">select</span> * from event_subscribers;</span><br><span class="line">|aaa|http://helloworld.cn|bbb|ccc</span><br><span class="line">sqlite&gt; insert into event_subscribers (name, address, appKeyId, appKeySecret) values (<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;http://helloworld.cn&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">sqlite&gt; <span class="keyword">select</span> * from event_subscribers;</span><br><span class="line">|aaa|http://helloworld.cn|bbb|ccc</span><br><span class="line">|aaa|http://helloworld.cn|bbb|ccc</span><br><span class="line">sqlite&gt; drop event_subscribers;</span><br><span class="line">Parse error: near <span class="string">&quot;event_subscribers&quot;</span>: syntax error</span><br><span class="line">  drop event_subscribers;</span><br><span class="line">       ^--- error here</span><br><span class="line">sqlite&gt; drop table event_subscribers;</span><br><span class="line">sqlite&gt; CREATE TABLE event_subscribers (<span class="built_in">id</span> INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, address TEXT, appKeyId TEXT, appKeySecret TEXT);</span><br><span class="line">sqlite&gt; insert into event_subscribers (name, address, appKeyId, appKeySecret) values (<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;http://helloworld.cn&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">sqlite&gt; <span class="keyword">select</span> * from event_subscribers;</span><br><span class="line">1|aaa|http://helloworld.cn|bbb|ccc</span><br><span class="line">sqlite&gt; insert into event_subscribers (name, address, appKeyId, appKeySecret) values (<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;http://helloworld.cn&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">sqlite&gt; <span class="keyword">select</span> * from event_subscribers;</span><br><span class="line">1|aaa|http://helloworld.cn|bbb|ccc</span><br><span class="line">2|aaa|http://helloworld.cn|bbb|ccc</span><br><span class="line">sqlite&gt; </span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sqlpp11_2_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sqlpp11_2_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">sqlpp11_2_编程技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>sqlpp11 常用的编程技巧</li>
</ul>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>以下是一个简单的示例，演示如何在 C++ 中使用 sqlpp11 进行数据库查询：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sqlpp11/sqlpp11.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sqlpp11/mysql/connection.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">SQLPP_ALIAS_PROVIDER</span>(left);</span><br><span class="line"><span class="built_in">SQLPP_ALIAS_PROVIDER</span>(right);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建数据库连接</span></span><br><span class="line">    sqlpp::<span class="function">mysql::connection <span class="title">db</span><span class="params">(<span class="string">&quot;database&quot;</span>, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;host&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义表对象和别名</span></span><br><span class="line">    <span class="keyword">auto</span> user = test::user&#123;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> u = test::user.<span class="built_in">as</span>(left);</span><br><span class="line">    <span class="keyword">auto</span> v = test::user.<span class="built_in">as</span>(right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行查询操作</span></span><br><span class="line">    <span class="keyword">auto</span> query = db.<span class="built_in">select</span>(u.name)</span><br><span class="line">                     .<span class="built_in">from</span>(u)</span><br><span class="line">                     .<span class="built_in">join</span>(v)</span><br><span class="line">                     .<span class="built_in">on</span>(u.id == v.id)</span><br><span class="line">                     .<span class="built_in">where</span>(u.age &gt;= <span class="number">18</span>)</span><br><span class="line">                     .<span class="built_in">group_by</span>(u.name)</span><br><span class="line">                     .<span class="built_in">order_by</span>(u.name.<span class="built_in">asc</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印查询结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; row : query) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; row.name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们假设使用了名为 “database” 的 MySQL 数据库，并提供了正确的用户名、密码和主机信息。</p>
<p>该示例演示了如何进行简单的数据库查询操作。我们定义了一个名为 “user” 的表对象，并使用别名 <code>u</code> 和 <code>v</code> 来引用该表。然后，我们使用 <code>db.select()</code> 来选择查询字段，使用 <code>db.from()</code> 来指定要查询的表，使用 <code>db.join()</code> 和 <code>db.on()</code> 进行表连接操作，使用 <code>db.where()</code> 来指定查询条件，使用 <code>db.group_by()</code> 和 <code>db.order_by()</code> 来进行分组和排序。</p>
<p>最后，我们通过遍历查询结果，并输出每一行的 “name” 字段。</p>
<p>请注意，以上示例只是一个简单的演示，实际使用时需要根据数据库的实际结构和需求进行相应的修改和配置。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/SQL/2024-05-22-sqlite3_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/SQL/2024-05-22-sqlite3_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">sqlite3_2_常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="Update-语句"><a href="#Update-语句" class="headerlink" title="Update 语句"></a>Update 语句</h2><ul>
<li><p>简介</p>
<ul>
<li>SQLite 的 UPDATE 查询用于修改表中已有的记录。可以使用带有 WHERE 子句的 UPDATE 查询来更新选定行，否则所有的行都会被更新</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2...., columnN <span class="operator">=</span> valueN</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br></pre></td></tr></table></figure></li>
<li><p>注 ：</p>
<ul>
<li>您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。</li>
</ul>
</li>
</ul>
<h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><ul>
<li><p>简介：</p>
<ul>
<li>SQLite 的 DROP TABLE 语句用来删除表定义及其所有相关数据、索引、触发器、约束和该表的权限规范</li>
<li>使用此命令时要特别注意，因为一旦一个表被删除，表中所有信息也将永远丢失。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>DROP TABLE database_name.table_name;</code></li>
</ul>
</li>
<li><p>示例：</p>
<ul>
<li>让我们先确认 COMPANY 表已经存在，然后我们将其从数据库中删除。</li>
<li><code>sqlite&gt;.tables</code></li>
<li><code>COMPANY       test.COMPANY</code></li>
</ul>
</li>
<li><p>把它从数据库中删除，如下：</p>
<ul>
<li><code>sqlite&gt;DROP TABLE COMPANY;</code></li>
</ul>
</li>
<li><p>现在，如果尝试 .TABLES 命令，那么将无法找到 COMPANY 表了：</p>
<ul>
<li><code>sqlite&gt;.tables</code></li>
</ul>
</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li><p><code>.help</code> : 显示各种重要的 SQLite 点命令的列表</p>
</li>
<li><p><code>.tables</code></p>
</li>
</ul>
<p>SQLite是一种轻量级的嵌入式关系型数据库管理系统，具有简单、快速、可靠的特点。以下是一些常用的SQLite命令：</p>
<ol>
<li><p>打开或创建数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3 database_name.db</span><br></pre></td></tr></table></figure>

<p>该命令将打开名为<code>database_name.db</code>的数据库。如果数据库不存在，则会创建一个新的数据库。</p>
</li>
<li><p>显示数据库中的所有表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.tables</span><br></pre></td></tr></table></figure>

<p>该命令将列出数据库中的所有表。</p>
</li>
<li><p>显示表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.schema table_name</span><br></pre></td></tr></table></figure>

<p>该命令将显示名为<code>table_name</code>的表的结构，包括列名、数据类型和约束等信息。</p>
</li>
<li><p>执行SQL查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>

<p>该命令将执行一个SELECT查询，并显示<code>table_name</code>表中的所有行。</p>
</li>
<li><p>插入数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> table_name (column1, column2, ...) <span class="keyword">VALUES</span> (value1, value2, ...);</span><br></pre></td></tr></table></figure>

<p>该命令将在<code>table_name</code>表中插入一行数据，指定列和对应的值。</p>
</li>
<li><p>更新数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2, ... <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>

<p>该命令将更新满足条件<code>WHERE</code>的行，设置指定列的新值。</p>
</li>
<li><p>删除数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>

<p>该命令将从<code>table_name</code>表中删除满足条件<code>WHERE</code>的行。</p>
</li>
<li><p>创建表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> table_name (</span><br><span class="line">    column1 datatype <span class="keyword">constraint</span>,</span><br><span class="line">    column2 datatype <span class="keyword">constraint</span>,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>该命令将创建一个新的表，指定列名、数据类型和约束等信息。</p>
</li>
<li><p>删除表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure>

<p>该命令将删除名为<code>table_name</code>的表。</p>
</li>
</ol>
<p>这只是SQLite命令的一小部分，SQLite还提供了许多其他命令和功能，如索引、事务、连接等。您可以参考SQLite官方文档或其他资源来了解更多有关SQLite的命令和功能。</p>
<h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>SQLite 是一种嵌入式关系型数据库管理系统 (RDBMS)，它是一个轻量级、高效、自包含的数据库引擎。与传统的客户端-服务器模式的数据库不同，SQLite 是以库的形式嵌入到应用程序中，应用程序可以直接与数据库文件进行交互，而无需独立的数据库服务器。</p>
<p>以下是 SQLite 的一些特点和用途：</p>
<ol>
<li><p>轻量级：SQLite 是一个轻量级的数据库引擎，它的核心库非常小巧，不依赖于外部服务器或配置。这使得 SQLite 在嵌入式系统、移动设备和资源受限的环境中非常适用。</p>
</li>
<li><p>自包含：SQLite 数据库以单个文件的形式存储，并且包含了完整的数据库结构和数据。这意味着应用程序可以直接操作一个 SQLite 数据库文件，而无需额外的数据库管理系统。</p>
</li>
<li><p>事务支持：SQLite 支持 ACID（原子性、一致性、隔离性和持久性）事务特性，它可以确保数据库的完整性和一致性。</p>
</li>
<li><p>SQL 兼容：SQLite 支持 SQL 查询语言，可以使用标准的 SQL 语句进行数据库操作，包括数据的查询、插入、更新和删除等。</p>
</li>
<li><p>广泛应用：由于其轻量级和自包含的特性，SQLite 在各种应用场景中得到广泛应用，包括嵌入式系统、移动应用程序、桌面应用程序、Web 浏览器、数据分析和开发测试等。</p>
</li>
</ol>
<p>在使用 SQLite 时，你可以通过编写 SQL 语句或使用相应的 SQLite API 来创建数据库、定义表结构、插入和查询数据等操作。同时，有许多编程语言和框架提供了对 SQLite 的支持和封装，使得在不同的开发环境中使用 SQLite 更加便捷。</p>
<p>SQLite 是C语言接口的</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>以下是在 Linux 系统上编译和安装 SQLite 的基本步骤：</p>
<ol>
<li><p>下载源代码：访问 SQLite 的官方网站（<a target="_blank" rel="noopener" href="https://www.sqlite.org/index.html%EF%BC%89%E5%B9%B6%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8E%8B%E7%BC%A9%E5%8C%85%E3%80%82">https://www.sqlite.org/index.html）并下载最新版本的源代码压缩包。</a></p>
</li>
<li><p>解压源代码：使用命令行解压下载的源代码压缩包。例如，可以使用以下命令解压名为 “sqlite.tar.gz” 的压缩包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xzf sqlite.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入源代码目录：切换到解压后的源代码目录。例如，如果解压后的目录名为 “sqlite-x.x.x”，可以使用以下命令进入该目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd sqlite-x.x.x</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置编译选项：运行以下命令来配置编译选项，其中 <code>prefix</code> 是指定安装目录的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/path/to/installation</span><br></pre></td></tr></table></figure>

<p>你可以根据需要指定其他选项，如启用或禁用特定功能。可以运行 <code>./configure --help</code> 命令查看可用的配置选项。</p>
</li>
<li><p>编译源代码：运行以下命令来编译源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 SQLite：运行以下命令以将 SQLite 安装到指定的安装目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>注意确保你有足够的权限来将文件安装到指定目录。</p>
</li>
<li><p>完成安装：安装完成后，你可以在指定的安装目录中找到 SQLite 的可执行文件和相关库文件。</p>
</li>
</ol>
<p>完成上述步骤后，你已成功编译和安装了 SQLite。你可以使用 SQLite 的命令行工具或在你的应用程序中使用 SQLite 库进行数据库操作。记得参考 SQLite 的文档和相关资源，以了解如何使用 SQLite 进行数据库管理和操作。</p>
<h2 id="查看数据库表"><a href="#查看数据库表" class="headerlink" title="查看数据库表"></a>查看数据库表</h2><p>要查看 SQLite 数据库中的表，你可以使用 SQLite 提供的命令行工具 <code>sqlite3</code> 或编写一个简单的 C++ 程序来执行查询。</p>
<p>使用命令行工具 <code>sqlite3</code>，按照以下步骤进行操作：</p>
<ol>
<li><p>打开终端或命令提示符。</p>
</li>
<li><p>运行以下命令来连接到 SQLite 数据库文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3 your_database.db</span><br></pre></td></tr></table></figure>
<p>将 <code>your_database.db</code> 替换为实际的数据库文件名。</p>
</li>
<li><p>连接成功后，你将进入 SQLite 的命令行界面。运行以下命令来查看数据库中的表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.tables</span><br></pre></td></tr></table></figure>
<p>这将显示数据库中所有的表的列表。</p>
</li>
<li><p>若要查看特定表的详细结构，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.schema table_name</span><br></pre></td></tr></table></figure>
<p>将 <code>table_name</code> 替换为实际的表名。</p>
</li>
</ol>
<p>使用 C++ 程序来查看数据库表，你可以编写类似以下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sqlite3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sqlite3* db;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开数据库连接</span></span><br><span class="line">    rc = <span class="built_in">sqlite3_open</span>(<span class="string">&quot;your_database.db&quot;</span>, &amp;db);</span><br><span class="line">    <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法打开数据库: &quot;</span> &lt;&lt; <span class="built_in">sqlite3_errmsg</span>(db) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询表名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* selectTablesSQL = <span class="string">&quot;SELECT name FROM sqlite_master WHERE type=&#x27;table&#x27;;&quot;</span>;</span><br><span class="line">    rc = <span class="built_in">sqlite3_exec</span>(db, selectTablesSQL, [](<span class="type">void</span>* data, <span class="type">int</span> argc, <span class="type">char</span>** argv, <span class="type">char</span>** <span class="comment">/*azColName*/</span>) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">            std::cout &lt;&lt; argv[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc != SQLITE_OK) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;无法查询表: &quot;</span> &lt;&lt; <span class="built_in">sqlite3_errmsg</span>(db) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭数据库连接</span></span><br><span class="line">    <span class="built_in">sqlite3_close</span>(db);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将代码中的 <code>&quot;your_database.db&quot;</code> 替换为实际的数据库文件名，然后编译和运行程序。它将连接到数据库文件并执行查询来获取表名列表，并将其打印到控制台。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/VectorSearch/2024-05-22-faiss_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/VectorSearch/2024-05-22-faiss_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">faiss_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/VectorSearch/" itemprop="url" rel="index"><span itemprop="name">VectorSearch</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>faiss工具的理论基础</li>
</ul>
<h2 id="faiss-基础"><a href="#faiss-基础" class="headerlink" title="faiss 基础"></a>faiss 基础</h2><p>Faiss 是一个用于高效相似向量搜索和聚类的库，由Facebook AI Research开发。它提供了一系列用于向量索引、相似度搜索和聚类的算法和工具。Faiss 在处理大规模向量数据时非常高效，适用于各种应用场景，例如图像搜索、文本检索、推荐系统等。</p>
<p>以下是 Faiss 的一些主要特性和功能：</p>
<ol>
<li><p>向量索引：Faiss 提供了多种向量索引结构，包括平均哈希（IndexFlat），倒排文件（IndexIVF）等，可以在索引中快速存储和检索向量数据。</p>
</li>
<li><p>相似度搜索：Faiss 支持通过向量之间的相似度进行搜索，可以使用欧氏距离、内积等度量来计算相似度，并返回最相似的向量。</p>
</li>
<li><p>高效性能：Faiss 针对大规模向量数据进行了优化，使用了高度并行的算法和数据结构，以实现快速的搜索和检索操作。</p>
</li>
<li><p>GPU 支持：Faiss 提供了对 GPU 的支持，可以利用 GPU 的并行计算能力加速向量检索的速度。</p>
</li>
<li><p>多种距离度量：Faiss 支持多种距离度量方式，包括欧氏距离、内积、余弦相似度等，可以根据具体需求选择适当的度量方式。</p>
</li>
<li><p>扩展性：Faiss 具有良好的可扩展性，可以处理数百万或数十亿维度的向量数据，适用于大规模应用场景。</p>
</li>
</ol>
<p>要使用 Faiss 进行向量检索，通常需要执行以下步骤：</p>
<ol>
<li><p>准备数据：将需要进行检索的向量数据准备好，可以是图像特征、文本向量或其他类型的向量。</p>
</li>
<li><p>创建索引：选择适当的索引结构，根据数据集合的大小和特性创建 Faiss 索引。可以选择不同的索引类型和配置参数。</p>
</li>
<li><p>添加向量：将向量数据添加到 Faiss 索引中，构建索引结构。</p>
</li>
<li><p>执行搜索：使用索引结构进行相似向量搜索，提供查询向量，Faiss 将返回最相似的向量结果。</p>
</li>
</ol>
<p>Faiss 提供了多种编程语言的接口，包括 C++、Python 和其他语言的封装。你可以根据自己的需求选择适合的接口和编程语言进行使用。</p>
<p>请注意，Faiss 是一个功能强大的库，需要一定的学习和使用成本。如果你有具体的问题或需要更详细的指导，可以提供更多具体的信息，我将尽力提供帮助。</p>
<hr>
<h2 id="faiss-详解"><a href="#faiss-详解" class="headerlink" title="faiss 详解"></a>faiss 详解</h2><p>Faiss（Facebook AI Similarity Search）是一个由Facebook AI Research开发的库，用于高效相似向量搜索和聚类。它主要用于处理大规模向量数据集，具有快速、可扩展和高效的特性。</p>
<p>以下是对 Faiss 的一些详细解释：</p>
<ol>
<li><p>特点和功能：</p>
<ul>
<li>高效性能：Faiss 针对大规模向量数据进行了优化，使用了高度并行的算法和数据结构，以实现快速的搜索和检索操作。</li>
<li>多种索引结构：Faiss 提供了多种索引结构，包括平均哈希（IndexFlat）、倒排文件（IndexIVF）等。每种结构适用于不同的数据集和搜索需求。</li>
<li>相似度搜索：Faiss 支持通过向量之间的相似度进行搜索，可以使用欧氏距离、内积等度量来计算相似度，并返回最相似的向量结果。</li>
<li>GPU 支持：Faiss 可以利用 GPU 的并行计算能力加速向量检索的速度，提供了与 GPU 相关的索引和搜索功能。</li>
</ul>
</li>
<li><p>应用领域：</p>
<ul>
<li>图像搜索：Faiss 可以应用于图像特征向量的索引和搜索，用于快速的图像相似性匹配和检索。</li>
<li>文本检索：Faiss 也可用于文本向量的索引和搜索，用于语义相似性搜索和相关性匹配。</li>
<li>推荐系统：Faiss 在推荐系统中可以用于用户向量和商品向量的相似性匹配，以提供个性化推荐。</li>
</ul>
</li>
<li><p>编程语言和接口：</p>
<ul>
<li>Faiss 提供了 C++ 和 Python 的接口，可以在这两种编程语言中使用 Faiss 进行向量索引和搜索。</li>
<li>对于 Python 用户，Faiss 提供了 numpy 数组和 PyTorch 张量之间的无缝集成，方便数据的加载和处理。</li>
</ul>
</li>
<li><p>文档和资源：</p>
<ul>
<li>Faiss 的官方文档提供了详细的使用指南、示例代码和API参考，可以帮助开发者快速上手并了解各种功能和配置选项。</li>
<li>Faiss 的 GitHub 存储库包含了源代码、问题跟踪和社区讨论，开发者可以在其中获取更多的资源和支持。</li>
</ul>
</li>
</ol>
<p>总体而言，Faiss 是一个功能强大的向量检索库，被广泛应用于图像搜索、文本检索和推荐系统等领域。它的高性能、多样的索引结构和灵活的编程接口使得处理大规模向量数据变得高效且可扩展。</p>
<hr>
<h2 id="C-常用接口"><a href="#C-常用接口" class="headerlink" title="C++ 常用接口"></a>C++ 常用接口</h2><p>在 Faiss C++ 库中，以下是一些常用的接口：</p>
<ol>
<li><p>Index：Index 是 Faiss 中索引的基类，定义了向量索引和搜索的通用接口。各种具体的索引结构都派生自 Index 类。常用的派生类包括 IndexFlat、IndexIVF、IndexIVFPQ 等。</p>
</li>
<li><p>IndexFlat：IndexFlat 是 Faiss 中平坦索引的类，适用于小规模数据集。它提供了基于距离度量的搜索功能，例如欧氏距离或内积。</p>
</li>
<li><p>IndexIVF：IndexIVF 是 Faiss 中倒排文件索引的类，适用于大规模数据集。它使用倒排文件结构组织向量数据，并提供了高效的相似向量搜索。</p>
</li>
<li><p>IndexIVFPQ：IndexIVFPQ 是 Faiss 中倒排文件索引的量化版本。它通过对向量进行量化和编码来减小存储空间，并提供了高效的相似向量搜索。</p>
</li>
<li><p>IndexLSH：IndexLSH 是 Faiss 中局部敏感哈希索引的类，用于高维向量的近似搜索。它使用局部敏感哈希函数将向量映射到多个桶中，以实现高效的近似最近邻搜索。</p>
</li>
<li><p>IndexHNSW：IndexHNSW 是 Faiss 中基于 HNSW（Hierarchical Navigable Small World）算法的索引类。它构建了一个层次结构的近邻图，以提供快速的相似向量搜索。</p>
</li>
</ol>
<p>这些是 Faiss C++ 库中的一些常用接口和类示例。每个索引类都提供了特定的功能和选项，可以根据应用需求选择适合的接口和类。在使用 Faiss C++ 库时，建议参考官方文档和示例代码，以了解更多详细的接口和类说明。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/VectorSearch/2024-05-22-vector_search_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/VectorSearch/2024-05-22-vector_search_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">vector_search_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/VectorSearch/" itemprop="url" rel="index"><span itemprop="name">VectorSearch</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>向量检索工具相关的理论知识</li>
</ul>
<h2 id="向量检索工具-是什么"><a href="#向量检索工具-是什么" class="headerlink" title="向量检索工具 是什么"></a>向量检索工具 是什么</h2><p>向量检索工具是一类用于处理和搜索向量数据的软件工具或库。它们提供了一系列算法和数据结构，用于构建索引和执行相似向量搜索，以便快速地找到与给定查询向量最相似的向量。</p>
<p>向量检索工具的主要目标是高效地处理大规模的向量数据集，使得在高维向量空间中进行相似性搜索变得可行和高效。这些工具通常用于各种应用领域，包括图像搜索、文本检索、推荐系统、自然语言处理等。</p>
<p>这些工具提供了多种索引结构和算法，如平均哈希、倒排文件、KD-Tree、HNSW 等，用于构建和组织向量数据，以便快速进行搜索和检索操作。它们还支持不同的距离度量方式，如欧氏距离、余弦相似度等，以根据具体需求选择最适合的度量方式。</p>
<p>一些常见的向量检索工具包括 Faiss、Annoy、NMSLIB、Milvus 等。它们提供了多种编程语言的接口和封装，以方便在不同的编程环境中使用和集成。</p>
<p>通过使用这些向量检索工具，开发者可以快速构建索引结构，加载向量数据，并执行高效的相似向量搜索，从而实现各种应用场景中的相关性匹配和相似性检索功能。</p>
<hr>
<h2 id="常见的向量检索工具"><a href="#常见的向量检索工具" class="headerlink" title="常见的向量检索工具"></a>常见的向量检索工具</h2><p>以下是对几个常用的向量检索工具的详细解释：</p>
<ol>
<li><p>Faiss（Facebook AI Similarity Search）：</p>
<ul>
<li>特点：Faiss 是一个高性能的相似向量搜索库，专注于快速的向量索引和搜索。它提供了多种索引结构和算法，如平均哈希（IndexFlat）、倒排文件（IndexIVF）等，以及对 GPU 的支持。Faiss 适用于大规模的向量数据集和高维度的向量空间。</li>
<li>语言支持：C++ 和 Python。</li>
<li>官方网站：<a target="_blank" rel="noopener" href="https://github.com/facebookresearch/faiss">https://github.com/facebookresearch/faiss</a></li>
</ul>
</li>
<li><p>Annoy（Approximate Nearest Neighbors Oh Yeah）：</p>
<ul>
<li>特点：Annoy 是一个近似最近邻搜索库，使用随机投影树（Random Projection Trees）来进行高维向量的近似搜索。它具有较快的索引构建速度和搜索速度，适用于大规模的向量数据。</li>
<li>语言支持：C++ 和 Python。</li>
<li>官方网站：<a target="_blank" rel="noopener" href="https://github.com/spotify/annoy">https://github.com/spotify/annoy</a></li>
</ul>
</li>
<li><p>NMSLIB（Non-Metric Space Library）：</p>
<ul>
<li>特点：NMSLIB 是一个用于非度量空间的相似向量搜索库。它提供了多种索引结构和算法，如 M-Tree、KD-Tree、HNSW（Hierarchical Navigable Small World）等，可用于高效的向量索引和搜索。</li>
<li>语言支持：C++ 和 Python。</li>
<li>官方网站：<a target="_blank" rel="noopener" href="https://github.com/searchivarius/nmslib">https://github.com/searchivarius/nmslib</a></li>
</ul>
</li>
<li><p>Milvus：</p>
<ul>
<li>特点：Milvus 是一个开源的向量相似度搜索引擎，旨在提供高性能和可扩展性。它支持多种向量索引结构，包括 IVF、HNSW、RNSG（Randomized Neighborhood Structure Graph）等。Milvus 适用于大规模的向量数据集和高维度的向量空间。</li>
<li>语言支持：C++、Python 和 Java。</li>
<li>官方网站：<a target="_blank" rel="noopener" href="https://github.com/milvus-io/milvus">https://github.com/milvus-io/milvus</a></li>
</ul>
</li>
</ol>
<p>这些工具都有其独特的特点和适用场景，具体选择哪个工具取决于你的需求、数据集的特征以及性能要求。在使用这些工具时，建议查阅它们的文档、示例代码和社区支持，以便更好地理解和应用它们。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/VTK/2024-05-22-VTK_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/VTK/2024-05-22-VTK_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">VTK_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/VTK/" itemprop="url" rel="index"><span itemprop="name">VTK</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>VTK(Visualization Toolkit) 理论基础知识</li>
</ul>
<h2 id="VTK-详解"><a href="#VTK-详解" class="headerlink" title="VTK 详解"></a>VTK 详解</h2><p>Visualization Toolkit（VTK）是一个用于处理和可视化科学和工程数据的开源软件系统。它提供了丰富的功能和工具，可以用于生成各种类型的可视化效果，包括三维渲染、图像处理、体积渲染、几何建模、数据分析等。VTK 被广泛应用于科学计算、医学图像处理、工程仿真、地理信息系统等领域。</p>
<p>以下是一些关键特点和组件，以及关于 VTK 的详细解释：</p>
<ol>
<li><p><strong>数据表示和处理</strong>：VTK 提供了多种数据结构来表示不同类型的科学和工程数据，包括点云、网格、图像、体数据等。它还提供了用于处理和转换这些数据的算法和工具。</p>
</li>
<li><p><strong>渲染和可视化</strong>：VTK 支持高质量的三维渲染，可以创建逼真的可视化效果。它包括了各种渲染器、光照、纹理映射、混合模式等功能，可以生成交互式的三维图形界面。</p>
</li>
<li><p><strong>几何建模和体积渲染</strong>：VTK 提供了一些几何建模和体积渲染工具，可以用于创建和操作复杂的几何形状，并在体数据上进行渲染和分析。</p>
</li>
<li><p><strong>数据分析和可视化</strong>：VTK 提供了数据分析和可视化工具，可以用于可视化数据的不同方面，包括统计分析、数据交互、图表绘制等。</p>
</li>
<li><p><strong>交互式界面和用户交互</strong>：VTK 可以与各种用户界面库（如 Qt、FLTK 等）集成，从而实现交互式的用户界面和用户交互。</p>
</li>
<li><p><strong>扩展性和自定义性</strong>：VTK 具有高度的扩展性，可以通过编写自定义的类和算法来满足特定需求。它的体系结构允许开发者轻松地添加新的模块和功能。</p>
</li>
<li><p><strong>支持多种数据格式</strong>：VTK 支持多种数据格式，包括常见的图像格式、网格格式、点云格式等，使其能够处理各种不同类型的数据。</p>
</li>
<li><p><strong>多语言支持</strong>：VTK 最初是用 C++ 编写的，但还提供了多语言的绑定，如 Python，使得开发者可以使用不同的编程语言进行开发。</p>
</li>
</ol>
<p>VTK 的基本组件和功能在不同的模块中组织，这些模块包括了各种不同的可视化和数据处理任务。例如：</p>
<ul>
<li><p><code>vtkCommon</code>：这个模块包含了通用的数据结构和算法，例如点、线、面、网格等。</p>
</li>
<li><p><code>vtkRendering</code>：这个模块提供了渲染和可视化相关的功能，包括渲染器、相机、纹理映射、光照等。</p>
</li>
<li><p><code>vtkFilters</code>：这个模块包含了各种数据处理和滤波器算法，例如平滑、截取、表面重建等。</p>
</li>
<li><p><code>vtkIO</code>：这个模块提供了多种文件格式的读写功能，如图像、网格、体数据等。</p>
</li>
<li><p><code>vtkVolumeRendering</code>：这个模块专门用于体积渲染，可以创建逼真的体积可视化效果。</p>
</li>
</ul>
<p>总之，VTK 是一个功能强大且高度可定制的可视化和数据处理工具集，适用于各种科学、工程和医学领域的数据可视化和分析任务。它的文档和示例丰富，可以帮助开发者快速入门并实现复杂的可视化应用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/VTK/2024-05-22-VTK_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/VTK/2024-05-22-VTK_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">VTK_2_常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/VTK/" itemprop="url" rel="index"><span itemprop="name">VTK</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>VTK(Visualization Toolkit) 常用的编程技巧</li>
</ul>
<h2 id="vtkDebugLeaksManager-类-链接哪一个动态库"><a href="#vtkDebugLeaksManager-类-链接哪一个动态库" class="headerlink" title="vtkDebugLeaksManager 类 链接哪一个动态库"></a>vtkDebugLeaksManager 类 链接哪一个动态库</h2><p>在 VTK 7.1 版本中，<code>vtkDebugLeaksManager</code> 类属于 <code>vtkCommonCore</code> 模块，因此你需要链接到 <code>vtkCommonCore</code> 动态库。以下是可能的库名称，可以在链接命令中使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-lvtkCommonCore-7.1</span><br></pre></td></tr></table></figure>

<p>请注意，库名称可能因操作系统和安装配置而有所不同。在使用 CMake 构建项目时，CMake 通常会自动处理库的链接。如果你手动编写链接命令，确保链接到 <code>vtkCommonCore</code> 动态库以使用 <code>vtkDebugLeaksManager</code> 类。</p>
<p>如果你使用的是 CMake，可以在你的 CMakeLists.txt 文件中添加类似以下内容来链接 VTK 动态库：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(VTK <span class="number">7.1</span> REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(YourTargetName PRIVATE <span class="variable">$&#123;VTK_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>其中 <code>YourTargetName</code> 是你要构建的目标名称。上述代码将会自动链接所需的 VTK 动态库，包括 <code>vtkCommonCore</code>。</p>
<p>请确保你的 VTK 安装是正确的，包含了 <code>vtkCommonCore</code> 动态库，以及你想要使用的其他模块和类。</p>
<h2 id="pcl-VoxelGrid-链接哪一个动态库"><a href="#pcl-VoxelGrid-链接哪一个动态库" class="headerlink" title="pcl::VoxelGrid 链接哪一个动态库"></a>pcl::VoxelGrid 链接哪一个动态库</h2><p>在 Point Cloud Library (PCL) 中，<code>pcl::VoxelGrid</code> 类属于点云处理的模块，因此你需要链接到与点云处理相关的动态库。通常情况下，你需要链接到以下两个主要的动态库：</p>
<ol>
<li><p><code>pcl_common</code>: 这个库包含了 PCL 中一些常用的数据结构、算法和函数，包括点云的表示和操作等。</p>
</li>
<li><p><code>pcl_filters</code>: 这个库包含了各种点云滤波器，包括 <code>pcl::VoxelGrid</code> 网格滤波器。</p>
</li>
</ol>
<p>如果你使用的是 CMake 来构建项目，你可以在你的 <code>CMakeLists.txt</code> 文件中添加类似以下的内容来链接 PCL 相关的动态库：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PCL REQUIRED COMPONENTS common filters)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(YourTargetName PRIVATE <span class="variable">$&#123;PCL_COMMON_LIBRARIES&#125;</span> <span class="variable">$&#123;PCL_FILTERS_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>其中 <code>YourTargetName</code> 是你要构建的目标名称。上述代码会自动链接所需的 PCL 动态库，包括 <code>pcl_common</code> 和 <code>pcl_filters</code>。</p>
<p>请注意，PCL 的库名称可能因为操作系统和 PCL 版本而有所不同。上述示例中的库名称是基于通用的命名约定，具体情况可能会有所变化。你可以查阅你所使用的 PCL 版本的文档以获取更准确的库名称和链接信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Webfrontend/2024-05-22-HTML_1_%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Webfrontend/2024-05-22-HTML_1_%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/" class="post-title-link" itemprop="url">HTML_1_常用标签</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Webfrontend/" itemprop="url" rel="index"><span itemprop="name">Webfrontend</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>HTML 常用的标签</li>
</ul>
<h2 id="HTML-nav标签是什么-详解"><a href="#HTML-nav标签是什么-详解" class="headerlink" title="HTML nav标签是什么 详解"></a>HTML nav标签是什么 详解</h2><p><code>&lt;nav&gt;</code> 标签是HTML5中的一个语义化标签，用于定义页面中的导航部分。它用于包含页面的导航链接，例如菜单，链接列表或其他导航功能的集合。</p>
<p>以下是 <code>&lt;nav&gt;</code> 标签的一些重要特点和用法：</p>
<ol>
<li><p><strong>语义化：</strong> <code>&lt;nav&gt;</code> 标签的使用有助于提供更清晰的文档结构，使搜索引擎和屏幕阅读器能够更好地理解页面内容，从而提高可访问性和SEO。</p>
</li>
<li><p><strong>导航区域：</strong> 通常用于包含页面主要的导航链接。这些链接可能指向网站的不同部分，如首页、关于页面、联系页面等。</p>
</li>
<li><p><strong>唯一性：</strong> 一个页面中可以有多个 <code>&lt;nav&gt;</code> 标签，但每个 <code>&lt;nav&gt;</code> 应该代表不同的导航区域。</p>
</li>
<li><p><strong>结构示例：</strong> <code>&lt;nav&gt;</code> 可以包含各种导航元素，例如 <code>&lt;ul&gt;</code> 列表、<code>&lt;ol&gt;</code> 列表或一系列的链接 <code>&lt;a&gt;</code> 元素。</p>
</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/services&quot;</span>&gt;</span>服务<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/contact&quot;</span>&gt;</span>联系<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>&lt;nav&gt;</code> 标签包含了一个无序列表 <code>&lt;ul&gt;</code>，其中包含了页面的几个导航链接。这些链接分别指向网站的首页、关于页面、服务页面和联系页面。</p>
<p>总之，<code>&lt;nav&gt;</code> 标签是HTML中用于定义导航链接部分的语义化标签，有助于提高网页的可访问性和结构清晰度。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
