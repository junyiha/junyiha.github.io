<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/20/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/20/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_6_errno_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_6_errno_h/" class="post-title-link" itemprop="url">C_5_6_errno_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Linux POSIX &lt;errno.h&gt; 详解</li>
</ul>
<h2 id="Linux-POSIX-详解"><a href="#Linux-POSIX-详解" class="headerlink" title="Linux POSIX &lt;errno.h&gt; 详解"></a>Linux POSIX &lt;errno.h&gt; 详解</h2><p>在 Linux POSIX 系统中，<code>&lt;errno.h&gt;</code> 头文件定义了 <code>errno</code>，这是一个特殊的全局变量，用于指示发生错误时的错误码。<code>errno</code> 提供了对发生错误的类型进行识别的机制。</p>
<p>以下是关于 <code>&lt;errno.h&gt;</code> 头文件和 <code>errno</code> 变量的详细解释：</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li><code>&lt;errno.h&gt;</code> 头文件定义了一组可能的错误码，每个错误码对应一个特定的错误情况。</li>
<li>当系统函数或库函数出现错误时，会设置 <code>errno</code> 变量，以表示特定类型的错误。</li>
</ul>
<h3 id="errno-变量"><a href="#errno-变量" class="headerlink" title="errno 变量"></a><code>errno</code> 变量</h3><ul>
<li><code>errno</code> 是一个全局的 <code>int</code> 类型变量，存储了最近一次发生错误的错误码。</li>
<li>错误码的值可以是 POSIX 定义的标准错误码，也可以是特定的系统错误码。</li>
</ul>
<h3 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;nonexistent_file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件，错误码: %d\n&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 perror 打印出错误信息</span></span><br><span class="line">        perror(<span class="string">&quot;fopen() 错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据错误码输出错误信息</span></span><br><span class="line">        <span class="keyword">switch</span> (errno) &#123;</span><br><span class="line">            <span class="keyword">case</span> ENOENT:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;文件不存在\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EACCES:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;权限不足\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;未知错误\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>错误码的值在不同的系统中可能会有所不同，但 POSIX 标准定义了一组常见的错误码，通常在不同的系统中保持一致性。</li>
<li>在检测系统调用或库函数是否失败后，可以通过检查 <code>errno</code> 变量来获取特定的错误码，以便对错误类型进行判断和处理。</li>
</ul>
<p><code>&lt;errno.h&gt;</code> 头文件中的 <code>errno</code> 变量是处理错误的重要机制，可以帮助程序员识别和处理在执行系统调用或库函数时发生的错误。</p>
<h2 id="Linux-POSIX-常用错误码"><a href="#Linux-POSIX-常用错误码" class="headerlink" title="Linux POSIX &lt;errno.h&gt; 常用错误码"></a>Linux POSIX &lt;errno.h&gt; 常用错误码</h2><p>在 Linux POSIX 系统中，<code>&lt;errno.h&gt;</code> 头文件定义了一组常见的错误码，用于标识在系统调用或库函数执行过程中可能发生的各种错误情况。以下是一些常见的错误码及其含义：</p>
<ol>
<li><p>**<code>EACCES</code>**（13）：权限不足，表示访问权限被拒绝。</p>
</li>
<li><p>**<code>EEXIST</code>**（17）：文件已存在，通常用于创建文件时，指定了一个已经存在的文件名。</p>
</li>
<li><p>**<code>EINVAL</code>**（22）：无效的参数，表示传递给函数的参数无效或不合法。</p>
</li>
<li><p>**<code>ENOENT</code>**（2）：文件或目录不存在，用于指示找不到指定的文件或路径。</p>
</li>
<li><p>**<code>ENOMEM</code>**（12）：内存不足，表示没有足够的内存可用。</p>
</li>
<li><p>**<code>ENOSPC</code>**（28）：空间不足，用于指示磁盘空间不足。</p>
</li>
<li><p>**<code>EIO</code>**（5）：输入&#x2F;输出错误，表示发生了与设备或文件系统I&#x2F;O相关的错误。</p>
</li>
<li><p>**<code>EFAULT</code>**（14）：地址错误，表示传递给函数的地址无效。</p>
</li>
<li><p>**<code>EBADF</code>**（9）：无效的文件描述符，用于表示传递给函数的文件描述符无效。</p>
</li>
<li><p>**<code>EPIPE</code>**（32）：管道破裂，表示尝试向一个已关闭的管道写入数据。</p>
</li>
<li><p>**<code>EINTR</code>**（4）：中断的系统调用，表示一个系统调用被中断。</p>
</li>
<li><p>**<code>ETIMEDOUT</code>**（110）：操作超时，指示操作超出了预定的时间限制。</p>
</li>
</ol>
<p>这些错误码代表了可能在程序执行中遇到的常见错误情况。当系统调用或库函数返回一个失败状态时，通过检查 <code>errno</code> 变量并根据相应的错误码进行处理，可以更好地识别和解决程序中的问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_2_dirent_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_2_dirent_h/" class="post-title-link" itemprop="url">C_5_2_dirent_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>&lt;dirent.h&gt;标准头文件</li>
</ul>
<h2 id="Linux-POSIX-详解"><a href="#Linux-POSIX-详解" class="headerlink" title="Linux POSIX &lt;dirent.h&gt; 详解"></a>Linux POSIX &lt;dirent.h&gt; 详解</h2><p>在 POSIX 系统中（如 Linux），<code>&lt;dirent.h&gt;</code> 头文件提供了访问目录及其条目的函数和数据结构，允许程序对目录进行操作，比如遍历目录、读取目录下的文件等。</p>
<p>以下是 <code>&lt;dirent.h&gt;</code> 中常见的一些功能和相关的数据结构：</p>
<ol>
<li><p>**数据结构 <code>struct dirent</code>**：<br><code>struct dirent</code> 是 <code>&lt;dirent.h&gt;</code> 中定义的结构体，用于表示目录中的一个条目（文件或子目录）。它通常包含以下成员：</p>
<ul>
<li><code>ino_t d_ino</code>：表示目录条目的 inode 号。</li>
<li><code>char d_name[]</code>：表示目录条目的名称。</li>
</ul>
</li>
<li><p>**函数 <code>opendir()</code>**：<br><code>opendir()</code> 函数用于打开一个目录，它接收目录路径作为参数，并返回一个指向 <code>DIR</code> 结构的指针。示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DIR *dir = opendir(<span class="string">&quot;/path/to/directory&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**函数 <code>readdir()</code>**：<br><code>readdir()</code> 函数用于读取打开的目录中的条目。它接收 <code>opendir()</code> 返回的 <code>DIR</code> 结构指针作为参数，并返回指向 <code>struct dirent</code> 结构的指针。示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line"><span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, entry-&gt;d_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**函数 <code>closedir()</code>**：<br><code>closedir()</code> 函数用于关闭先前由 <code>opendir()</code> 打开的目录流。示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closedir(dir);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>使用这些函数，你可以在程序中对目录进行操作，例如打开目录、遍历目录中的文件或子目录，读取它们的属性，然后进行相应的操作。这些函数使得在 POSIX 兼容系统上进行文件和目录处理更加方便和灵活。</p>
<h2 id="Linux-POSIX-struct-dirent-详解"><a href="#Linux-POSIX-struct-dirent-详解" class="headerlink" title="Linux POSIX &lt;dirent.h&gt; struct dirent 详解"></a>Linux POSIX &lt;dirent.h&gt; struct dirent 详解</h2><p>在 POSIX 系统中，<code>&lt;dirent.h&gt;</code> 头文件定义了用于访问目录及其条目的函数和数据结构。其中，<code>struct dirent</code> 是该头文件中定义的结构体，用于表示目录中的单个条目（即文件或子目录）的信息。</p>
<p><code>struct dirent</code> 结构体通常包含以下成员：</p>
<ol>
<li><p><code>ino_t d_ino</code>：这是目录项的 inode 号码（在文件系统中唯一标识文件或目录）。使用 inode 号码可以唯一地标识文件系统中的特定文件或目录。</p>
</li>
<li><p><code>off_t d_off</code>：这是目录项在目录中的偏移量，通常在一些特定的文件系统中有用。</p>
</li>
<li><p><code>unsigned short d_reclen</code>：这是目录项的长度。</p>
</li>
<li><p><code>unsigned char d_type</code>：这是目录项的类型。这个成员通常在 POSIX 系统中非标准化，因此在不同系统上可能会有不同的值，表示文件类型（比如普通文件、目录、链接等）。</p>
</li>
<li><p><code>char d_name[]</code>：这是一个字符数组，表示目录项的名称。该数组的大小通常是可变的，因为文件名的长度可能不同。</p>
</li>
</ol>
<p><code>struct dirent</code> 结构体的定义可能会因系统而异，因为不同的操作系统或文件系统可能具有不同的字段或实现。在 POSIX 兼容系统上，通常会使用这个结构体来在程序中读取目录中的条目，并获取每个条目的名称和其他基本信息。</p>
<p>在使用 <code>&lt;dirent.h&gt;</code> 头文件中的函数（如 <code>readdir()</code>）读取目录内容时，通常会创建 <code>struct dirent</code> 类型的变量来存储每个读取到的目录项的信息，然后进一步处理这些信息，比如打印文件名、获取文件属性等操作。</p>
<h2 id="Linux-POSIX-opendir-详解"><a href="#Linux-POSIX-opendir-详解" class="headerlink" title="Linux POSIX &lt;dirent.h&gt; opendir() 详解"></a>Linux POSIX &lt;dirent.h&gt; opendir() 详解</h2><p>在 POSIX 系统中，<code>opendir()</code> 函数是 <code>&lt;dirent.h&gt;</code> 头文件中用于打开目录的函数之一。它允许程序员打开一个目录流，并返回一个指向 <code>DIR</code> 结构的指针，以便后续对该目录进行操作。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dirname)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dirname</code> 是一个字符串，表示目标目录的路径名。函数返回一个指向 <code>DIR</code> 结构的指针，或者在出错时返回 <code>NULL</code>。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    dir = opendir(<span class="string">&quot;/path/to/directory&quot;</span>); <span class="comment">// 打开目录流</span></span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123; <span class="comment">// 读取目录中的条目</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, entry-&gt;d_name); <span class="comment">// 打印条目名称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(dir); <span class="comment">// 关闭目录流</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该示例演示了如何使用 <code>opendir()</code> 打开目录流，然后使用 <code>readdir()</code> 读取目录中的条目，最后使用 <code>closedir()</code> 关闭目录流。在这个例子中，<code>readdir()</code> 用于读取目录中的每个条目，并通过 <code>entry-&gt;d_name</code> 打印出每个条目的名称。</p>
<p>需要注意的是，如果 <code>opendir()</code> 执行成功，它会返回一个指向 <code>DIR</code> 结构的指针，该指针可以用于后续的目录操作。而在出错时，它会返回 <code>NULL</code>，此时可以使用 <code>perror()</code> 或其他错误处理函数来输出错误信息或进行处理。</p>
<h2 id="Linux-POSIX-readdir-详解"><a href="#Linux-POSIX-readdir-详解" class="headerlink" title="Linux POSIX &lt;dirent.h&gt; readdir() 详解"></a>Linux POSIX &lt;dirent.h&gt; readdir() 详解</h2><p>在 POSIX 系统中，<code>readdir()</code> 函数是 <code>&lt;dirent.h&gt;</code> 头文件中用于读取目录中条目的函数之一。它允许程序员逐个读取打开的目录流中的目录项，并返回指向 <code>struct dirent</code> 结构的指针，指向每个目录项的信息。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dir)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dir</code> 是一个指向先前由 <code>opendir()</code> 打开的目录流的指针。函数返回一个指向 <code>struct dirent</code> 结构的指针，或者在读取到目录末尾或出错时返回 <code>NULL</code>。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    dir = opendir(<span class="string">&quot;/path/to/directory&quot;</span>); <span class="comment">// 打开目录流</span></span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123; <span class="comment">// 读取目录中的条目</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, entry-&gt;d_name); <span class="comment">// 打印条目名称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(dir); <span class="comment">// 关闭目录流</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>readdir()</code> 用于读取目录中的每个条目，并将其存储在类型为 <code>struct dirent</code> 的结构体指针 <code>entry</code> 中。<code>entry-&gt;d_name</code> 包含每个条目的名称，可以用于打印或进一步处理。</p>
<p>循环中的条件 <code>(entry = readdir(dir)) != NULL</code> 表示只要 <code>readdir()</code> 返回的指针不是 <code>NULL</code>，就会继续读取并处理目录中的下一个条目。当读取到目录末尾或出现错误时，<code>readdir()</code> 将返回 <code>NULL</code>，循环结束。</p>
<p>最后，使用 <code>closedir()</code> 函数关闭先前由 <code>opendir()</code> 打开的目录流，释放资源并结束操作。</p>
<p>通过 <code>readdir()</code> 函数，你可以逐个读取目录中的条目，从而获取目录下文件和子目录的信息，并进行相应的处理。</p>
<h2 id="Linux-POSIX-closedir-详解"><a href="#Linux-POSIX-closedir-详解" class="headerlink" title="Linux POSIX &lt;dirent.h&gt; closedir() 详解"></a>Linux POSIX &lt;dirent.h&gt; closedir() 详解</h2><p>在 POSIX 系统中，<code>closedir()</code> 函数是 <code>&lt;dirent.h&gt;</code> 头文件中用于关闭先前打开的目录流的函数。它用于释放由 <code>opendir()</code> 打开的目录流所占用的资源，并清理相关的内存，以防止资源泄漏。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dir)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dir</code> 是一个指向先前由 <code>opendir()</code> 打开的目录流的指针。函数返回整型值，通常在成功关闭目录流时返回 0，出错时返回 -1。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line"></span><br><span class="line">    dir = opendir(<span class="string">&quot;/path/to/directory&quot;</span>); <span class="comment">// 打开目录流</span></span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对目录进行操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (closedir(dir) == <span class="number">-1</span>) &#123; <span class="comment">// 关闭目录流</span></span><br><span class="line">        perror(<span class="string">&quot;closedir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>closedir()</code> 函数用于关闭先前由 <code>opendir()</code> 打开的目录流 <code>dir</code>。它应该在对目录进行操作后使用，以释放相关资源。</p>
<p>如果成功关闭目录流，<code>closedir()</code> 返回 0。如果出现错误，它会返回 -1，并且你可以使用 <code>perror()</code> 或其他错误处理方法来输出错误信息。</p>
<p>使用 <code>closedir()</code> 是一个良好的编程实践，以确保在不再需要目录流时正确释放相关资源，避免资源泄漏和其他问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_5_stdio_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_5_stdio_h/" class="post-title-link" itemprop="url">C_5_5_stdio_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>&lt;stdio.h&gt;标准头文件</li>
</ul>
<h2 id="Linux-POSIX-详解"><a href="#Linux-POSIX-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; 详解"></a>Linux POSIX &lt;stdio.h&gt; 详解</h2><p><code>&lt;stdio.h&gt;</code> 是 C 标准库的头文件之一，在 Linux POSIX 系统中提供了对标准输入和输出的支持。</p>
<h3 id="主要功能和常见函数："><a href="#主要功能和常见函数：" class="headerlink" title="主要功能和常见函数："></a>主要功能和常见函数：</h3><ol>
<li><p><strong>标准输入输出函数</strong>：</p>
<ul>
<li><code>printf()</code>：用于将格式化数据打印到标准输出（终端）。</li>
<li><code>scanf()</code>：用于从标准输入（键盘）读取格式化的数据。</li>
<li><code>fprintf()</code>：将格式化数据打印到指定文件流中。</li>
<li><code>fscanf()</code>：从指定文件流中读取格式化的数据。</li>
<li><code>getchar()</code>：从标准输入中读取一个字符。</li>
<li><code>putchar()</code>：将一个字符输出到标准输出。</li>
</ul>
</li>
<li><p><strong>文件操作函数</strong>：</p>
<ul>
<li><code>fopen()</code>：打开文件并返回文件指针。</li>
<li><code>fclose()</code>：关闭文件。</li>
<li><code>fgets()</code>：从文件中读取一行数据。</li>
<li><code>fputs()</code>：将字符串写入文件。</li>
<li><code>fgetc()</code> 和 <code>fputc()</code>：用于读取和写入单个字符到文件。</li>
<li><code>feof()</code> 和 <code>ferror()</code>：检查文件结束和错误标志。</li>
</ul>
</li>
<li><p><strong>文件定位函数</strong>：</p>
<ul>
<li><code>fseek()</code> 和 <code>ftell()</code>：用于在文件中定位和获取当前位置。</li>
</ul>
</li>
<li><p><strong>格式化输出函数</strong>：</p>
<ul>
<li><code>sprintf()</code>：将格式化的数据写入字符串中。</li>
<li><code>snprintf()</code>：类似于 <code>sprintf()</code>，但提供了字符数限制，避免缓冲区溢出。</li>
</ul>
</li>
<li><p><strong>标准流</strong>：</p>
<ul>
<li><code>stdin</code>：标准输入流，通常代表键盘输入。</li>
<li><code>stdout</code>：标准输出流，通常代表终端输出。</li>
<li><code>stderr</code>：标准错误流，通常用于输出错误消息。</li>
</ul>
</li>
<li><p><strong>宏定义</strong>：</p>
<ul>
<li><code>EOF</code>：表示文件结束。</li>
<li><code>NULL</code>：表示空指针。</li>
</ul>
</li>
</ol>
<h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(file, <span class="string">&quot;这是一个示例文件\n&quot;</span>);</span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取文件内容：\n&quot;</span>);</span><br><span class="line">    FILE *fileRead = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fileRead != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), fileRead) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fileRead);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>&lt;stdio.h&gt;</code> 中的函数进行文件的写入和读取操作。其中，<code>fopen()</code> 用于打开文件，<code>fprintf()</code> 用于将内容写入文件，<code>fgets()</code> 用于从文件中读取内容并打印到控制台上。</p>
<h2 id="Linux-POSIX-printf-详解"><a href="#Linux-POSIX-printf-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; printf() 详解"></a>Linux POSIX &lt;stdio.h&gt; printf() 详解</h2><p><code>&lt;stdio.h&gt;</code> 是 C 语言中的一个头文件，用于提供标准输入输出功能。其中的 <code>printf()</code> 函数是用于格式化输出的一个重要函数。</p>
<h3 id="printf-函数"><a href="#printf-函数" class="headerlink" title="printf() 函数"></a><code>printf()</code> 函数</h3><p><code>printf()</code> 用于将格式化的数据输出到标准输出（通常是控制台），其功能是“打印格式化的内容”，可以按指定格式在屏幕上显示信息。</p>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>format</code>**：一个字符串，用于指定输出的格式，可以包含普通字符（按原样输出）和格式说明符。</li>
<li>**<code>...</code>**：额外的参数（可选），对应于 <code>format</code> 字符串中的格式说明符。</li>
</ul>
<h4 id="格式说明符："><a href="#格式说明符：" class="headerlink" title="格式说明符："></a>格式说明符：</h4><p><code>format</code> 字符串中的格式说明符以百分号 <code>%</code> 开始，后跟一个表示要打印数据类型的字符。</p>
<p>常见的格式说明符包括：</p>
<ul>
<li><code>%d</code>：整数</li>
<li><code>%f</code>：浮点数</li>
<li><code>%c</code>：字符</li>
<li><code>%s</code>：字符串</li>
<li><code>%p</code>：指针地址</li>
<li><code>%x</code>、<code>%X</code>：十六进制整数</li>
<li><code>%o</code>：八进制整数</li>
<li><code>%u</code>：无符号整数</li>
</ul>
<h4 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">float</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;整数：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;浮点数：%f\n&quot;</span>, pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符：%c\n&quot;</span>, ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串：%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><ul>
<li><code>%d</code>、<code>%f</code>、<code>%c</code>、<code>%s</code> 是用于打印不同数据类型变量的格式说明符。</li>
<li>每个 <code>printf()</code> 调用中，格式说明符会被对应的变量值替换，作为额外的参数提供给 <code>printf()</code> 函数。</li>
</ul>
<h4 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h4><ul>
<li><code>printf()</code> 返回打印的字符数（不包括用于结束字符串输出的空字节）。如果发生错误，它将返回负值。</li>
</ul>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul>
<li><code>printf()</code> 函数在格式化输出方面非常强大和灵活，允许精确控制数据的显示方式。</li>
<li>如果格式说明符使用不正确，可能会导致未定义的行为或错误，如打印错误的值或使程序崩溃。</li>
</ul>
<h2 id="Linux-POSIX-scanf-详解"><a href="#Linux-POSIX-scanf-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; scanf() 详解"></a>Linux POSIX &lt;stdio.h&gt; scanf() 详解</h2><p><code>&lt;stdio.h&gt;</code> 是 C 语言中的一个头文件，提供了输入输出操作的函数和宏。<code>scanf()</code> 是其中用于输入的函数之一。</p>
<h3 id="scanf-函数"><a href="#scanf-函数" class="headerlink" title="scanf() 函数"></a><code>scanf()</code> 函数</h3><p><code>scanf()</code> 函数用于从标准输入（通常是键盘）获取输入，并根据指定的格式将数据存储到指定的变量中。</p>
<h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>format</code>**：包含格式说明符的字符串，用于指定输入的格式。</li>
<li>**<code>...</code>**：用于接收输入数据的变量列表，按照 <code>format</code> 字符串中的格式进行匹配。</li>
</ul>
<h4 id="格式说明符：-1"><a href="#格式说明符：-1" class="headerlink" title="格式说明符："></a>格式说明符：</h4><p>格式说明符在 <code>format</code> 字符串中，用于指定输入的数据类型。</p>
<p>常见的格式说明符与 <code>printf()</code> 相似，包括：</p>
<ul>
<li><code>%d</code>：整数</li>
<li><code>%f</code>：浮点数</li>
<li><code>%c</code>：字符</li>
<li><code>%s</code>：字符串</li>
<li><code>%p</code>：指针地址</li>
<li><code>%x</code>、<code>%X</code>：十六进制整数</li>
<li><code>%o</code>：八进制整数</li>
<li><code>%u</code>：无符号整数</li>
</ul>
<h4 id="示例用法：-1"><a href="#示例用法：-1" class="headerlink" title="示例用法："></a>示例用法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">float</span> pi;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个浮点数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;pi);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个字符：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;ch);  <span class="comment">// 注意空格，避免读取上一个输入后的回车符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您输入的整数是：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您输入的浮点数是：%f\n&quot;</span>, pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您输入的字符是：%c\n&quot;</span>, ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您输入的字符串是：%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a>解释：</h4><ul>
<li><code>scanf()</code> 函数按照指定的格式说明符从标准输入中读取输入，并将输入的数据存储到相应的变量中。</li>
<li>格式说明符 <code>%d</code>、<code>%f</code>、<code>%c</code>、<code>%s</code> 分别用于读取不同类型的数据。</li>
<li><code>&amp;</code> 运算符用于传递变量的地址，使得 <code>scanf()</code> 函数可以将输入的值存储到相应变量的内存位置中。</li>
</ul>
<h4 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h4><ul>
<li><code>scanf()</code> 返回成功读取的参数数目。如果发生读取失败或到达文件结束，则返回值可能会少于指定的参数数目。</li>
</ul>
<h3 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h3><ul>
<li>使用 <code>scanf()</code> 时要确保提供正确的格式说明符，否则可能导致输入解析错误或意外行为。</li>
<li>对于字符串 <code>%s</code>，它会在空白字符（如空格、制表符、换行符等）处停止读取，可以使用其他函数（如 <code>fgets()</code>）更安全地读取一行字符串。</li>
</ul>
<p>使用 <code>scanf()</code> 需要谨慎，确保输入与格式匹配，以避免潜在的问题。</p>
<h2 id="Linux-POSIX-fprintf-详解"><a href="#Linux-POSIX-fprintf-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fprintf() 详解"></a>Linux POSIX &lt;stdio.h&gt; fprintf() 详解</h2><p><code>&lt;stdio.h&gt;</code> 中的 <code>fprintf()</code> 函数与 <code>printf()</code> 函数类似，但不是将输出发送到标准输出（通常是屏幕），而是将格式化的输出发送到指定的文件流中。这允许将格式化的数据写入文件而不是控制台。</p>
<h3 id="fprintf-函数"><a href="#fprintf-函数" class="headerlink" title="fprintf() 函数"></a><code>fprintf()</code> 函数</h3><h4 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>stream</code>**：指向文件的指针，表示要写入的文件流。</li>
<li>**<code>format</code>**：一个字符串，用于指定输出的格式，可以包含普通字符和格式说明符。</li>
<li>**<code>...</code>**：额外的参数（可选），对应于 <code>format</code> 字符串中的格式说明符。</li>
</ul>
<h4 id="格式说明符和用法与-printf-相同。"><a href="#格式说明符和用法与-printf-相同。" class="headerlink" title="格式说明符和用法与 printf() 相同。"></a>格式说明符和用法与 <code>printf()</code> 相同。</h4><h4 id="示例用法：-2"><a href="#示例用法：-2" class="headerlink" title="示例用法："></a>示例用法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *filePointer;</span><br><span class="line">    <span class="type">char</span> data[] = <span class="string">&quot;Hello, File I/O!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    filePointer = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>); <span class="comment">// 打开文件以写入模式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filePointer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(filePointer, <span class="string">&quot;这是 fprintf() 写入的内容：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(filePointer, <span class="string">&quot;字符串：%s\n&quot;</span>, data);</span><br><span class="line">    <span class="built_in">fprintf</span>(filePointer, <span class="string">&quot;整数：%d\n&quot;</span>, <span class="number">12345</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(filePointer, <span class="string">&quot;浮点数：%f\n&quot;</span>, <span class="number">3.14159</span>);</span><br><span class="line"></span><br><span class="line">    fclose(filePointer); <span class="comment">// 关闭文件流</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据已写入文件\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解释：-2"><a href="#解释：-2" class="headerlink" title="解释："></a>解释：</h4><ul>
<li><code>fprintf()</code> 将格式化的输出写入指定的文件流（在此示例中是名为 “output.txt” 的文件）。</li>
<li>使用 <code>fopen()</code> 函数打开文件，指定 “w”（写入）模式。</li>
<li>检查文件指针是否为 <code>NULL</code>，以确保文件成功打开。</li>
<li>然后，<code>fprintf()</code> 将数据写入文件，格式与 <code>printf()</code> 相同。</li>
<li>使用 <code>fclose()</code> 关闭文件流。</li>
</ul>
<h4 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h4><ul>
<li><code>fprintf()</code> 返回写入文件的字符数。如果发生错误，则返回负值。</li>
</ul>
<h3 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h3><ul>
<li>使用 <code>fprintf()</code> 时要确保提供正确的文件指针以及正确的格式说明符，否则可能导致写入文件错误或意外结果。</li>
<li>在完成对文件的操作后，务必关闭文件流以释放资源。</li>
</ul>
<p><code>fprintf()</code> 提供了一种将格式化数据写入文件的方法，可以根据需要指定不同的文件流，并将数据写入文件而不是标准输出。</p>
<h2 id="Linux-POSIX-fscanf-详解"><a href="#Linux-POSIX-fscanf-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fscanf() 详解"></a>Linux POSIX &lt;stdio.h&gt; fscanf() 详解</h2><p><code>&lt;stdio.h&gt;</code> 中的 <code>fscanf()</code> 函数与 <code>scanf()</code> 函数类似，但它从指定的文件流中读取格式化的输入，而不是从标准输入（键盘）中读取输入。</p>
<h3 id="fscanf-函数"><a href="#fscanf-函数" class="headerlink" title="fscanf() 函数"></a><code>fscanf()</code> 函数</h3><h4 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>stream</code>**：指向文件的指针，表示要从中读取数据的文件流。</li>
<li>**<code>format</code>**：包含格式说明符的字符串，用于指定输入的格式。</li>
<li>**<code>...</code>**：用于接收读取数据的变量列表，按照 <code>format</code> 字符串中的格式进行匹配。</li>
</ul>
<h4 id="格式说明符和用法与-scanf-相同。"><a href="#格式说明符和用法与-scanf-相同。" class="headerlink" title="格式说明符和用法与 scanf() 相同。"></a>格式说明符和用法与 <code>scanf()</code> 相同。</h4><h4 id="示例用法：-3"><a href="#示例用法：-3" class="headerlink" title="示例用法："></a>示例用法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *filePointer;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">float</span> pi;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    filePointer = fopen(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="comment">// 以读取模式打开文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filePointer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fscanf</span>(filePointer, <span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="built_in">fscanf</span>(filePointer, <span class="string">&quot;%f&quot;</span>, &amp;pi);</span><br><span class="line">    <span class="built_in">fscanf</span>(filePointer, <span class="string">&quot; %c&quot;</span>, &amp;ch); <span class="comment">// 注意空格，避免读取上一个输入后的回车符</span></span><br><span class="line">    <span class="built_in">fscanf</span>(filePointer, <span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从文件中读取的整数是：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从文件中读取的浮点数是：%f\n&quot;</span>, pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从文件中读取的字符是：%c\n&quot;</span>, ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从文件中读取的字符串是：%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    fclose(filePointer); <span class="comment">// 关闭文件流</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解释：-3"><a href="#解释：-3" class="headerlink" title="解释："></a>解释：</h4><ul>
<li><code>fscanf()</code> 函数按照指定的格式说明符从指定文件流中读取输入，并将数据存储到相应的变量中。</li>
<li>使用 <code>fopen()</code> 函数以 “r”（读取）模式打开文件流。</li>
<li>检查文件指针是否为 <code>NULL</code>，以确保文件成功打开。</li>
<li>然后，<code>fscanf()</code> 从文件中读取数据，格式与 <code>scanf()</code> 相同。</li>
<li>最后，使用 <code>fclose()</code> 关闭文件流。</li>
</ul>
<h4 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a>返回值：</h4><ul>
<li><code>fscanf()</code> 返回成功读取的参数数目。如果发生读取失败或到达文件结束，则返回值可能会少于指定的参数数目。</li>
</ul>
<h3 id="注意：-3"><a href="#注意：-3" class="headerlink" title="注意："></a>注意：</h3><ul>
<li>使用 <code>fscanf()</code> 时要确保提供正确的文件指针以及正确的格式说明符，否则可能导致读取文件错误或意外结果。</li>
<li>在完成对文件的操作后，务必关闭文件流以释放资源。</li>
</ul>
<p><code>fscanf()</code> 提供了一种从文件流中读取格式化数据的方法，可以根据需要从不同的文件流读取数据而不是标准输入。</p>
<h2 id="Linux-POSIX-getchar-详解"><a href="#Linux-POSIX-getchar-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; getchar() 详解"></a>Linux POSIX &lt;stdio.h&gt; getchar() 详解</h2><p><code>getchar()</code> 是 <code>&lt;stdio.h&gt;</code> 头文件中的函数，用于从标准输入（通常是键盘）获取一个字符。</p>
<h3 id="getchar-函数"><a href="#getchar-函数" class="headerlink" title="getchar() 函数"></a><code>getchar()</code> 函数</h3><h4 id="语法：-4"><a href="#语法：-4" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>无参数</strong>：<code>getchar()</code> 不接受任何参数。</li>
<li><strong>返回值</strong>：返回一个整数值，表示获取的字符的 ASCII 值（或者在遇到文件结束或错误时返回特殊值 <code>EOF</code>）。</li>
</ul>
<h4 id="示例用法：-4"><a href="#示例用法：-4" class="headerlink" title="示例用法："></a>示例用法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个字符：\n&quot;</span>);</span><br><span class="line">    ch = getchar();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您输入的字符是：%c\n&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解释：-4"><a href="#解释：-4" class="headerlink" title="解释："></a>解释：</h4><ul>
<li><code>getchar()</code> 函数用于从标准输入中获取一个字符，并将其作为整数返回。</li>
<li><code>getchar()</code> 在用户输入一个字符后，程序会等待用户按下回车键以表示输入完成，然后才会返回该字符的 ASCII 值。</li>
</ul>
<h4 id="返回值：-4"><a href="#返回值：-4" class="headerlink" title="返回值："></a>返回值：</h4><ul>
<li>如果成功获取字符，则返回该字符的 ASCII 值（0 到 255 之间的整数）。</li>
<li>如果在获取字符时出现错误或者达到文件结束（End of File，EOF），则返回特殊值 <code>EOF</code>（一般为 <code>-1</code>）。</li>
</ul>
<h3 id="注意：-4"><a href="#注意：-4" class="headerlink" title="注意："></a>注意：</h3><ul>
<li><code>getchar()</code> 函数每次只能获取一个字符，即使用户输入多个字符也只返回第一个字符的 ASCII 值。</li>
<li>在需要连续获取多个字符的情况下，通常需要循环调用 <code>getchar()</code>。</li>
</ul>
<p><code>getchar()</code> 是一个简单且常用的函数，适用于获取单个字符的输入。如果需要读取整行文本或者处理大量输入，可能需要考虑其他输入函数或循环来获取和处理数据。</p>
<h2 id="Linux-POSIX-putchar-详解"><a href="#Linux-POSIX-putchar-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; putchar() 详解"></a>Linux POSIX &lt;stdio.h&gt; putchar() 详解</h2><p><code>putchar()</code> 是 C 标准库 <code>&lt;stdio.h&gt;</code> 中的函数，用于将一个字符输出到标准输出设备（通常是屏幕）。</p>
<h3 id="putchar-函数"><a href="#putchar-函数" class="headerlink" title="putchar() 函数"></a><code>putchar()</code> 函数</h3><h4 id="语法：-5"><a href="#语法：-5" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> character)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>character</code>**：要输出的字符，以整数形式传递（ASCII 值）。</li>
<li><strong>返回值</strong>：如果成功输出字符，则返回输出的字符（<code>character</code> 参数的值）。如果发生错误，返回特殊值 <code>EOF</code>。</li>
</ul>
<h4 id="示例用法：-5"><a href="#示例用法：-5" class="headerlink" title="示例用法："></a>示例用法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输出一个字符：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解释：-5"><a href="#解释：-5" class="headerlink" title="解释："></a>解释：</h4><ul>
<li><code>putchar()</code> 函数用于将指定的字符输出到标准输出设备（通常是屏幕）上。</li>
<li>在示例中，<code>putchar(ch)</code> 将字符 <code>&#39;A&#39;</code>（ASCII 值为 65）输出到屏幕上。</li>
</ul>
<h4 id="返回值：-5"><a href="#返回值：-5" class="headerlink" title="返回值："></a>返回值：</h4><ul>
<li>如果成功输出字符，则返回输出的字符的 ASCII 值（即 <code>character</code> 参数的值）。</li>
<li>如果发生错误，返回特殊值 <code>EOF</code>（一般为 <code>-1</code>）。</li>
</ul>
<h3 id="注意：-5"><a href="#注意：-5" class="headerlink" title="注意："></a>注意：</h3><ul>
<li><code>putchar()</code> 函数每次只能输出一个字符。</li>
<li>如果需要输出多个字符，通常需要循环调用 <code>putchar()</code> 或者结合使用其他输出函数进行输出。</li>
</ul>
<p><code>putchar()</code> 是一个简单且常用的函数，用于将单个字符输出到标准输出设备。如果需要输出整个字符串或进行大量输出，可能需要考虑其他输出函数或循环来实现。</p>
<h2 id="Linux-POSIX-fopen-详解"><a href="#Linux-POSIX-fopen-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fopen() 详解"></a>Linux POSIX &lt;stdio.h&gt; fopen() 详解</h2><p>在 POSIX 标准中，<code>&lt;stdio.h&gt;</code> 头文件提供了处理文件输入输出的函数和宏定义。其中之一是 <code>fopen()</code> 函数，用于打开文件并返回一个文件指针，可以在文件中执行读取或写入操作。</p>
<p>以下是关于 <code>fopen()</code> 函数的详细解释：</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>filename</code>：要打开的文件的路径和名称。</li>
<li><code>mode</code>：文件打开模式，定义了文件如何被打开。模式字符串包括：<ul>
<li><code>&quot;r&quot;</code>：只读模式，文件必须存在，从文件的开头开始。</li>
<li><code>&quot;w&quot;</code>：写入模式，如果文件不存在则创建，如果文件已存在则截断为零长度，从文件的开头开始。</li>
<li><code>&quot;a&quot;</code>：追加模式，如果文件不存在则创建，从文件末尾开始写入。</li>
<li><code>&quot;r+&quot;</code>：读写模式，文件必须存在，从文件的开头开始。</li>
<li><code>&quot;w+&quot;</code>：读写模式，如果文件不存在则创建，如果文件已存在则截断为零长度，从文件的开头开始。</li>
<li><code>&quot;a+&quot;</code>：读写模式，如果文件不存在则创建，从文件末尾开始写入。</li>
</ul>
</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>fopen()</code> 函数返回一个指向 <code>FILE</code> 结构的指针，如果文件打开成功，则返回指向文件的指针。如果打开失败，则返回 <code>NULL</code>。</li>
</ul>
<h3 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="comment">// 以只读模式打开文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 对文件执行读取或其他操作</span></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>在使用 <code>fopen()</code> 函数后，始终应该检查返回的文件指针是否为 <code>NULL</code>，以确保文件是否成功打开。</li>
<li>打开文件后，使用完毕应该使用 <code>fclose()</code> 函数关闭文件，以释放资源并确保写入缓冲区的数据被刷新到文件中。</li>
<li>在使用文件操作相关函数时，应该检查每个函数的返回值以确保操作成功。</li>
</ul>
<p><code>fopen()</code> 是处理文件输入输出中常用的函数之一，使用正确的打开模式并检查返回值是确保文件操作正确执行的重要步骤。</p>
<h2 id="Linux-POSIX-fclose-详解"><a href="#Linux-POSIX-fclose-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fclose() 详解"></a>Linux POSIX &lt;stdio.h&gt; fclose() 详解</h2><p>在 Linux POSIX 系统中，<code>&lt;stdio.h&gt;</code> 头文件提供了许多用于文件操作的函数。<code>fclose()</code> 是其中一个函数，用于关闭先前使用 <code>fopen()</code> 打开的文件流。这个函数的作用是关闭指定文件流，并确保在关闭文件之前将所有的缓冲区数据刷新到文件中。</p>
<p>以下是关于 <code>fclose()</code> 函数的详细解释：</p>
<h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，它标识了要关闭的文件流。</li>
</ul>
<h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>fclose()</code> 函数返回整型值。若关闭成功，则返回 <code>0</code>；若出现错误，则返回 <code>EOF</code>。</li>
</ul>
<h3 id="示例用法-1"><a href="#示例用法-1" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 对文件执行读取或其他操作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fclose(file) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;文件关闭成功\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;文件关闭失败\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>fclose()</code> 函数关闭文件后，应该确保不再对该文件执行读取或写入操作，否则可能会导致未定义的行为。</li>
<li>关闭文件时，系统会清理所有与该文件相关的资源，并将缓冲区的数据刷新到磁盘中。因此，关闭文件是一个重要的操作，以确保数据完整性和释放资源。</li>
</ul>
<p><code>fclose()</code> 函数是在文件操作中非常重要的一个函数，用于安全地关闭文件流并清理相应的资源。使用时，应该注意检查其返回值，确保文件被成功关闭。</p>
<h2 id="Linux-POSIX-fgets-详解"><a href="#Linux-POSIX-fgets-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fgets() 详解"></a>Linux POSIX &lt;stdio.h&gt; fgets() 详解</h2><p>在 POSIX 标准的 <code>&lt;stdio.h&gt;</code> 头文件中，<code>fgets()</code> 是用于从文件中读取一行数据的函数。它可以读取指定长度的字符或直到遇到换行符（<code>\n</code>）为止，并将结果存储到一个字符串缓冲区中。</p>
<p>以下是关于 <code>fgets()</code> 函数的详细解释：</p>
<h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> size, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>str</code>：指向字符数组的指针，用于存储读取的字符串数据。</li>
<li><code>size</code>：要读取的最大字符数（包括结尾的空字符 ‘\0’）。</li>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，表示要读取的文件流。</li>
</ul>
<h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>fgets()</code> 函数返回一个指向存储读取的字符串的指针，如果读取成功，则返回 <code>str</code>；如果达到文件尾或发生错误，则返回 <code>NULL</code>。</li>
</ul>
<h3 id="示例用法-2"><a href="#示例用法-2" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>]; <span class="comment">// 定义一个缓冲区来存储读取的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取文件中的一行数据</span></span><br><span class="line">        <span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), file) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;读取的内容：%s&quot;</span>, buffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>fgets()</code> 函数从文件中读取一行文本数据，并在读取的数据中保留换行符（如果存在的话）。如果一行数据超过了指定的 <code>size - 1</code> 大小，则只会读取部分数据，剩余部分会在下一次读取时继续获取。</li>
<li>使用 <code>fgets()</code> 时应该检查返回值是否为 <code>NULL</code>，以便判断是否读取到文件末尾或发生错误。</li>
</ul>
<p><code>fgets()</code> 函数在从文件中逐行读取数据时非常有用，特别是对于文本文件的处理。它允许你逐行读取文件内容并对每一行进行处理。</p>
<h2 id="Linux-POSIX-fputs-详解"><a href="#Linux-POSIX-fputs-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fputs() 详解"></a>Linux POSIX &lt;stdio.h&gt; fputs() 详解</h2><p>在 POSIX 标准的 <code>&lt;stdio.h&gt;</code> 头文件中，<code>fputs()</code> 是用于向文件写入字符串的函数。它将字符串写入到指定的文件流中，不包括字符串结尾的空字符 (‘\0’)。</p>
<p>以下是关于 <code>fputs()</code> 函数的详细解释：</p>
<h3 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>str</code>：要写入的字符串，以 null 结尾。</li>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，表示要写入的文件流。</li>
</ul>
<h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>fputs()</code> 函数返回一个非负整数值来表示成功写入的字符数。如果发生错误，则返回 <code>EOF</code>。</li>
</ul>
<h3 id="示例用法-3"><a href="#示例用法-3" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入字符串到文件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fputs</span>(<span class="string">&quot;Hello, fputs!\n&quot;</span>, file) != EOF) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;字符串写入成功\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;字符串写入失败\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>fputs()</code> 函数写入字符串时，不会自动添加换行符。如果需要换行，需要在字符串中包含 <code>\n</code>。</li>
<li>需要检查 <code>fputs()</code> 的返回值，以确保写入操作成功完成。返回值为 <code>EOF</code> 表示写入发生错误。</li>
</ul>
<p><code>fputs()</code> 函数是一个常用的文件操作函数，用于将字符串写入到指定的文件中。在使用时应该注意检查返回值，确保写入操作成功。</p>
<h2 id="Linux-POSIX-fgetc-详解"><a href="#Linux-POSIX-fgetc-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fgetc() 详解"></a>Linux POSIX &lt;stdio.h&gt; fgetc() 详解</h2><p>在 Linux POSIX 标准的 <code>&lt;stdio.h&gt;</code> 头文件中，<code>fgetc()</code> 函数用于从指定文件流中读取一个字符。它可以逐个字符地读取文件内容。</p>
<p>以下是关于 <code>fgetc()</code> 函数的详细解释：</p>
<h3 id="函数原型-4"><a href="#函数原型-4" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，表示要读取的文件流。</li>
</ul>
<h3 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>fgetc()</code> 函数返回一个整型值，即所读取的字符的 ASCII 值。如果到达文件结尾或发生错误，则返回 <code>EOF</code>（End of File）。</li>
</ul>
<h3 id="示例用法-4"><a href="#示例用法-4" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">int</span> character;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐字符读取文件内容</span></span><br><span class="line">        <span class="keyword">while</span> ((character = fgetc(file)) != EOF) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, character); <span class="comment">// 打印所读取的字符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>fgetc()</code> 函数逐个字符地读取文件内容时，返回值是一个整数（ASCII 值），需要将其转换为字符或进行相应的处理。</li>
<li>在使用文件流的读取函数时，应该检查返回值是否为 <code>EOF</code>，以判断是否到达文件结尾或发生了错误。</li>
</ul>
<p><code>fgetc()</code> 函数允许你逐个字符地读取文件内容，适用于需要对文件内容逐个字符进行处理的场景。在读取文件时要确保文件能够成功打开，并在读取过程中对返回值进行适当的检查。</p>
<h2 id="Linux-POSIX-fputc-详解"><a href="#Linux-POSIX-fputc-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fputc() 详解"></a>Linux POSIX &lt;stdio.h&gt; fputc() 详解</h2><p>在 Linux POSIX 标准的 <code>&lt;stdio.h&gt;</code> 头文件中，<code>fputc()</code> 函数用于将一个字符写入到指定的文件流中。</p>
<p>以下是关于 <code>fputc()</code> 函数的详细解释：</p>
<h3 id="函数原型-5"><a href="#函数原型-5" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>c</code>：要写入的字符，以整数形式传入，会被转换为相应的字符。</li>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，表示要写入的文件流。</li>
</ul>
<h3 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>fputc()</code> 函数返回写入的字符，如果写入成功，则返回写入的字符；如果出现错误，则返回 <code>EOF</code>。</li>
</ul>
<h3 id="示例用法-5"><a href="#示例用法-5" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入字符到文件</span></span><br><span class="line">        <span class="keyword">if</span> (fputc(<span class="string">&#x27;A&#x27;</span>, file) != EOF) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;字符写入成功\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;字符写入失败\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>fputc()</code> 函数写入字符时，会将整数参数 <code>c</code> 转换为相应的字符写入到文件中。</li>
<li>需要检查 <code>fputc()</code> 的返回值，以确保写入操作成功完成。返回值为 <code>EOF</code> 表示写入发生错误。</li>
</ul>
<p><code>fputc()</code> 函数用于将单个字符写入到文件中。在使用时应该注意检查返回值，确保写入操作成功。</p>
<h2 id="Linux-POSIX-feof-详解"><a href="#Linux-POSIX-feof-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; feof() 详解"></a>Linux POSIX &lt;stdio.h&gt; feof() 详解</h2><p>在 Linux POSIX 中，<code>&lt;stdio.h&gt;</code> 头文件中的 <code>feof()</code> 函数用于检查文件流的结束标志（End-of-File）。这个函数允许你判断文件指针当前是否位于文件结束位置。</p>
<p>以下是关于 <code>feof()</code> 函数的详细解释：</p>
<h3 id="函数原型-6"><a href="#函数原型-6" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，表示要检查的文件流。</li>
</ul>
<h3 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>feof()</code> 函数返回一个非零值（通常是整数1），表示已经到达文件的结束位置（End-of-File）。如果未到达文件结尾，则返回0。</li>
</ul>
<h3 id="示例用法-6"><a href="#示例用法-6" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取文件内容</span></span><br><span class="line">        <span class="type">int</span> character;</span><br><span class="line">        <span class="keyword">while</span> ((character = fgetc(file)) != EOF) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, character); <span class="comment">// 输出读取的字符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否到达文件结尾</span></span><br><span class="line">        <span class="keyword">if</span> (feof(file)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n已到达文件结尾\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n未到达文件结尾\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>feof()</code> 函数并不会主动读取文件流，它只是返回文件流的结束标志状态。</li>
<li>通常在读取文件时，读取循环结束后可以使用 <code>feof()</code> 函数来检查文件是否已经读取到了结束位置。</li>
</ul>
<p><code>feof()</code> 函数是一个用于检查文件流状态的工具，特别适用于循环读取文件并在文件末尾做出相应处理的情况。在使用时应该了解其返回值的含义，以正确判断文件的结束状态。</p>
<h2 id="Linux-POSIX-ferror-详解"><a href="#Linux-POSIX-ferror-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; ferror() 详解"></a>Linux POSIX &lt;stdio.h&gt; ferror() 详解</h2><p>在 Linux POSIX 中，<code>&lt;stdio.h&gt;</code> 头文件中的 <code>ferror()</code> 函数用于检查文件流的错误标志。这个函数允许你判断文件指针相关的错误状态。</p>
<p>以下是关于 <code>ferror()</code> 函数的详细解释：</p>
<h3 id="函数原型-7"><a href="#函数原型-7" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，表示要检查的文件流。</li>
</ul>
<h3 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>ferror()</code> 函数返回一个非零值（通常是整数1），表示指定的文件流上发生了错误。如果没有发生错误，则返回0。</li>
</ul>
<h3 id="示例用法-7"><a href="#示例用法-7" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取文件内容</span></span><br><span class="line">        <span class="type">int</span> character;</span><br><span class="line">        <span class="keyword">while</span> ((character = fgetc(file)) != EOF) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, character); <span class="comment">// 输出读取的字符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查文件流是否发生错误</span></span><br><span class="line">        <span class="keyword">if</span> (ferror(file)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n发生了文件流错误\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n文件流无错误\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>ferror()</code> 函数用于检查文件流的错误状态，通常在读写文件时进行检查，以确保文件操作没有发生意外的错误。</li>
<li>如果在文件流上发生了错误，<code>ferror()</code> 将返回非零值。这可能是由于设备错误、磁盘空间不足、权限问题等引起的文件流错误。</li>
</ul>
<p><code>ferror()</code> 函数是用于检查文件流错误状态的工具。在进行文件操作时，特别是在读写文件的过程中，建议在适当的位置使用 <code>ferror()</code> 来检查文件流是否发生了错误。</p>
<h2 id="Linux-POSIX-fseek-详解"><a href="#Linux-POSIX-fseek-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fseek() 详解"></a>Linux POSIX &lt;stdio.h&gt; fseek() 详解</h2><p>在 Linux POSIX 中，<code>&lt;stdio.h&gt;</code> 头文件中的 <code>fseek()</code> 函数用于设置文件流的位置指针。这个函数可以在文件中移动文件位置指针，以便进行读写文件的操作。</p>
<p>以下是关于 <code>fseek()</code> 函数的详细解释：</p>
<h3 id="函数原型-8"><a href="#函数原型-8" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，表示要设置位置的文件流。</li>
<li><code>offset</code>：表示偏移量，即要移动的字节数，可以为正数、负数或零。</li>
<li><code>whence</code>：表示起始点，可以取以下值：<ul>
<li><code>SEEK_SET</code>：从文件起始位置开始偏移。</li>
<li><code>SEEK_CUR</code>：从当前位置开始偏移。</li>
<li><code>SEEK_END</code>：从文件末尾位置开始偏移。</li>
</ul>
</li>
</ul>
<h3 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>fseek()</code> 函数返回一个非零值表示失败，返回0表示成功。</li>
</ul>
<h3 id="示例用法-8"><a href="#示例用法-8" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将文件指针移动到文件末尾</span></span><br><span class="line">        <span class="keyword">if</span> (fseek(file, <span class="number">0</span>, SEEK_END) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;文件指针移动到文件末尾\n&quot;</span>);</span><br><span class="line">            <span class="type">long</span> fileSize = ftell(file); <span class="comment">// 获取文件大小</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;文件大小为 %ld 字节\n&quot;</span>, fileSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;文件指针移动失败\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>fseek()</code> 函数时应该注意文件流的打开模式是否支持定位操作，例如，只读模式可能不允许随意移动文件指针。</li>
<li><code>fseek()</code> 可以用来移动文件指针到文件的特定位置，以便进行读取或写入操作。</li>
<li>在使用 <code>fseek()</code> 函数后应该检查返回值，确保文件指针移动操作是否成功。</li>
</ul>
<p><code>fseek()</code> 函数是一个用于定位文件指针的重要工具，可以在文件中定位到特定位置进行读写操作。在使用时应该了解 <code>offset</code> 和 <code>whence</code> 参数的用法，并检查返回值以确保操作成功。</p>
<h2 id="Linux-POSIX-ftell-详解"><a href="#Linux-POSIX-ftell-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; ftell() 详解"></a>Linux POSIX &lt;stdio.h&gt; ftell() 详解</h2><p>在 Linux POSIX 中，<code>&lt;stdio.h&gt;</code> 头文件中的 <code>ftell()</code> 函数用于获取文件流的当前位置指针相对于文件起始位置的偏移量，即返回当前文件指针的位置。</p>
<p>以下是关于 <code>ftell()</code> 函数的详细解释：</p>
<h3 id="函数原型-9"><a href="#函数原型-9" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，表示要获取位置的文件流。</li>
</ul>
<h3 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>ftell()</code> 函数返回一个 <code>long</code> 类型值，表示文件指针的当前位置。如果发生错误，则返回 <code>-1L</code>。</li>
</ul>
<h3 id="示例用法-9"><a href="#示例用法-9" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取文件指针当前位置</span></span><br><span class="line">        <span class="type">long</span> position = ftell(file);</span><br><span class="line">        <span class="keyword">if</span> (position != <span class="number">-1L</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;文件指针当前位置：%ld\n&quot;</span>, position);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;获取文件指针位置失败\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-9"><a href="#注意事项-9" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>ftell()</code> 函数返回文件指针相对于文件起始位置的偏移量，以字节为单位。</li>
<li>返回值 <code>-1L</code> 表示获取文件指针位置时出现了错误。</li>
<li><code>ftell()</code> 返回的值可以用于标识当前文件指针的位置，通常用于记录或控制文件的读写位置。</li>
</ul>
<p><code>ftell()</code> 函数用于获取文件指针的当前位置，允许你知道文件指针在文件中的偏移量。在文件处理时，了解当前文件指针的位置对于读取或写入文件非常有用。</p>
<h2 id="Linux-POSIX-sprintf-详解"><a href="#Linux-POSIX-sprintf-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; sprintf() 详解"></a>Linux POSIX &lt;stdio.h&gt; sprintf() 详解</h2><p>在 Linux POSIX 系统中，<code>&lt;stdio.h&gt;</code> 头文件中的 <code>sprintf()</code> 函数用于将格式化的数据写入到字符串中。它类似于 <code>printf()</code> 函数，但是将格式化的输出写入到一个字符串中，而不是输出到标准输出流（屏幕）上。</p>
<p>以下是关于 <code>sprintf()</code> 函数的详细解释：</p>
<h3 id="函数原型-10"><a href="#函数原型-10" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>str</code>：指向字符数组的指针，用于存储格式化后的字符串。</li>
<li><code>format</code>：一个格式化字符串，包含要写入字符串的文本以及格式化指示符，与 <code>printf()</code> 中的格式化字符串相同。</li>
<li><code>...</code>：可变数量的参数，用于替换格式化字符串中的格式化指示符。</li>
</ul>
<h3 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>sprintf()</code> 函数返回一个整数值，表示写入到 <code>str</code> 中的字符数（不包括终止 null 字符 <code>\0</code>）。如果发生错误，则返回一个负数。</li>
</ul>
<h3 id="示例用法-10"><a href="#示例用法-10" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="type">float</span> floatValue = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化数据并将结果存储到字符串中</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;The number is %d and the float value is %.2f&quot;</span>, number, floatValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;格式化后的字符串：%s\n&quot;</span>, buffer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入的字符数：%d\n&quot;</span>, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发生了错误\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-10"><a href="#注意事项-10" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>sprintf()</code> 函数将格式化后的数据写入到一个字符数组中，并在末尾自动添加 null 终止符 <code>\0</code>。</li>
<li>需要确保目标字符数组足够大，以存储格式化后的数据，防止溢出问题。</li>
<li><code>sprintf()</code> 函数是一个强大的工具，但要注意避免缓冲区溢出，可以考虑使用安全版本的函数（如 <code>snprintf()</code>），该函数允许指定要写入的最大字符数。</li>
</ul>
<p><code>sprintf()</code> 函数在需要将格式化的数据写入到字符串中时非常有用，能够对数据进行格式化并存储到一个指定的字符数组中。</p>
<h2 id="Linux-POSIX-snprintf-详解"><a href="#Linux-POSIX-snprintf-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; snprintf() 详解"></a>Linux POSIX &lt;stdio.h&gt; snprintf() 详解</h2><p>在 Linux POSIX 中，<code>&lt;stdio.h&gt;</code> 头文件中的 <code>snprintf()</code> 函数类似于 <code>sprintf()</code> 函数，但是增加了对输出字符数量的控制。<code>snprintf()</code> 允许你指定要写入的最大字符数，以避免缓冲区溢出问题。</p>
<p>以下是关于 <code>snprintf()</code> 函数的详细解释：</p>
<h3 id="函数原型-11"><a href="#函数原型-11" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-11"><a href="#参数-11" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>str</code>：指向字符数组的指针，用于存储格式化后的字符串。</li>
<li><code>size</code>：要写入的最大字符数（包括终止 null 字符 <code>\0</code>）。</li>
<li><code>format</code>：格式化字符串，包含要写入字符串的文本以及格式化指示符，与 <code>printf()</code> 中的格式化字符串相同。</li>
<li><code>...</code>：可变数量的参数，用于替换格式化字符串中的格式化指示符。</li>
</ul>
<h3 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>snprintf()</code> 函数返回一个整数值，表示实际写入到 <code>str</code> 中的字符数（不包括终止 null 字符 <code>\0</code>）。</li>
</ul>
<h3 id="示例用法-11"><a href="#示例用法-11" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="type">float</span> floatValue = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化数据并将结果存储到字符串中，最大存储字符数为 50</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;The number is %d and the float value is %.2f&quot;</span>, number, floatValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result &gt;= <span class="number">0</span> &amp;&amp; result &lt; <span class="keyword">sizeof</span>(buffer)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;格式化后的字符串：%s\n&quot;</span>, buffer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入的字符数：%d\n&quot;</span>, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发生了错误或缓冲区不足\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-11"><a href="#注意事项-11" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>snprintf()</code> 函数与 <code>sprintf()</code> 类似，但允许指定要写入的最大字符数，以防止缓冲区溢出。</li>
<li>函数返回值表示实际写入到 <code>str</code> 中的字符数，如果返回值等于传入的 <code>size</code> 参数，表示字符串被截断。</li>
<li>使用 <code>snprintf()</code> 可以更加安全地处理格式化数据，确保不会超出目标字符数组的大小。</li>
</ul>
<p><code>snprintf()</code> 函数是一个安全版本的格式化输出函数，允许指定最大写入字符数，避免了缓冲区溢出问题。</p>
<h2 id="Linux-POSIX-stdin-详解"><a href="#Linux-POSIX-stdin-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; stdin 详解"></a>Linux POSIX &lt;stdio.h&gt; stdin 详解</h2><p>在 Linux POSIX 系统中，<code>&lt;stdio.h&gt;</code> 头文件中定义了三个标准的文件流指针：<code>stdin</code>、<code>stdout</code> 和 <code>stderr</code>。这些指针用于标准输入、标准输出和标准错误流。</p>
<h3 id="stdin-概述"><a href="#stdin-概述" class="headerlink" title="stdin 概述"></a><code>stdin</code> 概述</h3><ul>
<li><code>stdin</code> 是一个指向标准输入流的 <code>FILE</code> 结构指针，用于从用户输入设备（通常是键盘）读取数据。</li>
<li><code>stdin</code> 是一个预定义的常量，无需额外定义即可使用。</li>
<li>在程序中使用 <code>stdin</code> 可以实现从标准输入读取用户输入的数据。</li>
</ul>
<h3 id="示例用法-12"><a href="#示例用法-12" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number); <span class="comment">// 从标准输入(stdin)读取整数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您输入的整数是: %d\n&quot;</span>, number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-12"><a href="#注意事项-12" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>stdin</code> 是一个标准输入流指针，通常用于读取用户输入。使用标准输入时，可以通过函数如 <code>scanf()</code>、<code>fgets()</code> 等从键盘读取数据。</li>
<li><code>stdin</code> 是一个常量指针，不允许修改，因为它指向标准输入流。</li>
</ul>
<p><code>stdin</code> 在 Linux POSIX 系统中是一个重要的标准输入流指针，允许程序从标准输入中读取用户输入。</p>
<h2 id="Linux-POSIX-stdout-详解"><a href="#Linux-POSIX-stdout-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; stdout 详解"></a>Linux POSIX &lt;stdio.h&gt; stdout 详解</h2><p>在 Linux POSIX 系统中，<code>&lt;stdio.h&gt;</code> 头文件中定义了三个标准的文件流指针：<code>stdin</code>、<code>stdout</code> 和 <code>stderr</code>。这些指针用于标准输入、标准输出和标准错误流。</p>
<h3 id="stdout-概述"><a href="#stdout-概述" class="headerlink" title="stdout 概述"></a><code>stdout</code> 概述</h3><ul>
<li><code>stdout</code> 是一个指向标准输出流的 <code>FILE</code> 结构指针，用于向标准输出设备（通常是屏幕）写入数据。</li>
<li><code>stdout</code> 是一个预定义的常量，无需额外定义即可使用。</li>
<li>在程序中使用 <code>stdout</code> 可以实现向标准输出打印数据。</li>
</ul>
<h3 id="示例用法-13"><a href="#示例用法-13" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是标准输出示例\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;这也是标准输出示例\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Hello, %s!\n&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;The number is: %d\n&quot;</span>, number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-13"><a href="#注意事项-13" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>stdout</code> 是一个标准输出流指针，通常用于输出程序的结果到屏幕。使用标准输出时，可以通过函数如 <code>printf()</code>、<code>fprintf()</code> 等向屏幕打印数据。</li>
<li><code>stdout</code> 是一个常量指针，不允许修改，因为它指向标准输出流。</li>
</ul>
<p><code>stdout</code> 在 Linux POSIX 系统中是一个重要的标准输出流指针，允许程序向标准输出设备（通常是屏幕）打印数据。</p>
<h2 id="Linux-POSIX-stderr-详解"><a href="#Linux-POSIX-stderr-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; stderr 详解"></a>Linux POSIX &lt;stdio.h&gt; stderr 详解</h2><p>在 Linux POSIX 系统中，<code>&lt;stdio.h&gt;</code> 头文件中定义了三个标准的文件流指针：<code>stdin</code>、<code>stdout</code> 和 <code>stderr</code>。这些指针用于标准输入、标准输出和标准错误流。</p>
<h3 id="stderr-概述"><a href="#stderr-概述" class="headerlink" title="stderr 概述"></a><code>stderr</code> 概述</h3><ul>
<li><code>stderr</code> 是一个指向标准错误流的 <code>FILE</code> 结构指针，用于向标准错误设备（通常也是屏幕）输出错误信息。</li>
<li><code>stderr</code> 是一个预定义的常量，无需额外定义即可使用。</li>
<li>在程序中使用 <code>stderr</code> 可以实现向标准错误流输出错误信息。</li>
</ul>
<h3 id="示例用法-14"><a href="#示例用法-14" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;发生了错误：数字太小\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;nonexistent_file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-14"><a href="#注意事项-14" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>stderr</code> 是一个标准错误流指针，通常用于输出程序运行时的错误信息到屏幕。使用标准错误流时，可以通过函数如 <code>fprintf()</code> 向屏幕输出错误信息。</li>
<li><code>stderr</code> 是一个常量指针，不允许修改，因为它指向标准错误流。</li>
</ul>
<p><code>stderr</code> 在 Linux POSIX 系统中是一个重要的标准错误流指针，允许程序输出错误信息到标准错误设备（通常是屏幕）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_7_signal_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_7_signal_h/" class="post-title-link" itemprop="url">C_5_7_signal_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Linux POSIX &lt;signal.h&gt; 详解</li>
</ul>
<h2 id="Linux-POSIX-详解"><a href="#Linux-POSIX-详解" class="headerlink" title="Linux POSIX &lt;signal.h&gt; 详解"></a>Linux POSIX &lt;signal.h&gt; 详解</h2><p>在 Linux POSIX 系统中，<code>&lt;signal.h&gt;</code> 头文件用于处理信号（signals）。信号是一种异步通知机制，用于通知进程发生了特定的事件。</p>
<p>以下是关于 <code>&lt;signal.h&gt;</code> 头文件的详细解释：</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li><code>&lt;signal.h&gt;</code> 头文件声明了与信号处理相关的函数和宏。</li>
<li>它允许程序注册信号处理函数、发送信号以及处理由操作系统或其他进程发送的信号。</li>
</ul>
<h3 id="一些常见的信号"><a href="#一些常见的信号" class="headerlink" title="一些常见的信号"></a>一些常见的信号</h3><p>在 POSIX 系统中，有一些常见的信号及其含义如下：</p>
<ol>
<li><p>**<code>SIGINT</code>**：终端中断信号，通常由用户在终端按下 Ctrl+C 产生，用于终止正在运行的进程。</p>
</li>
<li><p>**<code>SIGKILL</code>**：终止进程信号，用于强制终止进程，无法被捕获或忽略。</p>
</li>
<li><p>**<code>SIGTERM</code>**：终止信号，通常用于请求进程自己优雅地终止运行。</p>
</li>
<li><p>**<code>SIGSEGV</code>**：段错误信号，表示进程访问了无效的内存地址，通常是因为内存访问越界或者操作未分配的内存导致。</p>
</li>
<li><p><strong><code>SIGUSR1</code></strong> 和 **<code>SIGUSR2</code>**：用户自定义信号。</p>
</li>
</ol>
<h3 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h3><ul>
<li>使用 <code>signal()</code> 函数来注册信号处理函数，语法如下：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signum, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>
  这个函数用于设置 <code>signum</code> 信号的处理函数为 <code>handler</code>，当收到信号时执行该处理函数。</li>
</ul>
<h3 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收到 SIGINT 信号，按下 Ctrl+C。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGINT, sigint_handler); <span class="comment">// 注册 SIGINT 信号的处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下 Ctrl+C 终止程序...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 进程保持运行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>信号处理函数需要快速执行，不要包含太多耗时操作。</li>
<li>信号是异步事件，可以在任何时候发生。因此，处理信号的时候需要小心并确保安全性。</li>
</ul>
<p><code>&lt;signal.h&gt;</code> 头文件允许程序员处理信号，以响应进程发生的特定事件。通过信号处理，程序可以捕获并处理异步发生的事件，使得程序具有更好的鲁棒性和可靠性。</p>
<h2 id="Linux-POSIX-signal-详解"><a href="#Linux-POSIX-signal-详解" class="headerlink" title="Linux POSIX &lt;signal.h&gt; signal() 详解"></a>Linux POSIX &lt;signal.h&gt; signal() 详解</h2><p>在 Linux POSIX 系统中，<code>&lt;signal.h&gt;</code> 头文件中的 <code>signal()</code> 函数用于设置信号的处理函数。</p>
<p>以下是关于 <code>signal()</code> 函数的详细解释：</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signum, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>signum</code>：表示要处理的信号的编号。它可以是预定义的信号常量，如 <code>SIGINT</code>、<code>SIGTERM</code> 等。</li>
<li><code>handler</code>：是一个函数指针，表示要与 <code>signum</code> 信号相关联的处理函数。可以是自定义的函数指针，用于处理接收到的信号。</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>signal()</code> 函数返回一个函数指针，表示之前与 <code>signum</code> 相关联的信号处理函数。如果之前没有设置过信号处理函数，则返回 <code>SIG_ERR</code>。</li>
</ul>
<h3 id="示例用法-1"><a href="#示例用法-1" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收到 SIGINT 信号，按下 Ctrl+C。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注册 SIGINT 信号的处理函数</span></span><br><span class="line">    signal(SIGINT, sigint_handler);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下 Ctrl+C 终止程序...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 进程保持运行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>signal()</code> 函数用于设置对指定信号的处理方式。</li>
<li>可以设置 <code>SIG_IGN</code> 来忽略某个信号，或者设置 <code>SIG_DFL</code> 恢复该信号的默认处理方式。</li>
<li>调用 <code>signal()</code> 函数设置信号处理函数后，一旦接收到相应信号，就会调用注册的信号处理函数。</li>
</ul>
<p><code>signal()</code> 函数允许程序员为指定的信号设置自定义的处理函数，从而可以在程序中对接收到的信号做出相应的响应和处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_4_stdlib_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_4_stdlib_h/" class="post-title-link" itemprop="url">C_5_4_stdlib_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>&lt;stdlib.h&gt;标准头文件</li>
</ul>
<h2 id="Linux-POSIX-详解"><a href="#Linux-POSIX-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; 详解"></a>Linux POSIX &lt;stdlib.h&gt; 详解</h2><p><code>&lt;stdlib.h&gt;</code> 是 POSIX（可移植操作系统接口）规范中针对类 Unix 操作系统的 C 标准库中的一个头文件。它提供了一些标准函数、类型和宏，用于内存分配、转换、随机数生成等各种操作。</p>
<p>以下是 <code>&lt;stdlib.h&gt;</code> 中常用的一些函数和类型的概述：</p>
<h3 id="内存分配与管理："><a href="#内存分配与管理：" class="headerlink" title="内存分配与管理："></a>内存分配与管理：</h3><ul>
<li><code>malloc()</code>: 分配一块内存。</li>
<li><code>calloc()</code>: 分配一块内存并将其初始化为零。</li>
<li><code>realloc()</code>: 调整之前分配的内存块的大小。</li>
<li><code>free()</code>: 释放之前分配的内存块。</li>
</ul>
<h3 id="字符串转换："><a href="#字符串转换：" class="headerlink" title="字符串转换："></a>字符串转换：</h3><ul>
<li><code>atoi()</code>, <code>atol()</code>, <code>atoll()</code>: 将字符串转换为整数。</li>
<li><code>atof()</code>: 将字符串转换为浮点数。</li>
<li><code>itoa()</code>: 将整数转换为字符串（不是标准 C 的一部分，但在某些实现中可用）。</li>
</ul>
<h3 id="伪随机数生成："><a href="#伪随机数生成：" class="headerlink" title="伪随机数生成："></a>伪随机数生成：</h3><ul>
<li><code>rand()</code>: 生成伪随机整数。</li>
<li><code>srand()</code>: 种子初始化随机数生成器。</li>
</ul>
<h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><ul>
<li><code>getenv()</code>: 获取环境变量的值。</li>
<li><code>system()</code>: 执行 shell 命令。</li>
</ul>
<h3 id="实用函数："><a href="#实用函数：" class="headerlink" title="实用函数："></a>实用函数：</h3><ul>
<li><code>exit()</code>: 终止程序执行。</li>
<li><code>abort()</code>: 中止程序执行。</li>
<li><code>qsort()</code>: 对数组进行排序。</li>
<li><code>bsearch()</code>: 在排序数组中执行二分查找。</li>
</ul>
<h3 id="其他常量和类型："><a href="#其他常量和类型：" class="headerlink" title="其他常量和类型："></a>其他常量和类型：</h3><ul>
<li><code>EXIT_SUCCESS</code>, <code>EXIT_FAILURE</code>: 标准的退出状态码。</li>
<li><code>NULL</code>: 空指针常量。</li>
<li><code>size_t</code>: 用于对象大小的无符号整数类型。</li>
</ul>
<p>需要注意的是，<code>&lt;stdlib.h&gt;</code> 中的这些功能是 C 的标准功能，在不同的实现中可能会有系统特定的变化或扩展。此外，POSIX 的兼容性确保了这些函数和宏在各种类 Unix 系统中都是可用的。</p>
<p>要使用这些函数，需要在 C 程序的开头包含 <code>&lt;stdlib.h&gt;</code>，以便访问其定义和原型。</p>
<h2 id="Linux-POSIX-malloc-详解"><a href="#Linux-POSIX-malloc-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; malloc() 详解"></a>Linux POSIX &lt;stdlib.h&gt; malloc() 详解</h2><p>在 Linux POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>malloc()</code> 函数是用于动态内存分配的关键函数之一。它允许程序在运行时请求分配一块指定大小的内存空间，并返回一个指向分配内存的指针。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>size_t size</code>: 要分配的内存块的大小（以字节为单位）。</li>
</ul>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>malloc()</code> 返回一个指向分配内存的指针。如果分配失败，则返回 <code>NULL</code>。</li>
</ul>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>malloc()</code> 用于动态地分配内存。它在堆上分配一块指定大小的连续内存块，并返回一个指向此内存块的指针。</li>
</ul>
<h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个包含5个整数的内存块</span></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对分配的内存进行操作...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            ptr[i] = i * <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] = %d\n&quot;</span>, i, ptr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放分配的内存</span></span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>malloc()</code> 被用来分配一个包含5个整数的内存块。然后，分配的内存被使用，最后通过 <code>free()</code> 函数释放了已分配的内存。此外，在使用 <code>malloc()</code> 分配内存后，通常需要检查返回的指针是否为 <code>NULL</code>，以确保分配操作成功。</p>
<h2 id="Linux-POSIX-calloc-详解"><a href="#Linux-POSIX-calloc-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; calloc() 详解"></a>Linux POSIX &lt;stdlib.h&gt; calloc() 详解</h2><p>在 Linux POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>calloc()</code> 函数是用于动态内存分配的重要函数之一，类似于 <code>malloc()</code>。不同之处在于，<code>calloc()</code> 不仅分配内存，还将分配的内存块初始化为零。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> num_elements, <span class="type">size_t</span> element_size)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>size_t num_elements</code>: 要分配的元素数量。</li>
<li><code>size_t element_size</code>: 每个元素的大小（以字节为单位）。</li>
</ul>
<h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>calloc()</code> 返回一个指向分配内存的指针。如果分配失败，则返回 <code>NULL</code>。</li>
</ul>
<h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>calloc()</code> 用于动态分配一块指定数量和大小的连续内存块，并将所有的位初始化为零。</li>
</ul>
<h3 id="使用示例：-1"><a href="#使用示例：-1" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个包含5个整数的内存块，并将其初始化为零</span></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">calloc</span>(size, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对分配的内存进行操作...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] = %d\n&quot;</span>, i, ptr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放分配的内存</span></span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>calloc()</code> 被用来分配一个包含5个整数的内存块，并将其初始化为零。然后，分配的内存被使用，并通过 <code>free()</code> 函数释放了已分配的内存。同样，需要检查返回的指针是否为 <code>NULL</code>，以确保分配操作成功。</p>
<h2 id="Linux-POSIX-realloc-详解"><a href="#Linux-POSIX-realloc-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; realloc() 详解"></a>Linux POSIX &lt;stdlib.h&gt; realloc() 详解</h2><p>在 Linux POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>realloc()</code> 函数是用于重新分配动态内存的重要函数。它允许程序修改先前分配的内存块的大小，可能扩大或缩小该内存块的大小。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-2"><a href="#参数：-2" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>void *ptr</code>: 指向先前分配内存的指针。</li>
<li><code>size_t size</code>: 新的内存块大小（以字节为单位）。</li>
</ul>
<h3 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>realloc()</code> 返回一个指向重新分配内存的指针。如果分配失败，则返回 <code>NULL</code>。如果 <code>ptr</code> 为 <code>NULL</code>，则 <code>realloc()</code> 的行为类似于 <code>malloc()</code>。</li>
</ul>
<h3 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>realloc()</code> 用于更改先前分配的内存块的大小。如果内存大小增加，可能会移动现有的数据到新的内存位置，并将新分配的空间初始化为未定义的值。</li>
</ul>
<h3 id="使用示例：-2"><a href="#使用示例：-2" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个包含5个整数的内存块</span></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对分配的内存进行操作...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            ptr[i] = i * <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] = %d\n&quot;</span>, i, ptr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配内存块大小为10个整数大小</span></span><br><span class="line">        <span class="type">int</span> new_size = <span class="number">10</span>;</span><br><span class="line">        ptr = (<span class="type">int</span> *)<span class="built_in">realloc</span>(ptr, new_size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;重新分配内存失败！\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;重新分配内存成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 继续操作重新分配的内存...</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = size; i &lt; new_size; ++i) &#123;</span><br><span class="line">                ptr[i] = i * <span class="number">10</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] = %d\n&quot;</span>, i, ptr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放重新分配的内存</span></span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，首先使用 <code>malloc()</code> 分配了一个包含5个整数的内存块。然后，使用 <code>realloc()</code> 函数重新分配内存块的大小为10个整数大小。需要注意的是，<code>realloc()</code> 可能会在必要时重新分配内存并将原始数据复制到新分配的位置。最后，通过 <code>free()</code> 函数释放了重新分配的内存。</p>
<h2 id="Linux-POSIX-free-详解"><a href="#Linux-POSIX-free-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; free() 详解"></a>Linux POSIX &lt;stdlib.h&gt; free() 详解</h2><p>在 Linux POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>free()</code> 函数是用于释放动态分配的内存块的关键函数。</p>
<h3 id="函数签名：-3"><a href="#函数签名：-3" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-3"><a href="#参数：-3" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>void *ptr</code>: 指向先前分配内存的指针。</li>
</ul>
<h3 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>free()</code> 函数没有返回值。</li>
</ul>
<h3 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>free()</code> 用于释放先前使用 <code>malloc()</code>、<code>calloc()</code> 或 <code>realloc()</code> 分配的动态内存。通过释放已分配的内存，将其返回给系统，使其可以在以后的操作中重新使用。</li>
</ul>
<h3 id="使用示例：-3"><a href="#使用示例：-3" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个包含5个整数的内存块</span></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对分配的内存进行操作...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            ptr[i] = i * <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] = %d\n&quot;</span>, i, ptr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放分配的内存</span></span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存已释放。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，首先使用 <code>malloc()</code> 分配了一个包含5个整数的内存块，然后使用 <code>free()</code> 函数释放了该内存块。释放内存后，应避免继续使用指向已释放内存的指针，因为这可能导致未定义的行为。因此，在释放内存后，通常将指针设置为 <code>NULL</code>，以避免意外使用。</p>
<h2 id="Linux-POSIX-atoi-详解"><a href="#Linux-POSIX-atoi-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; atoi() 详解"></a>Linux POSIX &lt;stdlib.h&gt; atoi() 详解</h2><p>在 Linux POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>atoi()</code> 函数用于将字符串转换为整数。</p>
<h3 id="函数签名：-4"><a href="#函数签名：-4" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-4"><a href="#参数：-4" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>const char *str</code>: 要转换为整数的字符串。</li>
</ul>
<h3 id="返回值：-4"><a href="#返回值：-4" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>atoi()</code> 返回转换后的整数值。如果输入字符串不是有效的整数表示形式，则返回 0。</li>
</ul>
<h3 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>atoi()</code> 函数将传入的字符串参数解析为整数。它会跳过字符串开始的空格字符，然后从第一个非空格字符开始，尝试解析尽可能多的连续字符作为整数。它会忽略非数字字符，直到遇到非数字字符或字符串结束。</li>
</ul>
<h3 id="使用示例：-4"><a href="#使用示例：-4" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">    <span class="type">int</span> result = atoi(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串转换为整数结果：%d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str2 = <span class="string">&quot;42abc&quot;</span>;</span><br><span class="line">    <span class="type">int</span> result2 = atoi(str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;非完整字符串转换为整数结果：%d\n&quot;</span>, result2);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str3 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">int</span> result3 = atoi(str3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;非数字字符串转换为整数结果：%d\n&quot;</span>, result3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>atoi()</code> 函数被用于将不同的字符串转换为整数。第一个示例中的字符串 “12345” 被成功转换为整数 12345。第二个示例中的字符串 “42abc” 以数字部分 “42” 被成功转换为整数 42。第三个示例中的字符串 “abc” 不是有效的整数表示形式，因此 <code>atoi()</code> 返回 0。需要注意的是，<code>atoi()</code> 对于不完整或无效的输入可能会返回 0，因此在使用时需要谨慎检查返回值。</p>
<h2 id="Linux-POSIX-atof-详解"><a href="#Linux-POSIX-atof-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; atof() 详解"></a>Linux POSIX &lt;stdlib.h&gt; atof() 详解</h2><p>在 Linux POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>atof()</code> 函数用于将字符串转换为浮点数。</p>
<h3 id="函数签名：-5"><a href="#函数签名：-5" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">atof</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-5"><a href="#参数：-5" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>const char *str</code>: 要转换为浮点数的字符串。</li>
</ul>
<h3 id="返回值：-5"><a href="#返回值：-5" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>atof()</code> 返回转换后的浮点数值。如果输入字符串不是有效的浮点数表示形式，则返回 0.0。</li>
</ul>
<h3 id="功能：-5"><a href="#功能：-5" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>atof()</code> 函数将传入的字符串参数解析为浮点数。它会跳过字符串开始的空格字符，然后从第一个非空格字符开始，尝试解析尽可能多的连续字符作为浮点数。它会忽略非数字字符，直到遇到非数字字符、小数点、指数标志（如 ‘e’ 或 ‘E’）或字符串结束。</li>
</ul>
<h3 id="使用示例：-5"><a href="#使用示例：-5" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;123.456&quot;</span>;</span><br><span class="line">    <span class="type">double</span> result = atof(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串转换为浮点数结果：%f\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str2 = <span class="string">&quot;3.14abc&quot;</span>;</span><br><span class="line">    <span class="type">double</span> result2 = atof(str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;非完整字符串转换为浮点数结果：%f\n&quot;</span>, result2);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str3 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">double</span> result3 = atof(str3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;非数字字符串转换为浮点数结果：%f\n&quot;</span>, result3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>atof()</code> 函数被用于将不同的字符串转换为浮点数。第一个示例中的字符串 “123.456” 被成功转换为浮点数 123.456。第二个示例中的字符串 “3.14abc” 以浮点数部分 “3.14” 被成功转换为浮点数 3.14。第三个示例中的字符串 “abc” 不是有效的浮点数表示形式，因此 <code>atof()</code> 返回 0.0。需要注意的是，<code>atof()</code> 对于不完整或无效的输入可能会返回 0.0，因此在使用时需要谨慎检查返回值。</p>
<h2 id="Linux-POSIX-itoa-详解"><a href="#Linux-POSIX-itoa-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; itoa() 详解"></a>Linux POSIX &lt;stdlib.h&gt; itoa() 详解</h2><p>在 POSIX 标准中，<code>itoa()</code> 函数实际上不是标准 C 函数，它不在 C 标准库 <code>&lt;stdlib.h&gt;</code> 中定义。<code>itoa()</code> 用于将整数转换为字符串。尽管在某些特定的编译器或系统中可能会提供 <code>itoa()</code> 函数，但它并不是 C 语言标准库的一部分，因此在不同的系统或编译器中，<code>itoa()</code> 的可用性和实现方式可能会有所不同。</p>
<p>通常情况下，如果没有 <code>itoa()</code> 函数，可以使用标准库函数 <code>sprintf()</code> 或 <code>snprintf()</code> 来实现整数到字符串的转换。这两个函数允许将格式化的数据写入字符串缓冲区中。</p>
<p>下面是使用 <code>snprintf()</code> 函数将整数转换为字符串的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LENGTH 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">12345</span>;</span><br><span class="line">    <span class="type">char</span> str[MAX_LENGTH];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(str, MAX_LENGTH, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;整数转换为字符串结果：%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>snprintf()</code> 函数将整数 <code>num</code> 转换为字符串，并将结果存储在 <code>str</code> 缓冲区中。使用 <code>&quot;%d&quot;</code> 格式化字符串指定要转换的整数类型。这种方法提供了一种可移植且不依赖于特定编译器或系统的整数到字符串转换方式。</p>
<h2 id="Linux-POSIX-rand-详解"><a href="#Linux-POSIX-rand-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; rand() 详解"></a>Linux POSIX &lt;stdlib.h&gt; rand() 详解</h2><p>在 POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>rand()</code> 函数用于生成伪随机整数。</p>
<h3 id="函数签名：-6"><a href="#函数签名：-6" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rand</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-6"><a href="#参数：-6" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>void</code>：<code>rand()</code> 函数没有参数。</li>
</ul>
<h3 id="返回值：-6"><a href="#返回值：-6" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>rand()</code> 返回一个伪随机整数值。范围通常是 0 到 <code>RAND_MAX</code> 之间（包括 0 和 <code>RAND_MAX</code>）。</li>
</ul>
<h3 id="功能：-6"><a href="#功能：-6" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>rand()</code> 函数生成伪随机整数。每次调用 <code>rand()</code>，它会返回一个在指定范围内的整数值。伪随机性意味着生成的数字序列是基于初始种子值的，因此在相同的种子值下，<code>rand()</code> 将生成相同的数字序列。</li>
</ul>
<h3 id="使用示例：-6"><a href="#使用示例：-6" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, randomNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用当前时间作为种子</span></span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;生成的随机数为：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成并打印 10 个随机数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        randomNum = rand();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, randomNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>srand()</code> 函数使用当前时间作为种子，以确保每次程序运行时生成的随机数序列是不同的。然后，使用 <code>rand()</code> 函数生成并打印了 10 个随机数。需要注意的是，如果不调用 <code>srand()</code> 来设置种子，每次程序运行时将会生成相同的随机数序列。因此，在许多情况下，通常在程序开始时使用不同的种子来初始化随机数生成器，以产生不同的随机数序列。</p>
<h2 id="Linux-POSIX-srand-详解"><a href="#Linux-POSIX-srand-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; srand() 详解"></a>Linux POSIX &lt;stdlib.h&gt; srand() 详解</h2><p>在 POSIX 标准的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>srand()</code> 函数用于设置 <code>rand()</code> 函数生成随机数所使用的种子值。</p>
<h3 id="函数签名：-7"><a href="#函数签名：-7" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-7"><a href="#参数：-7" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>unsigned int seed</code>：用作随机数生成器种子的整数值。</li>
</ul>
<h3 id="返回值：-7"><a href="#返回值：-7" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>srand()</code> 函数没有返回值。</li>
</ul>
<h3 id="功能：-7"><a href="#功能：-7" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>srand()</code> 函数设置 <code>rand()</code> 函数使用的种子值。这个种子值将影响 <code>rand()</code> 函数生成的随机数序列。如果使用相同的种子值调用 <code>srand()</code>，则后续对 <code>rand()</code> 的调用将生成相同的随机数序列。</li>
</ul>
<h3 id="使用示例：-7"><a href="#使用示例：-7" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, randomNum;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> seed = <span class="number">123</span>; <span class="comment">// 设置种子值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用指定种子值</span></span><br><span class="line">    srand(seed);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用种子值 %u 生成的随机数为：\n&quot;</span>, seed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成并打印 10 个随机数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        randomNum = rand();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, randomNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>srand()</code> 函数被用于设置随机数生成器的种子值为 <code>123</code>。然后，<code>rand()</code> 函数被调用多次以生成随机数序列。重要的是要注意，如果使用相同的种子值多次调用 <code>srand()</code>，后续对 <code>rand()</code> 的调用将生成相同的随机数序列。通常情况下，使用随机的种子值（比如当前时间）可以帮助确保每次程序运行时都生成不同的随机数序列。</p>
<h2 id="Linux-POSIX-getenv-详解"><a href="#Linux-POSIX-getenv-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; getenv() 详解"></a>Linux POSIX &lt;stdlib.h&gt; getenv() 详解</h2><p>在 POSIX 标准的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>getenv()</code> 函数用于获取指定环境变量的值。</p>
<h3 id="函数签名：-8"><a href="#函数签名：-8" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-8"><a href="#参数：-8" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>const char *name</code>：要获取其值的环境变量的名称字符串。</li>
</ul>
<h3 id="返回值：-8"><a href="#返回值：-8" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>getenv()</code> 函数返回一个指向环境变量值的字符串指针。如果未找到指定名称的环境变量，则返回 <code>NULL</code>。</li>
</ul>
<h3 id="功能：-8"><a href="#功能：-8" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>getenv()</code> 函数用于获取指定环境变量的值。环境变量是一种在程序执行时存储有关环境信息的方式，比如系统路径、用户信息等。</li>
</ul>
<h3 id="使用示例：-8"><a href="#使用示例：-8" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *path = getenv(<span class="string">&quot;PATH&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PATH 环境变量的值是：%s\n&quot;</span>, path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到 PATH 环境变量\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>getenv()</code> 函数被用于获取名为 “PATH” 的环境变量的值。如果找到了名为 “PATH” 的环境变量，则打印其值。如果未找到指定的环境变量，则打印一条消息说明未找到该环境变量。需要注意的是，如果环境变量不存在或未定义，则 <code>getenv()</code> 返回 <code>NULL</code>。</p>
<h2 id="Linux-POSIX-system-详解"><a href="#Linux-POSIX-system-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; system() 详解"></a>Linux POSIX &lt;stdlib.h&gt; system() 详解</h2><p>在 POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>system()</code> 函数用于执行命令行中的命令。</p>
<h3 id="函数签名：-9"><a href="#函数签名：-9" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-9"><a href="#参数：-9" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>const char *command</code>：要执行的命令的字符串。</li>
</ul>
<h3 id="返回值：-9"><a href="#返回值：-9" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>system()</code> 函数返回命令执行的状态信息。返回值通常是命令退出状态的表示方式，通常情况下，0 表示命令成功执行，非零值表示出现了错误。</li>
</ul>
<h3 id="功能：-9"><a href="#功能：-9" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>system()</code> 函数用于在程序中执行命令。它将传入的命令字符串发送给系统命令解释器来执行。在执行完成后，会返回命令的退出状态信息。</li>
</ul>
<h3 id="使用示例：-9"><a href="#使用示例：-9" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 执行命令 ls，并检查返回状态</span></span><br><span class="line">    <span class="type">int</span> status = system(<span class="string">&quot;ls -l&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;命令执行成功！\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;命令执行失败或出现错误！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>system()</code> 函数被用于执行 <code>ls -l</code> 命令，并通过检查返回的状态信息来判断命令是否执行成功。需要注意的是，<code>system()</code> 函数执行命令后，会等待命令执行完成，并返回其退出状态信息。因此，如果执行的命令会花费很长时间，程序也会相应地等待。此外，<code>system()</code> 函数也可以用来执行其他的系统命令，但需要注意潜在的安全风险，尤其是当传入的命令字符串由用户输入或动态生成时。</p>
<h2 id="Linux-POSIX-exit-详解"><a href="#Linux-POSIX-exit-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; exit() 详解"></a>Linux POSIX &lt;stdlib.h&gt; exit() 详解</h2><p>在 POSIX 标准的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>exit()</code> 函数用于终止程序的执行，并返回一个指定的退出状态给操作系统。</p>
<h3 id="函数签名：-10"><a href="#函数签名：-10" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-10"><a href="#参数：-10" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>int status</code>：程序的退出状态码。通常情况下，0 表示成功退出，非零值表示出现了错误。</li>
</ul>
<h3 id="返回值：-10"><a href="#返回值：-10" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>exit()</code> 函数没有返回值。</li>
</ul>
<h3 id="功能：-10"><a href="#功能：-10" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>exit()</code> 函数用于正常终止程序的执行。当调用 <code>exit()</code> 时，它会立即终止当前正在运行的程序，清理所有的资源并返回指定的退出状态码给操作系统。</li>
</ul>
<h3 id="使用示例：-10"><a href="#使用示例：-10" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序执行中...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一些操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止程序的执行，并返回退出状态码 0（表示成功）</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>exit()</code> 函数被用于正常终止程序的执行。当程序到达 <code>exit(0)</code> 时，程序将立即终止，并将退出状态码 <code>0</code> 返回给操作系统。<code>exit()</code> 函数可以用于在程序的任何地方终止执行，不仅仅是在 <code>main()</code> 函数内。</p>
<h2 id="Linux-POSIX-abort-详解"><a href="#Linux-POSIX-abort-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; abort() 详解"></a>Linux POSIX &lt;stdlib.h&gt; abort() 详解</h2><p>在 POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>abort()</code> 函数用于使程序异常终止。</p>
<h3 id="函数签名：-11"><a href="#函数签名：-11" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-11"><a href="#参数：-11" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>void</code>：<code>abort()</code> 函数没有参数。</li>
</ul>
<h3 id="返回值：-11"><a href="#返回值：-11" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>abort()</code> 函数不会返回，它会导致程序异常终止。</li>
</ul>
<h3 id="功能：-11"><a href="#功能：-11" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>abort()</code> 函数用于引发程序的异常终止。调用 <code>abort()</code> 会立即终止程序的执行，并向操作系统发送一个异常终止信号。通常情况下，会生成一个 <code>SIGABRT</code> 信号，表示程序发生了严重错误，并且无法继续运行。</li>
</ul>
<h3 id="使用示例：-11"><a href="#使用示例：-11" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序执行中...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在某些条件下触发异常终止</span></span><br><span class="line">    <span class="type">int</span> condition = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发生错误，程序即将异常终止！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的代码不会被执行，因为在上面已经调用了 abort()</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这行代码不会被执行\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>abort()</code> 函数被用于条件满足时触发异常终止。如果条件满足（<code>condition</code> 为真），则会触发 <code>abort()</code> 调用，导致程序立即终止，并不会执行 <code>abort()</code> 之后的代码。<code>abort()</code> 函数通常用于标记程序发生了严重错误或遇到不可恢复的情况，需要立即停止程序的执行。</p>
<h2 id="Linux-POSIX-qsort-详解"><a href="#Linux-POSIX-qsort-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; qsort() 详解"></a>Linux POSIX &lt;stdlib.h&gt; qsort() 详解</h2><p>在 POSIX 标准的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>qsort()</code> 函数用于对数组进行快速排序。</p>
<h3 id="函数签名：-12"><a href="#函数签名：-12" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> nmemb, <span class="type">size_t</span> size, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-12"><a href="#参数：-12" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>void *base</code>：指向要排序的数组的指针。</li>
<li><code>size_t nmemb</code>：数组中元素的数量。</li>
<li><code>size_t size</code>：每个元素的大小（以字节为单位）。</li>
<li><code>int (*compar)(const void *, const void *)</code>：指向比较函数的指针，用于定义元素之间的比较规则。</li>
</ul>
<h3 id="返回值：-12"><a href="#返回值：-12" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>qsort()</code> 函数没有返回值。</li>
</ul>
<h3 id="功能：-12"><a href="#功能：-12" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>qsort()</code> 函数用于对数组进行快速排序。它根据提供的比较函数，按照升序排列数组元素。快速排序是一种高效的排序算法，具有较好的平均性能。</li>
</ul>
<h3 id="比较函数-compar："><a href="#比较函数-compar：" class="headerlink" title="比较函数 compar："></a>比较函数 <code>compar</code>：</h3><ul>
<li>比较函数 <code>compar</code> 接受两个指向要比较的元素的指针，返回一个整数值表示它们的关系：<ul>
<li>如果第一个元素应排在第二个元素之前，则返回负值；</li>
<li>如果第一个元素应排在第二个元素之后，则返回正值；</li>
<li>如果两个元素相等，则返回零。</li>
</ul>
</li>
</ul>
<h3 id="使用示例：-12"><a href="#使用示例：-12" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数，用于指定排序规则（升序）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">int</span> *)a - *(<span class="type">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前的数组：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数组进行快速排序</span></span><br><span class="line">    qsort(arr, size, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>qsort()</code> 函数被用于对整数数组 <code>arr</code> 进行升序排序。通过提供的比较函数 <code>compare</code>，指定了元素之间的比较规则。<code>qsort()</code> 函数将数组按升序排列后，打印排序前后的数组内容。</p>
<h2 id="Linux-POSIX-bsearch-详解"><a href="#Linux-POSIX-bsearch-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; bsearch() 详解"></a>Linux POSIX &lt;stdlib.h&gt; bsearch() 详解</h2><p>在 POSIX 标准的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>bsearch()</code> 函数用于在已排序数组中执行二分查找。</p>
<h3 id="函数签名：-13"><a href="#函数签名：-13" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">bsearch</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="type">void</span> *base, <span class="type">size_t</span> nmemb, <span class="type">size_t</span> size, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-13"><a href="#参数：-13" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>const void *key</code>：要查找的元素的指针。</li>
<li><code>const void *base</code>：指向已排序数组的起始地址的指针。</li>
<li><code>size_t nmemb</code>：数组中元素的数量。</li>
<li><code>size_t size</code>：每个元素的大小（以字节为单位）。</li>
<li><code>int (*compar)(const void *, const void *)</code>：指向比较函数的指针，用于定义元素之间的比较规则。</li>
</ul>
<h3 id="返回值：-13"><a href="#返回值：-13" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>bsearch()</code> 函数返回一个指针，指向查找到的元素的位置。如果未找到匹配的元素，则返回 <code>NULL</code>。</li>
</ul>
<h3 id="功能：-13"><a href="#功能：-13" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>bsearch()</code> 函数用于在已排序的数组中执行二分查找。它搜索数组中是否存在与指定关键字匹配的元素。二分查找是一种高效的查找算法，但要求数组必须是已排序的。</li>
</ul>
<h3 id="比较函数-compar：-1"><a href="#比较函数-compar：-1" class="headerlink" title="比较函数 compar："></a>比较函数 <code>compar</code>：</h3><ul>
<li>比较函数 <code>compar</code> 与 <code>qsort()</code> 函数中的比较函数类似，接受两个指向要比较的元素的指针，返回一个整数值表示它们的关系。</li>
</ul>
<h3 id="使用示例：-13"><a href="#使用示例：-13" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数，用于指定比较规则</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">int</span> *)a - *(<span class="type">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> key = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数组进行快速排序（必须是已排序的数组）</span></span><br><span class="line">    qsort(arr, size, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在已排序数组中执行二分查找</span></span><br><span class="line">    <span class="type">int</span> *result = (<span class="type">int</span> *)bsearch(&amp;key, arr, size, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 找到在数组中的位置：%ld\n&quot;</span>, key, result - arr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 未找到在数组中\n&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>bsearch()</code> 函数被用于在已排序数组 <code>arr</code> 中查找元素 <code>key</code>。首先，数组必须是已排序的，然后使用 <code>qsort()</code> 对其进行排序。然后调用 <code>bsearch()</code> 函数来寻找 <code>key</code>，并根据返回结果确定是否找到该元素。如果找到，<code>bsearch()</code> 返回指向匹配元素的指针，否则返回 <code>NULL</code>。</p>
<h2 id="C-putenv-函数-详解"><a href="#C-putenv-函数-详解" class="headerlink" title="C putenv() 函数 详解"></a>C putenv() 函数 详解</h2><p><code>putenv()</code> 函数用于设置环境变量。它是C标准库中的一部分，定义在 <code>&lt;stdlib.h&gt;</code> 头文件中。</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>string</code>：一个以形式 <code>name=value</code> 表示的字符串，用于设置环境变量。这个字符串会被函数复制，因此你可以在调用后安全地释放它。</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li>如果设置环境变量成功，则返回0；否则返回一个非零值。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>putenv()</code> 在某些平台上可能不是线程安全的，因此在多线程环境中使用时需要小心。</li>
<li>在某些平台上，使用 <code>putenv()</code> 可能会导致内存泄漏，因为它只是修改了指向环境变量的指针，而不是为其分配新的内存空间。</li>
<li>在某些操作系统上，对环境变量的更改可能会影响整个程序的行为，因此使用 <code>putenv()</code> 需要谨慎。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面是一个简单的示例，演示了如何使用 <code>putenv()</code> 设置一个环境变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置环境变量</span></span><br><span class="line">    <span class="type">char</span> env_var[] = <span class="string">&quot;MY_ENV_VAR=Hello World&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (putenv(env_var) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to set environment variable\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取环境变量并输出</span></span><br><span class="line">    <span class="type">char</span>* value = getenv(<span class="string">&quot;MY_ENV_VAR&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Value of MY_ENV_VAR: %s\n&quot;</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;MY_ENV_VAR is not set\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们设置了一个名为 <code>MY_ENV_VAR</code> 的环境变量，其值为 <code>Hello World</code>。然后，我们获取并输出这个环境变量的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_9_time_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_9_time_h/" class="post-title-link" itemprop="url">C_5_9_time_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Linux POSIX &lt;time.h&gt;  详解</li>
</ul>
<h2 id="Linux-POSIX-详解"><a href="#Linux-POSIX-详解" class="headerlink" title="Linux POSIX &lt;time.h&gt;  详解"></a>Linux POSIX &lt;time.h&gt;  详解</h2><p><code>&lt;time.h&gt;</code> 是 C 标准库中的一个头文件，用于处理日期和时间相关的操作。它同时也是 POSIX 操作系统接口的一部分，提供了在 POSIX 兼容环境下处理时间的函数和类型。</p>
<p>以下是 <code>&lt;time.h&gt;</code> 中一些关键组成部分的详解：</p>
<h3 id="时间类型："><a href="#时间类型：" class="headerlink" title="时间类型："></a>时间类型：</h3><ol>
<li><p>**<code>time_t</code>**：表示自 1970 年 1 月 1 日 00:00:00 UTC（称为 Epoch）以来经过的秒数。它通常用于存储和操作时间值。</p>
</li>
<li><p>**<code>struct tm</code>**：表示一个日期和时间，以其各个组成部分表示（例如年、月、日、小时、分钟、秒等）。</p>
</li>
</ol>
<h3 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h3><ol>
<li><p>**<code>time()</code>**：从系统时钟获取当前时间，并以 <code>time_t</code> 值的形式返回。</p>
</li>
<li><p>**<code>gmtime()</code>**：将 <code>time_t</code> 值转换为包含 UTC 时间的 <code>struct tm</code> 结构。</p>
</li>
<li><p>**<code>localtime()</code>**：将 <code>time_t</code> 值转换为包含本地时间的 <code>struct tm</code> 结构，已经根据当前时区进行了调整。</p>
</li>
<li><p>**<code>mktime()</code>**：将 <code>struct tm</code> 时间表示转换为 <code>time_t</code> 值。</p>
</li>
<li><p>**<code>strftime()</code>**：根据格式字符串，将 <code>struct tm</code> 时间值格式化为指定的字符串表示形式。</p>
</li>
<li><p>**<code>difftime()</code>**：计算两个 <code>time_t</code> 值之间的差异，以秒为单位返回差值。</p>
</li>
</ol>
<h3 id="常量："><a href="#常量：" class="headerlink" title="常量："></a>常量：</h3><ol>
<li><p><strong>Epoch</strong>：定义为时间的起始点，通常被表示为 1970 年 1 月 1 日（00:00:00 UTC）。</p>
</li>
<li><p><strong>与日期&#x2F;时间计算相关的常量</strong>：比如 <code>SECONDS_PER_MINUTE</code>（每分钟秒数）、<code>SECONDS_PER_HOUR</code>（每小时秒数）、<code>SECONDS_PER_DAY</code>（每天秒数）等，用于时间计算。</p>
</li>
</ol>
<h3 id="时间操作："><a href="#时间操作：" class="headerlink" title="时间操作："></a>时间操作：</h3><p>通过 <code>&lt;time.h&gt;</code>，你可以进行各种时间相关的操作，比如：</p>
<ul>
<li>获取当前时间和日期。</li>
<li>在不同的时间表示之间进行转换（比如 <code>time_t</code> 和 <code>struct tm</code>）。</li>
<li>将时间值格式化为字符串。</li>
<li>对时间值进行算术运算。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> currentTime;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">localTime</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    currentTime = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前时间转换为本地时间</span></span><br><span class="line">    localTime = localtime(&amp;currentTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示本地时间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前本地时间和日期：%s&quot;</span>, asctime(localTime));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>&lt;time.h&gt;</code> 中的函数获取当前本地时间和日期，并将其打印到控制台。</p>
<p>请注意，虽然 <code>&lt;time.h&gt;</code> 提供了在 C 中进行基本日期和时间操作的功能，但是对于更高级的操作或在 C++ 中进行操作时，可能有更现代和功能更强大的库可用，比如 C++ 中的 <code>&lt;chrono&gt;</code>，或者其他库提供的更高级抽象。</p>
<h2 id="Linux-POSIX-time-详解"><a href="#Linux-POSIX-time-详解" class="headerlink" title="Linux POSIX &lt;time.h&gt; time()  详解"></a>Linux POSIX &lt;time.h&gt; time()  详解</h2><p><code>time()</code> 是 POSIX 操作系统中 <code>&lt;time.h&gt;</code> 头文件中所定义的一个函数，用于获取当前系统时间，并以 <code>time_t</code> 格式返回从 Epoch（1970 年 1 月 1 日 00:00:00 UTC）到当前时间经过的秒数。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *seconds)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：返回一个 <code>time_t</code> 类型的值，表示自 Epoch 起至当前时间经过的秒数。</li>
<li><strong>参数</strong>：<ul>
<li><code>seconds</code>（可选）：一个指向 <code>time_t</code> 类型变量的指针。如果不为 <code>NULL</code>，函数会把获取到的当前时间也存储在这个指针所指向的位置，以便于进一步使用。</li>
</ul>
</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> currentTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    currentTime = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前时间（自 Epoch 起的秒数）：%lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)currentTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释示例："><a href="#解释示例：" class="headerlink" title="解释示例："></a>解释示例：</h3><ol>
<li>引入 <code>&lt;stdio.h&gt;</code> 和 <code>&lt;time.h&gt;</code> 头文件。</li>
<li>声明一个 <code>time_t</code> 类型的变量 <code>currentTime</code>。</li>
<li>使用 <code>time(NULL)</code> 函数来获取当前时间，<code>NULL</code> 作为参数意味着函数只返回当前时间，不将其存储到其他地方。</li>
<li>使用 <code>printf()</code> 将获取的当前时间值打印出来。</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>time()</code> 函数返回的时间值通常是自 Epoch（1970 年 1 月 1 日 00:00:00 UTC）起至当前时间的秒数。这个值的精度因系统而异，一般是秒级别的精度。</li>
<li>如果 <code>seconds</code> 参数不为 <code>NULL</code>，则会将当前时间的值保存到这个参数所指向的位置，方便进一步处理。</li>
</ul>
<p><code>time()</code> 函数在 C 编程中常用于获取时间戳或者记录程序运行时间等任务。</p>
<h2 id="Linux-POSIX-gmtime-详解"><a href="#Linux-POSIX-gmtime-详解" class="headerlink" title="Linux POSIX &lt;time.h&gt; gmtime()  详解"></a>Linux POSIX &lt;time.h&gt; gmtime()  详解</h2><p><code>gmtime()</code> 是 POSIX 操作系统中 <code>&lt;time.h&gt;</code> 头文件中定义的一个函数，用于将 <code>time_t</code> 类型的时间值（从 Epoch 起的秒数）转换为一个 UTC（协调世界时）时间的结构体表示，即 <code>struct tm</code> 类型。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：返回一个指向 <code>struct tm</code> 结构体的指针，其中包含了由 <code>time_t</code> 值表示的 UTC 时间的各个分量。</li>
<li><strong>参数</strong>：<ul>
<li><code>timep</code>：一个指向 <code>time_t</code> 类型变量的指针，表示待转换的时间值。</li>
</ul>
</li>
</ul>
<h3 id="struct-tm-结构体定义："><a href="#struct-tm-结构体定义：" class="headerlink" title="struct tm 结构体定义："></a><code>struct tm</code> 结构体定义：</h3><p><code>struct tm</code> 结构体包含了表示时间的各个成员变量，例如年、月、日、小时、分钟、秒等，它的定义通常如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> tm_sec;   <span class="comment">// 秒，范围 0-59</span></span><br><span class="line">    <span class="type">int</span> tm_min;   <span class="comment">// 分，范围 0-59</span></span><br><span class="line">    <span class="type">int</span> tm_hour;  <span class="comment">// 小时，范围 0-23</span></span><br><span class="line">    <span class="type">int</span> tm_mday;  <span class="comment">// 一个月中的日期，范围 1-31</span></span><br><span class="line">    <span class="type">int</span> tm_mon;   <span class="comment">// 月份，从一月开始计数，范围 0-11</span></span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">// 自 1900 年起至今的年数</span></span><br><span class="line">    <span class="type">int</span> tm_wday;  <span class="comment">// 一周中的天数，范围 0-6 (0 表示周日)</span></span><br><span class="line">    <span class="type">int</span> tm_yday;  <span class="comment">// 一年中的天数，范围 0-365</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">// 夏令时标志（0 表示不使用夏令时，正值表示夏令时，负值表示信息不可用）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> currentTime;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">utcTime</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    currentTime = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前时间转换为 UTC 时间</span></span><br><span class="line">    utcTime = gmtime(&amp;currentTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示 UTC 时间的各个成员</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UTC 时间：%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>,</span><br><span class="line">        utcTime-&gt;tm_year + <span class="number">1900</span>, utcTime-&gt;tm_mon + <span class="number">1</span>, utcTime-&gt;tm_mday,</span><br><span class="line">        utcTime-&gt;tm_hour, utcTime-&gt;tm_min, utcTime-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释示例：-1"><a href="#解释示例：-1" class="headerlink" title="解释示例："></a>解释示例：</h3><ol>
<li>引入 <code>&lt;stdio.h&gt;</code> 和 <code>&lt;time.h&gt;</code> 头文件。</li>
<li>声明一个 <code>time_t</code> 类型的变量 <code>currentTime</code> 和一个指向 <code>struct tm</code> 的指针 <code>utcTime</code>。</li>
<li>使用 <code>time(NULL)</code> 函数获取当前时间。</li>
<li>使用 <code>gmtime(&amp;currentTime)</code> 函数将获取的时间转换为 UTC 时间，并将结果保存在 <code>utcTime</code> 指针指向的位置。</li>
<li>使用 <code>printf()</code> 打印 UTC 时间的各个成员变量，需要注意月份应加一、年份需要加上 1900。</li>
</ol>
<p><code>gmtime()</code> 函数将 <code>time_t</code> 类型的时间值转换为 UTC 时间的结构体表示，方便对时间进行更详细的分析和处理。</p>
<h2 id="Linux-POSIX-localtime-详解"><a href="#Linux-POSIX-localtime-详解" class="headerlink" title="Linux POSIX &lt;time.h&gt; localtime()  详解"></a>Linux POSIX &lt;time.h&gt; localtime()  详解</h2><p><code>localtime()</code> 是 POSIX 操作系统中 <code>&lt;time.h&gt;</code> 头文件中定义的一个函数，用于将 <code>time_t</code> 类型的时间值（从 Epoch 起的秒数）转换为一个本地时间的结构体表示，即 <code>struct tm</code> 类型。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：返回一个指向 <code>struct tm</code> 结构体的指针，其中包含了由 <code>time_t</code> 值表示的本地时间的各个分量。</li>
<li><strong>参数</strong>：<ul>
<li><code>timep</code>：一个指向 <code>time_t</code> 类型变量的指针，表示待转换的时间值。</li>
</ul>
</li>
</ul>
<h3 id="struct-tm-结构体定义：-1"><a href="#struct-tm-结构体定义：-1" class="headerlink" title="struct tm 结构体定义："></a><code>struct tm</code> 结构体定义：</h3><p><code>struct tm</code> 结构体包含了表示时间的各个成员变量，例如年、月、日、小时、分钟、秒等，它的定义通常如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> tm_sec;   <span class="comment">// 秒，范围 0-59</span></span><br><span class="line">    <span class="type">int</span> tm_min;   <span class="comment">// 分，范围 0-59</span></span><br><span class="line">    <span class="type">int</span> tm_hour;  <span class="comment">// 小时，范围 0-23</span></span><br><span class="line">    <span class="type">int</span> tm_mday;  <span class="comment">// 一个月中的日期，范围 1-31</span></span><br><span class="line">    <span class="type">int</span> tm_mon;   <span class="comment">// 月份，从一月开始计数，范围 0-11</span></span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">// 自 1900 年起至今的年数</span></span><br><span class="line">    <span class="type">int</span> tm_wday;  <span class="comment">// 一周中的天数，范围 0-6 (0 表示周日)</span></span><br><span class="line">    <span class="type">int</span> tm_yday;  <span class="comment">// 一年中的天数，范围 0-365</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">// 夏令时标志（0 表示不使用夏令时，正值表示夏令时，负值表示信息不可用）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> currentTime;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">localTime</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    currentTime = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前时间转换为本地时间</span></span><br><span class="line">    localTime = localtime(&amp;currentTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示本地时间的各个成员</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;本地时间：%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>,</span><br><span class="line">        localTime-&gt;tm_year + <span class="number">1900</span>, localTime-&gt;tm_mon + <span class="number">1</span>, localTime-&gt;tm_mday,</span><br><span class="line">        localTime-&gt;tm_hour, localTime-&gt;tm_min, localTime-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释示例：-2"><a href="#解释示例：-2" class="headerlink" title="解释示例："></a>解释示例：</h3><ol>
<li>引入 <code>&lt;stdio.h&gt;</code> 和 <code>&lt;time.h&gt;</code> 头文件。</li>
<li>声明一个 <code>time_t</code> 类型的变量 <code>currentTime</code> 和一个指向 <code>struct tm</code> 的指针 <code>localTime</code>。</li>
<li>使用 <code>time(NULL)</code> 函数获取当前时间。</li>
<li>使用 <code>localtime(&amp;currentTime)</code> 函数将获取的时间转换为本地时间，并将结果保存在 <code>localTime</code> 指针指向的位置。</li>
<li>使用 <code>printf()</code> 打印本地时间的各个成员变量，需要注意月份应加一、年份需要加上 1900。</li>
</ol>
<p><code>localtime()</code> 函数将 <code>time_t</code> 类型的时间值转换为本地时间的结构体表示，这样就可以方便地对时间进行更详细的分析和处理，并以易读的形式输出。</p>
<h2 id="Linux-POSIX-mktime-详解"><a href="#Linux-POSIX-mktime-详解" class="headerlink" title="Linux POSIX &lt;time.h&gt; mktime()  详解"></a>Linux POSIX &lt;time.h&gt; mktime()  详解</h2><p><code>mktime()</code> 是 POSIX 操作系统中 <code>&lt;time.h&gt;</code> 头文件中定义的一个函数，用于将一个表示日期和时间的 <code>struct tm</code> 结构体转换为 <code>time_t</code> 类型的时间值（从 Epoch 起的秒数）。</p>
<h3 id="函数签名：-3"><a href="#函数签名：-3" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *timeptr)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：返回一个 <code>time_t</code> 类型的值，表示由 <code>struct tm</code> 结构体表示的时间值，即从 Epoch 起的秒数。</li>
<li><strong>参数</strong>：<ul>
<li><code>timeptr</code>：一个指向 <code>struct tm</code> 结构体的指针，表示待转换为 <code>time_t</code> 类型的时间值。</li>
</ul>
</li>
</ul>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">dateTime</span>;</span></span><br><span class="line">    <span class="type">time_t</span> timeValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充日期和时间信息到 struct tm 结构体</span></span><br><span class="line">    dateTime.tm_year = <span class="number">2023</span> - <span class="number">1900</span>; <span class="comment">// 年份从 1900 开始计数</span></span><br><span class="line">    dateTime.tm_mon = <span class="number">11</span> - <span class="number">1</span>;       <span class="comment">// 月份从 0 开始计数</span></span><br><span class="line">    dateTime.tm_mday = <span class="number">23</span>;          <span class="comment">// 日期</span></span><br><span class="line">    dateTime.tm_hour = <span class="number">10</span>;          <span class="comment">// 小时</span></span><br><span class="line">    dateTime.tm_min = <span class="number">30</span>;           <span class="comment">// 分钟</span></span><br><span class="line">    dateTime.tm_sec = <span class="number">0</span>;            <span class="comment">// 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 struct tm 结构体转换为 time_t 类型的时间值</span></span><br><span class="line">    timeValue = mktime(&amp;dateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示转换后的时间值（从 Epoch 起的秒数）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;转换后的时间值：%lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)timeValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释示例：-3"><a href="#解释示例：-3" class="headerlink" title="解释示例："></a>解释示例：</h3><ol>
<li>引入 <code>&lt;stdio.h&gt;</code> 和 <code>&lt;time.h&gt;</code> 头文件。</li>
<li>声明一个 <code>struct tm</code> 类型的变量 <code>dateTime</code> 和一个 <code>time_t</code> 类型的变量 <code>timeValue</code>。</li>
<li>填充 <code>struct tm</code> 结构体 <code>dateTime</code> 中的年、月、日、小时、分钟、秒等成员变量。</li>
<li>使用 <code>mktime(&amp;dateTime)</code> 函数将 <code>struct tm</code> 结构体转换为 <code>time_t</code> 类型的时间值，并将结果保存在 <code>timeValue</code> 变量中。</li>
<li>使用 <code>printf()</code> 打印转换后的时间值（从 Epoch 起的秒数）。</li>
</ol>
<p><code>mktime()</code> 函数将日期和时间信息从 <code>struct tm</code> 结构体转换为 <code>time_t</code> 类型的时间值，方便在不同的时间表示之间进行转换。</p>
<h2 id="Linux-POSIX-strftime-详解"><a href="#Linux-POSIX-strftime-详解" class="headerlink" title="Linux POSIX &lt;time.h&gt; strftime()  详解"></a>Linux POSIX &lt;time.h&gt; strftime()  详解</h2><p><code>strftime()</code> 是 POSIX 操作系统中 <code>&lt;time.h&gt;</code> 头文件中定义的一个函数，用于将 <code>struct tm</code> 结构体表示的时间值格式化为指定格式的字符串。</p>
<h3 id="函数签名：-4"><a href="#函数签名：-4" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *s, <span class="type">size_t</span> maxsize, <span class="type">const</span> <span class="type">char</span> *format, <span class="type">const</span> <span class="keyword">struct</span> tm *timeptr)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：返回生成的字符串的字符数（不包括空字符 <code>\0</code>），如果格式化失败或者输出的字符串超出了 <code>maxsize</code> 的限制，则返回 0。</li>
<li><strong>参数</strong>：<ul>
<li><code>s</code>：一个指向字符数组的指针，用于存储生成的格式化后的字符串。</li>
<li><code>maxsize</code>：字符数组 <code>s</code> 的最大长度，以防止溢出。</li>
<li><code>format</code>：一个表示输出格式的字符串。该格式字符串可以包含转换说明符以及普通字符。</li>
<li><code>timeptr</code>：一个指向 <code>struct tm</code> 结构体的指针，表示待格式化的时间值。</li>
</ul>
</li>
</ul>
<h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">dateTime</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充日期和时间信息到 struct tm 结构体</span></span><br><span class="line">    dateTime.tm_year = <span class="number">2023</span> - <span class="number">1900</span>; <span class="comment">// 年份从 1900 开始计数</span></span><br><span class="line">    dateTime.tm_mon = <span class="number">11</span> - <span class="number">1</span>;       <span class="comment">// 月份从 0 开始计数</span></span><br><span class="line">    dateTime.tm_mday = <span class="number">23</span>;          <span class="comment">// 日期</span></span><br><span class="line">    dateTime.tm_hour = <span class="number">10</span>;          <span class="comment">// 小时</span></span><br><span class="line">    dateTime.tm_min = <span class="number">30</span>;           <span class="comment">// 分钟</span></span><br><span class="line">    dateTime.tm_sec = <span class="number">0</span>;            <span class="comment">// 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化 struct tm 结构体中的时间信息为字符串</span></span><br><span class="line">    strftime(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, &amp;dateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示格式化后的字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;格式化后的时间字符串：%s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释示例：-4"><a href="#解释示例：-4" class="headerlink" title="解释示例："></a>解释示例：</h3><ol>
<li>引入 <code>&lt;stdio.h&gt;</code> 和 <code>&lt;time.h&gt;</code> 头文件。</li>
<li>声明一个 <code>struct tm</code> 类型的变量 <code>dateTime</code> 和一个字符数组 <code>buffer</code>。</li>
<li>填充 <code>struct tm</code> 结构体 <code>dateTime</code> 中的年、月、日、小时、分钟、秒等成员变量。</li>
<li>使用 <code>strftime()</code> 函数将 <code>struct tm</code> 结构体中的时间信息格式化为字符串，按照给定的格式 <code>&quot;%Y-%m-%d %H:%M:%S&quot;</code>（表示年-月-日 时:分:秒）。</li>
<li>生成的格式化后的字符串保存在 <code>buffer</code> 数组中，并使用 <code>printf()</code> 打印出来。</li>
</ol>
<p><code>strftime()</code> 函数可以根据指定的格式将 <code>struct tm</code> 结构体表示的时间值格式化为字符串，非常方便用于生成各种不同格式的日期时间字符串。</p>
<h2 id="Linux-POSIX-difftime-详解"><a href="#Linux-POSIX-difftime-详解" class="headerlink" title="Linux POSIX &lt;time.h&gt; difftime()  详解"></a>Linux POSIX &lt;time.h&gt; difftime()  详解</h2><p><code>difftime()</code> 是 POSIX 操作系统中 <code>&lt;time.h&gt;</code> 头文件中定义的一个函数，用于计算两个 <code>time_t</code> 类型的时间值之间的差异，返回结果以秒为单位。</p>
<h3 id="函数签名：-5"><a href="#函数签名：-5" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">difftime</span><span class="params">(<span class="type">time_t</span> time1, <span class="type">time_t</span> time0)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：返回一个 <code>double</code> 类型的值，表示两个时间值之间的差异（以秒为单位）。</li>
<li><strong>参数</strong>：<ul>
<li><code>time1</code>：第一个 <code>time_t</code> 类型的时间值。</li>
<li><code>time0</code>：第二个 <code>time_t</code> 类型的时间值。</li>
</ul>
</li>
</ul>
<h3 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> currentTime;</span><br><span class="line">    <span class="type">time_t</span> startTime;</span><br><span class="line">    <span class="type">double</span> difference;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间和起始时间</span></span><br><span class="line">    currentTime = time(<span class="literal">NULL</span>);</span><br><span class="line">    startTime = <span class="number">1638732000</span>; <span class="comment">// 2021-12-06 12:00:00 的时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两个时间之间的差异</span></span><br><span class="line">    difference = difftime(currentTime, startTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示两个时间之间的差异（秒数）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;时间差：%f 秒\n&quot;</span>, difference);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释示例：-5"><a href="#解释示例：-5" class="headerlink" title="解释示例："></a>解释示例：</h3><ol>
<li>引入 <code>&lt;stdio.h&gt;</code> 和 <code>&lt;time.h&gt;</code> 头文件。</li>
<li>声明 <code>time_t</code> 类型的变量 <code>currentTime</code>、<code>startTime</code> 和 <code>double</code> 类型的变量 <code>difference</code>。</li>
<li>使用 <code>time(NULL)</code> 获取当前时间戳 <code>currentTime</code>，并将特定日期时间的时间戳（<code>2021-12-06 12:00:00</code>）存储在 <code>startTime</code> 变量中。</li>
<li>使用 <code>difftime()</code> 函数计算当前时间 <code>currentTime</code> 和特定起始时间 <code>startTime</code> 之间的差异。</li>
<li>将计算得到的时间差异（秒数）显示在控制台上。</li>
</ol>
<p><code>difftime()</code> 函数可用于计算两个 <code>time_t</code> 类型的时间值之间的差异，常用于测量时间间隔或计算程序执行时间等场景。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_8_pthread_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_8_pthread_h/" class="post-title-link" itemprop="url">C_5_8_pthread_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Linux POSIX &lt;pthread.h&gt;  详解</li>
</ul>
<h2 id="Linux-POSIX-详解"><a href="#Linux-POSIX-详解" class="headerlink" title="Linux POSIX &lt;pthread.h&gt;  详解"></a>Linux POSIX &lt;pthread.h&gt;  详解</h2><p>在 Linux POSIX 系统中，<code>&lt;pthread.h&gt;</code> 是用于多线程编程的头文件。POSIX 线程（Pthreads）是一种遵循 POSIX 标准的线程模型，允许程序在单个进程中创建和管理多个并发执行的线程。</p>
<p>以下是关于 <code>&lt;pthread.h&gt;</code> 头文件的详细解释：</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li><code>&lt;pthread.h&gt;</code> 头文件中定义了用于线程管理的函数、类型和常量，允许程序创建、控制和同步线程的执行。</li>
<li>通过该头文件提供的函数，可以创建线程、等待线程结束、线程互斥、条件变量等。</li>
</ul>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul>
<li>**<code>pthread_create()</code>**：用于创建一个新的线程。</li>
<li>**<code>pthread_join()</code>**：用于等待一个线程的结束。</li>
<li>**<code>pthread_exit()</code>**：用于退出当前线程。</li>
<li><strong><code>pthread_mutex_init()</code></strong> 和 <strong><code>pthread_mutex_lock()</code></strong> 等：用于创建和操作互斥锁。</li>
<li><strong><code>pthread_cond_init()</code></strong> 和 <strong><code>pthread_cond_wait()</code></strong> 等：用于创建和操作条件变量。</li>
</ul>
<h3 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">print_message</span><span class="params">(<span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *message = (<span class="type">char</span> *)ptr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, message);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message1 = <span class="string">&quot;线程1&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message2 = <span class="string">&quot;线程2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程1</span></span><br><span class="line">    pthread_create(&amp;thread1, <span class="literal">NULL</span>, print_message, (<span class="type">void</span> *)message1);</span><br><span class="line">    <span class="comment">// 创建线程2</span></span><br><span class="line">    pthread_create(&amp;thread2, <span class="literal">NULL</span>, print_message, (<span class="type">void</span> *)message2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程1结束</span></span><br><span class="line">    pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 等待线程2结束</span></span><br><span class="line">    pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>多线程编程需要小心处理共享资源，避免出现数据竞争和死锁等问题。</li>
<li>使用线程时需要谨慎管理线程的生命周期，确保适当地创建、等待和退出线程，以免出现资源泄露或未预期的行为。</li>
</ul>
<p><code>&lt;pthread.h&gt;</code> 头文件提供了在 POSIX 系统中进行多线程编程所需的函数和工具，允许程序员创建并发执行的线程，以实现更高效的并发和异步操作。</p>
<h2 id="Linux-POSIX-pthread-create-详解"><a href="#Linux-POSIX-pthread-create-详解" class="headerlink" title="Linux POSIX &lt;pthread.h&gt; pthread_create()  详解"></a>Linux POSIX &lt;pthread.h&gt; pthread_create()  详解</h2><p><code>pthread_create()</code> 是 Linux POSIX 系统中 <code>&lt;pthread.h&gt;</code> 头文件中提供的函数，用于创建新的线程。</p>
<p>以下是关于 <code>pthread_create()</code> 函数的详细解释：</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>thread</code>：指向 <code>pthread_t</code> 类型的指针，用于存储新线程的标识符。</li>
<li><code>attr</code>：指向 <code>pthread_attr_t</code> 类型的指针，用于指定新线程的属性（通常为 <code>NULL</code>，表示使用默认属性）。</li>
<li><code>start_routine</code>：是一个指向线程函数的指针，新线程将从这个函数开始执行。</li>
<li><code>arg</code>：传递给 <code>start_routine</code> 函数的参数。</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>pthread_create()</code> 函数成功创建新线程时，返回0；如果出现错误，则返回相应的错误码。</li>
</ul>
<h3 id="示例用法-1"><a href="#示例用法-1" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> value = *(<span class="type">int</span> *)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;传入的值是：%d\n&quot;</span>, value);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> my_thread;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新线程</span></span><br><span class="line">    <span class="type">int</span> result = pthread_create(&amp;my_thread, <span class="literal">NULL</span>, thread_function, (<span class="type">void</span> *)&amp;value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;新线程创建成功\n&quot;</span>);</span><br><span class="line">        pthread_join(my_thread, <span class="literal">NULL</span>); <span class="comment">// 等待新线程结束</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;新线程创建失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>线程函数的签名必须为 <code>void *function(void *arg)</code>，并且参数和返回值必须是 <code>void *</code> 类型。</li>
<li>在使用 <code>pthread_create()</code> 创建线程时，需要传递一个函数指针作为新线程的入口点，并可以传递参数给新线程的函数。</li>
</ul>
<p><code>pthread_create()</code> 函数是在 Linux POSIX 环境下创建新线程的标准方法。它允许程序员指定新线程的入口函数，并传递参数给新线程。成功创建线程后，可以通过 <code>pthread_join()</code> 等待线程的结束。</p>
<h2 id="Linux-POSIX-pthread-join-详解"><a href="#Linux-POSIX-pthread-join-详解" class="headerlink" title="Linux POSIX &lt;pthread.h&gt; pthread_join()  详解"></a>Linux POSIX &lt;pthread.h&gt; pthread_join()  详解</h2><p><code>pthread_join()</code> 是 Linux POSIX 系统中 <code>&lt;pthread.h&gt;</code> 头文件提供的函数，用于等待一个特定线程的结束。</p>
<p>以下是关于 <code>pthread_join()</code> 函数的详细解释：</p>
<h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>thread</code>：表示要等待的线程标识符，即被等待线程的 <code>pthread_t</code>。</li>
<li><code>retval</code>：用于接收线程的返回值的指针，可以为 <code>NULL</code>（如果不需要获取线程的返回值）。</li>
</ul>
<h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>pthread_join()</code> 函数成功时返回0；如果出现错误，则返回相应的错误码。</li>
</ul>
<h3 id="示例用法-2"><a href="#示例用法-2" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程执行中...\n&quot;</span>);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> my_thread;</span><br><span class="line">    <span class="type">void</span> *thread_result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新线程</span></span><br><span class="line">    pthread_create(&amp;my_thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待新线程结束并获取返回值</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_join(my_thread, &amp;thread_result) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子线程执行完成，返回值为：%ld\n&quot;</span>, (<span class="type">long</span>)thread_result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法等待子线程\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>pthread_join()</code> 函数允许主线程等待指定的线程结束，并且获取线程的返回值。</li>
<li>如果主线程不关心线程的返回值，可以将 <code>retval</code> 参数设置为 <code>NULL</code>。</li>
<li>如果线程已经在运行并且成功完成，调用 <code>pthread_join()</code> 将立即返回；否则，它将阻塞主线程，直到被等待的线程结束。</li>
</ul>
<p><code>pthread_join()</code> 函数用于实现线程之间的同步，允许一个线程等待另一个线程的完成，并获取其返回值（如果有）。</p>
<h2 id="Linux-POSIX-pthread-exit-详解"><a href="#Linux-POSIX-pthread-exit-详解" class="headerlink" title="Linux POSIX &lt;pthread.h&gt; pthread_exit()  详解"></a>Linux POSIX &lt;pthread.h&gt; pthread_exit()  详解</h2><p><code>pthread_exit()</code> 是 Linux POSIX 系统中 <code>&lt;pthread.h&gt;</code> 头文件提供的函数，用于在线程执行过程中退出线程。</p>
<p>以下是关于 <code>pthread_exit()</code> 函数的详细解释：</p>
<h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>retval</code>：表示线程的返回值，可以是任何类型的指针（<code>void *</code>）。线程的返回值可以在其他线程中通过 <code>pthread_join()</code> 获取。</li>
</ul>
<h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>pthread_exit()</code> 函数本身没有返回值，它将导致调用它的线程立即退出。</li>
</ul>
<h3 id="示例用法-3"><a href="#示例用法-3" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程执行中...\n&quot;</span>);</span><br><span class="line">    pthread_exit((<span class="type">void</span> *)<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> my_thread;</span><br><span class="line">    <span class="type">void</span> *thread_result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新线程</span></span><br><span class="line">    pthread_create(&amp;my_thread, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待新线程结束并获取返回值</span></span><br><span class="line">    pthread_join(my_thread, &amp;thread_result);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程执行完成，返回值为：%ld\n&quot;</span>, (<span class="type">long</span>)thread_result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>在线程执行过程中，调用 <code>pthread_exit()</code> 可以立即退出线程，不必等到线程执行完毕。</li>
<li>线程的返回值可以通过 <code>pthread_join()</code> 获取，这个返回值也可以是指向堆中分配内存的指针。</li>
</ul>
<p><code>pthread_exit()</code> 函数允许线程在执行期间提前退出，同时可以指定一个返回值，这个返回值可以在其他线程中获取。</p>
<h2 id="Linux-POSIX-pthread-mutex-init-详解"><a href="#Linux-POSIX-pthread-mutex-init-详解" class="headerlink" title="Linux POSIX &lt;pthread.h&gt; pthread_mutex_init()  详解"></a>Linux POSIX &lt;pthread.h&gt; pthread_mutex_init()  详解</h2><p><code>pthread_mutex_init()</code> 是 Linux POSIX 系统中 <code>&lt;pthread.h&gt;</code> 头文件提供的函数，用于初始化互斥锁（mutex）。</p>
<p>以下是关于 <code>pthread_mutex_init()</code> 函数的详细解释：</p>
<h3 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>mutex</code>：指向 <code>pthread_mutex_t</code> 类型的指针，用于指定要初始化的互斥锁。</li>
<li><code>attr</code>：指向 <code>pthread_mutexattr_t</code> 类型的指针，用于指定互斥锁的属性，通常为 <code>NULL</code> 表示使用默认属性。</li>
</ul>
<h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>pthread_mutex_init()</code> 函数成功时返回0；如果出现错误，则返回相应的错误码。</li>
</ul>
<h3 id="示例用法-4"><a href="#示例用法-4" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex; <span class="comment">// 全局互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex); <span class="comment">// 锁定互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程 %ld 运行中...\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex); <span class="comment">// 解锁互斥锁</span></span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥锁</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;互斥锁初始化失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_function, (<span class="type">void</span> *)(<span class="type">long</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>pthread_mutex_init()</code> 用于初始化互斥锁，它为指定的互斥锁分配资源并设置初始属性。</li>
<li>在使用互斥锁之前，必须先初始化互斥锁，否则会导致未定义的行为。</li>
</ul>
<p><code>pthread_mutex_init()</code> 函数允许程序员初始化互斥锁，以确保多线程环境中对共享资源的访问是安全的。</p>
<h2 id="Linux-POSIX-pthread-mutex-lock-详解"><a href="#Linux-POSIX-pthread-mutex-lock-详解" class="headerlink" title="Linux POSIX &lt;pthread.h&gt; pthread_mutex_lock()  详解"></a>Linux POSIX &lt;pthread.h&gt; pthread_mutex_lock()  详解</h2><p><code>pthread_mutex_lock()</code> 是 Linux POSIX 系统中 <code>&lt;pthread.h&gt;</code> 头文件提供的函数，用于对互斥锁（mutex）进行加锁操作。</p>
<p>以下是关于 <code>pthread_mutex_lock()</code> 函数的详细解释：</p>
<h3 id="函数原型-4"><a href="#函数原型-4" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>mutex</code>：指向 <code>pthread_mutex_t</code> 类型的指针，表示要加锁的互斥锁。</li>
</ul>
<h3 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>pthread_mutex_lock()</code> 函数成功时返回0；如果出现错误，则返回相应的错误码。</li>
</ul>
<h3 id="示例用法-5"><a href="#示例用法-5" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER; <span class="comment">// 静态初始化互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex); <span class="comment">// 加锁互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;线程 %ld 运行中...\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex); <span class="comment">// 解锁互斥锁</span></span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多个线程</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_function, (<span class="type">void</span> *)(<span class="type">long</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>pthread_mutex_lock()</code> 用于对互斥锁进行加锁操作，如果互斥锁已经被其他线程锁定，则调用线程会阻塞直到获得锁。</li>
<li>加锁的互斥锁应该在使用后及时解锁，以免造成死锁或其他线程无法获得锁的情况。</li>
</ul>
<p><code>pthread_mutex_lock()</code> 函数用于保护共享资源，确保在多线程环境中对共享资源的访问是互斥且安全的。</p>
<h2 id="Linux-POSIX-pthread-cond-init-详解"><a href="#Linux-POSIX-pthread-cond-init-详解" class="headerlink" title="Linux POSIX &lt;pthread.h&gt; pthread_cond_init()  详解"></a>Linux POSIX &lt;pthread.h&gt; pthread_cond_init()  详解</h2><p><code>pthread_cond_init()</code> 是 Linux POSIX 系统中 <code>&lt;pthread.h&gt;</code> 头文件提供的函数，用于初始化条件变量（condition variable）。</p>
<p>以下是关于 <code>pthread_cond_init()</code> 函数的详细解释：</p>
<h3 id="函数原型-5"><a href="#函数原型-5" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>cond</code>：指向 <code>pthread_cond_t</code> 类型的指针，表示要初始化的条件变量。</li>
<li><code>attr</code>：指向 <code>pthread_condattr_t</code> 类型的指针，用于指定条件变量的属性，通常为 <code>NULL</code> 表示使用默认属性。</li>
</ul>
<h3 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>pthread_cond_init()</code> 函数成功时返回0；如果出现错误，则返回相应的错误码。</li>
</ul>
<h3 id="示例用法-6"><a href="#示例用法-6" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_cond_t</span> condition = PTHREAD_COND_INITIALIZER; <span class="comment">// 静态初始化条件变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER; <span class="comment">// 静态初始化互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">waiter_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;等待线程开始等待...\n&quot;</span>);</span><br><span class="line">    pthread_cond_wait(&amp;condition, &amp;mutex); <span class="comment">// 等待条件变量满足</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;等待线程收到信号，继续执行...\n&quot;</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">signaler_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;信号发送线程睡眠一秒...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 模拟延迟</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;信号发送线程发送信号...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    pthread_cond_signal(&amp;condition); <span class="comment">// 发送信号通知等待线程</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> waiter_thread, signaler_thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建等待线程和发送信号线程</span></span><br><span class="line">    pthread_create(&amp;waiter_thread, <span class="literal">NULL</span>, waiter_function, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;signaler_thread, <span class="literal">NULL</span>, signaler_function, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    pthread_join(waiter_thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(signaler_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>pthread_cond_init()</code> 用于初始化条件变量，在使用条件变量之前必须先进行初始化。</li>
<li>条件变量通常与互斥锁结合使用，以确保线程在等待条件变量时能够安全地访问共享资源。</li>
</ul>
<p>条件变量允许线程在满足特定条件时等待或者唤醒其他线程。结合互斥锁，它可以用于线程之间的同步和通信。</p>
<h2 id="Linux-POSIX-pthread-cond-wait-详解"><a href="#Linux-POSIX-pthread-cond-wait-详解" class="headerlink" title="Linux POSIX &lt;pthread.h&gt; pthread_cond_wait()  详解"></a>Linux POSIX &lt;pthread.h&gt; pthread_cond_wait()  详解</h2><p><code>pthread_cond_wait()</code> 是 Linux POSIX 系统中 <code>&lt;pthread.h&gt;</code> 头文件提供的函数，用于等待条件变量的信号。</p>
<p>以下是关于 <code>pthread_cond_wait()</code> 函数的详细解释：</p>
<h3 id="函数原型-6"><a href="#函数原型-6" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>cond</code>：指向 <code>pthread_cond_t</code> 类型的指针，表示要等待的条件变量。</li>
<li><code>mutex</code>：指向 <code>pthread_mutex_t</code> 类型的指针，表示与条件变量关联的互斥锁。在等待条件变量之前，线程必须持有这个互斥锁。</li>
</ul>
<h3 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>pthread_cond_wait()</code> 函数成功时返回0；如果出现错误，则返回相应的错误码。</li>
</ul>
<h3 id="示例用法-7"><a href="#示例用法-7" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_cond_t</span> condition = PTHREAD_COND_INITIALIZER; <span class="comment">// 静态初始化条件变量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER; <span class="comment">// 静态初始化互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">waiter_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;等待线程开始等待...\n&quot;</span>);</span><br><span class="line">    pthread_cond_wait(&amp;condition, &amp;mutex); <span class="comment">// 等待条件变量满足</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;等待线程收到信号，继续执行...\n&quot;</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">signaler_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;信号发送线程睡眠一秒...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 模拟延迟</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;信号发送线程发送信号...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    pthread_cond_signal(&amp;condition); <span class="comment">// 发送信号通知等待线程</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> waiter_thread, signaler_thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建等待线程和发送信号线程</span></span><br><span class="line">    pthread_create(&amp;waiter_thread, <span class="literal">NULL</span>, waiter_function, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;signaler_thread, <span class="literal">NULL</span>, signaler_function, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    pthread_join(waiter_thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(signaler_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>pthread_cond_wait()</code> 用于让线程等待条件变量满足，它在等待之前会释放关联的互斥锁，并在返回时重新获取这个锁。</li>
<li>在使用 <code>pthread_cond_wait()</code> 时，必须与关联的互斥锁配合使用，以确保线程等待和接收条件变量信号的正确性。</li>
</ul>
<p><code>pthread_cond_wait()</code> 函数允许线程在等待特定条件变量时释放互斥锁，这样其他线程可以修改共享资源并发送信号通知正在等待的线程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_2_%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/2024-05-22-C_2_%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_2_%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/2024-05-22-C_2_%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C_2_重要函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C语言中重要的函数笔记</li>
</ul>
<h2 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h2><h3 id="clock-nanosleep"><a href="#clock-nanosleep" class="headerlink" title="clock_nanosleep"></a>clock_nanosleep</h3><ul>
<li><p>简介：</p>
<ul>
<li>clock_nanosleep() 是一个 C 标准库函数，用于将进程挂起指定的时间长度。它提供了更高精度的休眠功能，可以以纳秒级的精度控制休眠时间</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clock_nanosleep</span><span class="params">(<span class="type">clockid_t</span> clock_id, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> timespec *request, <span class="keyword">struct</span> timespec *remain)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>clock_id：一个表示时钟源的标识符，指定用于计算时间的时钟。常见的时钟源包括<ul>
<li>CLOCK_REALTIME：实时时钟，表示实际时间。</li>
<li>CLOCK_MONOTONIC：单调时钟，表示经过的时间，不受系统时间的影响</li>
</ul>
</li>
<li>flags：用于指定 clock_nanosleep() 函数的行为标志。可以为以下常量的按位或（bitwise OR）组合<ul>
<li>TIMER_ABSTIME：指定 request 参数为绝对时间值，而不是相对于当前时间的相对时间值。</li>
</ul>
</li>
<li>request：指定休眠的时间长度，以 struct timespec 结构表示，包括秒数和纳秒数</li>
<li>remain：用于返回剩余的休眠时间（如果休眠被中断）</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果休眠时间已经完全过去，则返回 0。</li>
<li>如果休眠被中断，返回 -1，并设置 remain 参数为剩余的休眠时间。</li>
<li>如果发生错误，返回 -1，并设置 errno 变量表示错误的原因</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>clock_nanosleep() 函数用于将进程挂起指定的时间长度。</li>
<li>要使用 clock_nanosleep() 函数，需要包含头文件 &lt;time.h&gt;。</li>
<li>休眠时间可以是相对时间值（相对于当前时间的长度）或绝对时间值（指定具体的时间点）。</li>
<li>使用 clock_id 参数指定要使用的时钟源，从而确定时间的基准。</li>
<li>request 参数指定要休眠的时间长度，以秒数和纳秒数表示。</li>
<li>如果指定了 TIMER_ABSTIME 标志，request 参数被视为绝对时间值，而不是相对时间值。</li>
<li>如果休眠时间已经完全过去，函数返回 0。如果休眠被中断，则返回 -1，并通过 remain 参数返回剩余的休眠时间。</li>
<li>返回的剩余休眠时间可以用于重新调用 clock_nanosleep() 函数，以继续休眠。</li>
<li>使用 clock_nanosleep() 函数可以实现更高精度的休眠，比传统的 sleep() 函数提供更细致的时间控制</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> req;</span><br><span class="line">    req.tv_sec = <span class="number">1</span>;         <span class="comment">// 休眠 1 秒</span></span><br><span class="line">    req.tv_nsec = <span class="number">500000000</span>; <span class="comment">// 休眠 500 毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">clock_nanosleep</span>(CLOCK_MONOTONIC, <span class="number">0</span>, &amp;req, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;休眠时间已过。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;休眠被中断。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在此示例中，我们创建了一个 struct timespec 结构 req，指定要休眠的时间为 1 秒 500 毫秒。然后，我们调用 clock_nanosleep() 函数，将 CLOCK_MONOTONIC 作为时钟源，并传递 req 结构作为休眠时间的请求。根据函数的返回值，我们打印相应的消息，指示休眠是否已经完全过去或被中断</li>
<li>需要注意的是，由于 clock_nanosleep() 提供了更高精度的休眠控制，但在使用时需要注意兼容性和平台特定的差异</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/asio/2024-05-22-1_2_asio_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/asio/2024-05-22-1_2_asio_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">1_2_asio_常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>asio模块常用的函数</li>
</ul>
<h2 id="boost-asio-dispatch-函数-详解"><a href="#boost-asio-dispatch-函数-详解" class="headerlink" title="boost::asio::dispatch() 函数 详解"></a>boost::asio::dispatch() 函数 详解</h2><p><code>boost::asio::dispatch()</code> 函数是 Boost.Asio 库中用于将操作投递到执行器（executor）的函数。执行器是一个抽象概念，代表了异步操作的执行上下文和调度策略。</p>
<p>以下是对 <code>boost::asio::dispatch()</code> 函数的详细说明：</p>
<ol>
<li><p><strong>函数签名：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Executor, <span class="keyword">typename</span> Function&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dispatch</span><span class="params">(Executor <span class="type">const</span>&amp; ex, Function&amp;&amp; func)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数接受一个执行器 <code>ex</code> 和一个可调用对象 <code>func</code>，并将 <code>func</code> 投递到 <code>ex</code> 所指定的执行上下文中。</p>
</li>
<li><p><strong>参数解释：</strong></p>
<ul>
<li><p><code>Executor const&amp; ex</code>：执行器对象，表示异步操作将在其上下文中执行。</p>
</li>
<li><p><code>Function&amp;&amp; func</code>：可调用对象，表示要执行的异步操作。</p>
</li>
</ul>
</li>
<li><p><strong>使用场景：</strong></p>
<ul>
<li><p><strong>确保操作在正确的上下文中执行：</strong> <code>dispatch</code> 通常用于确保某个操作在特定的执行上下文中执行。这对于与异步 I&#x2F;O 操作相关的场景非常有用，以确保操作在正确的线程或上下文中执行。</p>
</li>
<li><p><strong>避免竞态条件：</strong> 如果在多个执行上下文中可能同时访问某个共享资源，<code>dispatch</code> 可以用于确保某个操作在适当的上下文中执行，从而避免竞态条件。</p>
</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取默认的系统执行器</span></span><br><span class="line">    <span class="keyword">auto</span> system_executor = boost::asio::<span class="built_in">system_executor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 dispatch 将操作投递到系统执行器上下文</span></span><br><span class="line">    boost::asio::<span class="built_in">dispatch</span>(system_executor, [&amp;]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Async operation in the context of the system executor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>dispatch</code> 函数用于将一个操作投递到系统执行器的上下文中，以确保操作在系统执行器的执行上下文中执行。</p>
</li>
</ol>
<p>总的来说，<code>boost::asio::dispatch()</code> 是一个用于投递异步操作到指定执行器上下文的工具函数，有助于确保操作在正确的执行上下文中执行。</p>
<h2 id="boost-asio-ip-tcp-acceptor-async-accept-函数-传递socket参数"><a href="#boost-asio-ip-tcp-acceptor-async-accept-函数-传递socket参数" class="headerlink" title="boost::asio::ip::tcp::acceptor::async_accept() 函数 传递socket参数"></a>boost::asio::ip::tcp::acceptor::async_accept() 函数 传递socket参数</h2><p><code>boost::asio::ip::tcp::acceptor::async_accept()</code> 函数可以通过额外的参数传递一个 socket 对象，以在连接建立后使用。这通常是通过使用带有额外参数的版本的 <code>async_accept</code> 函数来完成的。</p>
<p>以下是一个简单的示例，演示如何在 <code>async_accept</code> 中传递一个 socket 参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_accept</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error, boost::asio::ip::tcp::socket socket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="comment">// 处理连接成功的情况，可以使用传递的 socket 对象进行数据传输</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Connection accepted!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里可以使用 socket 对象进行数据传输或其他操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理连接失败的情况</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error in async_accept: &quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), <span class="number">12345</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 socket 对象，用于传递给 async_accept</span></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步接受连接，一旦有连接建立，调用 handle_accept 函数，并传递 socket 对象</span></span><br><span class="line">    acceptor.<span class="built_in">async_accept</span>(socket, std::<span class="built_in">bind</span>(handle_accept, std::placeholders::_1, std::<span class="built_in">move</span>(socket)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 io_context 以等待异步操作完成</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>async_accept</code> 函数接受一个额外的参数 <code>socket</code>，并且通过 <code>std::bind</code> 将 <code>handle_accept</code> 函数与这个参数进行绑定。在 <code>handle_accept</code> 中，你可以使用传递的 <code>socket</code> 对象进行数据传输或其他操作。需要注意的是，这里使用了 <code>std::move(socket)</code> 来确保 <code>socket</code> 对象的所有权正确地转移到 <code>handle_accept</code> 函数中。</p>
<h2 id="boost-asio-ip-tcp-acceptor-async-accept-函数-详解"><a href="#boost-asio-ip-tcp-acceptor-async-accept-函数-详解" class="headerlink" title="boost::asio::ip::tcp::acceptor::async_accept() 函数 详解"></a>boost::asio::ip::tcp::acceptor::async_accept() 函数 详解</h2><p><code>boost::asio::ip::tcp::acceptor::async_accept()</code> 函数是 Boost.Asio 库中用于异步接受传入连接的方法。这个函数是非阻塞的，它会启动一个异步操作来等待传入连接，一旦连接建立，将调用指定的回调函数。</p>
<p>下面是一个简要的说明和示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_accept</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="comment">// 处理连接成功的情况</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Connection accepted!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理连接失败的情况</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error in async_accept: &quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), <span class="number">12345</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步接受连接，一旦有连接建立，调用 handle_accept 函数</span></span><br><span class="line">    acceptor.<span class="built_in">async_accept</span>(handle_accept);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 io_context 以等待异步操作完成</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>async_accept()</code> 函数用于异步接受连接。一旦连接建立或者出现错误，指定的回调函数 <code>handle_accept</code> 将被调用。</p>
<p>需要注意的是，<code>io_context.run()</code> 会一直运行，直到所有的异步操作完成。在实际应用中，你可能会有其他的异步操作，而不仅仅是接受连接，所以你可能需要设计一个更复杂的事件循环。</p>
<p>此外，可以使用带有额外参数的 <code>async_accept</code>，以传递更多的信息给回调函数。例如，可以传递一个 socket 对象，以便在连接建立后能够立即处理数据传输。</p>
<h2 id="boost-asio-ip-tcp-acceptor-async-accept-函数-详解-1"><a href="#boost-asio-ip-tcp-acceptor-async-accept-函数-详解-1" class="headerlink" title="boost::asio::ip::tcp::acceptor::async_accept() 函数 详解"></a>boost::asio::ip::tcp::acceptor::async_accept() 函数 详解</h2><p><code>boost::asio::ip::tcp::acceptor::async_accept()</code> 函数是 Boost.Asio 库中用于异步接受传入连接的方法。它通常与 <code>boost::asio::ip::tcp::socket</code> 类结合使用，用于在服务端异步接受客户端的连接请求。以下是对 <code>async_accept</code> 函数的详细解释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;</span><br><span class="line">    <span class="keyword">typename</span> Protocol1,</span><br><span class="line">    <span class="keyword">typename</span> Protocol2,</span><br><span class="line">    <span class="keyword">typename</span> AcceptHandler&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_accept</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    basic_socket&lt;Protocol1&gt;&amp; peer,</span></span></span><br><span class="line"><span class="params"><span class="function">    basic_socket_acceptor&lt;Protocol2&gt;&amp; acceptor,</span></span></span><br><span class="line"><span class="params"><span class="function">    AcceptHandler&amp;&amp; handler)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><p><code>peer</code>: 表示接受连接后的新连接的 socket 对象，即用于与客户端通信的 socket。</p>
</li>
<li><p><code>acceptor</code>: 表示正在监听连接请求的 acceptor 对象。</p>
</li>
<li><p><code>handler</code>: 一个回调函数或函数对象，当连接被接受时会被调用。这个回调函数的签名应该为 <code>void handler(const boost::system::error_code&amp; error)</code></p>
</li>
</ul>
<p>使用 <code>async_accept</code> 时，你需要确保在调用这个函数之前，<code>acceptor</code> 已经被打开并处于监听状态。</p>
<p>以下是一个简单的使用例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_accept</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Connection accepted!\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 在这里可以处理新连接</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error accepting connection: &quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), <span class="number">12345</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个用于接受连接的 socket</span></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步接受连接，并指定回调函数</span></span><br><span class="line">    acceptor.<span class="built_in">async_accept</span>(socket, &amp;handle_accept);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 io_context 事件循环</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>async_accept</code> 被用于异步接受连接。当连接被接受时，<code>handle_accept</code> 回调函数会被调用。你可以在这个回调函数中处理新连接。注意，在真实的应用中，你可能需要使用更复杂的逻辑来处理连接和管理多个连接。</p>
<h2 id="boost-asio-make-strand"><a href="#boost-asio-make-strand" class="headerlink" title="boost::asio::make_strand()"></a>boost::asio::make_strand()</h2><p>在Boost.Asio库中，<code>boost::asio::make_strand()</code> 函数用于创建一个新的 <code>boost::asio::strand</code> 对象。<code>strand</code> 提供了一种机制，确保与它关联的异步操作在同一时间只能在一个线程中执行，从而避免了竞态条件（race conditions）。</p>
<p><code>make_strand</code> 的签名如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> boost::asio &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="function">strand&lt;Executor&gt; <span class="title">make_strand</span><span class="params">(Executor ex)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace boost::asio</span></span><br></pre></td></tr></table></figure>

<p>这个函数接受一个类型为 <code>Executor</code> 的参数，并返回一个 <code>strand&lt;Executor&gt;</code> 对象。<code>Executor</code> 是执行操作的执行上下文（execution context）。可以使用 <code>io_context</code> 对象作为 <code>Executor</code>，也可以使用其他类型的执行上下文。</p>
<p>以下是一些关键概念：</p>
<ul>
<li><p><strong><code>strand</code> 对象：</strong> <code>strand</code> 提供了一种序列化异步操作的机制，确保它们不会同时执行。这在多线程环境中特别有用，可以避免由并发访问共享资源引起的问题。</p>
</li>
<li><p><strong><code>Executor</code>：</strong> <code>Executor</code> 是一个概念，表示能够执行操作的对象。例如，<code>io_context</code> 和 <code>strand</code> 都是实现了 <code>Executor</code> 概念的类。</p>
</li>
</ul>
<p>下面是一个简单的示例，演示了如何使用 <code>make_strand</code> 函数创建一个 <code>strand</code> 对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 strand 对象</span></span><br><span class="line">    boost::asio::strand&lt;boost::asio::io_context::executor_type&gt; my_strand = boost::asio::<span class="built_in">make_strand</span>(io_context.<span class="built_in">get_executor</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 strand 上进行异步操作</span></span><br><span class="line">    my_strand.<span class="built_in">post</span>([]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Operation 1\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    my_strand.<span class="built_in">post</span>([]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Operation 2\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 io_context 事件循环</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个 <code>io_context</code> 对象，并使用 <code>make_strand</code> 函数创建了一个 <code>strand</code> 对象。然后，我们通过 <code>strand</code> 的 <code>post</code> 方法将两个异步操作提交给 <code>io_context</code>。由于这两个操作在同一个 <code>strand</code> 上，它们不会同时执行，确保了操作的顺序性。在运行 <code>io_context</code> 的事件循环后，将依次输出 “Operation 1” 和 “Operation 2”。</p>
<h2 id="boost-asio-post"><a href="#boost-asio-post" class="headerlink" title="boost::asio::post()"></a>boost::asio::post()</h2><p><code>boost::asio::post()</code> 函数是 Boost.Asio 库提供的一个用于将任务投递到 <code>io_context</code> 队列中以异步执行的工具。<code>io_context</code> 是 Boost.Asio 中的核心概念，负责处理异步操作和事件循环。</p>
<p>以下是对 <code>boost::asio::post()</code> 函数的详解：</p>
<ol>
<li><p><strong>函数签名</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CompletionToken&gt;</span><br><span class="line"><span class="built_in">BOOST_ASIO_INITFN_RESULT_TYPE</span>(CompletionToken, <span class="built_in">void</span>())</span><br><span class="line">boost::asio::<span class="built_in">post</span>(boost::asio::io_context&amp; io_context, CompletionToken&amp;&amp; token);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>io_context</code>：要将任务投递到的 <code>io_context</code> 对象的引用。</li>
<li><code>CompletionToken</code>：一个通用的模板参数，可以是函数、Lambda 表达式或其他可调用对象。</li>
</ul>
</li>
<li><p><strong>作用</strong>：</p>
<ul>
<li>将指定的任务投递到 <code>io_context</code> 的队列中，等待异步执行。</li>
<li>任务可以是一个函数、Lambda 表达式、函数对象等。</li>
</ul>
</li>
<li><p><strong>使用示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task executed asynchronously.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 post 将任务添加到 io_context 的队列中</span></span><br><span class="line">    boost::asio::<span class="built_in">post</span>(io_context, &amp;myFunction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 io_context，等待任务执行完成</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>myFunction</code> 函数被异步地投递到 <code>io_context</code> 中，并通过 <code>io_context.run()</code> 来运行队列中的任务。</p>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li><code>post</code> 函数的返回类型是 <code>void</code>，因为它只是将任务投递到队列，而不返回任何结果。</li>
<li>任务执行的具体时间取决于 <code>io_context</code> 的事件循环，可能在调用 <code>post</code> 后不久就执行，也可能在稍后执行。</li>
</ul>
</li>
<li><p><strong>用途</strong>：</p>
<ul>
<li><code>boost::asio::post()</code> 主要用于将任务从一个线程投递到另一个线程，实现异步操作。</li>
<li>在多线程编程中，避免直接在不同线程中调用 <code>io_context.run()</code>，而使用 <code>post</code> 将任务安全地传递给 <code>io_context</code> 是一种常见的做法。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>boost::asio::post()</code> 函数是 Boost.Asio 提供的一个有用的工具，用于实现异步任务的投递和执行，使得多线程编程和异步 I&#x2F;O 操作更为灵活和高效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/asio/2024-05-22-C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8Basio%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/asio/2024-05-22-C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8Basio%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">C++网络编程asio使用总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>asio库使用总结 原文参考链接 : <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/583533338">https://zhuanlan.zhihu.com/p/583533338</a></li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Asio 是一个用于网络和低级 I&#x2F;O 编程的跨平台 C++ 库，它使用现代 C++ 方法为开发人员提供一致的异步模型.</li>
</ul>
<h2 id="io-context"><a href="#io-context" class="headerlink" title="io_context"></a>io_context</h2><ul>
<li>io_context 类为异步I&#x2F;O对象的用户提供了核心I&#x2F;O功能，包含:<ul>
<li>asio::ip::tcp::socket</li>
<li>asio::ip::tcp::acceptor</li>
<li>asio::ip::udp::socket</li>
<li>asio::deadline_timer</li>
</ul>
</li>
</ul>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul>
<li><p>Boost.Asio 的线程安全模型。对于大多数 Boost.Asio 对象，在一个对象上挂起多个异步操作是安全的；只是指定对该对象的并发调用是不安全的。在下图中，每一列代表一个线程，每一行代表一个线程在某个时刻正在做什么。</p>
</li>
<li><p>单个线程进行顺序调用而其他线程不进行调用是安全的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread_1 | thread_2</span><br><span class="line">--------------------------------------+------------ ----------------------------</span><br><span class="line">socket.async_receive(...); | ...</span><br><span class="line">socket.async_write_some(...); | ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个线程进行调用是安全的，但不能同时进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread_1 | thread_2</span><br><span class="line">--------------------------------------+------------ ----------------------------</span><br><span class="line">socket.async_receive(...); | ...</span><br><span class="line">... | socket.async_write_some(...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是，多个线程并发调用是不安全的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread_1 | thread_2</span><br><span class="line">--------------------------------------+------------ ----------------------------</span><br><span class="line">socket.async_receive(...); | socket.async_write_some(...);</span><br><span class="line">... | ...</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="向io-context-提交任意任务"><a href="#向io-context-提交任意任务" class="headerlink" title="向io_context 提交任意任务"></a>向io_context 提交任意任务</h3><ul>
<li>要向 io_context 提交函数，请使用 asio::dispatch、asio::post 或 asio::defer 自由函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    <span class="comment">//提交一个函数</span></span><br><span class="line">    asio::<span class="built_in">post</span>(io_context, my_task);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提交一个lambda 表达式</span></span><br><span class="line">    asio::<span class="built_in">post</span>(io_context, []()&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行 io_context 直到它用完为止。</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="阻止-io-context-耗尽工作"><a href="#阻止-io-context-耗尽工作" class="headerlink" title="阻止 io_context 耗尽工作"></a>阻止 io_context 耗尽工作</h3><ul>
<li><p>某些应用程序可能需要阻止 io_context 对象的 run() 调用在没有更多工作要做时返回。 例如，io_context 可能在应用程序的异步操作之前启动的后台线程中运行。 run() 调用可以通过创建一个针对 io_context 跟踪工作的执行器来保持运行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    <span class="keyword">auto</span> work = asio::<span class="built_in">require</span>(io_context.<span class="built_in">get_executor</span>(), </span><br><span class="line">        asio::execution::outstanding_work.tracked);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了实现关闭，应用程序需要调用 io_context 对象的 stop() 成员函数。 这将导致 io_context run() 调用尽快返回，放弃未完成的操作并且不允许分派准备好的处理程序。<br>或者，如果应用程序要求允许所有操作和处理程序正常完成，请将工作跟踪执行程序存储在 any_io_executor 对象中，以便可以显式重置它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::any_io_executor work = asio::<span class="built_in">require</span>(io_context.<span class="built_in">get_executor</span>(),</span><br><span class="line">        asio::execution::outstanding_work.tracked);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    work = asio::<span class="built_in">any_io_executor</span>();<span class="comment">//允许 run() 退出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="io-context-run"><a href="#io-context-run" class="headerlink" title="io_context.run()"></a>io_context.run()</h3><ul>
<li><p>当线程调用 io_context.run() 时，工作和处理程序将从该线程内调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">asio::io_context io_context;</span><br><span class="line">asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">io_context.<span class="built_in">post</span>(&amp;print);                             <span class="comment">// 1</span></span><br><span class="line">socket.<span class="built_in">connect</span>(endpoint);                            <span class="comment">// 2</span></span><br><span class="line">socket.<span class="built_in">async_receive</span>(buffer, &amp;handle_async_receive); <span class="comment">// 3</span></span><br><span class="line">io_context.<span class="built_in">post</span>(&amp;print);                             <span class="comment">// 4</span></span><br><span class="line">io_context.<span class="built_in">run</span>();                                    <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li>
<li><p>在上面的示例中，io_context .run()(5) 将阻塞直到：</p>
<ul>
<li>它已从两个print处理程序调用并返回，接收操作成功或失败完成，并且其handle_async_receive处理程序已被调用并返回。</li>
<li>通过 io_context 明确停止 io_context.stop()。</li>
<li>从处理程序中抛出异常。</li>
</ul>
</li>
<li><p>请注意，当 io_context 工作用完时，应用程序必须 reset(), 在 io_context 再次运行之前。</p>
</li>
<li><p>run() 函数会阻塞，直到所有工作完成并且没有更多的处理程序要分派，或者直到 io_context 停止。</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Do you reckon this line displays?&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output: Do you reckon this line displays?</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们的程序用完了怎么办？工作类是一个“在有工作要做时通知 io_context 的类”。换句话说，只要 io_context 有一个与之关联的工作对象，它就永远不会无事可做。</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::<span class="function">io_context::work <span class="title">work</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Do you reckon this line displays?&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output: </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们不喜欢这种必须阻塞线程来工作的想法怎么办？我们将简单地模拟一个循环，调用io_context 的poll函数。poll 函数“运行 io_context 对象的事件处理循环来执行就绪的处理程序”</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">42</span>; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        io_context.<span class="built_in">poll</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Counter: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output: 我们将看到 42 行文本输出到控制台，然后程序退出</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当我们运行这个程序时，我们得到与之前完全相同的输出和结果。这是因为当有更多工作要做时，轮询函数不会阻塞。它只是执行当前的一组工作然后返回。在一个真实的程序中，循环将基于一些其他事件，但为了简单起见，我们只使用一个固定的事件。</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::<span class="function">io_context::work <span class="title">work</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">42</span>; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        io_context.<span class="built_in">poll</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Counter: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们想要从 io_context 中删除一个工作对象怎么办？为了实现此功能，我们必须改用指向工作对象的指针。与 boost 库保持一致，我们将使用shared_ptr，一个智能指针类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;asio::io_context::work&gt; <span class="title">work</span><span class="params">(<span class="keyword">new</span> asio::io_context::work(io_context))</span></span>;</span><br><span class="line"></span><br><span class="line">    work.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Do you reckon this line displays?&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们运行该程序，我们将看到显示的文本行。这有效地向我们展示了如何从 io_service 中删除工作对象。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>现在我们知道如何用一个线程驱动 io_context ，我们需要弄清楚更多线程需要什么。io_context 文档页面告诉我们“多个线程可以调用 run() 函数来设置一个线程池，io_context 可以从中执行处理程序。池中等待的所有线程都是等效的，io_context 可以选择其中的任何一个他们调用处理程序。”</p>
</li>
</ul>
<h2 id="Asio-多线程"><a href="#Asio-多线程" class="headerlink" title="Asio 多线程"></a>Asio 多线程</h2><ul>
<li>在多线程的场景下，每个线程都持有一个 io_context ，并且每个线程都调用各自的 io_context 的run()方法。</li>
<li>全局只分配一个io_context ，并且让这个 io_context 在多个线程之间共享，每个线程都调用全局的 io_context 的run()方法</li>
</ul>
<h3 id="每个线程一个I-O-Context"><a href="#每个线程一个I-O-Context" class="headerlink" title="每个线程一个I&#x2F;O Context"></a>每个线程一个I&#x2F;O Context</h3><ul>
<li>特点：<ul>
<li>在多核的机器上，这种方案可以充分利用多个 CPU 核心。</li>
<li>某个 socket 描述符并不会在多个线程之间共享，所以不需要引入同步机制</li>
<li>在 event handler 中不能执行阻塞的操作，否则将会阻塞掉 io_context 所在的线程</li>
</ul>
</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsioIOContextPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> IOContext = asio::io_context;</span><br><span class="line">    <span class="keyword">using</span> Work = asio::io_context::work;</span><br><span class="line">    <span class="keyword">using</span> WorkPtr = std::unique_ptr&lt;Work&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前系统支持的并发线程数</span></span><br><span class="line">    <span class="built_in">AsioIOContextPool</span>(std::<span class="type">size_t</span> size = std::thread::<span class="built_in">hardware_concurrency</span>()) : </span><br><span class="line">        <span class="built_in">ioContexts_</span>(size), </span><br><span class="line">        <span class="built_in">works_</span>(size),</span><br><span class="line">        <span class="built_in">nextIOContext_</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            works_[i] = std::<span class="built_in">unique_ptr</span>&lt;Work&gt;(<span class="keyword">new</span> <span class="built_in">Work</span>(ioContexts_[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ioContexts_.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            threads_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, i]()&#123;</span><br><span class="line">                ioContexts_[i].<span class="built_in">run</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AsioIOContextPool</span>(<span class="type">const</span> AsioIOContextPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    AsioIOContextPool &amp;<span class="keyword">operator</span>=(<span class="type">const</span> AsioIOContextPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">asio::io_context&amp; <span class="title">getIOContext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;context = ioContexts_[nextIOContext_++];</span><br><span class="line">        <span class="keyword">if</span>(nextIOContext_ == ioContexts_.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            nextIOContext_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;work : works_)</span><br><span class="line">        &#123;</span><br><span class="line">            work.<span class="built_in">reset</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t : threads_)</span><br><span class="line">        &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;IOContext&gt; ioContexts_;</span><br><span class="line">    std::vector&lt;WorkPtr&gt; works_;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads_;</span><br><span class="line">    std::<span class="type">size_t</span> nextIOContext_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    AsioIOContextPool pool;</span><br><span class="line">    asio::steady_timer timer&#123;pool.<span class="built_in">getIOContext</span>(), std::chrono::seconds&#123;<span class="number">2</span>&#125;&#125;;</span><br><span class="line">    timer.<span class="built_in">async_wait</span>([&amp;mtx](<span class="type">const</span> asio::error_code &amp;ec)&#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    pool.<span class="built_in">stop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="一个I-O-Service与多个线程"><a href="#一个I-O-Service与多个线程" class="headerlink" title="一个I&#x2F;O Service与多个线程"></a>一个I&#x2F;O Service与多个线程</h3><ul>
<li><p>先分配一个全局 io_context，然后开启多个线程，每个线程都调用这个 io_context的run()方法。这样，当某个异步事件完成时，io_context 就会将相应的 event handler 交给任意一个线程去执行</p>
</li>
<li><p>然而这种方案在实际使用中，需要注意一些问题：</p>
<ul>
<li>在 event handler 中允许执行阻塞的操作 (例如数据库查询操作)。</li>
<li>线程数可以大于 CPU 核心数，譬如说，如果需要在 event handler 中执行阻塞的操作，为了提高程序的响应速度，这时就需要提高线程的数目</li>
<li>由于多个线程同时运行事件循环(event loop)，所以会导致一个问题：即一个 socket 描述符可能会在多个线程之间共享，容易出现竞态条件 (race condition)。譬如说，如果某个 socket 的可读事件很快发生了两次，那么就会出现两个线程同时读同一个 socket 的问题 (可以使用strand解决这个问题)。</li>
</ul>
</li>
<li><p>无锁的同步方式：</p>
<ul>
<li>Asio 提供了 io_context::strand：如果多个 event handler 通过同一个 strand 对象分发 (dispatch)，那么这些 event handler 就会保证顺序地执行。</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsioThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//返回当前系统支持的并发线程数</span></span><br><span class="line">    <span class="built_in">AsioThreadPool</span>(std::<span class="type">size_t</span> size = std::thread::<span class="built_in">hardware_concurrency</span>()) : </span><br><span class="line">        <span class="built_in">work_</span>(<span class="keyword">new</span> asio::io_context::<span class="built_in">work</span>(io_context_))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            threads_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]()&#123;</span><br><span class="line">                io_context_.<span class="built_in">run</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AsioThreadPool</span>(<span class="type">const</span> AsioThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    AsioThreadPool &amp;<span class="keyword">operator</span>=(<span class="type">const</span> AsioThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">asio::io_context&amp; <span class="title">getIOContext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> io_context_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        work_.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t : threads_)</span><br><span class="line">        &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    asio::io_context io_context_;</span><br><span class="line">    std::unique_ptr&lt;asio::io_context::work&gt; work_;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">AsioThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;    <span class="comment">// 开启 4 个线程</span></span><br><span class="line">    asio::steady_timer timer1&#123;pool.<span class="built_in">getIOContext</span>(), std::chrono::seconds&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    asio::steady_timer timer2&#123;pool.<span class="built_in">getIOContext</span>(), std::chrono::seconds&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    asio::io_context::strand strand&#123;pool.<span class="built_in">getIOContext</span>()&#125;;</span><br><span class="line"></span><br><span class="line">    timer<span class="number">1.</span><span class="built_in">async_wait</span>(strand.<span class="built_in">wrap</span>([&amp;value] (<span class="type">const</span> asio::error_code &amp;ec)</span><br><span class="line">                              &#123;</span><br><span class="line">                                  std::cout &lt;&lt; <span class="string">&quot;Hello, World! &quot;</span> &lt;&lt; value++ &lt;&lt; std::endl;</span><br><span class="line">                              &#125;));</span><br><span class="line">    timer<span class="number">2.</span><span class="built_in">async_wait</span>(strand.<span class="built_in">wrap</span>([&amp;value] (<span class="type">const</span> asio::error_code &amp;ec)</span><br><span class="line">                              &#123;</span><br><span class="line">                                  std::cout &lt;&lt; <span class="string">&quot;Hello, World! &quot;</span> &lt;&lt; value++ &lt;&lt; std::endl;</span><br><span class="line">                              &#125;));</span><br><span class="line">    pool.<span class="built_in">stop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="socket连接相关的函数"><a href="#socket连接相关的函数" class="headerlink" title="socket连接相关的函数"></a>socket连接相关的函数</h2><h3 id="socket-初始化"><a href="#socket-初始化" class="headerlink" title="socket 初始化"></a>socket 初始化</h3><ul>
<li>context 提供 I&#x2F;O 执行程序的执行上下文，默认情况下，套接字将使用该执行程序为在套接字上执行的任何异步操作分派处理程序<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asio::io_context io_context;</span><br><span class="line">asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="socket-open"><a href="#socket-open" class="headerlink" title="socket.open"></a>socket.open</h3><ul>
<li>open 此函数打开套接字，以便它将使用指定的协议。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asio::io_context io_context;</span><br><span class="line">asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">socket.<span class="built_in">open</span>(asio::ip::tcp::<span class="built_in">v4</span>());</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="socket-bind"><a href="#socket-bind" class="headerlink" title="socket.bind"></a>socket.bind</h3><ul>
<li>将套接字绑定到给定的本地端点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asio::error_code ec;</span><br><span class="line">socket.<span class="built_in">bind</span>(asio::ip::tcp::<span class="built_in">endpoint</span>(</span><br><span class="line">        asio::ip::tcp::<span class="built_in">v4</span>(), <span class="number">12345</span>), ec);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="socket-close"><a href="#socket-close" class="headerlink" title="socket.close"></a>socket.close</h3><ul>
<li>该函数用于关闭套接字。任何异步发送、接收或连接操作都将立即取消，并以 asio::error::operation_aborted 错误完成</li>
<li>asio::system_error 失败时抛出。 请注意，即使函数指示错误，底层描述符也会关闭。</li>
<li>对于与正常关闭已连接套接字相关的可移植行为，请在关闭套接字之前调用 shutdown()。</li>
<li>ec 设置以指示发生了什么错误（如果有）。请注意，即使函数指示错误，底层描述符也会关闭。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asio::error_code ec;</span><br><span class="line">socket.<span class="built_in">close</span>(ec);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="socket-connect"><a href="#socket-connect" class="headerlink" title="socket.connect"></a>socket.connect</h3><ul>
<li>此函数用于将套接字连接到指定的远程端点。 函数调用将阻塞，直到连接成功或发生错误</li>
<li>如果套接字尚未打开，它会自动打开。 如果连接失败，套接字自动打开，则套接字不会返回到关闭状态。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">asio::io_context io_context;</span><br><span class="line">asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(asio::ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">12345</span>)</span></span>;</span><br><span class="line">socket.<span class="built_in">connect</span>(endpoint, ec);</span><br><span class="line"><span class="keyword">if</span>(!ec)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;socket connect&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="socket-async-connect"><a href="#socket-async-connect" class="headerlink" title="socket.async_connect"></a>socket.async_connect</h3><ul>
<li>此函数用于将套接字异步连接到指定的远程端点。 函数调用总是立即返回</li>
<li>如果套接字尚未打开，它会自动打开。 如果连接失败，套接字自动打开，则套接字不会返回到关闭状态</li>
<li>无论异步操作是否立即完成，都不会从此函数中调用处理程序。 立即完成后，处理程序的调用将以等同于使用 asio::post() 的方式执行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connect_handler</span><span class="params">(<span class="type">const</span> asio::error_code&amp; ec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ec)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Connect success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(asio::ip::address::from_string(<span class="string">&quot;180.222.102.202&quot;</span>), <span class="number">80</span>)</span></span>;</span><br><span class="line">    socket.<span class="built_in">async_connect</span>(endpoint, connect_handler);</span><br><span class="line">    </span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="asio-connect"><a href="#asio-connect" class="headerlink" title="asio::connect"></a>asio::connect</h3><ul>
<li><p>connect 函数是一个组合操作，它通过按顺序尝试每个端点来建立套接字连接</p>
</li>
<li><p>此函数尝试将套接字连接到一系列端点之一。 它通过重复调用套接字的 connect 成员函数来完成此操作，对序列中的每个端点调用一次，直到成功建立连接</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::ip::<span class="function">tcp::resolver <span class="title">r</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::ip::tcp::<span class="function">resolver::query <span class="title">q</span><span class="params">(<span class="string">&quot;www.yahoo.com&quot;</span>, <span class="string">&quot;http&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::error_code ec;</span><br><span class="line">    asio::<span class="built_in">connect</span>(socket, r.<span class="built_in">resolve</span>(q), ec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以下连接条件函数对象可用于输出有关各个连接尝试的信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_connect_condition</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> asio::error_code&amp; ec, <span class="type">const</span> asio::ip::tcp::endpoint&amp; next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ec) std::cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::ip::<span class="function">tcp::resolver <span class="title">r</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::ip::tcp::<span class="function">resolver::query <span class="title">q</span><span class="params">(<span class="string">&quot;www.yahoo.com&quot;</span>, <span class="string">&quot;http&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::ip::tcp::endpoint e = asio::<span class="built_in">connect</span>(socket, r.<span class="built_in">resolve</span>(q), <span class="built_in">my_connect_condition</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Connected to: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//Trying: 180.222.102.201:80</span></span><br><span class="line"><span class="comment">//Connected to: 180.222.102.201:80</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>或者:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在每次连接尝试之前调用的函数对象。 函数对象的签名必须是：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_connect_condition</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//ec 参数包含最近连接操作的结果。 在第一次连接尝试之前，ec 总是设置为指示成功。 </span></span><br><span class="line">    <span class="comment">//next 参数是要尝试的下一个端点。 如果应尝试下一个端点，则函数对象应返回 true，如果应跳过，则返回 false。</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> asio::error_code&amp; ec, <span class="type">const</span> asio::ip::tcp::endpoint&amp; next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ec) std::cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::ip::<span class="function">tcp::resolver <span class="title">r</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::ip::tcp::<span class="function">resolver::query <span class="title">q</span><span class="params">(<span class="string">&quot;www.yahoo.com&quot;</span>, <span class="string">&quot;http&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    asio::ip::tcp::resolver::results_type e = r.<span class="built_in">resolve</span>(q);</span><br><span class="line">    asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::error_code ec;</span><br><span class="line">    asio::ip::tcp::resolver::results_type::iterator i = </span><br><span class="line">        asio::<span class="built_in">connect</span>(socket, e.<span class="built_in">begin</span>(), e.<span class="built_in">end</span>(), <span class="built_in">my_connect_condition</span>(), ec);</span><br><span class="line">    <span class="keyword">if</span>(ec)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//发生错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Connected to: &quot;</span> &lt;&lt; i-&gt;<span class="built_in">endpoint</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="asio-async-connect"><a href="#asio-async-connect" class="headerlink" title="asio::async_connect"></a>asio::async_connect</h3><ul>
<li>async_connect 函数是一个组合的异步操作，它通过按顺序尝试每个端点来建立套接字连接。</li>
<li>此函数尝试将套接字连接到一系列端点之一。 它通过重复调用套接字的 async_connect 成员函数来完成此操作，对序列中的每个端点调用一次，直到成功建立连接<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//socket: 要连接的套接字。 如果套接字已经打开，它将被关闭。</span></span><br><span class="line"><span class="comment">//endpoints: 一系列端点。</span></span><br><span class="line"><span class="comment">//connect_handler: 连接操作完成时要调用的处理程序。</span></span><br><span class="line">asio::<span class="built_in">async_connect</span>(socket, results, connect_handler);</span><br></pre></td></tr></table></figure></li>
<li>示例:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">client</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">client</span>(asio::io_context&amp; io_context) : <span class="built_in">resolver_</span>(io_context), <span class="built_in">socket_</span>(io_context)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Connect</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_read_header</span><span class="params">(<span class="type">const</span> asio::error_code&amp; ec, asio::ip::tcp::resolver::results_type results)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect_handler</span><span class="params">(<span class="type">const</span> asio::error_code&amp; ec, <span class="type">const</span> asio::ip::tcp::endpoint&amp; endpoint)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    asio::ip::tcp::resolver resolver_;</span><br><span class="line">    asio::ip::tcp::socket socket_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client::Connect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// resolver_.async_resolve(&quot;www.yahoo.com&quot;, &quot;http&quot;, std::bind(&amp;client::handle_read_header, this,</span></span><br><span class="line">    <span class="comment">//                               std::placeholders::_1,</span></span><br><span class="line">    <span class="comment">//                               std::placeholders::_2));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不传入this Error: error C4573: “client::socket_”的用法要求编译器捕获“this”，但当前默认捕获模式不允许使用“this”</span></span><br><span class="line">    resolver_.<span class="built_in">async_resolve</span>(<span class="string">&quot;www.yahoo.com&quot;</span>, <span class="string">&quot;http&quot;</span>, [<span class="keyword">this</span>](<span class="type">const</span> asio::error_code&amp; ec, asio::ip::tcp::resolver::results_type results)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ec)</span><br><span class="line">        &#123;</span><br><span class="line">            asio::<span class="built_in">async_connect</span>(socket_, results, [](<span class="type">const</span> asio::error_code&amp; ec, <span class="type">const</span> asio::ip::tcp::endpoint&amp; endpoint)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ec)</span><br><span class="line">                &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client::handle_read_header</span><span class="params">(<span class="type">const</span> asio::error_code&amp; ec, asio::ip::tcp::resolver::results_type results)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ec)</span><br><span class="line">    &#123;</span><br><span class="line">        asio::<span class="built_in">async_connect</span>(socket_, results, std::<span class="built_in">bind</span>(&amp;client::connect_handler, <span class="keyword">this</span>,</span><br><span class="line">                                  std::placeholders::_1,</span><br><span class="line">                                  std::placeholders::_2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client::connect_handler</span><span class="params">(<span class="type">const</span> asio::error_code&amp; ec, <span class="type">const</span> asio::ip::tcp::endpoint&amp; endpoint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ec)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    <span class="function">client <span class="title">c</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    c.<span class="built_in">Connect</span>();</span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="asio-ip-tcp-endpoint"><a href="#asio-ip-tcp-endpoint" class="headerlink" title="asio::ip::tcp::endpoint"></a>asio::ip::tcp::endpoint</h3><ul>
<li><p>端点是使用某个端口连接到一个地址</p>
</li>
<li><p>创建方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(1) Default constructor</span></span><br><span class="line"><span class="built_in">basic_endpoint</span>() ASIO_NOEXCEPT : <span class="built_in">impl_</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2) 使用按主机字节顺序指定的端口号构造端点。IP地址将是任意地址（即INADDR_any或in6addr_any）。</span></span><br><span class="line"><span class="comment">//    此构造函数通常用于接受新连接。</span></span><br><span class="line"><span class="built_in">basic_endpoint</span>(<span class="type">const</span> InternetProtocol&amp; internet_protocol, <span class="type">unsigned</span> <span class="type">short</span> port_num) ASIO_NOEXCEPT</span><br><span class="line">: <span class="built_in">impl_</span>(internet_protocol.<span class="built_in">family</span>(), port_num) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3) 使用端口号和IP地址构造端点。此构造函数可用于接受特定接口上的连接或建立到远程端点的连接。</span></span><br><span class="line"><span class="built_in">basic_endpoint</span>(<span class="type">const</span> asio::ip::address&amp; addr, <span class="type">unsigned</span> <span class="type">short</span> port_num) ASIO_NOEXCEPT : <span class="built_in">impl_</span>(addr, port_num)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::tcp::v4(), <span class="number">1234</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想连接一台主机,例如 “<a target="_blank" rel="noopener" href="http://www.yahoo.com/">http://www.yahoo.com</a>“</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::ip::<span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::ip::tcp::<span class="function">resolver::query <span class="title">query</span><span class="params">(<span class="string">&quot;www.yahoo.com&quot;</span>, <span class="string">&quot;80&quot;</span>)</span></span>;</span><br><span class="line">    asio::ip::tcp::resolver::iterator iter = resolver.<span class="built_in">resolve</span>(query);</span><br><span class="line">    asio::ip::tcp::endpoint ep = *iter;</span><br><span class="line">    std::cout &lt;&lt; ep.<span class="built_in">address</span>().<span class="built_in">to_string</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output: 180.222.102.202</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="asio-ip-tcp-acceptor"><a href="#asio-ip-tcp-acceptor" class="headerlink" title="asio::ip::tcp::acceptor"></a>asio::ip::tcp::acceptor</h3><ul>
<li><p>如果底层操作系统调用也是线程安全的，则同步接受操作是线程安全的。 这意味着允许对单个套接字对象执行同步接受操作的并发调用。 其他同步操作，如打开或关闭，不是线程安全的</p>
</li>
<li><p>打开一个启用了 SO_REUSEADDR 选项的套接字接收器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(asio::ip::tcp::v4(), <span class="number">8888</span>)</span></span>;</span><br><span class="line">    <span class="comment">//此函数打开套接字接受器，以便它使用指定的协议。</span></span><br><span class="line">    acceptor.<span class="built_in">open</span>(endpoint.<span class="built_in">protocol</span>());</span><br><span class="line">    acceptor.<span class="built_in">set_option</span>(asio::ip::tcp::acceptor::<span class="built_in">reuse_address</span>(<span class="literal">true</span>));</span><br><span class="line">    <span class="comment">//将接受器绑定到给定的本地端点。</span></span><br><span class="line">    acceptor.<span class="built_in">bind</span>(endpoint);</span><br><span class="line">    asio::error_code ec;</span><br><span class="line">    <span class="comment">//max_listen_connections: 待处理连接队列的最大长度。</span></span><br><span class="line">    <span class="comment">//此函数将套接字接受器置于可以接受新连接的状态。</span></span><br><span class="line">    acceptor.<span class="built_in">listen</span>(asio::socket_base::max_listen_connections, ec);</span><br><span class="line">    <span class="keyword">if</span>(!ec)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;listen success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>asio::ip::tcp::acceptor::open()</p>
<ul>
<li>此函数打开套接字接受器，以便它使用指定的协议</li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::set_option()</p>
<ul>
<li>此函数用于在接受器上设置选项。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">acceptor.<span class="built_in">open</span>(endpoint.<span class="built_in">protocol</span>());</span><br><span class="line">acceptor.<span class="built_in">set_option</span>(asio::ip::tcp::acceptor::<span class="built_in">reuse_address</span>(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::get_option()</p>
<ul>
<li>此函数用于获取接受器上选项的当前值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::tcp::acceptor::reuse_address option;</span><br><span class="line">acceptor.<span class="built_in">get_option</span>(option);</span><br><span class="line"><span class="type">bool</span> is_set = option.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::bind()</p>
<ul>
<li>将接受器绑定到给定的本地端点。</li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::listen()</p>
<ul>
<li>max_listen_connections: 待处理连接队列的最大长度</li>
<li>此函数将套接字接受器置于可以接受新连接的状态</li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::close()</p>
<ul>
<li>此函数用于关闭接受器。 任何异步接受操作将立即取消<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asio::error_code ec;</span><br><span class="line">acceptor.<span class="built_in">close</span>(ec);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::cacel()</p>
<ul>
<li>此函数会导致所有未完成的异步连接、发送和接收操作立即完成，并且取消操作的处理程序将传递 asio::error::operation_aborted 错误</li>
</ul>
</li>
<li><p>asio::ip::tcp::socket::io_control()</p>
<ul>
<li>该函数用于在接收器上执行 IO 控制命令。</li>
<li>例如：获取准备读取的字节数：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::tcp::<span class="function">acceptor::non_blocking_io <span class="title">command</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">socket.<span class="built_in">io_control</span>(command);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::local_endpoint()</p>
<ul>
<li>此函数用于获取接受器的本地绑定端点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::tcp::endpoint endpoint = acceptor.<span class="built_in">local_endpoint</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::wait()</p>
<ul>
<li>此函数用于执行阻塞等待，以等待接受器进入准备好读、写或错误条件状态。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acceptor.<span class="built_in">wait</span>(asio::ip::tcp::acceptor::wait_read);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::async_wait()</p>
<ul>
<li>此函数用于执行异步等待接受器进入准备好读取、写入或错误条件状态。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acceptor.<span class="built_in">async_wait</span>(</span><br><span class="line">    asio::ip::tcp::acceptor::wait_read,</span><br><span class="line">    wait_handler);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::accept()</p>
<ul>
<li>此函数用于接受从对等点到给定套接字的新连接。 函数调用将阻塞，直到成功接受新连接或发生错误。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asio::io_context io_context;</span><br><span class="line">asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">accept</span>(socket);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::async_accept()</p>
<ul>
<li>此函数用于异步接受到套接字的新连接。 函数调用总是立即返回。</li>
<li>接受新连接的套接字。 对等对象的所有权由调用者保留，调用者必须保证在调用处理程序之前它是有效的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asio::io_context io_context;</span><br><span class="line">asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">async_accept</span>(socket, accept_handle);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::socket::async_read_some()</p>
<ul>
<li>开始异步读取。</li>
<li>此函数用于从流套接字中异步读取数据。</li>
<li>函数调用总是立即返回。</li>
<li>buffers： 一个或多个缓冲区，数据将被读入其中。</li>
<li>尽管可以根据需要复制缓冲区对象，但底层内存块的所有权由调用者保留，调用者必须保证它们在调用处理程序之前保持有效。</li>
<li>handler： 读取操作完成时要调用的处理程序。将根据需要制作处理程序的副本。的函数签名</li>
<li>无论异步操作是否立即完成，都不会从此函数中调用处理程序。立即完成后，处理程序的调用将以等同于使用 asio::post() 的方式执行。</li>
<li>读取操作可能无法读取所有请求的字节数。如果需要确保在异步操作完成之前读取请求的数据量，请考虑使用 async_read 函数。</li>
<li>要读入单个数据缓冲区，请使用缓冲区函数，如下所示：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="built_in">async_read_some</span>(asio::<span class="built_in">buffer</span>(data, size), handler);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::socket::async_read()</p>
<ul>
<li>async_read 函数是一个组合的异步操作，它在完成之前从流中读取一定数量的数据。</li>
<li>启动异步操作以从流中读取一定数量的数据。</li>
<li>此函数用于从流中异步读取一定数量字节的数据。函数调用总是立即返回。异步操作将继续，直到以下条件之一为真：</li>
<li>此操作是根据对流的 async_read_some 函数的零次或多次调用来实现的，称为组合操作。程序必须确保流不执行其他读取操作（例如 async_read、流的 async_read_some 函数或任何其他执行读取的组合操作），直到此操作完成。</li>
<li>s： 要从中读取数据的流。该类型必须支持 AsyncReadStream 概念。</li>
<li>buffers： 一个或多个缓冲区，数据将被读入其中。缓冲区大小的总和表示要从流中读取的最大字节数。尽管可以根据需要复制缓冲区对象，但底层内存块的所有权由调用者保留，调用者必须保证它们在调用处理程序之前保持有效。</li>
<li>handler： 读取操作完成时要调用的处理程序。将根据需要制作处理程序的副本。的函数签名</li>
<li>无论异步操作是否立即完成，都不会从此函数中调用处理程序。立即完成后，处理程序的调用将以等同于使用 asio::post() 的方式执行。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::<span class="built_in">async_read</span>(s, asio::<span class="built_in">buffer</span>(data, size), handler);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>async_read_some 和 async_read 的区别</p>
<ul>
<li>asio::async_read 通常用户读取指定长度的数据，读完或出错才返回</li>
<li>socket.async_read_some读取到数据或出错就返回，不一定读完了整个包</li>
</ul>
</li>
<li><p>asio::ip::tcp::socket::async_write_some()</p>
<ul>
<li>此函数用于将数据异步写入流套接字。函数调用总是立即返回。</li>
<li>buffers 一个或多个要写入套接字的数据缓冲区。</li>
<li>尽管可以根据需要复制缓冲区对象，但底层内存块的所有权由调用者保留，调用者必须保证它们在调用处理程序之前保持有效。</li>
<li>handler 写入操作完成时要调用的处理程序。 将根据需要制作处理程序的副本。</li>
<li>无论异步操作是否立即完成，都不会从此函数中调用处理程序。 立即完成后，处理程序的调用将以等同于使用 asio::post() 的方式执行。</li>
<li>写操作可能不会将所有数据传输到对等方。</li>
<li>如果需要确保在异步操作完成之前写入所有数据，请考虑使用 async_write 函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="built_in">async_write_some</span>(asio::<span class="built_in">buffer</span>(data, size), handler);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::async_write()</p>
<ul>
<li>此函数用于将一定数量的字节数据异步写入流。函数调用总是立即返回。异步操作将继续，直到以下条件之一为真：</li>
<li>提供的缓冲区中的所有数据都已写入。也就是说，传输的字节数等于缓冲区大小的总和。</li>
<li>此操作是根据对流的 async_write_some 函数的零次或多次调用来实现的，称为组合操作。程序必须确保流不执行其他写入操作（例如 async_write、流的 async_write_some 函数或任何其他执行写入的组合操作），直到此操作完成。</li>
<li>s 要写入数据的流。该类型必须支持 AsyncWriteStream 概念。</li>
<li>buffers 一个或多个包含要写入的数据的缓冲区。</li>
<li>尽管可以根据需要复制缓冲区对象，但底层内存块的所有权由调用者保留，调用者必须保证它们在调用处理程序之前保持有效。</li>
<li>param handler 写入操作完成时要调用的处理程序。</li>
<li>将根据需要制作处理程序的副本。</li>
<li>无论异步操作是否立即完成，都不会从此函数中调用处理程序。立即完成后，处理程序的调用将以等同于使用 asio::post() 的方式执行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::<span class="built_in">async_write</span>(s, asio::<span class="built_in">buffer</span>(data, size), handler);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><ul>
<li>asio在处理I&#x2F;O操作时支持两种类型的buffer<ul>
<li>asio::buffer</li>
<li>asio::streambuffer</li>
</ul>
</li>
</ul>
<h3 id="asio-buffer"><a href="#asio-buffer" class="headerlink" title="asio::buffer"></a>asio::buffer</h3><ul>
<li>asio::buffer 函数用于创建一个缓冲区对象来表示原始内存、POD 元素数组、POD 元素向量或 std::string</li>
<li>缓冲区对象将连续的内存区域表示为由指针和字节大小组成的二元组。{void*, size_t} 形式的元组指定内存的可变（可修改）区域。 类似地，{const void*, size_t} 形式的元组指定一个常量（不可修改的）内存区域。 这两种形式分别对应类mutable_buffer和const_buffer。 为了反映 C++ 的转换规则，mutable_buffer 可以隐式转换为 const_buffer，并且不允许进行相反的转换<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock.<span class="built_in">send</span>(asio::<span class="built_in">buffer</span>(data, size));</span><br></pre></td></tr></table></figure></li>
<li>在上面的例子中，asio::buffer 的返回值满足了ConstBufferSequence 概念的要求，可以直接传递给socket 的write 函数。 为可修改内存创建的缓冲区也符合 MutableBufferSequence 概念的要求</li>
<li>可以从 POD 元素的内置数组、std::vector、std::array 或 boost::array 创建一个单独的缓冲区。 这有助于通过自动确定缓冲区的大小来防止缓冲区溢出<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> d1[<span class="number">128</span>];</span><br><span class="line"><span class="type">size_t</span> bytes_transferred = sock.<span class="built_in">receive</span>(asio::<span class="built_in">buffer</span>(d1));</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">128</span>)</span></span>;</span><br><span class="line">bytes_transferred = sock.<span class="built_in">receive</span>(asio::<span class="built_in">buffer</span>(d2));</span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="type">char</span>, 128&gt; d3;</span><br><span class="line">bytes_transferred = sock.<span class="built_in">receive</span>(asio::<span class="built_in">buffer</span>(d3));</span><br></pre></td></tr></table></figure></li>
<li>在上述所有三种情况下，创建的缓冲区恰好为 128 字节长。 请注意，在创建或使用缓冲区时，向量永远不会自动调整大小。 缓冲区大小是使用向量的 size() 成员函数确定的，而不是其容量</li>
<li>可以使用 data() 和 size() 成员函数访问缓冲区的内容：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过 std::string 构造 asio::buffer</span></span><br><span class="line">    std::string str = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    asio::const_buffer const_buffer = asio::<span class="built_in">buffer</span>(str.<span class="built_in">data</span>(), str.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    std::<span class="type">size_t</span> s1 = const_buffer.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>* p1 = const_buffer.<span class="built_in">data</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot; p1: &quot;</span> &lt;&lt; p1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//output: s1: 4 p1: 000000D5A6B0F510</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过std::array构造asio::buffer</span></span><br><span class="line">    std::array&lt;<span class="type">char</span>, 5&gt; arrData = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    asio::mutable_buffer mutable_buffer = asio::<span class="built_in">buffer</span>(arrData.<span class="built_in">data</span>(), arrData.<span class="built_in">size</span>());</span><br><span class="line">    std::<span class="type">size_t</span> s2 = mutable_buffer.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p2 = <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>*&gt;(mutable_buffer.<span class="built_in">data</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&quot; p2: &quot;</span> &lt;&lt; p2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//output: s2: 5 p2: test</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过std::vector构造asio::buffer</span></span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; vecData = &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    asio::mutable_buffer v_buffer = asio::<span class="built_in">buffer</span>(vecData.<span class="built_in">data</span>(), vecData.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    std::<span class="type">size_t</span> s3 = asio::<span class="built_in">buffer_size</span>(v_buffer);</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>* p3 = asio::<span class="built_in">buffer_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(v_buffer);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s3: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="string">&quot; p3: &quot;</span> &lt;&lt; p3 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//output: s3: 5 p3: 000001F890A53410</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="asio-streambuf"><a href="#asio-streambuf" class="headerlink" title="asio::streambuf"></a>asio::streambuf</h3><ul>
<li>基于 std::streambuf 的可自动调整大小的缓冲区类</li>
<li>basic_streambuf 类派生自 std::streambuf 以将 streambuf 的输入和输出序列与一个或多个字符数组相关联。 这些字符数组在 basic_streambuf 对象内部，但提供了对数组元素的直接访问，以允许它们在 I&#x2F;O 操作中有效使用。 写入 basic_streambuf 对象的输出序列的字符将附加到同一对象的输入序列</li>
</ul>
<h3 id="asio-buffer-获取缓冲区大小并防止缓冲区溢出"><a href="#asio-buffer-获取缓冲区大小并防止缓冲区溢出" class="headerlink" title="asio::buffer 获取缓冲区大小并防止缓冲区溢出"></a>asio::buffer 获取缓冲区大小并防止缓冲区溢出</h3><ul>
<li><p>Asio 使用 Buffer 类来表示缓冲区。这些类提供抽象并保护 Asio 操作免受缓冲区溢出。尽管将结果asio::buffer()传递给操作，但不会传输原数据，例如缓冲区的大小或其基础类型。此外，这些缓冲区不拥有内存，因此应用程序有责任确保底层内存在缓冲区抽象的整个生命周期内保持有效</p>
</li>
<li><p>该 asio::buffer() 函数提供了一种创建缓冲区类的便捷方法，其中缓冲区的大小是从可能的类型中推导出来的。当 Asio 能够推导出缓冲区长度时，Asio 操作在使用结果缓冲区类型时不会引发缓冲区溢出。但是，如果应用程序代码将缓冲区的大小指定为 asio::buffer()，则应用程序有责任确保该大小不大于底层内存</p>
</li>
<li><p>读取数据时，需要缓冲区。如果 Asio 不传输大小，那么根本问题就变成了如何知道要分配多少内存。这个问题有几个解决方案</p>
<ul>
<li>通过查询套接字有多少数据可用 socket::available()，然后相应地分配缓冲区<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">data</span><span class="params">(socket_.available())</span></span>;</span><br><span class="line">asio::<span class="built_in">read</span>(socket_, asio::<span class="built_in">buffer</span>(data));</span><br></pre></td></tr></table></figure></li>
<li>使用Asio可用内存中增长的类，如 asio::streambuf。一些操作，比如asio::read()接受streambuf对象作为它们的缓冲区，并将根据操作的需要分配内存。但是应提供完成条件；否则操作将继续，直到缓冲区已满<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asio::streambuf data; </span><br><span class="line">asio::<span class="built_in">read</span>(socket_, data, asio::<span class="built_in">transfer_at_least</span>(socket_.<span class="built_in">avaliable</span>()));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在固定大小的协议中，数据生产者和消费者都使用相同大小的消息。由于读者知道消息的大小，读者可以预先分配一个缓冲区</p>
</li>
<li><p>在可变长度协议中，消息通常分为两部分：头部和主体。标头通常是固定大小的，并且可以包含各种元信息，例如正文的长度。这允许读取器将标头读入固定大小的缓冲区，提取正文长度，为正文分配缓冲区，然后读取正文。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read fixed header.</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">data</span><span class="params">(fixed_header_size)</span></span>;</span><br><span class="line">boost::asio::<span class="built_in">read</span>(socket_, boost::asio::<span class="built_in">buffer</span>(data));</span><br><span class="line"></span><br><span class="line"><span class="function">protocol::header <span class="title">header</span><span class="params">(data)</span></span>;</span><br><span class="line"><span class="built_in">network_to_local</span>(header); <span class="comment">// Handle endianess.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read body.</span></span><br><span class="line">data.<span class="built_in">resize</span>(header.<span class="built_in">body_length</span>());</span><br><span class="line">boost::asio::<span class="built_in">read</span>(socket_, boost::asio::<span class="built_in">buffer</span>(data));  </span><br><span class="line"></span><br><span class="line"><span class="function">protocol::body <span class="title">body</span><span class="params">(data)</span></span>;</span><br><span class="line"><span class="built_in">network_to_local</span>(body); <span class="comment">// Handle endianess.</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="mutable-buffer"><a href="#mutable-buffer" class="headerlink" title="mutable_buffer"></a>mutable_buffer</h3><ul>
<li>mutable_buffer 类提供了可以修改的缓冲区的安全表示。 它不拥有底层数据，因此复制或分配的成本很低</li>
<li>示例:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span> <span class="comment">// std::array</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::bind</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout, std::endl</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">noop</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> protocol &#123;</span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">  header_size = <span class="built_in">sizeof</span>(std::<span class="type">size_t</span>)</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace protocol</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">build_header</span><span class="params">(<span class="type">const</span> std::string&amp; body)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buffer</span><span class="params">(protocol::header_size)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> body_size = body.<span class="built_in">size</span>();</span><br><span class="line">  std::<span class="built_in">memcpy</span>(&amp;buffer[<span class="number">0</span>], &amp;body_size, <span class="keyword">sizeof</span> body_size);</span><br><span class="line">  <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">parse_header</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt;&amp; buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> std::<span class="type">size_t</span>*&gt;(&amp;buffer[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> asio::ip::tcp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create all I/O objects.</span></span><br><span class="line">  asio::io_context io_context;</span><br><span class="line">  <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, tcp::endpoint(asio::ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">1234</span>))</span></span>;</span><br><span class="line">  <span class="function">tcp::socket <span class="title">socket1</span><span class="params">(io_context)</span></span>;</span><br><span class="line">  <span class="function">tcp::socket <span class="title">socket2</span><span class="params">(io_context)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Connect the sockets.</span></span><br><span class="line">  acceptor.<span class="built_in">async_accept</span>(socket1, std::<span class="built_in">bind</span>(&amp;noop, <span class="string">&quot;accept&quot;</span>));</span><br><span class="line">  socket<span class="number">2.</span><span class="built_in">async_connect</span>(acceptor.<span class="built_in">local_endpoint</span>(), std::<span class="built_in">bind</span>(&amp;noop, <span class="string">&quot;connect&quot;</span>));</span><br><span class="line">  </span><br><span class="line">  io_context.<span class="built_in">run</span>();</span><br><span class="line">  io_context.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Write a message from socket1 to socket2.</span></span><br><span class="line">  std::string test_message = <span class="string">&quot;this is a test message&quot;</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> header = <span class="built_in">build_header</span>(test_message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gather header and body into a single buffer.</span></span><br><span class="line">    std::array&lt;asio::const_buffer, 2&gt; buffers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write header and body to socket.</span></span><br><span class="line">    std::cout &lt;&lt; socket<span class="number">1.</span><span class="built_in">is_open</span>() &lt;&lt; std::endl;</span><br><span class="line">    asio::<span class="built_in">write</span>(socket1, buffers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read from socket2.</span></span><br><span class="line">  &#123;  </span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read header.</span></span><br><span class="line">    buffer.<span class="built_in">resize</span>(protocol::header_size);</span><br><span class="line">    asio::<span class="built_in">read</span>(socket2, asio::<span class="built_in">buffer</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extract body size from header, resize buffer, then read body.</span></span><br><span class="line">    <span class="keyword">auto</span> body_size = <span class="built_in">parse_header</span>(buffer);</span><br><span class="line">    buffer.<span class="built_in">resize</span>(body_size);</span><br><span class="line">    asio::<span class="built_in">read</span>(socket2, asio::<span class="built_in">buffer</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify body was read.</span></span><br><span class="line">    <span class="built_in">assert</span>(std::<span class="built_in">equal</span>(<span class="built_in">begin</span>(buffer), <span class="built_in">end</span>(buffer), </span><br><span class="line">                      <span class="built_in">begin</span>(test_message)));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;received: \n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  header: &quot;</span> &lt;&lt; body_size &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  body: &quot;</span>;</span><br><span class="line">    std::cout.<span class="built_in">write</span>(&amp;buffer[<span class="number">0</span>], buffer.<span class="built_in">size</span>());</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/asio/2024-05-22-1_2_asio_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/asio/2024-05-22-1_2_asio_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">1_2_asio_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>BOOST.Asio 网络服务相关模块的笔记</li>
</ul>
<h2 id="Boost-Asio-库-详解"><a href="#Boost-Asio-库-详解" class="headerlink" title="Boost.Asio 库 详解"></a>Boost.Asio 库 详解</h2><h3 id="Boost-Asio-库详解"><a href="#Boost-Asio-库详解" class="headerlink" title="Boost.Asio 库详解"></a><strong>Boost.Asio 库详解</strong></h3><p><strong>Boost.Asio</strong> 是一个功能强大的 C++ 网络和并发编程库，属于 Boost 库的一部分。它提供了跨平台的异步 I&#x2F;O 支持，能够处理网络通信、定时器和文件 I&#x2F;O 等任务。以下是对 Boost.Asio 的详细解析：</p>
<hr>
<h3 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a><strong>1. 核心概念</strong></h3><h4 id="I-O-服务-io-context"><a href="#I-O-服务-io-context" class="headerlink" title="I&#x2F;O 服务 (io_context)"></a><strong>I&#x2F;O 服务 (<code>io_context</code>)</strong></h4><ul>
<li><strong>核心机制</strong>：<code>boost::asio::io_context</code> 是 Asio 的核心，用于调度所有异步操作。<br>它管理 I&#x2F;O 操作队列并为异步事件提供执行环境。</li>
<li><strong>功能</strong>：<ul>
<li>注册 I&#x2F;O 操作。</li>
<li>调度任务。</li>
<li>运行事件循环。</li>
</ul>
</li>
</ul>
<h4 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a><strong>工作线程</strong></h4><ul>
<li>多个线程可以同时调用 <code>io_context.run()</code> 来处理任务队列，实现多线程并发。</li>
</ul>
<h4 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a><strong>异步操作</strong></h4><ul>
<li>Boost.Asio 强调异步操作，以避免阻塞。</li>
<li>使用回调函数或协程处理完成的任务。</li>
</ul>
<h4 id="Handlers-和-Executors"><a href="#Handlers-和-Executors" class="headerlink" title="Handlers 和 Executors"></a><strong>Handlers 和 Executors</strong></h4><ul>
<li><strong>Handlers</strong>：异步操作完成后调用的回调函数。</li>
<li><strong>Executors</strong>：控制任务在哪个上下文中执行（单线程、多线程等）。</li>
</ul>
<hr>
<h3 id="2-常见功能模块"><a href="#2-常见功能模块" class="headerlink" title="2. 常见功能模块"></a><strong>2. 常见功能模块</strong></h3><h4 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a><strong>网络操作</strong></h4><p>Boost.Asio 提供了对常见网络协议（TCP、UDP）的支持。</p>
<h5 id="TCP-通信"><a href="#TCP-通信" class="headerlink" title="TCP 通信"></a>TCP 通信</h5><ol>
<li><p><strong>TCP Server 示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个监听器，绑定到 127.0.0.1:1234</span></span><br><span class="line">    <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, tcp::endpoint(tcp::v4(), <span class="number">1234</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待客户端连接</span></span><br><span class="line">    <span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    acceptor.<span class="built_in">accept</span>(socket);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送欢迎消息</span></span><br><span class="line">    std::string message = <span class="string">&quot;Hello from server!&quot;</span>;</span><br><span class="line">    boost::asio::<span class="built_in">write</span>(socket, boost::asio::<span class="built_in">buffer</span>(message));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>TCP Client 示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 TCP 连接到 127.0.0.1:1234</span></span><br><span class="line">    <span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> endpoints = resolver.<span class="built_in">resolve</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;1234&quot;</span>);</span><br><span class="line">    <span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    boost::asio::<span class="built_in">connect</span>(socket, endpoints);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">size_t</span> length = socket.<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(buffer));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Message from server: &quot;</span> &lt;&lt; std::<span class="built_in">string</span>(buffer, length) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="UDP-通信"><a href="#UDP-通信" class="headerlink" title="UDP 通信"></a>UDP 通信</h5><ol>
<li><p><strong>UDP Server 示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::asio::ip::udp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="function">udp::socket <span class="title">socket</span><span class="params">(io_context, udp::endpoint(udp::v4(), <span class="number">1234</span>))</span></span>;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">1024</span>];</span><br><span class="line">    udp::endpoint sender_endpoint;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收数据</span></span><br><span class="line">    <span class="type">size_t</span> length = socket.<span class="built_in">receive_from</span>(boost::asio::<span class="built_in">buffer</span>(data), sender_endpoint);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Received: &quot;</span> &lt;&lt; std::<span class="built_in">string</span>(data, length) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送响应</span></span><br><span class="line">    std::string response = <span class="string">&quot;Hello from server!&quot;</span>;</span><br><span class="line">    socket.<span class="built_in">send_to</span>(boost::asio::<span class="built_in">buffer</span>(response), sender_endpoint);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>UDP Client 示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::asio::ip::udp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="function">udp::resolver <span class="title">resolver</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> endpoints = resolver.<span class="built_in">resolve</span>(udp::<span class="built_in">v4</span>(), <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;1234&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">udp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    socket.<span class="built_in">open</span>(udp::<span class="built_in">v4</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    std::string message = <span class="string">&quot;Hello from client!&quot;</span>;</span><br><span class="line">    socket.<span class="built_in">send_to</span>(boost::asio::<span class="built_in">buffer</span>(message), *endpoints.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收响应</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    udp::endpoint server_endpoint;</span><br><span class="line">    <span class="type">size_t</span> length = socket.<span class="built_in">receive_from</span>(boost::asio::<span class="built_in">buffer</span>(buffer), server_endpoint);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Response from server: &quot;</span> &lt;&lt; std::<span class="built_in">string</span>(buffer, length) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h4><p>Boost.Asio 提供了基于时间的功能，例如超时处理或定时任务。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Timer expired!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建定时器，设置 5 秒超时</span></span><br><span class="line">    boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(io_context, boost::asio::chrono::seconds(<span class="number">5</span>))</span></span>;</span><br><span class="line">    timer.<span class="built_in">async_wait</span>(&amp;print);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动事件循环</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-同步与异步模式"><a href="#3-同步与异步模式" class="headerlink" title="3. 同步与异步模式"></a><strong>3. 同步与异步模式</strong></h3><h4 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h4><ul>
<li>直接调用函数（如 <code>boost::asio::read()</code>），操作完成后返回。</li>
<li>简单易用，但可能导致线程阻塞。</li>
</ul>
<h4 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h4><ul>
<li>通过 <code>async_*</code> 系列函数注册回调函数（如 <code>boost::asio::async_read()</code>）。</li>
<li>回调函数在操作完成后被触发。</li>
<li>非阻塞，更适合高性能和并发需求。</li>
</ul>
<hr>
<h3 id="4-常见特性"><a href="#4-常见特性" class="headerlink" title="4. 常见特性"></a><strong>4. 常见特性</strong></h3><h4 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a><strong>Error Handling</strong></h4><ul>
<li>使用 <code>boost::system::error_code</code> 对象捕获错误。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boost::system::error_code ec;</span><br><span class="line">boost::asio::<span class="built_in">write</span>(socket, boost::asio::<span class="built_in">buffer</span>(data), ec);</span><br><span class="line"><span class="keyword">if</span> (ec) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a><strong>多线程支持</strong></h4><ul>
<li>多线程可通过共享一个 <code>io_context</code> 对象实现并发任务调度。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;io_context]() &#123; io_context.run(); &#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;io_context]() &#123; io_context.run(); &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">t<span class="number">2.</span><span class="built_in">join</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="5-Boost-Asio-的优点"><a href="#5-Boost-Asio-的优点" class="headerlink" title="5. Boost.Asio 的优点"></a><strong>5. Boost.Asio 的优点</strong></h3><ol>
<li><strong>跨平台</strong>：支持多种操作系统和编译器。</li>
<li><strong>高性能</strong>：高效的异步 I&#x2F;O 模型。</li>
<li><strong>易于扩展</strong>：支持自定义 I&#x2F;O 对象和扩展功能。</li>
<li><strong>与标准库兼容</strong>：可以结合 <code>std::future</code> 和 C++20 协程使用。</li>
</ol>
<hr>
<h3 id="6-Boost-Asio-与-C-标准库"><a href="#6-Boost-Asio-与-C-标准库" class="headerlink" title="6. Boost.Asio 与 C++ 标准库"></a><strong>6. Boost.Asio 与 C++ 标准库</strong></h3><p>Boost.Asio 的一些功能已被纳入 C++ 标准库，如 C++11 的 <code>std::thread</code> 和 C++20 的网络库（<code>&lt;experimental/net&gt;</code>）。如果项目需要未来的标准兼容性，可以考虑迁移到标准库的实现。</p>
<h2 id="BOOST-Asio模块-是什么-详解"><a href="#BOOST-Asio模块-是什么-详解" class="headerlink" title="BOOST Asio模块 是什么 详解"></a>BOOST Asio模块 是什么 详解</h2><p>Boost.Asio是Boost库中的一个模块，提供了跨平台的异步I&#x2F;O和网络编程功能。它被设计用于简化异步编程、网络编程和低级I&#x2F;O操作，使开发者能够更轻松地创建高性能的网络应用程序。</p>
<p>主要特点和用途包括：</p>
<ol>
<li><p><strong>异步I&#x2F;O操作支持</strong>：Boost.Asio提供了异步I&#x2F;O操作的框架，允许开发者执行非阻塞的I&#x2F;O操作，以便同时处理多个操作，提高程序的并发性能。</p>
</li>
<li><p><strong>跨平台性</strong>：它可以在多种操作系统上运行，包括Windows、Linux、macOS等，提供了对不同平台的统一接口，简化了跨平台开发。</p>
</li>
<li><p><strong>网络编程</strong>：Boost.Asio支持TCP、UDP、SSL等网络协议，允许开发者轻松地创建网络应用程序，例如服务器、客户端和中间件。</p>
</li>
<li><p><strong>IO对象和Handler</strong>：使用Boost.Asio时，I&#x2F;O操作被封装在I&#x2F;O对象中，通过异步操作和回调函数（handler）来处理操作完成的通知。</p>
</li>
<li><p><strong>定时器和异步任务</strong>：它提供了定时器和异步任务的功能，允许开发者进行计时操作和调度异步任务。</p>
</li>
<li><p><strong>高性能</strong>：由于采用异步的方式处理I&#x2F;O操作，Boost.Asio可以实现高性能的网络应用程序。</p>
</li>
</ol>
<p>下面是一个简单的示例，展示了使用Boost.Asio库进行异步操作的方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; <span class="comment">/*ec*/</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_service io_service;</span><br><span class="line"></span><br><span class="line">    boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(io_service, boost::asio::chrono::seconds(<span class="number">1</span>))</span></span>;</span><br><span class="line">    timer.<span class="built_in">async_wait</span>(&amp;print);</span><br><span class="line"></span><br><span class="line">    io_service.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例创建了一个定时器，在1秒后触发一个异步操作，调用<code>print</code>函数输出”Hello, World!”。<code>io_service.run()</code>会一直运行，直到所有的异步操作完成或者<code>io_service</code>被停止。</p>
<p>Boost.Asio是一个强大而灵活的库，可以用于构建各种类型的网络应用程序，但它的使用需要一定的学习曲线。对于更复杂的应用程序，可能需要深入学习Boost.Asio文档并熟悉其API和异步编程的概念。</p>
<h2 id="boost-asio-io-context-详解"><a href="#boost-asio-io-context-详解" class="headerlink" title="boost::asio::io_context 详解"></a>boost::asio::io_context 详解</h2><p><code>boost::asio::io_context</code> 是 Boost.Asio 库中的关键类之一，用于管理异步 I&#x2F;O 操作和事件处理循环。它是 Boost.Asio 提供的核心组件之一，用于实现异步编程模型。</p>
<p>以下是对 <code>boost::asio::io_context</code> 的详细解释：</p>
<ol>
<li><p><strong>异步 I&#x2F;O 和事件循环</strong>：<br><code>boost::asio::io_context</code> 提供了一个事件处理循环，用于管理异步 I&#x2F;O 操作。它负责处理套接字、定时器、异步任务等操作的调度和执行。</p>
</li>
<li><p><strong>多线程支持</strong>：<br><code>io_context</code> 可以在多个线程中共享使用，允许在多线程环境中处理异步操作。多个线程可以同时运行 <code>io_context::run()</code>，从而实现并发的异步操作处理。</p>
</li>
<li><p><strong>操作队列管理</strong>：<br>它维护一个操作队列，用于存储待处理的异步操作。当调用 <code>io_context::run()</code> 时，它会处理队列中的操作，直到队列为空或者调用 <code>io_context::stop()</code> 来停止事件处理循环。</p>
</li>
<li><p><strong>定时器支持</strong>：<br><code>io_context</code> 可以创建定时器，用于在指定的时间点执行操作或者在指定的时间间隔内重复执行操作。</p>
</li>
<li><p><strong>回调机制</strong>：<br>当异步操作完成或者发生错误时，<code>io_context</code> 会调用相关的回调函数，通知调用者操作的完成情况。这样可以实现非阻塞的异步操作处理。</p>
</li>
<li><p><strong>资源管理</strong>：<br><code>io_context</code> 负责管理和分配底层资源，如套接字和文件句柄等资源，在操作完成后进行资源的释放。</p>
</li>
</ol>
<p>以下是一个简单的示例，展示了如何创建和使用 <code>boost::asio::io_context</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步操作，打印 &quot;Hello, World!&quot; 后停止 io_context</span></span><br><span class="line">    io_context.<span class="built_in">post</span>([]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始处理异步操作，直到所有操作完成</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个简单的示例创建了一个 <code>io_context</code> 对象，并使用 <code>post()</code> 方法在 <code>io_context</code> 上投递了一个异步操作，打印 “Hello, World!”。然后调用 <code>io_context.run()</code> 来启动事件循环，处理投递的异步操作，直到操作完成。在这个例子中，异步操作完成后程序退出。</p>
<p><code>boost::asio::io_context</code> 是 Boost.Asio 中重要的核心组件之一，是实现异步 I&#x2F;O 编程的关键部分。通过它，可以实现高效的异步操作处理和事件驱动的网络编程。</p>
<h2 id="boost-asio-thread-pool-详解"><a href="#boost-asio-thread-pool-详解" class="headerlink" title="boost::asio::thread_pool 详解"></a>boost::asio::thread_pool 详解</h2><p><code>boost::asio::thread_pool</code> 是 Boost.Asio 库中的一个类，用于管理线程池，方便地处理异步操作。它提供了一种机制，允许在一个固定数量的线程池中执行异步任务。</p>
<p>以下是对 <code>boost::asio::thread_pool</code> 的详细解释：</p>
<ol>
<li><p><strong>线程池管理</strong>：<br><code>boost::asio::thread_pool</code> 封装了一个线程池，可以在其中执行异步任务。它负责管理一组线程，这些线程可以被异步操作共享使用。</p>
</li>
<li><p><strong>简化异步任务处理</strong>：<br>通过 <code>thread_pool</code>，可以轻松地管理异步操作的执行。无需手动创建和管理线程，而是将异步任务提交到线程池中，由线程池自动调度和执行。</p>
</li>
<li><p><strong>控制线程数量</strong>：<br>可以在创建 <code>thread_pool</code> 时指定线程的数量。这个数量通常取决于系统资源和任务需求，可以避免创建过多线程而导致资源浪费。</p>
</li>
<li><p><strong>异步任务调度</strong>：<br><code>thread_pool</code> 提供了一种方便的方式来调度异步任务，使得多个任务可以并发执行，提高程序的并发性能。</p>
</li>
<li><p><strong>资源管理</strong>：<br>线程池负责管理其内部线程的资源分配和释放，当不再需要时，可以正确地释放线程资源。</p>
</li>
</ol>
<p>以下是一个简单的示例，展示了如何使用 <code>boost::asio::thread_pool</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::<span class="function">asio::thread_pool <span class="title">thread_pool</span><span class="params">(<span class="number">4</span>)</span></span>; <span class="comment">// 创建拥有4个线程的线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向线程池提交异步任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        boost::asio::<span class="built_in">post</span>(thread_pool, [i]() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; executed in thread: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有任务完成</span></span><br><span class="line">    thread_pool.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，首先创建了一个 <code>boost::asio::io_context</code> 对象和一个拥有4个线程的 <code>boost::asio::thread_pool</code> 对象。然后使用 <code>boost::asio::post()</code> 将8个异步任务提交到线程池中执行。每个任务输出了自己的标识符和线程ID。最后，通过 <code>thread_pool.join()</code> 等待所有任务完成。</p>
<p><code>boost::asio::thread_pool</code> 提供了一种便捷的方式来管理并发任务，避免了手动管理线程的复杂性，使得异步任务的管理更加简单和高效。</p>
<h2 id="boost-asio-ip-tcp-socket-详解"><a href="#boost-asio-ip-tcp-socket-详解" class="headerlink" title="boost::asio::ip::tcp::socket 详解"></a>boost::asio::ip::tcp::socket 详解</h2><p><code>boost::asio::ip::tcp::socket</code> 是 Boost.Asio 库中用于 TCP 协议通信的关键类之一。它提供了在 C++ 中进行 TCP 连接的接口，并允许进行异步的数据传输。</p>
<p>以下是对 <code>boost::asio::ip::tcp::socket</code> 的详细解释：</p>
<ol>
<li><p><strong>TCP 套接字</strong>：<br><code>boost::asio::ip::tcp::socket</code> 是用于 TCP 协议通信的套接字类。通过它可以进行基于流的数据传输。</p>
</li>
<li><p><strong>异步 I&#x2F;O</strong>：<br><code>tcp::socket</code> 支持异步 I&#x2F;O 操作，可以使用异步读取和写入函数来进行非阻塞的数据传输，从而允许在进行网络通信时不阻塞当前线程。</p>
</li>
<li><p><strong>连接管理</strong>：<br>通过 <code>tcp::socket</code> 可以连接到远程服务器，也可以接受远程客户端的连接请求，因此它可以用于客户端和服务器端编程。</p>
</li>
<li><p><strong>数据传输</strong>：<br><code>tcp::socket</code> 提供了方法来发送和接收数据。可以使用 <code>async_read_some()</code> 和 <code>async_write_some()</code> 等函数进行异步数据读取和写入。</p>
</li>
<li><p><strong>错误处理</strong>：<br>当发生错误时，<code>tcp::socket</code> 会生成相应的错误码，开发者可以根据错误码来处理异常情况。</p>
</li>
<li><p><strong>关闭连接</strong>：<br>可以通过 <code>close()</code> 方法关闭套接字，释放资源并关闭与远程端点的连接。</p>
</li>
</ol>
<p>以下是一个简单的示例，展示了如何使用 <code>boost::asio::ip::tcp::socket</code> 进行简单的 TCP 通信：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::asio::ip;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 连接到服务器</span></span><br><span class="line">        <span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">8080</span>)</span></span>;</span><br><span class="line">        socket.<span class="built_in">connect</span>(endpoint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        std::string message = <span class="string">&quot;Hello, Server!&quot;</span>;</span><br><span class="line">        socket.<span class="built_in">write_some</span>(<span class="built_in">buffer</span>(message));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取服务器响应</span></span><br><span class="line">        <span class="type">char</span> data[<span class="number">128</span>];</span><br><span class="line">        <span class="type">size_t</span> len = socket.<span class="built_in">read_some</span>(<span class="built_in">buffer</span>(data, <span class="number">128</span>));</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Received: &quot;</span> &lt;&lt; std::<span class="built_in">string</span>(data, len) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭套接字</span></span><br><span class="line">        socket.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个简单的示例创建了一个 TCP 套接字 <code>tcp::socket</code>，连接到本地 IP 地址 <code>127.0.0.1</code> 的端口 <code>8080</code>，发送 “Hello, Server!” 消息，并等待服务器的响应。这个示例只是一个基本的演示，实际中可能需要更复杂的错误处理和异步操作。</p>
<h2 id="boost-asio-ip-tcp-acceptor-详解"><a href="#boost-asio-ip-tcp-acceptor-详解" class="headerlink" title="boost::asio::ip::tcp::acceptor 详解"></a>boost::asio::ip::tcp::acceptor 详解</h2><p><code>boost::asio::ip::tcp::acceptor</code> 是 Boost 库中 <code>Asio</code> 网络编程库的一部分，用于在 C++ 中实现基于 TCP 协议的异步接受连接的操作。</p>
<h3 id="1-boost-asio-ip-tcp-acceptor-概述"><a href="#1-boost-asio-ip-tcp-acceptor-概述" class="headerlink" title="1. boost::asio::ip::tcp::acceptor 概述"></a>1. <code>boost::asio::ip::tcp::acceptor</code> 概述</h3><ul>
<li><strong>作用：</strong> <code>acceptor</code> 用于在服务器端监听指定的 IP 地址和端口，并接受传入的连接请求。</li>
<li><strong>工作原理：</strong> <code>acceptor</code> 负责等待来自客户端的连接请求，并在连接请求到达时接受连接。它允许服务器接受传入连接，并将其传递给对应的处理器。</li>
<li><strong>使用场景：</strong> 在服务器端实现 TCP 服务时，<code>acceptor</code> 通常与 <code>socket</code> 结合使用，通过 <code>acceptor</code> 接受连接，并创建一个新的 <code>socket</code> 用于处理客户端和服务器之间的通信。</li>
</ul>
<h3 id="2-boost-asio-ip-tcp-acceptor-的基本用法"><a href="#2-boost-asio-ip-tcp-acceptor-的基本用法" class="headerlink" title="2. boost::asio::ip::tcp::acceptor 的基本用法"></a>2. <code>boost::asio::ip::tcp::acceptor</code> 的基本用法</h3><p>以下是一个简单的示例，演示如何使用 <code>acceptor</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_accept</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="comment">// 处理新连接</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理连接错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>() &#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在本地地址 0.0.0.0，端口号 8080 上监听连接</span></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(boost::asio::ip::tcp::v4(), <span class="number">8080</span>)</span></span>;</span><br><span class="line">    acceptor.<span class="built_in">open</span>(endpoint.<span class="built_in">protocol</span>());</span><br><span class="line">    acceptor.<span class="built_in">bind</span>(endpoint);</span><br><span class="line">    acceptor.<span class="built_in">listen</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步等待连接请求</span></span><br><span class="line">    acceptor.<span class="built_in">async_accept</span>(</span><br><span class="line">        [&amp;acceptor](<span class="type">const</span> boost::system::error_code&amp; error, boost::asio::ip::tcp::socket socket) &#123;</span><br><span class="line">            <span class="built_in">handle_accept</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-重要方法和功能"><a href="#3-重要方法和功能" class="headerlink" title="3. 重要方法和功能"></a>3. 重要方法和功能</h3><ul>
<li><strong><code>open()</code>：</strong> 打开接受器并准备接受连接。</li>
<li><strong><code>bind()</code>：</strong> 将接受器绑定到指定的 IP 地址和端口。</li>
<li><strong><code>listen()</code>：</strong> 开始监听传入的连接请求。</li>
<li><strong><code>async_accept()</code>：</strong> 异步接受传入的连接请求。当有新的连接请求到达时，调用回调函数处理连接。</li>
</ul>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h3><ul>
<li>使用 <code>async_accept</code> 进行异步连接处理，必须确保在回调函数中处理连接，否则连接将被丢弃。</li>
<li><code>acceptor</code> 通常与 <code>io_context</code> 一起使用，后者用于异步操作的事件循环处理。</li>
</ul>
<p>请根据具体的需求和网络应用程序的逻辑，结合 Boost.Asio 的其他部分，例如 <code>socket</code> 类等，来构建一个完整的网络应用程序。</p>
<h2 id="boost-asio-ip-tcp-acceptor-初始化"><a href="#boost-asio-ip-tcp-acceptor-初始化" class="headerlink" title="boost::asio::ip::tcp::acceptor 初始化"></a>boost::asio::ip::tcp::acceptor 初始化</h2><p>在使用 <code>boost::asio::ip::tcp::acceptor</code> 初始化之前，需要提供一个 <code>io_context</code> 对象以及一个 <code>endpoint</code>（端点）来指定监听的地址和端口。</p>
<p>下面是一个简单的示例，演示了如何初始化 <code>boost::asio::ip::tcp::acceptor</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 io_context 对象</span></span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 acceptor 对象</span></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 定义 endpoint（端点），指定要监听的 IP 地址和端口</span></span><br><span class="line">        boost::asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(boost::asio::ip::tcp::v4(), <span class="number">8080</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开 acceptor，并绑定到指定端点</span></span><br><span class="line">        acceptor.<span class="built_in">open</span>(endpoint.<span class="built_in">protocol</span>());</span><br><span class="line">        acceptor.<span class="built_in">bind</span>(endpoint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始监听传入的连接</span></span><br><span class="line">        acceptor.<span class="built_in">listen</span>();</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Server started and listening on port 8080&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这之后，可以使用 acceptor 的 async_accept() 方法来接受连接请求并处理连接</span></span><br><span class="line">        <span class="comment">// acceptor.async_accept(...);</span></span><br><span class="line">        </span><br><span class="line">        io_context.<span class="built_in">run</span>(); <span class="comment">// 启动 IO 上下文的事件循环</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ol>
<li>创建了一个 <code>io_context</code> 对象用于异步 I&#x2F;O 操作的事件循环。</li>
<li>使用 <code>boost::asio::ip::tcp::acceptor</code> 创建了一个接受器对象。</li>
<li>指定了一个 <code>endpoint</code>，即要监听的 IP 地址和端口。在此示例中，IP 地址是 IPv4 的地址，端口是 8080。</li>
<li>打开 <code>acceptor</code> 并将其绑定到指定的端点。</li>
<li>调用 <code>listen()</code> 开始监听传入的连接请求。</li>
<li><code>io_context.run()</code> 启动了异步操作的事件循环，以便接受来自客户端的连接请求。</li>
</ol>
<p>请注意，这只是初始化 <code>boost::asio::ip::tcp::acceptor</code> 的一个基本示例。实际的应用程序需要根据需求进一步扩展，可能需要添加异步连接接受处理等操作。</p>
<h2 id="boost-asio-ip-tcp-endpoint-详解"><a href="#boost-asio-ip-tcp-endpoint-详解" class="headerlink" title="boost::asio::ip::tcp::endpoint 详解"></a>boost::asio::ip::tcp::endpoint 详解</h2><p><code>boost::asio::ip::tcp::endpoint</code> 是 Boost.Asio 中用于表示 TCP 协议的端点（endpoint）的类。它定义了一个包含 IP 地址和端口号的组合，用于标识网络上的一个节点。</p>
<h3 id="主要特点和功能："><a href="#主要特点和功能：" class="headerlink" title="主要特点和功能："></a>主要特点和功能：</h3><ol>
<li><strong>表示网络上的节点：</strong> <code>tcp::endpoint</code> 表示了网络上的一个节点，它由 IP 地址和端口号组成。</li>
<li><strong>跨平台性：</strong> <code>endpoint</code> 类支持跨平台操作，可以在各种操作系统上使用。</li>
<li><strong>灵活性：</strong> 允许用户指定 IPv4 或 IPv6 地址，以及端口号。</li>
</ol>
<h3 id="主要方法和操作："><a href="#主要方法和操作：" class="headerlink" title="主要方法和操作："></a>主要方法和操作：</h3><ul>
<li><strong>构造函数：</strong> 提供了多种构造函数来创建 <code>tcp::endpoint</code> 实例，可以根据不同的参数设置 IP 地址和端口号。</li>
<li><strong>协议访问：</strong> 可以通过 <code>protocol()</code> 方法访问端点的协议信息。</li>
<li><strong>IP 地址和端口访问：</strong> 通过 <code>address()</code> 和 <code>port()</code> 方法获取端点的 IP 地址和端口号。</li>
</ul>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><p>以下是一个示例，演示了如何使用 <code>tcp::endpoint</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 IPv4 的 endpoint</span></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint_v4</span><span class="params">(boost::asio::ip::address_v4::any(), <span class="number">8080</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 IPv6 的 endpoint</span></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint_v6</span><span class="params">(boost::asio::ip::address_v6::any(), <span class="number">8080</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;IPv4 Endpoint: &quot;</span> &lt;&lt; endpoint_v<span class="number">4.</span><span class="built_in">address</span>().<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endpoint_v<span class="number">4.</span><span class="built_in">port</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;IPv6 Endpoint: &quot;</span> &lt;&lt; endpoint_v<span class="number">6.</span><span class="built_in">address</span>().<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endpoint_v<span class="number">6.</span><span class="built_in">port</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此示例演示了如何创建一个 IPv4 和一个 IPv6 的 <code>tcp::endpoint</code>，并打印它们的 IP 地址和端口号。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>tcp::endpoint</code> 是一个用于表示网络节点的类，并且常用于创建 <code>acceptor</code> 和 <code>socket</code> 对象来监听和建立连接。</li>
<li>在实际应用中，可以使用 <code>tcp::endpoint</code> 来标识本地或远程服务器的地址和端口号。</li>
</ul>
<p>这是一个简单的概述，<code>tcp::endpoint</code> 可以用于标识和操作 TCP 网络上的节点，它是 Boost.Asio 中处理网络连接和数据传输的重要组件之一。</p>
<h2 id="boost-asio-ip-tcp-endpoint-构造函数-输入字符串"><a href="#boost-asio-ip-tcp-endpoint-构造函数-输入字符串" class="headerlink" title="boost::asio::ip::tcp::endpoint 构造函数 输入字符串"></a>boost::asio::ip::tcp::endpoint 构造函数 输入字符串</h2><p><code>boost::asio::ip::tcp::endpoint</code> 类提供了一种从字符串构造端点的方法，它可以解析字符串来创建 TCP 端点。这个构造函数通常用于将用户提供的 IP 地址和端口字符串转换为 <code>tcp::endpoint</code> 对象。</p>
<p>以下是一个示例，演示了如何使用 <code>tcp::endpoint</code> 的构造函数从字符串创建端点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从字符串创建 TCP 端点</span></span><br><span class="line">    std::string ip_address = <span class="string">&quot;127.0.0.1&quot;</span>; <span class="comment">// IP 地址字符串</span></span><br><span class="line">    std::string port_number = <span class="string">&quot;8080&quot;</span>;      <span class="comment">// 端口号字符串</span></span><br><span class="line"></span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用字符串创建 TCP 端点</span></span><br><span class="line">        boost::asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(boost::asio::ip::address::from_string(ip_address), std::stoi(port_number))</span></span>;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Created endpoint from strings: &quot;</span> &lt;&lt; endpoint.<span class="built_in">address</span>().<span class="built_in">to_string</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endpoint.<span class="built_in">port</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>boost::asio::ip::address::from_string()</code> 方法将 IP 地址字符串转换为 <code>address</code> 对象，然后将此对象与端口号一起传递给 <code>tcp::endpoint</code> 的构造函数。最后，使用 <code>endpoint.address().to_string()</code> 和 <code>endpoint.port()</code> 来获取所创建端点的 IP 地址和端口号。</p>
<p>请注意，为了示例简洁，没有进行输入验证。在实际应用程序中，您可能需要添加输入验证来确保字符串包含有效的 IP 地址和端口号。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_3_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22-C_3_1_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_3_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22-C_3_1_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C_3_1_常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C语言常用函数</li>
</ul>
<h2 id="mlockall"><a href="#mlockall" class="headerlink" title="mlockall"></a>mlockall</h2><ul>
<li><p>简介：</p>
<ul>
<li>mlockall() 是一个函数，它用于将进程的内存锁定在物理内存中，防止被换出到磁盘交换空间</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mlockall</span><span class="params">(<span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>flags：指定锁定内存的选项。可以是以下值的按位或<ul>
<li>MCL_CURRENT：锁定当前进程的地址空间中的所有内存。</li>
<li>MCL_FUTURE：锁定当前进程在将来动态分配的内存</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回0；</li>
<li>失败时，返回-1，并设置 errno 表示错误原因</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>mlockall() 函数用于在内存敏感的应用程序中确保关键数据或代码保持在物理内存中，以提高访问速度和可靠性</li>
<li>调用 mlockall() 后，指定选项的内存将被锁定，不会被交换到磁盘上的交换空间</li>
<li>锁定内存可能需要特权权限，通常只有具有足够权限的进程才能成功调用 mlockall() 函数</li>
<li>当不再需要锁定内存时，可以使用 munlockall() 函数来解锁内存</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li>需要注意的是，使用 mlockall() 函数需要谨慎，因为过度锁定内存可能导致系统资源不足，并影响整体性能。仅在确实需要将关键数据保留在物理内存中并且有足够的系统资源时才应使用该函数</li>
</ul>
</li>
</ul>
<hr>
<h2 id="popen"><a href="#popen" class="headerlink" title="popen"></a>popen</h2><ul>
<li><p>简介：</p>
<ul>
<li>popen()是一个C标准库函数，用于在一个新进程中执行shell命令，并创建一个管道来与该进程通信</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE* <span class="title">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* command, <span class="type">const</span> <span class="type">char</span>* mode)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>command：要执行的shell命令。</li>
<li>mode：操作模式，可以是”r”（读取模式）或”w”（写入模式）</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果成功，返回一个指向FILE结构的指针，用于后续与新进程之间的读写操作</li>
<li>如果失败，返回NULL</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>函数功能：<ul>
<li>popen()函数通过创建一个新的进程来执行指定的shell命令，并返回一个指向FILE结构的指针。该FILE结构可以用于后续的读取或写入操作。新进程的标准输入或标准输出将通过管道与调用进程进行通信</li>
</ul>
</li>
<li>操作模式<ul>
<li>“r”：读取模式，用于从新进程的标准输出读取数据。</li>
<li>“w”：写入模式，用于向新进程的标准输入写入数据</li>
</ul>
</li>
<li>注意事项<ul>
<li>使用popen()函数执行shell命令时，请确保命令参数是可信的，以防止命令注入等安全问题。</li>
<li>在使用完popen()函数后，应该使用pclose()函数关闭由popen()创建的管道</li>
</ul>
</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*下面是一个简单的示例，演示如何使用popen()函数执行shell命令并读取输出：*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* command = <span class="string">&quot;ls -l&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* mode = <span class="string">&quot;r&quot;</span>;</span><br><span class="line"></span><br><span class="line">    FILE* pipe = <span class="built_in">popen</span>(command, mode);</span><br><span class="line">    <span class="keyword">if</span> (pipe) &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">feof</span>(pipe) &amp;&amp; <span class="built_in">fgets</span>(buffer, <span class="built_in">sizeof</span>(buffer), pipe) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pclose</span>(pipe);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Command execution failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>上述示例执行ls -l命令，并将命令的输出打印到控制台</li>
</ul>
</li>
</ul>
<h2 id="sync-fetch-and-add"><a href="#sync-fetch-and-add" class="headerlink" title="__sync_fetch_and_add"></a>__sync_fetch_and_add</h2><!-- + 简述：先返回没有操作的`*ptr`，然后将`*ptr`与`value`相加并将结果存入到`*ptr`
+ 声明：`type __sync_fetch_and_add (type *ptr, type value, ...)` -->

<ul>
<li><p>简介：</p>
<ul>
<li>__sync_fetch_and_add() 是一个GCC内置函数，用于实现原子的自增操作。它可以用于多线程环境下对共享变量进行原子操作，确保操作的原子性和可见性</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T __sync_fetch_and_add(T* ptr, T value);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>ptr：指向共享变量的指针。</li>
<li>value：要添加到共享变量的值</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回执行自增操作前的共享变量的值</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>函数功能：<ul>
<li>__sync_fetch_and_add() 函数用于对给定的共享变量进行原子的自增操作。它将指定的值（value）添加到共享变量（通过指针 ptr 引用）中，并返回执行自增操作前的共享变量的值。</li>
</ul>
</li>
<li>原子操作的特性确保了多个线程对同一共享变量进行自增操作时的正确性。该操作在执行期间不会被中断，以确保其他线程不会在此期间修改共享变量的值</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*下面是一个简单的示例，演示了如何使用 __sync_fetch_and_add() 函数对共享变量进行原子的自增操作*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sharedVariable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> previousValue = __sync_fetch_and_add(&amp;sharedVariable, <span class="number">1</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Previous value: &quot;</span> &lt;&lt; previousValue &lt;&lt; <span class="string">&quot;, New value: &quot;</span> &lt;&lt; sharedVariable &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>上述示例使用 __sync_fetch_and_add() 函数对共享变量 sharedVariable 进行了10次原子的自增操作。每次自增操作都会打印出执行自增前的值和执行自增后的值</li>
</ul>
</li>
</ul>
<h2 id="sync-fetch-and-sub"><a href="#sync-fetch-and-sub" class="headerlink" title="__sync_fetch_and_sub"></a>__sync_fetch_and_sub</h2><!-- + 简述：先返回没有操作的`*ptr`，然后将`*ptr`与`value`相减并将结果存入到`*ptr`
+ 声明：`type __sync_fetch_and_sub (type *ptr, type value, ...)` -->

<ul>
<li><p>简介：</p>
<ul>
<li>__sync_fetch_and_sub() 是一个GCC内置函数，用于实现原子的自减操作。它可以在多线程环境下对共享变量进行原子操作，确保操作的原子性和可见性</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T __sync_fetch_and_sub(T* ptr, T value);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>ptr：指向共享变量的指针。</li>
<li>value：要从共享变量减去的值</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回执行自减操作前的共享变量的值</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>函数功能：<ul>
<li>__sync_fetch_and_sub() 函数用于对给定的共享变量进行原子的自减操作。它从共享变量（通过指针 ptr 引用）中减去指定的值（value），并返回执行自减操作前的共享变量的值</li>
</ul>
</li>
<li>原子操作的特性确保了多个线程对同一共享变量进行自减操作时的正确性。该操作在执行期间不会被中断，以确保其他线程不会在此期间修改共享变量的值</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*下面是一个简单的示例，演示了如何使用 __sync_fetch_and_sub() 函数对共享变量进行原子的自减操作*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sharedVariable = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> previousValue = __sync_fetch_and_sub(&amp;sharedVariable, <span class="number">1</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Previous value: &quot;</span> &lt;&lt; previousValue &lt;&lt; <span class="string">&quot;, New value: &quot;</span> &lt;&lt; sharedVariable &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>上述示例使用 __sync_fetch_and_sub() 函数对共享变量 sharedVariable 进行了10次原子的自减操作。每次自减操作都会打印出执行自减前的值和执行自减后的值</li>
</ul>
</li>
</ul>
<h2 id="sync-fetch-and-or"><a href="#sync-fetch-and-or" class="headerlink" title="__sync_fetch_and_or"></a>__sync_fetch_and_or</h2><!-- + 简述：先返回没有操作的`*ptr`，然后将`*ptr`与`value`做按位或运算，并将结果存入到`*ptr`
+ 声明：`type __sync_fetch_and_or (type *ptr, type value, ...)` -->

<ul>
<li><p>简介：</p>
<ul>
<li>__sync_fetch_and_or() 是一个GCC内置函数，用于实现原子的按位或操作。它可以在多线程环境下对共享变量进行原子操作，确保操作的原子性和可见性</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T __sync_fetch_and_or(T* ptr, T value);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>ptr：指向共享变量的指针。</li>
<li>value：要进行按位或操作的值</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回执行按位或操作前的共享变量的值</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>函数功能：<ul>
<li>__sync_fetch_and_or() 函数用于对给定的共享变量进行原子的按位或操作。它将指定的值（value）与共享变量（通过指针 ptr 引用）进行按位或操作，并返回执行按位或操作前的共享变量的值</li>
</ul>
</li>
<li>原子操作的特性确保了多个线程对同一共享变量进行按位或操作时的正确性。该操作在执行期间不会被中断，以确保其他线程不会在此期间修改共享变量的值</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 下面是一个简单的示例，演示了如何使用 __sync_fetch_and_or() 函数对共享变量进行原子的按位或操作*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sharedVariable = <span class="number">0b1100</span>;  <span class="comment">// 初始值为 12，二进制为 1100</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> newValue = <span class="number">0b0011</span>;  <span class="comment">// 要进行按位或操作的值，二进制为 0011</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> previousValue = __sync_fetch_and_or(&amp;sharedVariable, newValue);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Previous value: &quot;</span> &lt;&lt; previousValue &lt;&lt; <span class="string">&quot;, New value: &quot;</span> &lt;&lt; sharedVariable &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>上述示例使用 __sync_fetch_and_or() 函数对共享变量 sharedVariable 进行了原子的按位或操作。在示例中，共享变量初始值为 12，二进制表示为 1100，要进行按位或操作的值为 3，二进制表示为 0011。执行按位或操作后，共享变量的值变为 15，二进制表示为 1111。示例中打印出了执行按位或操作前的值和执行按位或操作后的值</li>
</ul>
</li>
</ul>
<h2 id="sync-and-and-fetch"><a href="#sync-and-and-fetch" class="headerlink" title="__sync_and_and_fetch"></a>__sync_and_and_fetch</h2><!-- + 简述：先将`*ptr`与`val`做按位与运算，返回操作之后的值
+ 声明：`type __sync_add_and_fetch (type *ptr, type value, ...)` -->

<ul>
<li><p>简介：</p>
<ul>
<li>__sync_and_and_fetch() 是一个GCC内置函数，用于实现原子的按位与操作。它可以在多线程环境下对共享变量进行原子操作，确保操作的原子性和可见性</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T __sync_and_and_fetch(T* ptr, T value);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>ptr：指向共享变量的指针。</li>
<li>value：要进行按位与操作的值</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回执行按位与操作后的共享变量的值</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>函数功能：<ul>
<li>__sync_and_and_fetch() 函数用于对给定的共享变量进行原子的按位与操作。它将指定的值（value）与共享变量（通过指针 ptr 引用）进行按位与操作，并返回执行按位与操作后的共享变量的值</li>
</ul>
</li>
<li>原子操作的特性确保了多个线程对同一共享变量进行按位与操作时的正确性。该操作在执行期间不会被中断，以确保其他线程不会在此期间修改共享变量的值</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*下面是一个简单的示例，演示了如何使用 __sync_and_and_fetch() 函数对共享变量进行原子的按位与操作*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sharedVariable = <span class="number">0b1111</span>;  <span class="comment">// 初始值为 15，二进制为 1111</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value = <span class="number">0b1100</span>;  <span class="comment">// 要进行按位与操作的值，二进制为 1100</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = __sync_and_and_fetch(&amp;sharedVariable, value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>上述示例使用 __sync_and_and_fetch() 函数对共享变量 sharedVariable 进行了原子的按位与操作。在示例中，共享变量初始值为 15，二进制表示为 1111，要进行按位与操作的值为 12，二进制表示为 1100。执行按位与操作后，共享变量的值变为 12，二进制表示为 1100。示例中打印出了执行按位与操作后的值</li>
</ul>
</li>
</ul>
<h2 id="sync-bool-compare-and-swap"><a href="#sync-bool-compare-and-swap" class="headerlink" title="__sync_bool_compare_and_swap"></a>__sync_bool_compare_and_swap</h2><ul>
<li><p>简介：</p>
<ul>
<li>__sync_bool_compare_and_swap() 是一个GCC内置函数，用于实现原子的比较并交换操作。它可以在多线程环境下对共享变量进行原子操作，确保操作的原子性和可见性</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __sync_bool_compare_and_swap(T* ptr, T oldval, T newval);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>ptr：指向共享变量的指针。</li>
<li>oldval：期望的旧值。</li>
<li>newval：要替换的新值</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果共享变量的当前值与旧值相等，则将新值赋给共享变量，并返回 true。</li>
<li>如果共享变量的当前值与旧值不相等，则不进行替换，并返回 false</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>函数功能：<ul>
<li>__sync_bool_compare_and_swap() 函数用于比较共享变量的当前值与旧值是否相等，如果相等则替换为新值。该操作是原子的，确保在执行期间不会被中断，以确保其他线程不会在此期间修改共享变量的值</li>
</ul>
</li>
<li>函数返回 true 表示替换操作成功，共享变量的值已被替换为新值。返回 false 表示替换操作失败，共享变量的值与旧值不相等，替换未执行</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*下面是一个简单的示例，演示了如何使用 __sync_bool_compare_and_swap() 函数进行原子的比较并交换操作*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sharedVariable = <span class="number">10</span>;  <span class="comment">// 共享变量的初始值为 10</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> oldValue = <span class="number">10</span>;  <span class="comment">// 期望的旧值</span></span><br><span class="line">    <span class="type">int</span> newValue = <span class="number">20</span>;  <span class="comment">// 要替换的新值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> result = __sync_bool_compare_and_swap(&amp;sharedVariable, oldValue, newValue);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;, Shared variable: &quot;</span> &lt;&lt; sharedVariable &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>上述示例使用 __sync_bool_compare_and_swap() 函数对共享变量 sharedVariable 进行了比较并交换操作。在示例中，共享变量初始值为 10，我们期望将其替换为新值 20。通过 __sync_bool_compare_and_swap() 函数，我们将共享变量的当前值与旧值 10 进行比较，如果相等则替换为新值 20。示例中打印出了操作的结果和最终的共享变量值</li>
</ul>
</li>
</ul>
<h2 id="sync-val-compare-and-swap"><a href="#sync-val-compare-and-swap" class="headerlink" title="__sync_val_compare_and_swap"></a>__sync_val_compare_and_swap</h2><ul>
<li><p>简介：</p>
<ul>
<li>__sync_val_compare_and_swap() 是一个GCC内置函数，用于实现原子的比较并交换操作。它可以在多线程环境下对共享变量进行原子操作，确保操作的原子性和可见性</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T __sync_val_compare_and_swap(T* ptr, T oldval, T newval);</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>ptr：指向共享变量的指针。</li>
<li>oldval：期望的旧值。</li>
<li>newval：要替换的新值</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回共享变量在比较并交换操作之前的值</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>函数功能：<ul>
<li>__sync_val_compare_and_swap() 函数用于比较共享变量的当前值与旧值是否相等，如果相等则替换为新值，并返回比较交换之前的共享变量的值。该操作是原子的，确保在执行期间不会被中断，以确保其他线程不会在此期间修改共享变量的值</li>
</ul>
</li>
<li>函数返回共享变量在比较并交换操作之前的值，可以用于判断操作是否成功执行</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*下面是一个简单的示例，演示了如何使用 __sync_val_compare_and_swap() 函数进行原子的比较并交换操作*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sharedVariable = <span class="number">10</span>;  <span class="comment">// 共享变量的初始值为 10</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> oldValue = <span class="number">10</span>;  <span class="comment">// 期望的旧值</span></span><br><span class="line">    <span class="type">int</span> newValue = <span class="number">20</span>;  <span class="comment">// 要替换的新值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = __sync_val_compare_and_swap(&amp;sharedVariable, oldValue, newValue);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;, Shared variable: &quot;</span> &lt;&lt; sharedVariable &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>上述示例使用 __sync_val_compare_and_swap() 函数对共享变量 sharedVariable 进行了比较并交换操作。在示例中，共享变量初始值为 10，我们期望将其替换为新值 20。通过 __sync_val_compare_and_swap() 函数，我们将共享变量的当前值与旧值 10 进行比较，如果相等则替换为新值 20，并返回比较交换之前的共享变量的值。示例中打印出了操作的结果和最终的共享变量值</li>
</ul>
</li>
</ul>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h2><!-- + 简述：睡眠函数
+ 声明：`unsigned int sleep(unsigned int __seconds);`
+ 参数：
  + `__seconds`  --  睡眠的时间，单位为秒
+ 注意：
  + 需要包含头文件：`<unistd.h>` -->

<ul>
<li><p>简介：</p>
<ul>
<li>sleep() 函数是用于在指定的时间内使程序暂停执行的函数。它可以用于创建一定的延迟或控制程序的执行速度</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>seconds : 表示要暂停的秒数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果函数成功暂停了指定的秒数，返回为 0。</li>
<li>如果函数由于被信号中断而返回，则返回剩余的秒数</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Start\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂停 2 秒</span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;End\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上面的示例中，使用 sleep(2) 函数使程序暂停 2 秒。在输出 “Start” 后，程序会暂停 2 秒钟，然后输出 “End”</li>
<li>sleep() 函数在头文件 unistd.h 中声明，并且是一个标准库函数。它会导致当前进程阻塞，即程序会进入睡眠状态，不会执行其他操作，直到指定的时间过去</li>
<li>需要注意的是，sleep() 函数的时间精度是秒级别的，并且在暂停期间，程序会处于完全休眠状态，不会对其他任务进行处理。如果需要更精确的时间控制或需要同时处理其他任务，可以考虑使用定时器或多线程等机制来实现</li>
<li>另外，sleep() 函数在 POSIX 标准中定义，因此在不同的操作系统或编译器中可能会有一些差异。在特定平台或环境下使用 sleep() 函数时，建议查看相应的文档和标准以获取更详细的信息</li>
</ul>
</li>
</ul>
<hr>
<h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h2><!-- + 简述：分配所需的内存空间,并返回一个指向它的指针
+ 声明：`void *calloc(size_t nitems, size_t size)`
+ 参数：
  + nitems -- 要被分配的元素的个数
  + size   -- 元素的大小
+ 注意：
  + `malloc`和`calloc`之间的不同点是:`malloc`不会设置内存为零,而`calloc`会**设置分配的内存为零** -->

<ul>
<li><p>简介：</p>
<ul>
<li>calloc() 函数用于动态分配内存，并将分配的内存块初始化为零。它是 malloc() 函数的一种变体，用于分配连续的内存空间</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">calloc</span><span class="params">(<span class="type">size_t</span> num, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>num: 要分配的元素数量。</li>
<li>size: 每个元素的大小（以字节为单位）</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果分配成功，返回指向分配内存块的指针（指向首字节的指针）。</li>
<li>如果分配失败，返回 NULL</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配包含 5 个整数的内存块，并初始化为零</span></span><br><span class="line">    arr = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">5</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出分配的内存块中的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存块</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上面的示例中，使用 calloc(5, sizeof(int)) 函数分配了包含 5 个整数的内存块，并将其初始化为零。返回的指针 arr 指向分配内存块的首字节</li>
<li>calloc() 函数在头文件 stdlib.h 中声明，并且是一个标准库函数。它在内存分配时会自动将分配的内存块中的所有字节初始化为零值。这与使用 malloc() 函数后需要手动进行内存清零的过程相比，提供了方便和效率</li>
<li>需要注意的是，calloc() 函数返回的指针必须通过 free() 函数进行释放，以避免内存泄漏</li>
<li>另外，如果分配的内存块过大或者系统内存不足，calloc() 函数可能会分配失败，此时返回 NULL。在使用 calloc() 函数分配内存时，建议检查返回的指针是否为 NULL，以确保分配成功</li>
<li>总结而言，calloc() 函数是一种方便的内存分配函数，可以分配连续的内存块并初始化为零。在需要分配内存并初始化为零的情况下，可以考虑使用 calloc() 函数</li>
</ul>
</li>
</ul>
<hr>
<h2 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h2><!-- + 简述：计算字符串 `str` 的长度，直到空结束字符，但不包括空结束字符
+ 声明：`size_t strlen(const char *str);`
+ 参数：
  + `str` -- 要计算长度的字符串
+ 返回值：
  + 返回字符串的长度
+ 需求：
  + 头文件：`#include <string.h>` -->

<ul>
<li><p>简介：</p>
<ul>
<li>strlen() 函数用于计算字符串的长度，即字符串中字符的个数（不包括终止符 \0）</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>str : 要计算长度的字符串，必须是以 \0 结尾的字符数组或字符指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回类型为 size_t（无符号整数），表示字符串的长度</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="built_in">strlen</span>(str);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串的长度是：%zu\n&quot;</span>, length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上面的示例中，使用 strlen() 函数计算了字符串 str 的长度，并将结果存储在变量 length 中。然后，使用 printf() 函数打印字符串的长度</li>
<li>strlen() 函数在头文件 string.h 中声明，并且是一个标准库函数。它通过逐个扫描字符，直到遇到字符串终止符 \0 来计算字符串的长度</li>
<li>需要注意的是，strlen() 函数只能用于以 \0 结尾的字符串。如果传递的字符串不是以 \0 结尾或者是一个空指针（NULL），则 strlen() 函数的行为是未定义的。因此，在使用 strlen() 函数时，必须确保字符串是以 \0 结尾的有效字符串</li>
<li>另外，由于 strlen() 函数返回的是 size_t 类型，因此在使用 %zu 格式符打印字符串的长度时，需要使用 size_t 类型的变量作为参数</li>
<li>总结而言，strlen() 函数是一种方便的计算字符串长度的函数，可以用于获取字符串中字符的个数（不包括终止符 \0）。在需要获取字符串长度的情况下，可以使用 strlen() 函数。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="dup2"><a href="#dup2" class="headerlink" title="dup2()"></a>dup2()</h2><!-- + 简述：将 `fd` 复制到 `fd2`，关闭 `fd2` 并使其在同一文件上打开
+ 声明：`int dup2 (int fd, int fd2);`
+ 参数：
  + `fd`  --  已经打开的文件描述符
  + `fd2` --  需要重复打开的文件描述符
+ 返回值：
  + 成功
  + 失败 -->

<ul>
<li><p>简介：</p>
<ul>
<li>dup2() 函数用于复制文件描述符，并将其复制到指定的目标文件描述符。通过 dup2() 函数，可以实现重定向文件描述符的功能</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>oldfd：要复制的旧文件描述符。</li>
<li>newfd：要复制到的新文件描述符。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果复制成功，返回新的文件描述符。</li>
<li>如果复制失败，返回 -1，并设置 errno 错误码</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> oldfd = <span class="built_in">open</span>(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY); <span class="comment">// 打开旧文件描述符</span></span><br><span class="line">    <span class="type">int</span> newfd = <span class="number">3</span>; <span class="comment">// 新文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">dup2</span>(oldfd, newfd); <span class="comment">// 复制文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用新的文件描述符读取数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytesRead = <span class="built_in">read</span>(newfd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytesRead == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[bytesRead] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取的数据：%s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(oldfd); <span class="comment">// 关闭旧文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上面的示例中，首先通过 open() 函数打开一个文件，并获得旧的文件描述符 oldfd。然后，定义一个新的文件描述符 newfd，将其设置为 3</li>
<li>接下来，使用 dup2(oldfd, newfd) 函数将旧文件描述符复制到新的文件描述符。如果复制成功，dup2() 函数将返回新的文件描述符</li>
<li>在示例中，我们使用新的文件描述符 newfd 执行 read() 函数，读取数据到缓冲区 buffer 中，并在末尾添加字符串终止符。最后，我们打印读取的数据。</li>
<li>需要注意的是，dup2() 函数会关闭新的文件描述符（如果它已经打开）。因此，在使用 dup2() 函数之前，应确保新的文件描述符没有被使用或需要关闭</li>
<li>另外，通过使用 dup2() 函数，还可以实现重定向标准输入、输出和错误的功能。例如，将标准输出重定向到文件中可以使用 dup2(fileDescriptor, STDOUT_FILENO)</li>
<li>总结而言，dup2() 函数是一个用于复制文件描述符的函数，可以将一个文件描述符复制到另一个指定的文件描述符。通过 dup2() 函数，可以实现文件描述符的重定向和复制功能</li>
</ul>
</li>
</ul>
<hr>
<h2 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h2><!-- + 简述：将 n 字节的 buf 写入 __fd
+ 声明：`ssize_t write(int __fd, const void *__buf, size_t __n);`
+ 参数：
  + `__fd`  --  要保存写入数据的文件
  + `__buf` --  保存要写入的内存块指针
  + `n`     --  数据大小
+ 返回值：
  + 成功  --  返回写入的数字
  + 失败  --  -1 -->

<ul>
<li><p>简介：</p>
<ul>
<li>write()函数用于将数据从文件描述符（通常是文件、管道、套接字等）写入到指定的缓冲区</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>fd：文件描述符，表示要写入的文件或设备</li>
<li>buf：指向要写入的数据的缓冲区的指针</li>
<li>count：要写入的字节数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果写入成功，返回值为实际写入的字节数</li>
<li>如果发生错误，返回值为-1，并设置errno变量以指示错误类型</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>write()函数会尽可能地写入指定数量的字节到文件描述符中。它不保证一次性写入全部数据，可能会根据底层实现的不同进行分多次写入。因此，在使用write()函数时，需要检查返回值以确保写入了所需的字节数</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *data = <span class="string">&quot;Hello, World!&quot;</span>; <span class="comment">// 要写入的数据</span></span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">strlen</span>(data); <span class="comment">// 数据长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件（如果不存在则创建）</span></span><br><span class="line">    fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据到文件</span></span><br><span class="line">    <span class="type">ssize_t</span> bytes_written = write(fd, data, len);</span><br><span class="line">    <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to write data to file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data written to file: %ld bytes\n&quot;</span>, bytes_written);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上述示例中，我们首先使用open()函数打开一个文件，如果文件不存在则创建它。然后，我们使用write()函数将数据写入文件。最后，我们使用close()函数关闭文件</li>
<li>请注意，上述示例仅演示了将数据写入文件的情况。在实际应用中，你可能需要根据需要调整文件打开模式和权限，并处理错误情况</li>
</ul>
</li>
</ul>
<h2 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h2><!-- + 简述：将大小为`nbytes`的数据从文件`__fd`中读取到内存`__buf`中
+ 声明：`ssize_t read(int __fd, void *__buf, size_t __nbytes);`
+ 参数：
  + `__fd`  --  被读取数据的文件
  + `__buf` --  存放数据的内存块指针
  + `__nbytes`  --  要读取的数据大小
+ 返回值：
  + 成功  --  读取的数字
  + 失败  --  -1 or 0 
+ 注意：
  + 必须实际提供一个足够大的缓冲区来装载`nbyte`字节的数据
  + 常见的错误是提供了一个未初始化的指针buf，而没有提供实际的缓冲区
  + read的实现必须检测的错误及相应的错误码 -->

<ul>
<li><p>简介：</p>
<ul>
<li>read() 函数用于从文件描述符中读取数据</li>
</ul>
</li>
<li><p>原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<ul>
<li>fd：文件描述符，指定要读取的文件或其他数据源</li>
<li>buf：用于存储读取数据的缓冲区的指针</li>
<li>count：要读取的最大字节数</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果成功读取数据，返回实际读取的字节数</li>
<li>如果到达文件末尾，返回0</li>
<li>如果发生错误，返回-1，并设置 errno 变量来指示具体的错误原因</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>read() 函数将尽可能读取指定数量的字节，并将其存储在提供的缓冲区中。它会阻塞，直到读取到足够的字节或者遇到文件末尾。如果文件中没有足够的数据可供读取，那么 read() 函数将一直等待，直到有足够的数据可供读取或者遇到其他读取条件（如文件被关闭、读取超时等）</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;file.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">ssize_t</span> bytesRead;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((bytesRead = read(fd, buffer, BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write(STDOUT_FILENO, buffer, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bytesRead == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to read file&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>上述示例代码使用 open() 函数打开文件，并使用 read() 函数从文件中读取数据，然后使用 write() 函数将数据写入到标准输出。循环读取直到 read() 函数返回值为0，表示已读取完所有数据</li>
<li>注意：在实际使用 read() 函数时，需要注意处理返回值、错误检查和错误处理，以确保数据的正确读取和错误的及时处理</li>
</ul>
</li>
</ul>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h2><!-- + 简述：
  + 映射地址从`addr`附近开始并扩展到`len`字节。从`offset`根据`prot`和`flags`写入文件`fd`中描述。
  + 如果`MAP_FIXED`位是在`flags`中设置，映射将准确地位于`addr`；否则系统会选择一个方便的附近地址
+ 声明：`void* mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);`
+ 参数：
  + `addr`  --  要映射的地址
  + `len`   --  要映射的数据大小
  + `prot`  -- 
  + `flags` --  标识
  + `fd`    --  存放需要映射数据的文件
  + `offset`--  偏移
+ 返回值：
  + 成功  --  实际映射地址
  + 失败  --  `MAP_FAILED` -->

<ul>
<li><p>简述：</p>
<ul>
<li>mmap() 函数是 C&#x2F;C++ 中的一个系统调用，用于将文件映射到进程的虚拟内存空间。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>addr：映射的起始地址。可以传入 NULL，表示由系统自动选择一个合适的地址。</li>
<li>length：映射的长度，以字节为单位。</li>
<li>prot：映射的保护模式，指定对内存区域的访问权限。常用的取值包括 PROT_READ（可读）、PROT_WRITE（可写）和 PROT_EXEC（可执行）</li>
<li>flags：映射的标志位，用于指定映射的属性。常用的取值包括 MAP_SHARED（与其他进程共享）和 MAP_PRIVATE（私有映射）</li>
<li>fd：文件描述符，指定要映射的文件。如果不需要映射文件，可以传入 -1。</li>
<li>offset：文件偏移量，指定从文件的哪个位置开始映射</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果映射成功，返回映射区域的起始地址。</li>
<li>如果映射失败，返回 MAP_FAILED，即 (void*)-1。</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>使用 mmap() 函数可以将文件映射到进程的内存空间，从而可以直接通过内存访问文件的内容，而无需进行频繁的文件 I&#x2F;O 操作。映射的文件内容可以像访问内存一样进行读写操作，对映射区域的修改也会反映到原始文件上</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(filename, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open file: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> file_stat;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fstat</span>(fd, &amp;file_stat) == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to get file size&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> file_size = file_stat.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* addr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, file_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to map file to memory&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 addr 指向的内存区域中可以直接访问文件的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">munmap</span>(addr, file_size);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;File mapped to memory successfully&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>上述代码打开名为 “example.txt” 的文件，获取其大小后，使用 mmap() 函数将文件内容映射到内存中。如果映射成功，将输出 “File mapped to memory successfully”。最后，使用 munmap() 函数解除映射，关闭文件</li>
<li>请注意，使用 mmap() 函数时应格外谨慎，确保正确地处理内存映射区域，避免出现悬挂指针和访问越界等问题。同时，对映射区域的读写操作可能会影响到原始文件，需要注意数据的同步与持久化</li>
</ul>
</li>
</ul>
<h2 id="dirname"><a href="#dirname" class="headerlink" title="dirname()"></a>dirname()</h2><!-- + 简述：返回`path`的目录部分，如果没有可用的，就返回`.`
+ 声明：`char* dirname(char *path);`
+ 参数：
  + `path`  --  需要查找目录的文件
+ 返回值：
  + 成功  --  文件所在的目录
  + 失败  --   -->

<ul>
<li><p>简介：</p>
<ul>
<li>dirname() 函数用于提取路径字符串中的目录部分。它返回一个新的字符串，其中包含给定路径的目录部分</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">dirname</span><span class="params">(<span class="type">char</span>* path)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>path : 要提取目录的路径字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回一个指向目录部分的字符串的指针。</li>
<li>如果路径不包含目录部分（如根目录 &#x2F; 或空路径），则返回一个句点 .</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> path[] = <span class="string">&quot;/usr/local/bin/executable&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* dir = <span class="built_in">dirname</span>(path);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;目录部分：%s\n&quot;</span>, dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上面的示例中，使用 dirname() 函数从路径字符串 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;executable 中提取目录部分。然后，将返回的目录字符串 dir 打印出来</li>
<li>dirname() 函数在头文件 libgen.h 中声明，并且是一个标准库函数。它会修改传入的路径字符串，并返回指向目录部分的指针。注意，传入的路径字符串应为可修改的字符数组（C 字符串），而不是字符串常量</li>
<li>需要注意的是，dirname() 函数的操作是基于路径字符串的规则来进行的，它不会检查目录是否存在或路径是否有效。它只是从给定的路径字符串中提取目录部分，并返回一个新的字符串</li>
<li>另外，由于 dirname() 函数会修改传入的路径字符串，所以如果需要保留原始路径字符串，应在调用 dirname() 函数之前创建一个副本</li>
<li>总结而言，dirname() 函数是一个用于提取路径字符串中目录部分的函数。它可以帮助您从路径字符串中获取目录信息，以便进行进一步的处理</li>
</ul>
</li>
</ul>
<h2 id="basename"><a href="#basename" class="headerlink" title="basename()"></a>basename()</h2><!-- + 简述：去掉文件`pathfile`的前缀，只保存文件名(input string:/data/test.cpp , output string:test.cpp)
+ 声明：`char* basename(char *pathfile);`
+ 参数：
  + `pathfile`  --  需要操作的文件
+ 返回值：
  + 成功  --  文件名
  + 失败  --   -->

<ul>
<li><p>简介：</p>
<ul>
<li>basename() 函数用于提取路径字符串中的文件名部分。它返回一个新的字符串，其中包含给定路径的文件名部分</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">basename</span><span class="params">(<span class="type">char</span>* path)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>path : 要提取文件名的路径字符串。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回一个指向文件名部分的字符串的指针</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> path[] = <span class="string">&quot;/usr/local/bin/executable&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* file = <span class="built_in">basename</span>(path);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件名部分：%s\n&quot;</span>, file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上面的示例中，使用 basename() 函数从路径字符串 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;executable 中提取文件名部分。然后，将返回的文件名字符串 file 打印出来。</li>
<li>basename() 函数在头文件 libgen.h 中声明，并且是一个标准库函数。它会修改传入的路径字符串，并返回指向文件名部分的指针。注意，传入的路径字符串应为可修改的字符数组（C 字符串），而不是字符串常量</li>
<li>需要注意的是，basename() 函数的操作是基于路径字符串的规则来进行的，它不会检查文件是否存在或路径是否有效。它只是从给定的路径字符串中提取文件名部分，并返回一个新的字符串。</li>
<li>另外，由于 basename() 函数会修改传入的路径字符串，所以如果需要保留原始路径字符串，应在调用 basename() 函数之前创建一个副本。</li>
<li>总结而言，basename() 函数是一个用于提取路径字符串中文件名部分的函数。它可以帮助您从路径字符串中获取文件名信息，以便进行进一步的处理。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="readlink"><a href="#readlink" class="headerlink" title="readlink()"></a>readlink()</h2><!-- + 简述：
  + readlink()会将参数path的 符号链接内容存储到参数buf所指的内存空间，返回的内容不是以\000作字符串结尾，但会将字符串的字符数返回，这使得添加\000变得简单。
  + 若参数bufsiz小于符号连接的内容长度，过长的内容会被截断，如果 readlink 第一个参数指向一个文件而不是 符号链接时，readlink 设 置errno 为 EINVAL 并返回 -1。 
  + readlink()函数组合了open()、read()和close()的所有操作
+ 声明：`ssize_t readlink(const char *path, char *buf, size_t bufsize);`
+ 参数：
  + `path`  --  符号连接
  + `buf`   --  存储从`path`读取到的内容
  + `bufsize` --  读取到的字符数
+ 返回值：
  + 成功  --  返回读取到的字符数
  + 失败  --  -1
+ 注意：
  + Linux系统中有一个符号链接 `/proc/self/exe` -- 它代表当前程序
  + **所以可以使用`readlink()`读取它的源路径就可以获取当前程序的绝对路径** -->

<ul>
<li><p>简介：</p>
<ul>
<li>readlink() 函数用于读取符号链接文件的目标路径。它可以帮助我们获取符号链接文件所指向的实际文件或目录</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">char</span>* buf, <span class="type">size_t</span> bufsiz)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>path：符号链接文件的路径。</li>
<li>buf：用于存储目标路径的缓冲区。</li>
<li>bufsiz：缓冲区的大小</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果读取成功，返回实际读取的字节数。</li>
<li>如果读取失败，返回 -1，并设置 errno 错误码</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> path[] = <span class="string">&quot;symlink.txt&quot;</span>;</span><br><span class="line">    <span class="type">char</span> target[<span class="number">100</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">ssize_t</span> len = <span class="built_in">readlink</span>(path, target, <span class="built_in">sizeof</span>(target) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;readlink&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    target[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;符号链接 %s 的目标路径是：%s\n&quot;</span>, path, target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上面的示例中，我们使用 readlink() 函数读取名为 “symlink.txt” 的符号链接文件的目标路径。我们提供一个缓冲区 target 来存储目标路径，并指定缓冲区的大小</li>
<li>如果读取成功，readlink() 函数返回实际读取的字节数，并将目标路径存储在缓冲区 target 中。我们在目标路径末尾添加了字符串终止符，以确保字符串的正确性。</li>
<li>需要注意的是，readlink() 函数要求传入的路径是符号链接文件的路径，而不是目标文件的路径。如果路径不是符号链接文件，或者符号链接文件不存在，readlink() 函数将返回 -1，并设置适当的错误码</li>
<li>此外，为了避免缓冲区溢出，我们应该根据实际情况来确定缓冲区的大小，并在调用 readlink() 函数之前确保缓冲区足够大</li>
<li>总结而言，readlink() 函数是一个用于读取符号链接文件目标路径的函数。它可以帮助我们获取符号链接文件所指向的实际文件或目录</li>
</ul>
</li>
</ul>
<hr>
<h2 id="strdup"><a href="#strdup" class="headerlink" title="strdup()"></a>strdup()</h2><ul>
<li>简述：转储字符串，返回一个字符指针，其存储的内容和参数<code>s</code>相同，获得的内存是使用<code>malloc()</code>完成的，因此可以使用<code>free()</code>完成</li>
<li>声明：<code>char* strdup(const char *s);</code></li>
<li>参数：<ul>
<li><code>s</code>  –  需要转储的字符串</li>
</ul>
</li>
<li>返回值：<ul>
<li>返回新存储的字符指针</li>
</ul>
</li>
</ul>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir()"></a>mkdir()</h2><ul>
<li>简述：创建一个目录<code>path</code>，并将文件权限设置为<code>mode</code></li>
<li>声明：<code>int mkdir(const char *path, __model_t mode);</code></li>
<li>参数：<ul>
<li><code>path</code>  –  目录文件路径</li>
<li><code>model</code> –  创建的目录文件的权限</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  </li>
<li>失败  –</li>
</ul>
</li>
</ul>
<h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod()"></a>chmod()</h2><ul>
<li>简述：将文件<code>file</code>的权限设置为<code>mode</code></li>
<li>声明：<code>int chmod(const char* file, mode_t mode);</code></li>
<li>参数：<ul>
<li><code>file</code>  –  需要修改的文件</li>
<li><code>mode</code>  –  权限</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  </li>
<li>失败  –</li>
</ul>
</li>
</ul>
<h2 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h2><ul>
<li>简述：以指定模式打开指定文件</li>
<li>声明：<code>int open(const char *path, int __oflag, ...);</code></li>
<li>参数：<ul>
<li><code>path</code>  –  要操作的文件，绝对路径</li>
<li><code>oflag</code> –  通常由一下常量通过或运算<code>I</code>组成<ul>
<li><code>O_RDONlY</code> 只读打开</li>
<li><code>O_WRONlY</code> 只写打开</li>
<li><code>O_RDWR</code> 读写打开</li>
<li><code>O_EXEC</code> 只执行打开</li>
<li><code>O_SEARCH</code> 只搜索（对于目录有此选项）</li>
<li>在以上五个常量中必须指定且只能指定一个，而以下常量为可选的 <ul>
<li><code>O_APPEND</code> 每次写入追加到文件末尾</li>
<li><code>O_CLOEXEC</code> 把FD_CLOEXEC设定为文件描述符</li>
<li><code>O_CREATE</code> 若文件不存在则创建， 需要指定文件权限位 ， 即mode_t 参数。</li>
<li><code>O_DIRECTORY</code> 若path指向的不为目录，则出错。</li>
<li><code>O_EXCL</code> 若同时指定O_CREATE且文件不存在，则出错。可以将测试文件存在和创建文件封装为原子操作</li>
<li><code>O_NOCTTY</code> 若path引用的是终端设备，则不将该设备分配作为该进程的控制终端</li>
<li><code>O_NONBLOCK</code> 若path引用的是一个FIFO，一个块特殊文件或者字符特殊文件，则此选项将本次文件的打开操作和后续的IO操作设置为非阻塞模式</li>
<li><code>O_SYNC</code> 每次操作需要等待物理IO完成，包括更新文件属性而需要的物理IO</li>
<li><code>O_TURNC</code> 若文件存且为只写或读写打开，那么将其长度截断为零。</li>
<li><code>O_DSYNC</code> 每次写入需要等待物理IO完成，但是如果不影响读取，则不需要更新文件属性</li>
<li><code>O_FSYNC</code> 使每一个 以文件描述符为参数的进行的read操作等待，直到所有对文件同一部分的挂起写操作都完成</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  非负整数来表示打开的文件描述符</li>
<li>失败  –  返回-1，并设置errno</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;fcntl.h&gt;</code></li>
</ul>
</li>
<li>注意：<ul>
<li>open的实现必须检测的错误及相应的错误码</li>
</ul>
</li>
</ul>
<h2 id="atoi"><a href="#atoi" class="headerlink" title="atoi()"></a>atoi()</h2><!-- + 简述：把参数 str 所指向的字符串转换为一个整数（类型为 int 型）
+ 声明：`int atoi(const char *str);`
+ 参数：
  + `str`  -- 要转换为整数的字符串
+ 返回值：
  + 成功  --  返回转换后的整数
  + 失败  --  返回零 -->

<ul>
<li><p>简介：</p>
<ul>
<li>atoi()是C++标准库中的一个函数，用于将字符串转换为整数。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>str : 要转换为整数的字符串</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果转换成功，返回对应的整数值。</li>
<li>如果无法进行有效的转换，返回0</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>函数功能<ul>
<li>atoi()函数会尝试将参数str解析为整数。它会从字符串的开头开始解析，直到遇到第一个非数字字符为止（或者字符串结束）。它会忽略前导空格字符。如果字符串为空或无法进行有效的转换，atoi()会返回0</li>
</ul>
</li>
<li>注意事项<ul>
<li>atoi()函数只能转换纯整数字符串，它不能处理带有小数点、指数符号或其他非数字字符的字符串。</li>
<li>如果字符串表示的整数超出了int类型的范围，结果可能是未定义的。</li>
<li>为了更安全和更灵活的字符串转换，可以使用C++11引入的std::stoi()函数或更高级的字符串转换库，如Boost库中的boost::lexical_cast</li>
</ul>
</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">atoi</span>(str);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted integer: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="atol"><a href="#atol" class="headerlink" title="atol()"></a>atol()</h2><ul>
<li>简述：把参数 str 所指向的字符串转换为一个长整数（类型为 long int 型）</li>
<li>声明：<code>long int atol(const char *str);</code></li>
<li>参数：<ul>
<li><code>str</code> – 要转换为长整数的字符串</li>
</ul>
</li>
<li>返回值<ul>
<li>成功  –  返回转换后的长整数</li>
<li>失败  –  返回零</li>
</ul>
</li>
</ul>
<h2 id="atof"><a href="#atof" class="headerlink" title="atof()"></a>atof()</h2><ul>
<li>简述：把参数 str 所指向的字符串转换为一个浮点数（类型为 double 型）</li>
<li>声明：<code>double atof(const char *str);</code></li>
<li>参数：<ul>
<li><code>str</code>  –  要转换为浮点数的字符串</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回转换后的双精度浮点数</li>
<li>失败  –  返回零(0.0)</li>
</ul>
</li>
</ul>
<h2 id="clock-gettime"><a href="#clock-gettime" class="headerlink" title="clock_gettime()"></a>clock_gettime()</h2><!-- + 简述：获取当前时钟的时间，并保存到参数`tp`
+ 声明：`int clock_gettime(clockid_t clock_id, struct timespec *tp);`
+ 参数：
  + `clock_id`  --  时钟ID
  + `tp`        --  `timespec` 结构体指针
+ 返回值：
  + 成功  --  
  + 失败  -- 
+ 需求：
  + 头文件：`#include <time.h>` -->

<ul>
<li><p>简介：</p>
<ul>
<li>clock_gettime() 是一个 C 标准库函数，用于获取系统时钟的时间值。它提供了更高分辨率的时间测量，可以用于精确计时和性能分析</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clock_gettime</span><span class="params">(<span class="type">clockid_t</span> clk_id, <span class="keyword">struct</span> timespec *tp)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>clk_id：一个表示时钟源的标识符，指定要获取时间值的时钟。常见的时钟源包括<ul>
<li>CLOCK_REALTIME：表示实时时钟，可用于获取实际时间。</li>
<li>CLOCK_MONOTONIC：表示单调时钟，可用于测量经过的时间，不受系统时间的影响。</li>
<li>CLOCK_PROCESS_CPUTIME_ID：表示与当前进程相关的 CPU 时间。</li>
<li>CLOCK_THREAD_CPUTIME_ID：表示与当前线程相关的 CPU 时间</li>
</ul>
</li>
<li>tp：一个指向 struct timespec 结构的指针，用于存储获取的时间值</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功时，返回 0。</li>
<li>失败时，返回 -1，并设置 errno 变量表示错误的原因</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>clock_gettime() 函数用于获取指定时钟源的时间值。</li>
<li>要使用 clock_gettime() 函数，需要包含头文件 &lt;time.h&gt;。</li>
<li>通过指定不同的时钟源，可以获取不同类型的时间值，如实际时间、单调时间或 CPU 时间。</li>
<li>时间值以 struct timespec 结构的形式返回，该结构包含了秒数和纳秒数的值。</li>
<li>clock_gettime() 函数提供了更高精度的时间测量，相比于传统的 time() 函数，可以提供更精确的时间分辨率。</li>
<li>具体可用的时钟源和支持的精度可能因操作系统而异</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timespec</span> tp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取实时时钟的时间值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">clock_gettime</span>(CLOCK_REALTIME, &amp;tp) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;clock_gettime&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出时间值的秒数和纳秒数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Seconds: %ld\n&quot;</span>, tp.tv_sec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Nanoseconds: %ld\n&quot;</span>, tp.tv_nsec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在此示例中，我们使用 clock_gettime() 函数获取实时时钟的时间值，并将结果存储在 struct timespec 结构 tp 中。然后，我们将秒数和纳秒数分别打印出来</li>
<li>需要注意的是，不同的操作系统可能支持不同的时钟源和精度，并且可能会受到系统时钟的限制。因此，在使用 clock_gettime() 函数时，应该查阅相关文档并了解操作系统的特定行为。</li>
</ul>
</li>
</ul>
<h2 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h2><ul>
<li>简述：从打开的文件流中按行读取，将保存行字符的缓冲区地址保存到<code>*line_ptr</code></li>
<li>声明：<code>size_t getline(char **lineptr, size_t *n, FILE *stream);</code></li>
<li>参数：<ul>
<li><code>lineptr</code>  –  保存读取的字符的缓冲区</li>
<li><code>n</code>        </li>
<li><code>stream</code>   –  使用<code>fopen</code>打开的文件句柄</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  存储在缓冲区中的字符数，也就是读取的字符数</li>
<li>失败  –  -1</li>
</ul>
</li>
<li>需求<ul>
<li>头文件：<code>#include &lt;stdio.h&gt;</code></li>
</ul>
</li>
<li>注意：<ul>
<li><code>lineptr</code>，如果在调用函数之前被置为 <code>NULl</code>，则在函数执行过程中会自动申请内存资源，所以需要在调用失败时，手动释放<code>lineptr</code>指向的内存资源</li>
</ul>
</li>
</ul>
<h2 id="getdelim"><a href="#getdelim" class="headerlink" title="getdelim()"></a>getdelim()</h2><ul>
<li>简述：<ul>
<li>函数应从流读取，直到遇到与定界符字符匹配的字符为止。</li>
<li>定界符参数是一个int，应用程序应确保其为终止读取过程的无符号字符表示的字符。</li>
<li>如果定界符参数具有任何其他值，则行为是不确定的，换言之，从给定文件中读取流，遇到定界符参数就终止</li>
</ul>
</li>
<li>声明：<code>_IO_ssize_t __getdelim(char **__restrict __lineptr, size_t *__restrict __n, int __delimiter, FILE *__restrict __stream);</code></li>
<li>参数：<ul>
<li><code>lineptr</code>  –  指向初始缓冲区或空指针的指针</li>
<li><code>n</code>        –  指向初始缓冲区大小的指针</li>
<li><code>delimiter</code>–  定界线字符</li>
<li><code>stream</code>   –  有效输入流，由<code>fopen()</code>打开</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  存储在缓冲区中的字符数，包括定界符，但是不包括空字符</li>
<li>失败  –  -1</li>
</ul>
</li>
</ul>
<h2 id="iscntrl"><a href="#iscntrl" class="headerlink" title="iscntrl()"></a>iscntrl()</h2><ul>
<li>简述：检查所传的字符是否是控制字符<ul>
<li>根据标准 ASCII 字符集，控制字符的 ASCII 编码介于 0x00 (NUL) 和 0x1f (US) 之间，以及 0x7f (DEL)，某些平台的特定编译器实现还可以在扩展字符集（0x7f 以上）中定义额外的控制字符</li>
</ul>
</li>
<li>声明：<code>int iscntrl(int c);</code></li>
<li>参数：<ul>
<li><code>c</code>  –  要检查的字符</li>
</ul>
</li>
<li>返回值：<ul>
<li>如果c 是一个控制字符，则返回非零值</li>
<li>否则，返回0</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;ctype.h&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy()"></a>strcpy()</h2><ul>
<li>简述：把 <code>src</code> 所指向的字符串复制到 <code>dest</code></li>
<li>声明：<code>char *strcpy(char *dest, const char *src);</code></li>
<li>参数：<ul>
<li>dest  –  指向用于存储复制内容的目标数组</li>
<li>src   –  要复制的字符串</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  该函数返回一个指向最终的目标字符串 dest 的指针</li>
<li>失败  –  NULL</li>
</ul>
</li>
<li>注意：<ul>
<li>如果目标数组 dest 不够大，而源字符串的长度又太长，可能会造成缓冲溢出的情况</li>
</ul>
</li>
</ul>
<h2 id="strncpy"><a href="#strncpy" class="headerlink" title="strncpy()"></a>strncpy()</h2><ul>
<li>简述：把 src 所指向的字符串复制到 dest，最多复制 n 个字符。当 src 的长度小于 n 时，dest 的剩余部分将用空字节填充。</li>
<li>声明：<code>char *strncpy(char *dest, const char *src, size_t n);</code></li>
<li>参数：<ul>
<li><code>dest</code>  –  指向用于存储复制内容的目标数组。</li>
<li><code>src</code>   –  要复制的字符串。</li>
<li><code>n</code>     –  要从源中复制的字符数。</li>
</ul>
</li>
<li>返回值：<ul>
<li>返回最终复制的字符串</li>
</ul>
</li>
<li>注意：<ul>
<li>strncpy 没有自动加上终止符的，需要手动加上不然会出问题的。</li>
</ul>
</li>
</ul>
<h2 id="stdio-h-库宏"><a href="#stdio-h-库宏" class="headerlink" title="stdio.h 库宏"></a><code>stdio.h</code> 库宏</h2><ul>
<li><code>NULL</code>    – 这个宏是一个空指针常量的值。</li>
<li><code>_IOFBF</code>、<code>_IOLBF</code> 和 <code>_IONBF</code> – 这些宏扩展了带有特定值的整型常量表达式，并适用于 <code>setvbuf</code> 函数的第三个参数</li>
<li><code>BUFSIZ</code>  – 这个宏是一个整数，该整数代表了 <code>setbuf</code> 函数使用的缓冲区大小  </li>
<li><code>EOF</code>     –  这个宏是一个表示已经到达文件结束的负整数</li>
<li><code>FOPEN_MAX</code>     –  这个宏是一个整数，该整数代表了系统可以同时打开的文件数量。</li>
<li><code>FILENAME_MAX</code>  –  这个宏是一个整数，该整数代表了字符数组可以存储的文件名的最大长度。如果实现没有任何限制，则该值应为推荐的最大值</li>
<li><code>L_tmpnam</code>  –  这个宏是一个整数，该整数代表了字符数组可以存储的由 <code>tmpnam</code> 函数创建的临时文件名的最大长度</li>
<li><code>SEEK_CUR</code>、<code>SEEK_END</code> 和 <code>SEEK_SET</code> – 这些宏是在 <code>fseek</code> 函数中使用，用于在一个文件中定位不同的位置</li>
<li><code>TMP_MAX</code>   –  这个宏是 <code>tmpnam</code> 函数可生成的独特文件名的最大数量</li>
<li><code>stderr</code>、<code>stdin</code> 和 <code>stdout</code>  –  这些宏是指向 <code>FILE</code> 类型的指针，分别对应于标准错误、标准输入和标准输出流</li>
</ul>
<h2 id="stdio-h库函数"><a href="#stdio-h库函数" class="headerlink" title="stdio.h库函数"></a><code>stdio.h</code>库函数</h2><ul>
<li><p><code>int fclose(FILE *stream);</code>     –  关闭流 <code>stream</code> 。刷新所有的缓冲区。</p>
</li>
<li><p><code>void clearerr(FILE *stream);</code>  –  清除给定流 <code>stream</code> 的文件结束和错误标识符。</p>
</li>
<li><p><code>int feof(FILE *stream);</code>       –  测试给定流 <code>stream</code> 的文件结束标识符</p>
</li>
<li><p><code>int ferror(FILE *stream);</code>     –  测试给定流 <code>stream</code> 的错误标识符</p>
</li>
<li><p><code>int fflush(FILE *stream);</code>     –  刷新流 <code>stream</code> 的输出缓冲区</p>
</li>
<li><p><code>int fgetpos(FILE *stream, fpos_t *pos);</code>  – 获取流 <code>stream</code> 的当前文件位置，并把它写入到 <code>pos</code></p>
</li>
<li><p><code>FILE *fopen(const char *filename, const char *mode);</code>   – 使用给定的模式 <code>mode</code> 打开 <code>filename</code> 所指向的文件</p>
</li>
<li><p><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</code>     –  从给定流 <code>stream</code> 读取数据到 <code>ptr</code> 所指向的数组中</p>
</li>
<li><p><code>FILE *freopen(const char *filename, const char *mode, FILE *stream);</code>  –  把一个新的文件名 <code>filename</code> 与给定的打开的流 <code>stream</code> 关联，同时关闭流中的旧文件</p>
</li>
<li><p><code>	int fseek(FILE *stream, long int offset, int whence);</code> – 设置流 <code>stream</code> 的文件位置为给定的偏移 <code>offset</code> ，参数 <code>offset</code> 意味着从给定的 <code>whence</code> 位置查找的字节数</p>
</li>
<li><p><code>int fsetpos(FILE *stream, const fpos_t *pos);</code>  –  设置给定流 <code>stream</code> 的文件位置为给定的位置。参数 <code>pos</code> 是由函数 <code>fgetpos</code> 给定的位置</p>
</li>
<li><p><code>long int ftell(FILE *stream);</code>     – 返回给定流 <code>stream</code> 的当前文件位置</p>
</li>
<li><p><code>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</code>  –  把 <code>ptr</code> 所指向的数组中的数据写入到给定流 <code>stream</code> 中。</p>
</li>
<li><p><code>int remove(const char *filename);</code> –  删除给定的文件名 <code>filename</code> ，以便它不再被访问</p>
</li>
<li><p><code>int rename(const char *old_filename, const char *new_filename);</code>  –  把 <code>old_filename</code> 所指向的文件名改为 <code>new_filename</code></p>
</li>
<li><p><code>void rewind(FILE *stream);</code>  –  设置文件位置为给定流 <code>stream</code> 的文件的开头</p>
</li>
<li><p><code>void setbuf(FILE *stream, char *buffer);</code>  –  定义流 <code>stream</code> 应如何缓冲。</p>
</li>
<li><p><code>int setvbuf(FILE *stream, char *buffer, int mode, size_t size);</code>  –  另一个定义流 <code>stream</code> 应如何缓冲的函数</p>
</li>
<li><p><code>FILE *tmpfile(void);</code>  –  以二进制更新模式(<code>wb+</code>)创建临时文件</p>
</li>
<li><p><code>char *tmpnam(char *str);</code>  –  生成并返回一个有效的临时文件名，该文件名之前是不存在的</p>
</li>
<li><p><code>int fprintf(FILE *stream, const char *format, ...);</code>  –  发送格式化输出到流 <code>stream</code> 中</p>
</li>
<li><p><code>int printf(const char *format, ...);</code>  –  发送格式化输出到标准输出 <code>stdout</code></p>
</li>
<li><p><code>int sprintf(char *str, const char *format, ...);</code>  –  发送格式化输出到字符串</p>
</li>
<li><p><code>int vfprintf(FILE *stream, const char *format, va_list arg);</code>  –  用参数列表发送格式化输出到流 <code>stream</code> 中</p>
</li>
<li><p><code>int vprintf(const char *format, va_list arg);</code>  –  使用参数列表发送格式化输出到标准输出 <code>stdout</code></p>
</li>
<li><p><code>int vsprintf(char *str, const char *format, va_list arg);</code>  –  使用参数列表发送格式化输出到字符串</p>
</li>
<li><p><code>int fscanf(FILE *stream, const char *format, ...);</code>  –  从流 <code>stream</code> 读取格式化输入</p>
</li>
<li><p><code>int scanf(const char *format, ...);</code>  –  从标准输入 <code>stdin</code> 读取格式化输入</p>
</li>
<li><p><code>int sscanf(const char *str, const char *format, ...);</code>  –  从字符串读取格式化输入</p>
</li>
<li><p><code>int fgetc(FILE *stream);</code>  –  从指定的流 <code>stream</code> 获取下一个字符（一个无符号字符），并把位置标识符往前移动</p>
</li>
<li><p><code>char *fgets(char *str, int n, FILE *stream);</code>  –  从指定的流 <code>stream</code> 读取一行，并把它存储在 <code>str</code> 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定</p>
</li>
<li><p><code>int fputc(int char, FILE *stream);</code>  –  把参数 <code>char</code> 指定的字符（一个无符号字符）写入到指定的流 <code>stream</code> 中，并把位置标识符往前移动</p>
</li>
<li><p><code>int fputs(const char *str, FILE *stream);</code>  –  把字符串写入到指定的流 <code>stream</code> 中，但不包括空字符</p>
</li>
<li><p><code>int getc(FILE *stream);</code>  –  从指定的流 <code>stream</code> 获取下一个字符（一个无符号字符），并把位置标识符往前移动</p>
</li>
<li><p><code>int getchar(void);</code>  –  从标准输入 <code>stdin</code> 获取一个字符（一个无符号字符）</p>
</li>
<li><p><code>char *gets(char *str);</code>  –  从标准输入 <code>stdin</code> 读取一行，并把它存储在 <code>str</code> 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定</p>
</li>
<li><p><code>int putc(int char, FILE *stream);</code>  –  把参数 <code>char</code> 指定的字符（一个无符号字符）写入到指定的流 <code>stream</code> 中，并把位置标识符往前移动</p>
</li>
<li><p><code>int putchar(int char);</code>  –  把参数 <code>char</code> 指定的字符（一个无符号字符）写入到标准输出 <code>stdout</code> 中</p>
</li>
<li><p><code>int puts(const char *str);</code>  –  把一个字符串写入到标准输出 <code>stdout</code> ，直到空字符，但不包括空字符。换行符会被追加到输出中</p>
</li>
<li><p><code>int ungetc(int char, FILE *stream);</code>  –  把字符 <code>char</code>（一个无符号字符）推入到指定的流 <code>stream</code> 中，以便它是下一个被读取到的字符</p>
</li>
<li><p><code>void perror(const char *str);</code>  –  把一个描述性错误消息输出到标准错误 stderr。首先输出字符串 <code>str</code> ，后跟一个冒号，然后是一个空格</p>
</li>
<li><p><code>int snprintf(char *str, size_t size, const char *format, ...);</code>  –  格式字符串到 <code>str</code> 中</p>
</li>
</ul>
<h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a>fopen()</h2><ul>
<li>简述：使用给定的模式(mode)打开(filename)所指向的文件</li>
<li>声明： <code>FILE *fopen(const char *filename, const char *mode);</code></li>
<li>参数：<ul>
<li><code>filename</code> – 字符串，表示要打开的文件名称</li>
<li><code>mode</code>     – 字符串，表示文件的访问模式<ul>
<li><code>r</code>  – 打开一个用于读取的文件。该文件必须存在</li>
<li><code>w</code>  – 创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件</li>
<li><code>a</code>  – 追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件</li>
<li><code>b</code>  – 以二进制模式打开文件</li>
<li><code>r+</code> – 打开一个用于更新的文件，可读取也可写入。该文件必须存在</li>
<li><code>w+</code> – 创建一个用于读写的空文件</li>
<li><code>a+</code> – 打开一个用于读取和追加的文件</li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  – 返回一个<code>FILE</code>指针</li>
<li>失败  – 返回<code>NULL</code>，且设置全局变量<code>errno</code>来标识错误</li>
</ul>
</li>
</ul>
<h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite()"></a>fwrite()</h2><ul>
<li>简述：把 <code>ptr</code> 所指向的数组中的数据写入到给定流 <code>stream</code> 中</li>
<li>声明：<code>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</code></li>
<li>参数：<ul>
<li><code>ptr</code>    – 这是指向要被写入的元素数组的指针</li>
<li><code>size</code>   – 这是要被写入的每个元素的大小，以字节为单位</li>
<li><code>nmemb</code>  – 这是元素的个数，每个元素的大小为 size 字节</li>
<li><code>stream</code> – 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  – 返回一个 size_t 对象，表示元素的总数，该对象是一个整型数据类型</li>
<li>失败  – 返回一个错误</li>
</ul>
</li>
</ul>
<h2 id="fprintf"><a href="#fprintf" class="headerlink" title="fprintf()"></a>fprintf()</h2><ul>
<li>简述：发送格式化输出到流 stream 中</li>
<li>声明：<code>int fprintf(FILE *stream, const char *format, ...);</code></li>
<li>参数：<ul>
<li>stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>
<li>format – 这是 C 字符串，包含了要被写入到流 stream 中的文本。<ul>
<li>它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。</li>
<li>format 标签属性是 <code>%[flags][width][.precision][length]specifier</code></li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回写入的字符总数</li>
<li>失败  –  返回一个负数</li>
</ul>
</li>
</ul>
<h2 id="fflush"><a href="#fflush" class="headerlink" title="fflush()"></a>fflush()</h2><ul>
<li>简述：刷新流 <code>stream</code> 的输出缓冲区</li>
<li>声明：<code>int fflush(FILE *stream);</code></li>
<li>参数：<ul>
<li><code>stream</code> – 这是指向 <code>FILE</code> 对象的指针，该 <code>FILE</code> 对象指定了一个缓冲流</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功 – 返回零值</li>
<li>失败 – 返回 EOF，且设置错误标识符（即 feof）</li>
</ul>
</li>
<li>头文件：<ul>
<li><code>stdio.h</code></li>
</ul>
</li>
</ul>
<h2 id="fseek"><a href="#fseek" class="headerlink" title="fseek()"></a>fseek()</h2><ul>
<li>简述：设置流 <code>stream</code> 的文件位置为给定的偏移 <code>offset</code>，参数 <code>offset</code> 意味着从给定的 <code>whence</code> 位置查找的字节数。</li>
<li>声明：<code>int fseek(FILE *stream, long int offset, int whence);</code></li>
<li>参数：<ul>
<li>stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流</li>
<li>offset – 这是相对 whence 的偏移量，以字节为单位</li>
<li>whence – 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：<ul>
<li>SEEK_SET  –  文件的开头</li>
<li>SEEK_CUR  –  文件指针的当前位置</li>
<li>SEEK_END  –  文件的末尾</li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功 – 返回零值</li>
<li>失败 – 返回非零值</li>
</ul>
</li>
</ul>
<h2 id="ftell"><a href="#ftell" class="headerlink" title="ftell()"></a>ftell()</h2><ul>
<li>简述：返回给定流 stream 的当前文件位置</li>
<li>声明：<code>long int ftell(FILE *stream);</code></li>
<li>参数：<ul>
<li>stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了流</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  该函数返回位置标识符的当前值</li>
<li>失败  –  返回 -1L，全局变量 errno 被设置为一个正值。</li>
</ul>
</li>
</ul>
<h2 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h2><ul>
<li><p>简述：从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内</p>
</li>
<li><p>声明：<code>char *fgets(char *str, int n, FILE *stream);</code></p>
</li>
<li><p>参数：</p>
<ul>
<li>str – 这是指向一个字符数组的指针，该数组存储了要读取的字符串。</li>
<li>n – 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度</li>
<li>stream – 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功  –  返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。</li>
<li>失败  –  返回一个空指针。</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定</li>
</ul>
</li>
<li><p>简介：</p>
<ul>
<li>fgets()函数是C标准库中用于从文件中读取一行数据的函数。</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> size, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>str：指向字符数组的指针，用于存储读取的数据。</li>
<li>size：指定要读取的最大字符数（包括换行符），即字符数组str的大小</li>
<li>stream：指定要从中读取数据的文件流指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果成功读取到数据，fgets()会返回指向字符数组str的指针</li>
<li>如果遇到文件结束或发生读取错误，fgets()会返回NULL</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>fgets()函数从指定的文件流stream中读取一行数据（包括换行符），并将其存储到字符数组str中。读取的数据包括换行符，且最多读取size - 1个字符。如果一行数据的长度超过了size - 1个字符，则fgets()会截断剩余的字符</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), file) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read line: %s&quot;</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>上述示例中，打开名为”example.txt”的文件并将其用于读取，然后调用fgets()函数从文件中读取一行数据存储到buffer数组中，并通过printf()函数将读取的行打印出来。最后关闭文件</li>
</ul>
</li>
</ul>
<h2 id="rewind"><a href="#rewind" class="headerlink" title="rewind()"></a>rewind()</h2><ul>
<li>简述：设置文件位置为给定流 <code>stream</code> 的文件的开头</li>
<li>声明：<code>void rewind(FILE *stream);</code></li>
<li>参数：<ul>
<li><code>stream</code> – 这是指向 <code>FILE</code> 对象的指针，该 <code>FILE</code> 对象标识了流。</li>
</ul>
</li>
<li>返回值：<ul>
<li>无</li>
</ul>
</li>
<li>头文件：<ul>
<li><code>stdio.h</code></li>
</ul>
</li>
</ul>
<h2 id="access"><a href="#access" class="headerlink" title="access()"></a>access()</h2><ul>
<li>简述：确定文件或文件夹的访问权限。即，检查某个文件的存取方式，例如说是只读方式，只写方式等。</li>
<li>声明：<code>int access (const char *__name, int __type);</code></li>
<li>参数<ul>
<li><code>name</code> – 文件路径</li>
<li><code>type</code> – 判断参数<ul>
<li><code>R_OK 4</code> – 读权限</li>
<li><code>W_OK 2</code> – 写权限</li>
<li><code>X_OK 1</code> – 执行权限</li>
<li><code>F_OK 0</code> – 是否存在</li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>指定的存取方式有效，则函数返回0，</li>
<li>指定的存取方式无效，则返回-1</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;unistd.h&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><!-- + 简述：通过文件名称删除文件
+ 声明：`int remove(const char* __filename);`
+ 参数：
  + `filename`  --  指向文件名的字符指针
+ 需求：
  + 头文件：`#include <stdio.h>` -->

<ul>
<li><p>简介</p>
<ul>
<li>remove() 是C标准库中的一个函数，用于删除文件</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>remove() 函数接受一个字符串参数 filename，表示要删除的文件名（包括路径）</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>如果文件删除成功，则返回值为 0</li>
<li>如果删除失败，则返回一个非零值。</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>需要注意的是，remove() 函数只能删除普通的文件，无法删除目录。如果要删除目录，需要使用操作系统提供的特定函数或命令</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;file.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remove(filename) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件删除成功\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件删除失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在上述示例中，我们尝试删除名为 “file.txt” 的文件。如果文件删除成功，则输出 “文件删除成功”，否则输出 “文件删除失败”</li>
<li>需要注意的是，删除文件是一个具有风险的操作，因此在执行删除操作之前应该谨慎确认。确保要删除的文件存在且不再需要，以免误删重要文件</li>
</ul>
</li>
</ul>
<h2 id="rename"><a href="#rename" class="headerlink" title="rename()"></a>rename()</h2><ul>
<li>简述：重命名一个文件</li>
<li>声明：<code>int rename(const char* old, const char* new);</code></li>
<li>参数：<ul>
<li><code>old</code>  –  旧的文件名</li>
<li><code>new</code>  –  新的文件名</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  – </li>
<li>失败  –</li>
</ul>
</li>
<li>需求：<ul>
<li><code>#include &lt;stdio.h&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h2><ul>
<li>简述：C库宏 允许诊断信息被写入到标准错误文件中。换句话说，它可用于在C程序中添加诊断</li>
<li>声明：<code>void assert(int expression)</code></li>
<li>参数：<ul>
<li><code>expression</code> : 这可以是一个变量或任何C表达式。<ul>
<li>如果<code>expression</code>为真，<code>assert()</code>不执行任何动作。</li>
<li>如果<code>expression</code>为假，<code>assert()</code>会在标准错误<code>stderr</code>上显示错误消息，并中止程序执行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="getenv"><a href="#getenv" class="headerlink" title="getenv()"></a>getenv()</h2><ul>
<li>简述：搜索 name 所指向的环境字符串，并返回相关的值给字符串，</li>
<li>声明：<code>#include &lt;stdlib.h&gt;  char* getenv (const char* name);</code></li>
<li>参数：<ul>
<li>name  –  包含被请求变量名称的C字符串</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回一个以NULL结尾的字符串，该字符串为被请求环境变量的值</li>
<li>失败  –  返回NULL</li>
</ul>
</li>
<li>注意：<ul>
<li>如果没有将第一次返回的字符串拷贝到缓冲区中去，多次调用<code>getenv</code>就要特别小心</li>
<li><code>getenv</code>的某些实现为返回字符串使用了静态缓冲区，<strong>每次调用时都会重写缓冲区</strong></li>
</ul>
</li>
</ul>
<h2 id="to-string"><a href="#to-string" class="headerlink" title="to_string()"></a>to_string()</h2><ul>
<li>简述:一个字符串对象，包含val作为字符序列的表示形式</li>
<li>声明：<code>string to_string(int val);</code></li>
<li>参数：<ul>
<li><code>val</code>  –  数值</li>
</ul>
</li>
</ul>
<h2 id="strcat"><a href="#strcat" class="headerlink" title="strcat()"></a>strcat()</h2><ul>
<li>简述：将源字符串的副本附加到目标字符串。目标中的终止空字符被源的第一个字符覆盖，并且在目标中两者连接形成的新字符串的末尾包含一个空字符。</li>
<li>声明：<code>char* strcat(char* destination, const char* source);</code></li>
<li>参数：<ul>
<li><code>destination</code> ： 指向目标数组的指针，它应该包含一个C字符串，并且足够大以包含连接的结果字符串。</li>
<li><code>source</code> : 要附加的C字符串，这部应该与目标字符串相同。</li>
</ul>
</li>
</ul>
<h2 id="puts"><a href="#puts" class="headerlink" title="puts()"></a>puts()</h2><ul>
<li>简述：<ul>
<li>将字符串写入标准输出。将str指向的C字符串写入标准输出(stdout)并且附加一个换行符(<code>&#39;\n&#39;</code>)。</li>
<li>该函数从指定的地址（str）开始复制，直到到达终止空字符（’\0’)。此终止空字符不会复制到流中</li>
<li>注意，puts不仅与fputs不同，它使用标准输出作为目标，而且它还在末尾自动附加一个环行符（fputs则没有）</li>
</ul>
</li>
<li>声明：<code>int puts(const char* str);</code></li>
<li>参数：<ul>
<li><code>str</code> : 需要打印的C字符串</li>
</ul>
</li>
<li>返回值<ul>
<li>成功  –  返回一个非负值</li>
<li>失败  –  该函数返回EOF并且设置错误指示符(ferror)</li>
</ul>
</li>
</ul>
<h2 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf()"></a>sprintf()</h2><ul>
<li>简述：发送格式化输出到str所指向的字符串</li>
<li>声明：<code> int sprintf(char *str, const char* format, ... )</code></li>
<li>参数：<ul>
<li><code>str</code>：这是指向一个字符数组的指针，该数组存储了C字符串</li>
<li><code>format</code>:这是字符串，包含了要被写入到字符串<code>str</code>的文本。它可以包含嵌入的<code>format</code>标签，<code>format</code>标签可被随后的附加参数中指定的值替换，并按需求进行格式化。<code>format</code>标签属性是<code>%[flags][width][.precision][length]specifier</code></li>
<li>具体详情：</li>
<li><code>specifier, 类型说明符</code>：<ul>
<li><code>c</code> : 字符</li>
<li><code>d, i</code> : 有符号的十进制整数</li>
<li><code>e</code> : 使用<code>e</code>字符的科学计数法（尾数和指数）</li>
<li><code>E</code> : 使用<code>E</code>字符的科学计数法（尾数和指数）</li>
<li><code>f</code> : 十进制浮点数</li>
<li><code>g</code> : 自动选择<code>%e</code>或<code>%f</code>中合适的表示法</li>
<li><code>G</code> : 自动选择<code>%E</code>或<code>%f</code>中合适的表示法</li>
<li><code>o</code> : 有符号八进制</li>
<li><code>s</code> : 字符的字符串</li>
<li><code>u</code> : 无符号十进制整数</li>
<li><code>x</code> : 无符号十六进制整数</li>
<li><code>X</code> : 无符号十六进制整数（大写字母）</li>
<li><code>p</code> : 指针地址</li>
<li><code>n</code> : 无输出</li>
<li><code>%</code> : 字符</li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回写入的字符总数，不包括字符串追加在字符串末尾的空字符</li>
<li>失败  –  返回一个负数</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;stdio.h&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf()"></a>snprintf()</h2><ul>
<li>简述：将格式化的输出写入大小适中的缓冲区</li>
<li>声明：<code>int snprintf(char* s, size_t n, const char* format, ...);</code></li>
<li>参数：<ul>
<li><code>s</code> – 指向存储C字符串的缓冲区的指针。这个缓冲区的大小至少要能存储<code>n</code>个字符</li>
<li><code>n</code> – 在缓冲区存储的最大字节数。通常，生成的字符串最大长度为<code>n-1</code>，留下一个空间存储空字符</li>
<li><code>format</code> – 和printf格式一样，C字符串要存储的格式</li>
</ul>
</li>
<li>返回值<ul>
<li>如果写入正常，返回被写入的字符数</li>
<li>如果错误，返回一个负数</li>
<li>只有当返回的不是一个负数，且小于<code>n</code>时，字符串才被完全写入</li>
</ul>
</li>
</ul>
<h2 id="sscanf"><a href="#sscanf" class="headerlink" title="sscanf()"></a>sscanf()</h2><ul>
<li>简述：<ul>
<li>从s读取数据并根据参数格式将它们存储到附加参数给出的位置，就像使用了scanf一样，但从s而不是标准输入（stdin）读取数据。</li>
<li>附加参数应该指向已分配的对象，其类型由格式字符串中的相应格式说明符指定。</li>
</ul>
</li>
<li>声明：<code>int sscanf(const char* s, const char* format, ...);</code></li>
<li>参数：<ul>
<li><code>s</code>  –  存储数据的指针</li>
<li><code>format</code>  –  格式化字符串</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回参数列表中成功填充的项目数。</li>
<li>失败  –  匹配预期的项目数或更少（甚至为零）</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;stdio.h&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="c-str"><a href="#c-str" class="headerlink" title="c_str()"></a>c_str()</h2><ul>
<li>返回指向包含以null结尾的字符序列（即C字符串）的数组的指针，该字符序列表示字符串对象的当前值。</li>
<li>这个数组包含构成字符串对象值的相同字符序列，以及末尾的附加终止空字符<code>\0</code> </li>
<li>返回值：指向字符串对象值的C字符串表示形式的指针。</li>
</ul>
<h2 id="strtok"><a href="#strtok" class="headerlink" title="strtok()"></a>strtok()</h2><ul>
<li>简述： 分解字符串 str 为一组字符串，delim 为分隔符</li>
<li>声明：<code>char *strtok(char *str, const char *delim);</code></li>
<li>参数：<ul>
<li>str – 要被分解成一组小字符串的字符串。</li>
<li>delim – 包含分隔符的 C 字符串。</li>
</ul>
</li>
<li>返回值：<ul>
<li>函数返回被分解的第一个子字符串</li>
<li>如果没有可检索的字符串，则返回一个空指针。</li>
</ul>
</li>
<li>注意：<ul>
<li>首次调用时，<code>str</code>指向要分解的字符串，之后再次调用要把<code>str</code>设置称为NULL</li>
<li>当strtok()在参数s的字符串中发现参数delim中包含的分割字符时,则会将该字符改为\0 字符。</li>
<li>在第一次调用时，strtok()必需给予参数s字符串，往后的调用则将参数s设置成NULL。每次调用成功则返回指向被分割出片段的指针</li>
<li>需要注意的是，<strong>使用该函数进行字符串分割时，会破坏被分解字符串的完整，调用前和调用后的s已经不一样了</strong>。</li>
<li>第一次分割之后，原字符串str是分割完成之后的第一个字符串，剩余的字符串存储在一个静态变量中，因此多线程同时访问该静态变量时，则会出现错误。</li>
</ul>
</li>
</ul>
<h2 id="strtok-r"><a href="#strtok-r" class="headerlink" title="strtok_r()"></a>strtok_r()</h2><ul>
<li>简述：linux下分割字符串的安全函数</li>
<li>声明：<code>char *strtok_r(char *str, const char *delim, char **saveptr);</code></li>
<li>参数：<ul>
<li>str – 要被分解成一组小字符串的字符串。</li>
<li>delim – 包含分隔符的 C 字符串。</li>
<li>saveptr – 保存剩余的字符</li>
</ul>
</li>
<li>返回值：<ul>
<li>函数返回被分解的第一个子字符串</li>
<li>如果没有可检索的字符串，则返回一个空指针。</li>
</ul>
</li>
<li>注意：<ul>
<li>该函数也会破坏带分解字符串的完整性，但是其将剩余的字符串保存在saveptr变量中，保证了安全性</li>
</ul>
</li>
</ul>
<h2 id="strchr和sscanf组合，按指定分隔符分割字符串"><a href="#strchr和sscanf组合，按指定分隔符分割字符串" class="headerlink" title="strchr和sscanf组合，按指定分隔符分割字符串"></a>strchr和sscanf组合，按指定分隔符分割字符串</h2><h2 id="strtol"><a href="#strtol" class="headerlink" title="strtol()"></a>strtol()</h2><ul>
<li>简述：<ul>
<li>解析C字符串str，将其内容解释为指定基数的整数，该基数作为long int返回。如果endptr不是空指针，该函数还将endptr的值设置为指向数字后的第一个字符。</li>
<li>该函数首先根据需要丢弃尽可能多的空白字符，直到找到第一个非空白字符。然后，从这个字符开始，按照依赖于基本参数的语法获取尽可能多的有效字符，并将它们解释为数值。</li>
<li>最后，指向str中整数表示之后的第一个字符的指针存储在endptr指向的对象中。</li>
</ul>
</li>
<li>声明：<code> long int strtol (const char* str, char** endptr, int base);</code></li>
<li>参数：<ul>
<li><code>str</code>:以整数表示的C字符串开头(C-string beginning with the representation of an integral number)</li>
<li><code>endptr</code>:引用<code>char*</code>类型的对象，其值由函数设置为<code>str</code>中数值之后的下一个字符。</li>
<li><code>base</code>:确定有效字符及其解释的数字基数</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功时，该函数将转换后的整数作为long int值返回</li>
<li>如果无法执行有效转换，则返回零值</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;stdlib.h&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="reserve"><a href="#reserve" class="headerlink" title="reserve()"></a>reserve()</h2><ul>
<li>简述：请求更改容量</li>
<li>声明：<code>void reserve (size_type n);</code></li>
<li>参数：<ul>
<li><code>n</code> ： 向量的最小容量。</li>
</ul>
</li>
</ul>
<h2 id="C标准库-–-stdarg-h"><a href="#C标准库-–-stdarg-h" class="headerlink" title="C标准库 – stdarg.h"></a>C标准库 – <code>stdarg.h</code></h2><ul>
<li><p>简介：</p>
<ul>
<li><code>stdarg.h</code>头文件定义了一个变量类型<code>va_list</code>和三个宏，</li>
<li>这三个宏可用于在参数个数未知（即<strong>参数个数可变</strong>）时获取函数中的参数。</li>
<li>可变参数的函数通过在参数列表的末尾是使用省略号（<code>...</code>）定义的。</li>
</ul>
</li>
<li><p><strong>库变量：</strong></p>
<ul>
<li><code>va_list</code> ： 这是一个适用于<code>va_start()</code>, <code>va_arg()</code> 和 <code>va_end()</code>这三个宏存储信息的类型。</li>
</ul>
</li>
<li><p><strong>库宏：</strong></p>
<ul>
<li><code>void va_start(va_list ap, last_arg)</code>：<ul>
<li>这个宏初始化<code>ap</code>变量，它与<code>va_arg</code>和<code>va_end</code>宏是一起使用的。<code>last_arg</code>是最后一个传递给函数的已知的固定参数，即省略号之前的参数。这个宏必须在使用<code>va_arg</code>和<code>va_end</code>之前被调用</li>
<li>参数：<ul>
<li><code>ap</code> – 这是一个<code>va_list</code>类型的对象，它用来存储通过<code>va_arg</code>获取额外参数时所必需的信息。</li>
<li><code>last_arg</code> – 最后一个传递给函数的已知的固定参数</li>
</ul>
</li>
</ul>
</li>
<li><code>void va_end(va_list ap)</code>:<ul>
<li>C库宏<code>void va_end(va_list ap)</code>允许使用了<code>va_start</code>宏的带有可变参数的函数返回。如果在从函数返回之前没有调用<code>va_end</code>，则结果为未定义</li>
<li>参数：<ul>
<li><code>ap</code> – 这是之前由同一函数中的<code>va_start</code>初始化的<code>va_list</code>对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="std-get"><a href="#std-get" class="headerlink" title="std::get()"></a>std::get()</h2><ul>
<li>简述：<ul>
<li>返回对元组<code>tpl</code>的第<code>I</code>个元素的引用。</li>
<li>版本2将元组的右值作为引用参数，向前应用到返回的元素</li>
<li>版本3将const元组作为参数，返回对元素的const引用</li>
</ul>
</li>
<li>声明：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)<span class="keyword">template</span> &lt;<span class="type">size_t</span> I, <span class="keyword">class</span>... Types&gt; <span class="keyword">typename</span> tuple_element&lt;I, tuple&lt;Types...&gt;&gt;::<span class="function">type&amp; <span class="title">get</span><span class="params">(tuple&lt;Types...&gt;&amp; tpl)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">(<span class="number">2</span>)<span class="keyword">template</span> &lt;<span class="type">size_t</span> I, <span class="keyword">class</span>... Types&gt; <span class="keyword">typename</span> tuple_element&lt;I, tuple&lt;Types...&gt;&gt;::<span class="function">type&amp;&amp; <span class="title">get</span><span class="params">(tuple&lt;Types...&gt;&amp;&amp; tpl)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">(<span class="number">3</span>)<span class="keyword">template</span> &lt;<span class="type">size_t</span> I, <span class="keyword">class</span>... Types&gt; typ</span><br><span class="line">ename tuple_element&lt;I, tuple&lt;Types...&gt;&gt;::<span class="function">type <span class="type">const</span>&amp; <span class="title">get</span><span class="params">(tuple&lt;Types...&gt;&amp; tpl)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>参数<ul>
<li><code>I</code> – 元组中元素的位置，0为第一个元素的位置，<code>size_t</code>是无符号整数类型</li>
<li><code>Types</code> – 元组中元素的类型（通常从tpl隐式获得）</li>
</ul>
</li>
<li>返回值<ul>
<li>对元组中指定位置的元素的引用</li>
</ul>
</li>
</ul>
<h2 id="fstat"><a href="#fstat" class="headerlink" title="fstat()"></a>fstat()</h2><ul>
<li>简述：获取报告与打开的文件描述符<code>fildes</code>有关的文件的状态信息</li>
<li>声明：<code>int fstat(int __fd, struct stat *__buf);</code></li>
<li>参数：<ul>
<li><code>__fd</code>  –  文件描述符</li>
<li><code>__buf</code> –  内存区域指针，用户提供的缓冲区，<code>fstat</code>将信息写入这个缓冲区</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  0</li>
<li>失败  –  1</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;sys/stat.h&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="fmemopen"><a href="#fmemopen" class="headerlink" title="fmemopen()"></a>fmemopen()</h2><ul>
<li>简述：创建一个新的引用内存缓冲区的流</li>
<li>声明：<code>FILE* fmemopen(void *s, size_t len, const char *modes);</code></li>
<li>参数：<ul>
<li><code>s</code>     –  </li>
<li><code>len</code>   – </li>
<li><code>modes</code> –</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回创建的流指针</li>
<li>失败  –</li>
</ul>
</li>
<li>注意：<ul>
<li>虽然仍使用FILE指针进行访问，但其实并没有底层文件（并没有磁盘上的实际文件，因为打开的内存流fp是在内存中的）</li>
<li>所有的I&#x2F;O都是通过在缓冲区与主存（就是内存）之间来回传送字节来完成的</li>
</ul>
</li>
</ul>
<h2 id="mmap-1"><a href="#mmap-1" class="headerlink" title="mmap()"></a>mmap()</h2><ul>
<li><p>mmap(memory map，即地址的映射)，是一种内存映射文件的方法，将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。</p>
</li>
<li><p><code>mmap()</code>系统调用，使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以访问普通内存一样对文件进行访问，不必再调用<code>read(), write()</code>等操作。</p>
</li>
<li><p>mmap()系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而POSIX或系统V的共享内存IPC则只是用于共享目的。</p>
</li>
<li><p>Linux通过内存映像机制来提供用户程序对内存直接访问的能力。内存映像的意思是把内核中特定部分的内存空间映射到用户级程序的内存空间去。也就是说，用户空间和内核空间共享一块相同的内存。</p>
</li>
<li><p>相对于传统的write&#x2F;read IO系统调用，必需先把数据从磁盘拷贝至内核缓冲区（页缓冲），然后再把数据拷贝至用户进程中。两者相比，mmap会少一次拷贝数据，这样带来的性能提升是巨大的</p>
</li>
<li><p>声明：<code>void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);</code></p>
</li>
<li><p>参数</p>
<ul>
<li><code>addr</code> – 指定文件应被映射到进程空间的起始地址，一般被指定一个空指针，此时选择起始地址的任务留给内核来完成</li>
<li><code>length</code> – 指的是映射到调用进程地址空间的字节数，它从被映射文件开头offset各字节开始算起</li>
<li><code>prot</code> – 指定共享内存的访问权限</li>
<li><code>flags</code> – 常值 ： MAP_SHARED, MAP_PRIVATE, MAP_PIXED&#96;</li>
<li><code>offset</code> – 一般设置为0，表示从文件头开始映射</li>
<li><code>fd</code> – 为即将映射到进程空间的文件描述字，一般由<code>open()</code>返回。</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>函数的返回值为最后文件映射到进程空间的地址，进程可直接操作其是地址为该值的有效地值。</li>
</ul>
</li>
<li><p>需求：</p>
<ul>
<li>头文件：<code>#include &lt;sys/mman.h&gt;</code></li>
</ul>
</li>
<li><p>具体原理：<code>https://blog.csdn.net/Holy_666/article/details/86532671</code></p>
</li>
</ul>
<h2 id="munmap"><a href="#munmap" class="headerlink" title="munmap()"></a>munmap()</h2><ul>
<li>简述：解除任何内存映射</li>
<li>声明：<code>int munmap(void* __addr, size_t __len);</code></li>
<li>参数：<ul>
<li><code>addr</code>  –  内存地址</li>
<li><code>__len</code> –  内存地址大小</li>
</ul>
</li>
<li>返回值<ul>
<li>成功  –  0</li>
<li>失败  –  -1</li>
</ul>
</li>
<li>需求：<ul>
<li>头文件：<code>#include &lt;sys/mman.h&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="锁定物理内存-–-mlock家族"><a href="#锁定物理内存-–-mlock家族" class="headerlink" title="锁定物理内存 – mlock家族"></a>锁定物理内存 – mlock家族</h2><ul>
<li><p>锁住内存是为了防止这段内存被操作系统交换掉(swap)，并且由于此操作风险高，仅超级用户可以执行。</p>
</li>
<li><p>家族成员</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mlock</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* addr, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munlock</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* addr, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mlockall</span><span class="params">(<span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munlockall</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>getpagesize()</code> 函数返回系统的分页大小，在X86 Linux系统上，这个值是4KB</p>
</li>
<li><p>如果希望程序的全部地址空间被锁定在物理内存中，使用 <code>mlockall</code> ，该函数将调用进程的全部虚拟地址空间加锁，防止出现内存交换，将该进程的地址空间交换到外存上</p>
</li>
<li><p><code>mlockall()</code> 将所有映射到进程地址空间的内存上锁，这些页包括 – 代码段，数据段，栈段，共享库，共享内存, user space kernel data, memory-mapped file。当函数成功返回的时候，所有的被映射的页都在内存中</p>
</li>
<li><p>参数</p>
<ul>
<li><code>MCL_CURRENT</code> – 仅当前已分配的内存会被锁定，之后分配的内存则不会</li>
<li><code>MCL_FUTURE</code> – 锁定之后分配的所有内存</li>
<li><code>MCL_CURRENT|MCL_FUTURE</code> – 将已经以及将来分配的所有内存锁定在物理内存中</li>
</ul>
</li>
<li><p>返回值</p>
<ul>
<li>成功返回<code>0</code></li>
<li>出错返回<code>-1</code></li>
</ul>
</li>
<li><p>此函数有两个重要的应用：</p>
<ul>
<li><code>real-time algorithms（实时算法）</code> – 对事件要求非常高</li>
<li><code>high-scurity data processing（机密数据的处理）</code> – 如果数据被交换到外存上，可能会泄密</li>
</ul>
</li>
<li><p>如果进程执行了一个<code>execve</code>类函数，所有的锁都会被删除</p>
</li>
<li><p>内存锁不会被子进程继承</p>
</li>
<li><p>内存锁不会叠加，即使多次调用<code>mlockall()</code>函数，只调用一次<code>munlockall()</code>就会解锁</p>
</li>
</ul>
<h2 id="clock-gettime-1"><a href="#clock-gettime-1" class="headerlink" title="clock_gettime()"></a>clock_gettime()</h2><ul>
<li>简述：用于计算时间，有秒和纳秒两种精度</li>
<li>函数声明：<code>int clock_gettime(clockid_t clk_id, struct timespec *tp);</code></li>
<li>参数：<ul>
<li><code>clockid_t clk_id</code>有四种<ul>
<li><code>CLOCK_REALTIME</code> – 系统实时时间，随系统实时时间改变而改变</li>
<li><code>CLOCK_MONOTONIC</code> – 从系统启动这一刻开始计时，不受系统时间被用户改变的影响</li>
<li><code>CLOCK_PROCESS_CPUTIME_ID</code> – 本进程到当前代码系统CPU花费的时间</li>
<li><code>CLOCK_THREAD_CPUTIME_ID</code> – 本线程到当前代码系统CPU花费的时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="vsscanf"><a href="#vsscanf" class="headerlink" title="vsscanf()"></a>vsscanf()</h2><ul>
<li>简述：<strong>将格式化数据从字符串读取到变量参数列表中</strong>。从s读取数据并根据参数格式将它们存储到由arg标识的变量参数列表中的元素所指向的位置。</li>
<li>声明：<code>int vsscanf(const char* s, const char* format, va_list arg);</code><ul>
<li>在内部，该函数从由arg标识的列表中检索参数，就好像在其上使用了<code>va_arg</code>一样，因此<code>arg</code>的状态可能会被调用更改。</li>
<li>无论如何，<code>arg</code>应该在调用之前的某个时间点由<code>va_start</code>初始化，并且预计在调用之后的某个时间点由<code>va_end</code>释放。</li>
</ul>
</li>
<li>参数<ul>
<li><code>s</code> – 函数将其处理为检索数据的源的C字符串</li>
<li><code>format</code> – 包含<strong>格式字符串</strong>的C字符串，该格式字符串遵循与<code>scanf</code>中的格式相同的规范</li>
<li><code>arg</code> – 一个值，用于标识使用<code>va_start</code>初始化的变量参数列表。<code>va_list</code>是在<code>&lt;cstdarg&gt;</code>中定义的特殊类型。</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功时，该函数返回参数列表中成功填充的项目数</li>
<li>在匹配失败的情况下，此计数可以匹配预期的项目数或更少，甚至为零。</li>
<li>如果在成功解释任何数据之前输入失败，则返回EOF</li>
</ul>
</li>
</ul>
<h2 id="memset"><a href="#memset" class="headerlink" title="memset()"></a>memset()</h2><!-- + 简述：将`ptr`指向的内存块的前`num`字节设置为指定值（解释为无符号字符）
+ 声明：`void* memset(void* ptr, int value, size_t num);`
+ 参数
  + `ptr` -- 指向要填充的内存块的指针
  + `value` -- 要设置的值。该值作为int传递，但是该函数使用该值的转换的无符号字符填充内存块
  + `num` -- 要设置为值的字节数。`size_t`是无符号整数类型
+ 返回值
  + 返回`ptr` -->

<ul>
<li><p>简介：</p>
<ul>
<li>memset() 是 C 标准库中的一个函数，用于将一块内存区域的每个字节设置为指定的值</li>
</ul>
</li>
<li><p>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memset</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">int</span> value, <span class="type">size_t</span> num)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数：</p>
<ul>
<li>ptr：指向要填充的内存区域的起始地址的指针。</li>
<li>value：要设置的值，以 int 类型表示。</li>
<li>num：要设置的字节数，即要填充的内存区域的大小</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>返回 ptr 的指针</li>
</ul>
</li>
<li><p>详解：</p>
<ul>
<li>memset() 函数用于将一块内存区域的每个字节设置为指定的值。</li>
<li>要使用 memset() 函数，需要包含头文件 &lt;string.h&gt;。</li>
<li>ptr 是一个指向要填充的内存区域的指针，可以是任何类型的指针。</li>
<li>value 是要设置的值，可以是 int 类型的任何有效值。通常使用 0 或 -1（表示全部位设置为 1）来初始化内存区域。</li>
<li>num 表示要填充的字节数，即要设置的内存区域的大小。</li>
<li>memset() 函数将指定的值复制到内存区域中的每个字节，可以用来初始化数组、清除敏感数据等。</li>
<li>返回的指针与 ptr 相同，指向被填充的内存区域的起始地址</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 memset() 将数组元素设置为 0</span></span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：</p>
<ul>
<li>在此示例中，我们声明了一个包含 5 个整型元素的数组 arr。然后，我们使用 memset() 函数将数组的所有元素设置为零，通过将指向数组的指针、要设置的值（0）、以及要填充的字节数（sizeof(arr)）传递给 memset() 函数来实现。最后，我们打印数组的元素，可以看到它们都被设置为零</li>
<li>需要注意的是，使用 memset() 函数时要小心，确保不会超出要填充的内存区域的边界。同时，对于包含非 char 类型元素的数组，使用 memset() 函数进行初始化时要确保所设置的值类型正确，避免产生类型不匹配的问题</li>
</ul>
</li>
</ul>
<h2 id="max"><a href="#max" class="headerlink" title="max()"></a>max()</h2><ul>
<li>简述：返回a和b中的最大值。如果两者相等，则返回a</li>
<li>声明：<code>template &lt;class T&gt; const T&amp; max (const T&amp; a, const T&amp; b);</code></li>
<li>返回值<ul>
<li>作为参数传递的最大值</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_3_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22-C_3_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_3_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22-C_3_2_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C_3_2_常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C语言常用函数</li>
</ul>
<h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><p><code>open()</code> 函数是C语言标准库中的一个函数，用于打开文件或创建新文件。它是在文件操作中非常常用的一个函数，可以用来读取、写入和创建文件。</p>
<p>以下是关于<code>open()</code>函数的详细解释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pathname</code>：表示文件路径的字符串，可以是相对路径或绝对路径。</li>
<li><code>flags</code>：表示打开文件的标志，可以是以下之一或多个标志的组合：<ul>
<li><code>O_RDONLY</code>：以只读方式打开文件。</li>
<li><code>O_WRONLY</code>：以只写方式打开文件。</li>
<li><code>O_RDWR</code>：以读写方式打开文件。</li>
<li><code>O_CREAT</code>：如果文件不存在则创建文件。</li>
<li><code>O_TRUNC</code>：如果文件存在，截断文件长度为0。</li>
<li><code>O_APPEND</code>：在文件末尾追加数据。</li>
</ul>
</li>
<li><code>mode</code>：仅在使用<code>O_CREAT</code>标志时生效，表示新创建文件的权限。</li>
</ul>
<p><code>open()</code>函数返回一个非负整数的文件描述符（file descriptor），用于后续的文件操作。如果出现错误，它返回-1。</p>
<p>以下是一个简单的示例，演示如何使用<code>open()</code>函数打开或创建文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 open() 函数创建或打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用文件描述符进行读写操作</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytesRead = read(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="type">ssize_t</span> bytesWritten = write(fd, <span class="string">&quot;Hello, World!&quot;</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bytesRead == <span class="number">-1</span> || bytesWritten == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error reading/writing file&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，我们首先使用<code>open()</code>函数打开或创建一个名为 “example.txt” 的文件，并获取文件描述符。然后，我们使用文件描述符进行读写操作，最后使用<code>close()</code>函数关闭文件描述符。</p>
<p>请注意，<code>open()</code>函数的具体参数和标志可以根据你的需求进行调整，以便执行不同的文件操作。另外，为了防止资源泄漏，务必在不再需要使用文件描述符时使用<code>close()</code>函数关闭文件。</p>
<h2 id="ceil"><a href="#ceil" class="headerlink" title="ceil"></a>ceil</h2><p>在 C 语言中，<code>ceil()</code> 是一个数学函数，用于向上取整（上取整数）。这意味着它会将一个浮点数值调整到不小于它的最小整数。<code>ceil()</code> 函数位于 <code>math.h</code> 头文件中。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">ceil</span><span class="params">(<span class="type">double</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>x</code> 是一个浮点数，函数返回大于或等于 <code>x</code> 的最小整数值。返回值是一个双精度浮点数。</p>
<p>下面是一个示例代码，演示了如何使用 <code>ceil()</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">double</span> num = <span class="number">12.34</span>;</span><br><span class="line">    <span class="type">double</span> result = <span class="built_in">ceil</span>(num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original Number: %.2f\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ceil Value: %.2f\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>ceil(12.34)</code> 的返回值是 <code>13.00</code>，因为它是不小于 <code>12.34</code> 的最小整数。</p>
<p><code>ceil()</code> 函数在很多数学计算和处理场景中非常有用，特别是在需要确保向上取整的情况下，比如计算资源分配、涉及货币的计算等。</p>
<h2 id="fnmatch"><a href="#fnmatch" class="headerlink" title="fnmatch"></a>fnmatch</h2><p><code>fnmatch()</code> 函数是C标准库中用于进行模式匹配的函数之一，它可以用来比较一个字符串是否匹配指定的模式。这个函数通常用于文件名匹配等场景。以下是关于 <code>fnmatch()</code> 函数的详细解释：</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fnmatch.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fnmatch</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pattern, <span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><code>pattern</code>：要匹配的模式字符串。</li>
<li><code>string</code>：要进行匹配的输入字符串。</li>
<li><code>flags</code>：控制匹配行为的标志位，可以是以下之一或它们的组合：<ul>
<li><code>FNM_NOESCAPE</code>：不解释反斜杠 <code>\</code> 作为转义字符。</li>
<li><code>FNM_PATHNAME</code>：模式中的斜杠只与斜杠匹配。</li>
<li><code>FNM_PERIOD</code>：模式中的起始点 <code>.</code> 只与起始点匹配。</li>
<li><code>FNM_FILE_NAME</code>：等效于 <code>FNM_PATHNAME | FNM_PERIOD</code>。</li>
</ul>
</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>如果匹配成功，返回0。</li>
<li>如果不匹配，返回 <code>FNM_NOMATCH</code>。</li>
<li>如果发生错误，返回其他非零值。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fnmatch.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pattern = <span class="string">&quot;*.txt&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *strings[] = &#123;<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;document.doc&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(strings) / <span class="keyword">sizeof</span>(strings[<span class="number">0</span>]); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fnmatch(pattern, strings[i], <span class="number">0</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s matches the pattern.\n&quot;</span>, strings[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s does not match the pattern.\n&quot;</span>, strings[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>fnmatch()</code> 函数被用来检查字符串数组中的每个元素是否匹配指定的模式。<code>pattern</code> 参数是要匹配的模式，<code>string</code> 参数是要进行匹配的字符串。函数返回0表示匹配成功，<code>FNM_NOMATCH</code> 表示不匹配。</p>
<p>需要注意的是，<code>fnmatch()</code> 函数可能会依赖于实现和操作系统的特定行为。在使用时，务必查阅操作系统和标准库的文档来了解更多细节和支持情况。</p>
<h2 id="inet-ntoa"><a href="#inet-ntoa" class="headerlink" title="inet_ntoa"></a>inet_ntoa</h2><p>在 C 语言中，<code>inet_ntoa()</code> 函数用于将网络字节序（大端字节序）的IPv4地址转换为点分十进制形式的字符串表示。它的详细说明如下：</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><code>in</code>: 一个<code>struct in_addr</code>结构体，包含要转换的IPv4地址。</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>如果转换成功，函数返回一个指向包含点分十进制IPv4地址的静态缓冲区的指针。</li>
<li>如果转换失败，函数返回NULL，并设置<code>errno</code>。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li><code>inet_ntoa()</code>函数是不可重入的（not thread-safe）。它使用了一个静态缓冲区来存储转换后的字符串。因此，如果在同一线程中多次调用<code>inet_ntoa()</code>，它会覆盖前一次的结果。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.1.100&quot;</span>, &amp;addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *ip_str = inet_ntoa(addr);</span><br><span class="line">    <span class="keyword">if</span> (ip_str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;inet_ntoa&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IPv4 Address: %s\n&quot;</span>, ip_str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们首先使用<code>inet_pton()</code>函数将字符串形式的IPv4地址转换为<code>struct in_addr</code>结构体（网络字节序）。然后，我们使用<code>inet_ntoa()</code>函数将该结构体转换为点分十进制形式的字符串，并打印出来。</p>
<p>需要注意的是，由于<code>inet_ntoa()</code>使用静态缓冲区，如果需要在同一线程中多次使用它或保留转换后的字符串内容，最好将其复制到自己管理的内存中，以避免数据覆盖问题。</p>
<h2 id="sscanf"><a href="#sscanf" class="headerlink" title="sscanf()"></a>sscanf()</h2><p><code>sscanf()</code> 函数是 C 语言标准库 <code>&lt;stdio.h&gt;</code> 中的一个函数，用于从字符串中按照格式化字符串提取数据，类似于 <code>scanf()</code> 函数。它的作用是从一个字符串中解析数据，将解析的结果按照指定格式存储到给定的变量中。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>str</code> 是一个指向要解析的输入字符串的指针。</li>
<li><code>format</code> 是一个格式字符串，规定了解析 <code>str</code> 中数据的方式。</li>
<li>可变参数表示要将解析出的数据存储的位置。</li>
</ul>
<p><code>sscanf()</code> 会尝试按照指定的格式从输入字符串 <code>str</code> 中读取数据，并根据格式字符串 <code>format</code> 的定义将数据转换为相应类型。它会跳过空白字符（空格、制表符等），然后根据 <code>format</code> 字符串的指示进行解析。</p>
<p>以下是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *input_string = <span class="string">&quot;Age: 30, Height: 175.5, Weight: 70.2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> height, weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 sscanf() 从字符串中提取数据</span></span><br><span class="line">    <span class="built_in">sscanf</span>(input_string, <span class="string">&quot;Age: %d, Height: %f, Weight: %f&quot;</span>, &amp;age, &amp;height, &amp;weight);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Age: %d\n&quot;</span>, age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Height: %.1f\n&quot;</span>, height);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Weight: %.1f\n&quot;</span>, weight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>sscanf()</code> 函数从字符串 <code>input_string</code> 中读取数据。<code>&quot;Age: %d, Height: %f, Weight: %f&quot;</code> 指示了解析字符串的格式，分别提取整数、浮点数和浮点数，并将它们存储在 <code>age</code>、<code>height</code> 和 <code>weight</code> 变量中。</p>
<p>需要注意的是，<code>sscanf()</code> 在解析字符串时，要确保格式字符串与输入字符串的格式相匹配，否则可能会导致意外的行为或错误的解析结果。此外，也要注意输入数据的有效性和边界情况，以防止缓冲区溢出等问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/asio/2024-05-22-io_context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/asio/2024-05-22-io_context/" class="post-title-link" itemprop="url">io_context</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>io_context类</li>
</ul>
<h2 id="boost-asio-io-context-详解"><a href="#boost-asio-io-context-详解" class="headerlink" title="boost::asio::io_context 详解"></a>boost::asio::io_context 详解</h2><p><code>boost::asio::io_context</code> 是 Boost.Asio 库中的一个关键类，用于提供异步 I&#x2F;O 操作的执行上下文。它是 Boost.Asio 中的事件循环，用于处理异步操作的完成、定时器的触发以及其他事件。以下是对 <code>boost::asio::io_context</code> 的一些详细解释：</p>
<ol>
<li><p><strong>事件循环（Event Loop）</strong>:<br><code>io_context</code> 提供了一个事件循环，它负责处理异步操作的完成和其他事件。在事件循环中，异步操作的回调会被调用，从而使程序能够以非阻塞的方式执行异步操作。</p>
</li>
<li><p><strong>异步操作（Asynchronous Operations）</strong>:<br><code>io_context</code> 允许你发起异步操作，比如异步读取、写入或连接。当这些操作完成时，相关的回调会被调用，使程序能够在不阻塞主线程的情况下继续执行其他任务。</p>
</li>
<li><p><strong>定时器（Timer）</strong>:<br><code>io_context</code> 允许你创建定时器，用于在未来的某个时间点触发回调。这对于实现定时任务非常有用。</p>
</li>
<li><p><strong>Work 对象</strong>:<br><code>io_context</code> 需要保持活动状态，以便事件循环能够继续执行。为了确保 <code>io_context</code> 不会在没有任务时退出，可以使用 <code>io_context::work</code> 对象。当创建了一个 <code>io_context::work</code> 对象并将其绑定到 <code>io_context</code> 上时，<code>io_context</code> 将保持活动状态，即使没有待处理的任务。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br><span class="line">boost::asio::<span class="function">io_context::work <span class="title">work</span><span class="params">(io_context)</span></span>; <span class="comment">// Keeps io_context alive</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行事件循环</strong>:<br>使用 <code>io_context::run()</code> 方法可以运行事件循环。这个方法会一直运行，直到没有任务需要处理，或者 <code>io_context</code> 被明确停止。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io_context.<span class="built_in">run</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>停止事件循环</strong>:<br>使用 <code>io_context::stop()</code> 方法可以停止事件循环。这对于在某些条件下终止异步操作很有用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io_context.<span class="built_in">stop</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多线程操作</strong>:<br><code>io_context</code> 是可线程安全的，可以在多个线程中使用。这允许你在一个线程中发起异步操作，而在另一个线程中运行事件循环。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([&amp;io_context]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    io_context.run();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这是一个简单的示例，演示了如何使用 <code>io_context</code> 进行异步操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">asyncOperation</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Async operation completed!\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Async operation failed: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::asio::<span class="function">io_context::work <span class="title">work</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post an asynchronous operation</span></span><br><span class="line">    io_context.<span class="built_in">post</span>([]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Async operation started!\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Schedule a timer to trigger asyncOperation after 1 second</span></span><br><span class="line">    boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(io_context, boost::asio::chrono::seconds(<span class="number">1</span>))</span></span>;</span><br><span class="line">    timer.<span class="built_in">async_wait</span>(&amp;asyncOperation);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the io_context event loop</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>io_context</code> 被用于启动异步操作和定时器，并通过 <code>io_context.run()</code> 来运行事件循环。异步操作和定时器的回调函数 <code>asyncOperation</code> 在相应的事件发生时被调用。</p>
<h3 id="boost-asio-io-context-io-context-int-concurrency-hint-构造函数详解"><a href="#boost-asio-io-context-io-context-int-concurrency-hint-构造函数详解" class="headerlink" title="boost::asio::io_context::io_context(int concurrency_hint) 构造函数详解"></a>boost::asio::io_context::io_context(int concurrency_hint) 构造函数详解</h3><p>在 Boost.Asio 中，<code>boost::asio::io_context</code> 的构造函数可以接受一个 <code>concurrency_hint</code> 参数，该参数用于指定期望的并发执行线程数。这个构造函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> boost::asio &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">io_context</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">io_context</span><span class="params">(<span class="type">int</span> concurrency_hint = <span class="number">0</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 其他成员函数...</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>concurrency_hint</code> 参数的作用是提示 <code>io_context</code> 库，应用程序期望在多线程环境中使用多少个线程。这并不是一个强制性的值，而是一个提示，实际的并发执行线程数可能会受到系统和运行时环境的限制。</p>
<p>在构造函数中，<code>concurrency_hint</code> 参数的默认值是0，表示没有提供并发提示，<code>io_context</code> 将会根据系统和运行时环境的默认策略来决定并发执行线程数。</p>
<p>如果提供了 <code>concurrency_hint</code> 参数，<code>io_context</code> 会尽量按照提示的值来安排并发执行线程数。这对于在多核系统上实现更好的性能是有帮助的，因为 <code>io_context</code> 在多线程环境中可以更好地利用多核处理器。</p>
<p>以下是一个简单的示例，演示了如何使用带有并发提示的 <code>io_context</code> 构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提供并发提示为2</span></span><br><span class="line">    boost::<span class="function">asio::io_context <span class="title">io_context</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里可以使用 io_context 进行异步操作、定时器等的管理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个具有并发提示为2的 <code>io_context</code> 对象。请注意，提供并发提示并不是一定能够得到期望的线程数，具体的实现可能会根据系统和运行时环境的情况进行调整。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/beast/2024-05-22-1_3_beast_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/beast/2024-05-22-1_3_beast_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">1_3_beast_常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>beast常用函数</li>
</ul>
<h2 id="boost-beast-async-write-函数-详解"><a href="#boost-beast-async-write-函数-详解" class="headerlink" title="boost::beast::async_write() 函数 详解"></a>boost::beast::async_write() 函数 详解</h2><p>在 Boost.Beast 库中，<code>boost::beast::async_write()</code> 函数是用于执行异步写入操作的函数。这个函数用于向底层的异步写入流（例如 TCP 流或 SSL 流）写入数据，并在操作完成时调用用户提供的回调函数。</p>
<p>以下是 <code>boost::beast::async_write()</code> 函数的详细说明：</p>
<ol>
<li><p><strong>函数签名：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Stream, <span class="keyword">class</span> ConstBufferSequence, <span class="keyword">class</span> WriteHandler&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_write</span><span class="params">(Stream&amp; stream, <span class="type">const</span> ConstBufferSequence&amp; buffers, WriteHandler&amp;&amp; handler)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>Stream</code>：表示底层异步写入流的类型，例如 <code>boost::asio::ip::tcp::socket</code> 或 <code>boost::asio::ssl::stream&lt;boost::asio::ip::tcp::socket&gt;</code>。</p>
</li>
<li><p><code>ConstBufferSequence</code>：表示要写入的数据的缓冲区序列，可以是单个缓冲区或缓冲区数组。</p>
</li>
<li><p><code>WriteHandler</code>：表示写入操作完成后要调用的回调函数类型。</p>
</li>
</ul>
</li>
<li><p><strong>参数解释：</strong></p>
<ul>
<li><p><code>stream</code>：表示异步写入流，可以是 TCP 流或 SSL 流等。</p>
</li>
<li><p><code>buffers</code>：表示要写入的数据，可以是单个缓冲区或缓冲区序列。</p>
</li>
<li><p><code>handler</code>：是写入操作完成后将被调用的回调函数。回调函数的签名应为 <code>void(error_code, size_t)</code>，其中 <code>error_code</code> 表示异步操作的错误码，<code>size_t</code> 表示实际写入的字节数。</p>
</li>
</ul>
</li>
<li><p><strong>使用场景：</strong></p>
<ul>
<li><p><strong>异步写入数据：</strong> <code>async_write</code> 用于在异步模式下写入数据到异步写入流中。</p>
</li>
<li><p><strong>处理写入完成的回调：</strong> 用户可以通过提供回调函数来处理写入操作完成后的事件。</p>
</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/ip/tcp.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> beast = boost::beast;</span><br><span class="line"><span class="keyword">namespace</span> asio = boost::asio;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些数据准备</span></span><br><span class="line">    std::string data = <span class="string">&quot;Hello, Boost.Beast!&quot;</span>;</span><br><span class="line">    beast::error_code ec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步写入数据到流中</span></span><br><span class="line">    beast::<span class="built_in">async_write</span>(socket, asio::<span class="built_in">buffer</span>(data), [&amp;](beast::error_code write_ec, std::<span class="type">size_t</span> bytes_transferred) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!write_ec) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Async write successful. Bytes transferred: &quot;</span> &lt;&lt; bytes_transferred &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Async write error: &quot;</span> &lt;&lt; write_ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>async_write</code> 函数用于将数据异步写入到 TCP 流中。一旦写入操作完成，指定的回调函数将被调用。</p>
</li>
</ol>
<p>总的来说，<code>boost::beast::async_write()</code> 函数是 Boost.Beast 中用于执行异步写入操作的函数，适用于异步写入流的情况，如 TCP 流或 SSL 流。</p>
<h2 id="boost-beast-http-async-read-函数-详解"><a href="#boost-beast-http-async-read-函数-详解" class="headerlink" title="boost::beast::http::async_read() 函数 详解"></a>boost::beast::http::async_read() 函数 详解</h2><p><code>boost::beast::http::async_read()</code> 函数是 Boost.Beast 库中用于异步读取 HTTP 消息的函数。这个函数支持在异步操作中读取 HTTP 请求或响应。</p>
<p>以下是对 <code>boost::beast::http::async_read()</code> 函数的详细说明：</p>
<ol>
<li><p><strong>函数签名：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Stream, <span class="keyword">typename</span> Body, <span class="keyword">typename</span> Allocator, <span class="keyword">typename</span> ReadHandler&gt;</span><br><span class="line"><span class="built_in">BOOST_BEAST_ASYNC_RESULT1</span>(ReadHandler)</span><br><span class="line"><span class="built_in">async_read</span>(Stream&amp; stream, message&lt;isRequest, Body, Fields, Allocator&gt;&amp; msg, ReadHandler&amp;&amp; handler);</span><br></pre></td></tr></table></figure>

<p>这个函数接受一个 <code>Stream</code> 对象，一个表示消息的 <code>message</code> 对象，以及一个回调函数 <code>ReadHandler</code>。<code>message</code> 模板参数包括消息的类型（请求或响应）、消息体类型、消息头类型和消息体分配器类型。</p>
</li>
<li><p><strong>参数解释：</strong></p>
<ul>
<li><p><code>Stream&amp; stream</code>：表示数据流的对象，通常是 <code>boost::beast::tcp_stream</code> 或 <code>boost::asio::ssl::stream</code>。</p>
</li>
<li><p><code>message&lt;isRequest, Body, Fields, Allocator&gt;&amp; msg</code>：表示 HTTP 消息的对象，<code>isRequest</code> 表示消息类型，<code>Body</code> 表示消息体类型，<code>Fields</code> 表示消息头类型，<code>Allocator</code> 表示消息体的分配器类型。</p>
</li>
<li><p><code>ReadHandler&amp;&amp; handler</code>：表示异步操作完成后要调用的回调函数。回调函数签名应为 <code>void(boost::system::error_code, std::size_t)</code>。</p>
</li>
</ul>
</li>
<li><p><strong>使用场景：</strong></p>
<ul>
<li><p><strong>异步读取 HTTP 请求或响应：</strong> <code>async_read</code> 通常用于异步读取 HTTP 请求或响应。可以使用它来从输入流中读取并解析 HTTP 消息。</p>
</li>
<li><p><strong>与异步操作配合使用：</strong> <code>async_read</code> 适用于与 Boost.Asio 库的异步操作一起使用，以确保在非阻塞的情况下执行 HTTP 读取操作。</p>
</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/io_context.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> beast = boost::beast;</span><br><span class="line"><span class="keyword">namespace</span> http = boost::beast::http;</span><br><span class="line"><span class="keyword">namespace</span> asio = boost::asio;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    <span class="function">beast::tcp_stream <span class="title">stream</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 HTTP 请求消息</span></span><br><span class="line">    http::request&lt;http::string_body&gt; request;</span><br><span class="line">    request.<span class="built_in">method</span>(http::verb::get);</span><br><span class="line">    request.<span class="built_in">target</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    request.<span class="built_in">version</span>(<span class="number">11</span>);</span><br><span class="line">    request.<span class="built_in">set</span>(http::field::host, <span class="string">&quot;www.example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步读取 HTTP 请求消息</span></span><br><span class="line">    http::<span class="built_in">async_read</span>(stream, buffer, request, [&amp;](<span class="type">const</span> beast::error_code&amp; ec, std::<span class="type">size_t</span> bytes_transferred) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Bytes transferred: &quot;</span> &lt;&lt; bytes_transferred &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;HTTP Request: &quot;</span> &lt;&lt; request &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Error in async_read: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>async_read</code> 用于从 <code>stream</code> 中异步读取 HTTP 请求，并在完成后调用指定的回调函数。</p>
</li>
</ol>
<p>总的来说，<code>boost::beast::http::async_read()</code> 函数是 Boost.Beast 库中用于异步读取 HTTP 消息的关键函数，适用于异步操作场景。</p>
<h2 id="boost-beast-tcp-stream-expires-after-函数-详解"><a href="#boost-beast-tcp-stream-expires-after-函数-详解" class="headerlink" title="boost::beast::tcp_stream::expires_after() 函数 详解"></a>boost::beast::tcp_stream::expires_after() 函数 详解</h2><p><code>boost::beast::tcp_stream::expires_after()</code> 函数是 Boost.Beast 库中的成员函数，用于设置 TCP 流的超时时间。这个函数是用于异步操作的，它指定了在指定的时间段之后，相关的异步操作应该被取消。</p>
<p>以下是对 <code>expires_after()</code> 函数的详细说明：</p>
<ol>
<li><p><strong>函数签名：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Duration&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">expires_after</span><span class="params">(Duration d)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数接受一个表示时间段的 <code>Duration</code> 参数，并设置 TCP 流的超时时间。<code>Duration</code> 可以是 <code>std::chrono::duration</code> 类型，用于表示一段时间，例如 <code>std::chrono::seconds</code>。</p>
</li>
<li><p><strong>参数解释：</strong></p>
<ul>
<li><code>Duration d</code>：表示超时时间的时间段。</li>
</ul>
</li>
<li><p><strong>使用场景：</strong></p>
<ul>
<li><p><strong>设置异步操作的超时时间：</strong> <code>expires_after</code> 通常用于设置异步操作的超时时间。一旦超过指定的时间段，相关的异步操作将被取消，以防止无限期地等待。</p>
</li>
<li><p><strong>管理异步操作的生命周期：</strong> 超时机制有助于管理异步操作的生命周期，避免因为某些原因导致操作一直挂起而不结束。</p>
</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/io_context.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::<span class="function">beast::tcp_stream <span class="title">stream</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时时间为5秒</span></span><br><span class="line">    stream.<span class="built_in">expires_after</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在指定的超时时间内进行异步操作</span></span><br><span class="line">    stream.<span class="built_in">async_connect</span>(&#123;<span class="comment">/* endpoint details */</span>&#125;, [&amp;](boost::system::error_code ec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Connection established within the timeout period&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ec == boost::asio::error::operation_aborted) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Operation aborted due to timeout&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Error in async_connect: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>expires_after</code> 用于设置超时时间为5秒，然后通过 <code>async_connect</code> 进行异步连接。如果在超时时间内成功建立连接，或者超时时间到达时连接还未建立，相关的回调函数将被调用。</p>
</li>
</ol>
<p>总的来说，<code>boost::beast::tcp_stream::expires_after()</code> 用于设置 TCP 流的超时时间，是管理异步操作超时的一种方式。</p>
<h2 id="boost-beast-tcp-stream-get-executor-函数-详解"><a href="#boost-beast-tcp-stream-get-executor-函数-详解" class="headerlink" title="boost::beast::tcp_stream::get_executor() 函数 详解"></a>boost::beast::tcp_stream::get_executor() 函数 详解</h2><p><code>boost::beast::tcp_stream::get_executor()</code> 函数是用于获取与 <code>tcp_stream</code> 关联的执行器（executor）的成员函数。在 Boost.Beast 中，执行器是与异步操作相关的上下文和策略的抽象。</p>
<p>以下是对 <code>get_executor()</code> 函数的详细说明：</p>
<ol>
<li><p><strong>函数签名：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_executor</span><span class="params">()</span> -&gt; executor_type</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数返回 <code>executor_type</code>，是一个与 <code>tcp_stream</code> 关联的执行器类型。<code>executor_type</code> 是一个满足 <code>Executor</code> 概念的类型，它负责协调和调度与 <code>tcp_stream</code> 相关的异步操作。</p>
</li>
<li><p><strong>使用场景：</strong></p>
<ul>
<li><p><strong>与其他异步操作一起使用：</strong> 获取执行器后，可以将其传递给其他异步操作，以确保它们在相同的上下文中执行。</p>
</li>
<li><p><strong>管理异步操作的生命周期：</strong> 使用执行器可以更容易地管理异步操作的生命周期，以及确保它们在适当的上下文中执行。</p>
</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/io_context.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::<span class="function">beast::tcp_stream <span class="title">stream</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取与 tcp_stream 关联的执行器</span></span><br><span class="line">    <span class="keyword">auto</span> executor = stream.<span class="built_in">get_executor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行器的上下文中进行异步操作</span></span><br><span class="line">    boost::asio::<span class="built_in">post</span>(executor, [&amp;]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Async operation in the context of the executor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>get_executor()</code> 用于获取与 <code>tcp_stream</code> 关联的执行器，并使用 <code>post</code> 函数在执行器的上下文中执行异步操作。</p>
</li>
</ol>
<p>总的来说，<code>get_executor()</code> 函数是一个有用的工具，可以帮助管理异步操作的执行上下文，并确保它们在正确的地方执行。</p>
<h2 id="boost-beast-bind-front-handler"><a href="#boost-beast-bind-front-handler" class="headerlink" title="boost::beast::bind_front_handler()"></a>boost::beast::bind_front_handler()</h2><p>在 Boost.Beast 库中，<code>boost::beast::bind_front_handler()</code> 函数用于绑定参数并创建一个绑定了特定处理程序的函数对象。这个函数通常用于为异步操作提供参数，以及在回调函数中调用其他函数。</p>
<p>以下是 <code>boost::beast::bind_front_handler()</code> 函数的详细解释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Function, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bind_front_handler</span><span class="params">(Function&amp;&amp; f, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>Function</code>: 要绑定的处理程序的类型，通常是一个函数对象或可调用对象。</p>
</li>
<li><p><code>Args</code>: 要绑定到处理程序的参数的类型。</p>
</li>
</ul>
<p>这个函数返回一个函数对象，该对象包装了原始的处理程序，并带有预先绑定的参数。这可以用于将参数传递给异步操作的回调函数，而无需修改回调函数的签名。</p>
<p>以下是一个简单的例子，演示了 <code>bind_front_handler</code> 的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/core/bind_handler.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">const</span> boost::system::error_code&amp; error)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Callback: &quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 bind_front_handler 绑定参数</span></span><br><span class="line">    <span class="keyword">auto</span> boundCallback = boost::beast::<span class="built_in">bind_front_handler</span>(callback, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟异步操作，传递 error_code 作为回调参数</span></span><br><span class="line">    io_context.<span class="built_in">post</span>([boundCallback]() &#123;</span><br><span class="line">        boost::system::error_code error;</span><br><span class="line">        <span class="built_in">boundCallback</span>(error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 io_context 事件循环</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>bind_front_handler</code> 被用于绑定两个整数参数到 <code>callback</code> 函数。然后，使用 <code>io_context.post</code> 模拟了一个异步操作，调用了带有绑定参数的回调函数。这样，就可以在回调函数中使用预先绑定的参数，而无需修改回调函数的签名。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/beast/2024-05-22-1_3_beast_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/beast/2024-05-22-1_3_beast_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">1_3_beast_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Boost.Beast模块相关笔记</li>
</ul>
<h2 id="Boost-Beast模块-详解"><a href="#Boost-Beast模块-详解" class="headerlink" title="Boost.Beast模块 详解"></a>Boost.Beast模块 详解</h2><p>Boost.Beast 是 Boost 库中的一个模块，提供了对 HTTP、WebSocket 和网络通信的支持。它建立在 Boost.Asio 之上，为 C++ 开发者提供了处理网络通信和协议的高级接口。</p>
<p>Boost.Beast 主要包含以下功能和特性：</p>
<ol>
<li><p><strong>HTTP 和 WebSocket 支持</strong>：<br>Boost.Beast 提供了用于处理 HTTP 和 WebSocket 协议的功能。它可以处理 HTTP 请求和响应的解析、生成和序列化，支持 HTTP&#x2F;1.0、HTTP&#x2F;1.1 和部分 HTTP&#x2F;2 特性。同时，Boost.Beast 也支持 WebSocket 的握手、消息发送和接收。</p>
</li>
<li><p><strong>异步 I&#x2F;O 操作</strong>：<br>基于 Boost.Asio，Boost.Beast 支持异步 I&#x2F;O 操作，允许开发者执行非阻塞的网络通信。这使得在处理大量连接时能够高效地管理多个并发操作。</p>
</li>
<li><p><strong>网络编程抽象</strong>：<br>Boost.Beast 提供了更高层次的抽象，简化了使用 Boost.Asio 进行网络编程的过程。它封装了许多底层操作，提供了更易于使用的接口，使得编写网络应用程序更加方便。</p>
</li>
<li><p><strong>WebSocket 支持</strong>：<br>除了 HTTP，Boost.Beast 还提供了对 WebSocket 协议的支持。它允许开发者构建 WebSocket 服务器和客户端，实现双向通信的功能。</p>
</li>
<li><p><strong>TLS&#x2F;SSL 支持</strong>：<br>Boost.Beast 支持通过 Boost.Asio 的 SSL 接口进行安全的 TLS&#x2F;SSL 通信。这使得可以在网络通信中使用加密的安全通道，增加了数据传输的安全性。</p>
</li>
</ol>
<p>以下是一个简单的示例，展示了使用 Boost.Beast 构建一个简单的 HTTP 服务器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and bind an acceptor</span></span><br><span class="line">    asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, asio::ip::tcp::endpoint(asio::ip::tcp::v4(), <span class="number">8080</span>))</span></span>;</span><br><span class="line">    acceptor.<span class="built_in">listen</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">        acceptor.<span class="built_in">accept</span>(socket);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            beast::flat_buffer buffer;</span><br><span class="line">            beast::http::request&lt;beast::http::string_body&gt; request;</span><br><span class="line"></span><br><span class="line">            beast::http::<span class="built_in">read</span>(socket, buffer, request);</span><br><span class="line"></span><br><span class="line">            beast::http::response&lt;beast::http::string_body&gt; response&#123;beast::http::status::ok, request.<span class="built_in">version</span>()&#125;;</span><br><span class="line">            response.<span class="built_in">set</span>(beast::http::field::server, <span class="string">&quot;Boost HTTP Server&quot;</span>);</span><br><span class="line">            response.<span class="built_in">body</span>() = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">            response.<span class="built_in">prepare_payload</span>();</span><br><span class="line"></span><br><span class="line">            beast::http::<span class="built_in">write</span>(socket, response);</span><br><span class="line">        &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个简单的示例展示了一个基于 Boost.Beast 的简单 HTTP 服务器，监听端口 8080。它接受客户端连接并向客户端发送 “Hello, World!” 作为 HTTP 响应。</p>
<p>Boost.Beast 提供了更高层次的抽象和功能，使得处理 HTTP 和 WebSocket 协议变得更加简单和便捷。但是，要构建更完整和复杂的网络应用程序，可能需要更多的学习和深入了解网络编程以及 Boost.Beast 的 API 和特性。</p>
<h2 id="Boost-Beast模块-实现异步响应的HTTP服务器"><a href="#Boost-Beast模块-实现异步响应的HTTP服务器" class="headerlink" title="Boost.Beast模块 实现异步响应的HTTP服务器"></a>Boost.Beast模块 实现异步响应的HTTP服务器</h2><p>下面是一个简单的示例，演示了如何使用 Boost.Beast 模块实现一个异步的 HTTP 服务器，处理来自客户端的 HTTP 请求并异步发送响应。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/http.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> beast = boost::beast;</span><br><span class="line"><span class="keyword">namespace</span> http = beast::http;</span><br><span class="line"><span class="keyword">namespace</span> net = boost::asio;</span><br><span class="line"><span class="keyword">using</span> tcp = boost::asio::ip::tcp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle_request</span><span class="params">(<span class="type">const</span> http::request&lt;http::string_body&gt;&amp; req, http::response&lt;http::string_body&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理请求</span></span><br><span class="line">    <span class="keyword">if</span> (req.<span class="built_in">method</span>() == http::verb::get &amp;&amp; req.<span class="built_in">target</span>() == <span class="string">&quot;/hello&quot;</span>) &#123;</span><br><span class="line">        res.<span class="built_in">result</span>(http::status::ok);</span><br><span class="line">        res.<span class="built_in">set</span>(http::field::server, <span class="string">&quot;AsyncBoostServer&quot;</span>);</span><br><span class="line">        res.<span class="built_in">set</span>(http::field::content_type, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        res.<span class="built_in">keep_alive</span>(req.<span class="built_in">keep_alive</span>());</span><br><span class="line">        res.<span class="built_in">body</span>() = <span class="string">&quot;Hello, Boost.Beast!&quot;</span>;</span><br><span class="line">        res.<span class="built_in">prepare_payload</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.<span class="built_in">result</span>(http::status::not_found);</span><br><span class="line">        res.<span class="built_in">keep_alive</span>(req.<span class="built_in">keep_alive</span>());</span><br><span class="line">        res.<span class="built_in">body</span>() = <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line">        res.<span class="built_in">prepare_payload</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_session</span><span class="params">(tcp::socket&amp; socket)</span> </span>&#123;</span><br><span class="line">    beast::error_code ec;</span><br><span class="line">    beast::flat_buffer buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取请求</span></span><br><span class="line">    http::request&lt;http::string_body&gt; req;</span><br><span class="line">    http::<span class="built_in">read</span>(socket, buffer, req, ec);</span><br><span class="line">    <span class="keyword">if</span> (ec == http::error::end_of_stream) &#123;</span><br><span class="line">        socket.<span class="built_in">shutdown</span>(tcp::socket::shutdown_send, ec);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error reading HTTP request: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理请求</span></span><br><span class="line">    http::response&lt;http::string_body&gt; res;</span><br><span class="line">    <span class="built_in">handle_request</span>(req, res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入响应</span></span><br><span class="line">    http::<span class="built_in">write</span>(socket, res, ec);</span><br><span class="line">    <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error writing HTTP response: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        net::io_context io_context;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建监听端点</span></span><br><span class="line">        <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, &#123;tcp::v4(), <span class="number">8080</span>&#125;)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Server started and listening on port 8080&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">            acceptor.<span class="built_in">accept</span>(socket);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异步处理会话</span></span><br><span class="line">            net::<span class="built_in">post</span>(io_context, [&amp;socket]() &#123;</span><br><span class="line">                <span class="built_in">do_session</span>(socket);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例创建了一个简单的异步 HTTP 服务器，监听端口 <code>8080</code>。它使用 Boost.Beast 提供的函数来处理 HTTP 请求和生成相应的 HTTP 响应。在 <code>do_session()</code> 函数中，它异步地处理了每个传入的连接，并使用 <code>handle_request()</code> 函数根据请求的内容来生成响应。使用 <code>net::post()</code> 异步执行会话处理，确保在异步处理完成之前不会阻塞主线程。</p>
<p>请注意，这只是一个简单的示例。在实际的应用程序中，可能需要添加更多的错误处理、请求解析、路由处理和更复杂的逻辑。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/asio/2024-05-22-%E5%9F%BA%E4%BA%8EBoost_asio%E7%9A%84C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/asio/2024-05-22-%E5%9F%BA%E4%BA%8EBoost_asio%E7%9A%84C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">基于Boost_asio的C++网络编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>关于Boost.asio库的笔记，原文链接: <a target="_blank" rel="noopener" href="https://xzchsia.github.io/2020/03/06/boost-asio-learning/">https://xzchsia.github.io/2020/03/06/boost-asio-learning/</a></li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>Asio,即 异步IO(Asynchronous Input&#x2F;Output)，本是一个独立的C++网络程序库，后来加入Boost</p>
</li>
<li><p>从设计上来看，Asio 相似且重度依赖于 Boost，与 thread、bind、smart pointers 等结合时，体验顺滑。从使用上来看，依然是重组合而轻继承，一贯的 C++ 标准库风格</p>
</li>
<li><p>什么是异步IO？</p>
<ul>
<li>简单来说，就是你发起一个 IO 操作，却不用等它结束，你可以继续做其他事情，当它结束时，你会得到通知。</li>
</ul>
</li>
<li><p>当然这种表述是不精确的，操作系统并没有直接提供这样的机制。以 Unix 为例，有五种 IO 模型可用：</p>
<ul>
<li>阻塞 I&#x2F;O</li>
<li>非阻塞 I&#x2F;O</li>
<li>I&#x2F;O 多路复用（multiplexing）（select 和 poll）</li>
<li>信号驱动 I&#x2F;O（SIGIO）</li>
<li>异步 I&#x2F;O（POSIX aio_ 系列函数）</li>
</ul>
</li>
<li><p>这五种模型的定义和比较，详见「Unix Network Programming, Volume 1: The Sockets Networking API」一书 6.2 节</p>
</li>
<li><p>Asio 封装的正是「I&#x2F;O 多路复用」。具体一点，epoll 之于 Linux，kqueue 之于 Mac 和 BSD。epoll 和 kqueue 比 select 和 poll 更高效。当然在 Windows 上封装的则是 IOCP（完成端口）</p>
</li>
<li><p>Asio 的「I&#x2F;O 操作」，主要还是指「网络 IO」，比如 socket 读写。由于网络传输的特性，「网络 IO」相对比较费时，设计良好的服务器，不可能同步等待一个 IO 操作的结束，这太浪费 CPU 了。</p>
</li>
<li><p>对于普通的「文件 IO」，操作系统并没有提供“异步”读写机制，libuv 的做法是用线程模拟异步，为网络和文件提供了一致的接口。Asio 并没有这样做，它专注于网络。提供机制而不是策略，这很符合 C++ 哲学</p>
</li>
</ul>
<h2 id="I-O-Context"><a href="#I-O-Context" class="headerlink" title="I&#x2F;O Context"></a>I&#x2F;O Context</h2><ul>
<li>每个 Asio 程序都至少有一个 io_context 对象，它代表了操作系统的 I&#x2F;O 服务（io_context 在 Boost 1.66 之前一直叫 io_service），把你的程序和这些服务链接起来<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  ioc.<span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>io_context.run 是一个阻塞（blocking）调用，姑且把它想象成一个 loop（事件循环），直到所有异步操作完成后，loop 才结束，run 才返回。但是这个程序没有任何异步操作，所以 loop 直接就结束了</li>
</ul>
<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><ul>
<li><p>有了 io_context 还不足以完成 I&#x2F;O 操作，用户一般也不跟 io_context 直接交互</p>
</li>
<li><p>根据 I&#x2F;O 操作的不同，Asio 提供了不同的 I&#x2F;O 对象，比如 timer（定时器），socket，等等。 Timer 是最简单的一种 I&#x2F;O 对象，可以用来实现异步调用的超时机制，下面是最简单的用法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(boost::system::error_code ec)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(ioc, std::chrono::seconds(<span class="number">3</span>))</span></span>;</span><br><span class="line">  timer.<span class="built_in">async_wait</span>(&amp;Print);</span><br><span class="line">  ioc.<span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>先创建一个 steady_timer，指定时间 3 秒，然后异步等待这个 timer，3 秒后，timer 超时结束，Print 被调用</p>
</li>
<li><p>以下几点需要注意：</p>
<ul>
<li>所有 I&#x2F;O 对象都依赖 io_context，一般在构造时指定</li>
<li>async_wait 初始化了一个异步操作，但是这个异步操作的执行，要等到 io_context.run 时才开始</li>
<li>Timer 除了异步等待（async_wait），还可以同步等待（wait）。同步等待是阻塞的，直到 timer 超时结束。基本上所有 I&#x2F;O 对象的操作都有同步和异步两个版本，也许是出于设计上的完整性</li>
<li>async_wait 的参数是一个函数对象，异步操作完成时它会被调用，所以也叫 completion handler，简称 handler，可以理解成回调函数</li>
<li>所有 I&#x2F;O 对象的 async_xyz 函数都有 handler 参数，对于 handler 的签名，不同的异步操作有不同的要求，除了官方文档里的说明，也可以直接查看 Boost 源码。</li>
</ul>
</li>
<li><p>async_wait 的 handler 签名为 void (boost::system::error_code)，如果要传递额外的参数，就得用 bind</p>
</li>
<li><p>不妨修改一下 Print，让它每隔一秒打印一次计数，从 0 递增到 3</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(boost::system::error_code ec,</span></span></span><br><span class="line"><span class="params"><span class="function">           boost::asio::steady_timer* timer,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">int</span>* count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (*count &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; *count &lt;&lt; std::endl;</span><br><span class="line">    ++(*count);</span><br><span class="line"></span><br><span class="line">    timer-&gt;<span class="built_in">expires_after</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    timer-&gt;<span class="built_in">async_wait</span>(std::<span class="built_in">bind</span>(&amp;Print, std::placeholders::_1, timer, count));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(ioc, std::chrono::seconds(<span class="number">1</span>))</span></span>;</span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  timer.<span class="built_in">async_wait</span>(std::<span class="built_in">bind</span>(&amp;Print, std::placeholders::_1, &amp;timer, &amp;count));</span><br><span class="line"></span><br><span class="line">  ioc.<span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>与前版相比，Print 多了两个参数，以便访问当前计数及重启 timer。</p>
</li>
<li><p>调用 bind 时，使用了占位符（placeholder）std::placeholders::_1。数字占位符共有 9 个，_1 - _9</p>
</li>
</ul>
<h2 id="Echo-Server"><a href="#Echo-Server" class="headerlink" title="Echo Server"></a>Echo Server</h2><ul>
<li>Socket 也是一种 I&#x2F;O 对象，这一点前面已经提及。相比于 timer，socket 更为常用，毕竟 Asio 是一个网络程序库</li>
<li>下面以经典的 Echo 程序为例，实现一个 TCP Server。所谓 Echo，就是 Server 把 Client 发来的内容原封不动发回给 Client</li>
</ul>
<h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><ul>
<li><p>Session 代表会话，负责管理一个 client 的连接。参数 socket 传的是值，但是会用到 move 语义来避免拷贝</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session</span><span class="params">(tcp::socket socket)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      boost::array&lt;<span class="type">char</span>, BUF_SIZE&gt; data;</span><br><span class="line"></span><br><span class="line">      boost::system::error_code ec;</span><br><span class="line">      std::<span class="type">size_t</span> length = socket.<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(data), ec);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ec == boost::asio::error::eof) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;连接被 client 妥善的关闭了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">        <span class="comment">// 其他错误</span></span><br><span class="line">        <span class="keyword">throw</span> boost::system::<span class="built_in">system_error</span>(ec);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      boost::asio::<span class="built_in">write</span>(socket, boost::asio::<span class="built_in">buffer</span>(data, length));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt;  e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其中，tcp 即 boost::asio::ip::tcp；BUF_SIZE 定义为 enum { BUF_SIZE &#x3D; 1024 };。这些都是细节，后面的例子不再赘述</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;port&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> port = std::<span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 Acceptor 侦听新的连接</span></span><br><span class="line">  <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ioc, tcp::endpoint(tcp::v4(), port))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 一次处理一个连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="built_in">Session</span>(acceptor.<span class="built_in">accept</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt;  e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动时，通过命令行参数指定端口号，比如：</p>
</li>
<li><p><code>echo_server_sync 8080</code></p>
</li>
<li><p>以下几点需要注意：</p>
<ul>
<li>tcp::acceptor 也是一种 I&#x2F;O 对象，用来接收 TCP 连接，连接端口由 tcp::endpoint 指定</li>
<li>数据 buffer 以 boost::array&lt;char, BUF_SIZE&gt; 表示，也可以用 char data[BUF_SIZE]，或 std::vector<char> data(BUF_SIZE)。事实上，用 std::vector 是最推荐的，因为它不但可以动态调整大小，还支持 Buffer Debugging。</li>
<li>同步方式下，没有调用 io_context.run，因为 accept、read_some 和 write 都是阻塞的。这也意味着一次只能处理一个 Client 连接，但是可以连续 echo，除非 Client 断开连接</li>
<li>写回数据时，没有直接调用 socket.write_some，因为它不能保证一次写完所有数据，但是 boost::asio::write 可以。我觉得这是 Asio 接口设计不周，应该提供 socket.write</li>
<li>acceptor.accept 返回一个新的 socket 对象，利用 move 语义，直接就转移给了 Session 的参数，期间并没有拷贝开销</li>
</ul>
</li>
</ul>
<h3 id="异步方式"><a href="#异步方式" class="headerlink" title="异步方式"></a>异步方式</h3><ul>
<li><p>异步方式下，困难在于对象的生命周期，可以用 shared_ptr 解决</p>
</li>
<li><p>为了同时处理多个 Client 连接，需要保留每个连接的 socket 对象，于是抽象出一个表示连接会话的类，叫 Session：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Session&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Session</span>(tcp::socket socket) : <span class="built_in">socket_</span>(std::<span class="built_in">move</span>(socket)) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DoRead</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">self</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">    socket_.<span class="built_in">async_read_some</span>(</span><br><span class="line">        boost::asio::<span class="built_in">buffer</span>(buffer_),</span><br><span class="line">        [<span class="keyword">this</span>, self](boost::system::error_code ec, std::<span class="type">size_t</span> length) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            <span class="built_in">DoWrite</span>(length);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DoWrite</span><span class="params">(std::<span class="type">size_t</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">self</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(</span><br><span class="line">        socket_,</span><br><span class="line">        boost::asio::<span class="built_in">buffer</span>(buffer_, length),</span><br><span class="line">        [<span class="keyword">this</span>, self](boost::system::error_code ec, std::<span class="type">size_t</span> length) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            <span class="built_in">DoRead</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  tcp::socket socket_;</span><br><span class="line">  std::array&lt;<span class="type">char</span>, BUF_SIZE&gt; buffer_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>就代码风格来说，有以下几点需要注意：</p>
<ul>
<li>优先使用 STL，比如 std::enable_shared_from_this，std::bind，std::array，等等</li>
<li>定义 handler 时，尽量使用匿名函数（lambda 表达式）</li>
<li>以 C++ std::size_t 替 C size_t。 刚开始，你可能会不习惯，我也是这样，过了好久才慢慢拥抱 C++11 乃至 C++14</li>
</ul>
</li>
<li><p>Session 有两个成员变量，socket_ 与 Client 通信，buffer_ 是接收 Client 数据的缓存。只要 Session 对象在，socket 就在，连接就不断。Socket 对象是构造时传进来的，而且是通过 move 语义转移进来的。</p>
</li>
<li><p>虽然还没看到 Session 对象是如何创建的，但可以肯定的是，它必须用 std::shared_ptr 进行封装，这样才能保证异步模式下对象的生命周期。</p>
</li>
<li><p>此外，在 Session::DoRead 和 Session::DoWrite 中，因为读写都是异步的，同样为了防止当前 Session 不被销毁（因为超出作用域），所以要增加它的引用计数，即 auto self(shared_from_this()); 这一句的作用</p>
</li>
<li><p>至于读写的逻辑，基本上就是把 read_some 换成 async_read_some，把 write 换成 async_write，然后以匿名函数作为 completion handler</p>
</li>
<li><p>接收 Client 连接的代码，提取出来，抽象成一个类 Server</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, std::<span class="type">uint16_t</span> port)</span><br><span class="line">      : <span class="built_in">acceptor_</span>(ioc, tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">    <span class="built_in">DoAccept</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DoAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acceptor_.<span class="built_in">async_accept</span>(</span><br><span class="line">        [<span class="keyword">this</span>](boost::system::error_code ec, tcp::socket socket) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            std::<span class="built_in">make_shared</span>&lt;Session&gt;(std::<span class="built_in">move</span>(socket))-&gt;<span class="built_in">Start</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">DoAccept</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  tcp::acceptor acceptor_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>同样，async_accept 替换了 accept。async_accept 不再阻塞，DoAccept 即刻就会返回。 为了保证 Session 对象继续存在，使用 std::shared_ptr 代替普通的栈对象，同时把新接收的 socket 对象转移过去</p>
</li>
<li><p>最后是 main()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;port&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::<span class="type">uint16_t</span> port = std::<span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  <span class="function">Server <span class="title">server</span><span class="params">(ioc, port)</span></span>;</span><br><span class="line"></span><br><span class="line">  ioc.<span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Echo-Client"><a href="#Echo-Client" class="headerlink" title="Echo Client"></a>Echo Client</h2><ul>
<li>虽然用 netcat 测试 Echo Server 非常方便，但是自己动手写一个 Echo Client 仍然十分必要。 还是先考虑同步方式。</li>
</ul>
<h3 id="同步方式-1"><a href="#同步方式-1" class="headerlink" title="同步方式"></a>同步方式</h3><ul>
<li><p>首先通过 host 和 port 解析出 endpoints（对，是复数！）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(ioc)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> endpoints = resolver.<span class="built_in">resolve</span>(tcp::<span class="built_in">v4</span>(), host, port);</span><br></pre></td></tr></table></figure></li>
<li><p>resolve 返回的 endpoints 类型为 tcp::resolver::results_type，代之以 auto 可以简化代码。类型推导应适当使用，至于连 int 都用 auto 就没有必要了。 host 和 port 通过命令行参数指定，比如 localhost 和 8080</p>
</li>
<li><p>接着创建 socket，建立连接：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tcp::socket <span class="title">socket</span><span class="params">(ioc)</span></span>;</span><br><span class="line">boost::asio::<span class="built_in">connect</span>(socket, endpoints);</span><br></pre></td></tr></table></figure></li>
<li><p>这里没有直接调用 socket.connect，因为 endpoints 可能会有多个，boost::asio::connect 会挨个尝试，逐一调用 socket.connect 直到连接成功。</p>
</li>
<li><p>其实这样说不太严谨，根据我的测试，resolve 在没有指定 protocol 时，确实会返回多个 endpoints，一个是 IPv6，一个是 IPv4。但是我们已经指定了 protocol 为 tcp::v4()：</p>
</li>
<li><p>接下来，从标准输入（std::cin）读一行数据，然后通过 boost::asio::write 发送给 Server：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> request[BUF_SIZE];</span><br><span class="line">std::<span class="type">size_t</span> request_length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Enter message: &quot;</span>;</span><br><span class="line">  std::cin.<span class="built_in">getline</span>(request, BUF_SIZE);</span><br><span class="line">  request_length = std::<span class="built_in">strlen</span>(request);</span><br><span class="line">&#125; <span class="keyword">while</span> (request_length == <span class="number">0</span>);</span><br><span class="line">boost::asio::<span class="built_in">write</span>(socket, boost::asio::<span class="built_in">buffer</span>(request, request_length));</span><br></pre></td></tr></table></figure></li>
<li><p>do…while 是为了防止用户直接 Enter 导致输入为空。boost::asio::write 是阻塞调用，发送完才返回</p>
</li>
<li><p>从 Server 同步接收数据有两种方式：</p>
<ul>
<li>使用 boost::asio::read（对应于 boost::asio::write）；</li>
<li>使用 socket.read_some。</li>
</ul>
</li>
<li><p>两者的差别是</p>
<ul>
<li>boost::asio::read 读到指定长度时，就会返回，你需要知道你想读多少；</li>
<li>而 socket.read_some 一旦读到一些数据就会返回，所以必须放在循环里，然后手动判断是否已经读到想要的长度，否则无法退出循环。</li>
</ul>
</li>
<li><p>下面分别是两种实现的代码。</p>
<ul>
<li>使用 boost::asio::read：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> reply[BUF_SIZE];</span><br><span class="line">std::<span class="type">size_t</span> reply_length = boost::asio::<span class="built_in">read</span>(</span><br><span class="line">    socket,</span><br><span class="line">    boost::asio::<span class="built_in">buffer</span>(reply, request_length));</span><br><span class="line"></span><br><span class="line">std::cout.<span class="built_in">write</span>(reply, reply_length);</span><br></pre></td></tr></table></figure></li>
<li>使用 socket.read_some：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">size_t</span> total_reply_length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  std::array&lt;<span class="type">char</span>, BUF_SIZE&gt; reply;</span><br><span class="line">  std::<span class="type">size_t</span> reply_length = socket.<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(reply));</span><br><span class="line"></span><br><span class="line">  std::cout.<span class="built_in">write</span>(reply.<span class="built_in">data</span>(), reply_length);</span><br><span class="line"></span><br><span class="line">  total_reply_length += reply_length;</span><br><span class="line">  <span class="keyword">if</span> (total_reply_length &gt;= request_length) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>不难看出，socket.read_some 用起来更为复杂。 Echo 程序的特殊之处就是，你可以假定 Server 会原封不动的把请求发回来，所以你知道 Client 要读多少。 但是很多时候，我们不知道要读多少数据。 所以，socket.read_some 反倒更为实用</p>
</li>
<li><p>此外，在这个例子中，我们没有为各函数指定输出参数 boost::system::error_code，而是使用了异常，把整个代码块放在 try…catch 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">  std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Asio 的 API 基本都通过重载（overload），提供了 error_code 和 exception 两种错误处理方式。使用异常更易于错误处理，也可以简化代码，但是 try…catch 该包含多少代码，并不是那么明显，新手很容易误用，什么都往 try…catch 里放</p>
</li>
<li><p>一般来说，异步方式下，使用 error_code 更方便一些。所以 complete handler 的参数都有 error_code</p>
</li>
</ul>
<h3 id="异步方式-1"><a href="#异步方式-1" class="headerlink" title="异步方式"></a>异步方式</h3><ul>
<li><p>首先，抽取出一个类 Client</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Client</span>(boost::asio::io_context&amp; ioc,</span><br><span class="line">         <span class="type">const</span> std::string&amp; host, <span class="type">const</span> std::string&amp; port)</span><br><span class="line">      : <span class="built_in">socket_</span>(ioc), <span class="built_in">resolver_</span>(ioc) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  tcp::socket socket_;</span><br><span class="line">  tcp::resolver resolver_;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> cin_buf_[BUF_SIZE];</span><br><span class="line">  std::array&lt;<span class="type">char</span>, BUF_SIZE&gt; buf_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>resolver_ 是为了 async_resolve，作为成员变量，生命周期便得到了保证，不会因为函数结束而失效。</p>
</li>
<li><p>下面来看 async_resolve 实现（代码在构造函数中）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Client</span>(...) &#123;</span><br><span class="line">  resolver_.<span class="built_in">async_resolve</span>(tcp::<span class="built_in">v4</span>(), host, port,</span><br><span class="line">                          std::<span class="built_in">bind</span>(&amp;Client::OnResolve, <span class="keyword">this</span>,</span><br><span class="line">                                    std::placeholders::_1,</span><br><span class="line">                                    std::placeholders::_2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>async_resolve 的 handler：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnResolve</span><span class="params">(boost::system::error_code ec,</span></span></span><br><span class="line"><span class="params"><span class="function">               tcp::resolver::results_type endpoints)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Resolve: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    boost::asio::<span class="built_in">async_connect</span>(socket_, endpoints,</span><br><span class="line">                               std::<span class="built_in">bind</span>(&amp;Client::OnConnect, <span class="keyword">this</span>,</span><br><span class="line">                                         std::placeholders::_1,</span><br><span class="line">                                         std::placeholders::_2));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>async_connect 的 handler：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnConnect</span><span class="params">(boost::system::error_code ec, tcp::endpoint endpoint)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Connect failed: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">    socket_.<span class="built_in">close</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">DoWrite</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>连接成功后，调用 DoWrite，从标准输入读取一行数据，然后异步发送给 Server。 下面是异步读写相关的函数，一并给出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::<span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter message: &quot;</span>;</span><br><span class="line">    std::cin.<span class="built_in">getline</span>(cin_buf_, BUF_SIZE);</span><br><span class="line">    len = <span class="built_in">strlen</span>(cin_buf_);</span><br><span class="line">  &#125; <span class="keyword">while</span> (len == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  boost::asio::<span class="built_in">async_write</span>(socket_,</span><br><span class="line">                           boost::asio::<span class="built_in">buffer</span>(cin_buf_, len),</span><br><span class="line">                           std::<span class="built_in">bind</span>(&amp;Client::OnWrite, <span class="keyword">this</span>,</span><br><span class="line">                                     std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnWrite</span><span class="params">(boost::system::error_code ec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reply is: &quot;</span>;</span><br><span class="line"></span><br><span class="line">    socket_.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(buf_),</span><br><span class="line">                            std::<span class="built_in">bind</span>(&amp;Client::OnRead, <span class="keyword">this</span>,</span><br><span class="line">                                      std::placeholders::_1,</span><br><span class="line">                                      std::placeholders::_2));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRead</span><span class="params">(boost::system::error_code ec, std::<span class="type">size_t</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">    std::cout.<span class="built_in">write</span>(buf_.<span class="built_in">data</span>(), length);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 如果想继续下一轮，可以在这里调用 DoWrite()。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后是 main()：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;host&gt; &lt;port&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* host = argv[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* port = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  <span class="function">Client <span class="title">client</span><span class="params">(ioc, host, port)</span></span>;</span><br><span class="line"></span><br><span class="line">  ioc.<span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>asio示例的代码链接 : <a target="_blank" rel="noopener" href="https://github.com/sprinfall/boost-asio-study.git">https://github.com/sprinfall/boost-asio-study.git</a></p>
</li>
</ul>
<h2 id="Asio-Tips-And-Notes"><a href="#Asio-Tips-And-Notes" class="headerlink" title="Asio Tips And Notes"></a>Asio Tips And Notes</h2><ul>
<li>本文列举Asio各种值的注意的细节</li>
</ul>
<h3 id="No-Deprecated"><a href="#No-Deprecated" class="headerlink" title="No Deprecated"></a>No Deprecated</h3><ul>
<li>在包含 Asio 头文件之前，定义宏 BOOST_ASIO_NO_DEPRECATED，这样在编译时，Asio 就会剔除那些已经过时的接口</li>
<li>比如在最新的 Boost 1.66 中，io_service 已经改名为 io_context，如果没有 BOOST_ASIO_NO_DEPRECATED，还是可以用 io_service 的，虽然那只是 io_context 的一个 typedef</li>
<li>BOOST_ASIO_NO_DEPRECATED 可以保证你用的是最新修订的 API。长期来看，有便于代码的维护。何况，这些修订正是 Asio 进入标准库的前奏<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BOOST_ASIO_NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;boost/asio/io_context.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;boost/asio/steady_timer.hpp&quot;</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="WIN32-WINNT-Warning"><a href="#WIN32-WINNT-Warning" class="headerlink" title="_WIN32_WINNT Warning"></a>_WIN32_WINNT Warning</h3><ul>
<li>在 Windows 平台，编译时会遇到关于 _WIN32_WINNT 的警告。 可以说，这是 Asio 自身的问题。 它应该在某个地方包含 SDKDDKVer.h。 不应该让用户自己去定义平台的版本</li>
<li>如果你用 CMake，可以借助下面这个宏自动检测 _WIN32_WINNT： (详见：<a target="_blank" rel="noopener" href="https://stackoverflow.com/a/40217291/6825348">https://stackoverflow.com/a/40217291/6825348</a>)<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (WIN32)</span><br><span class="line">    <span class="keyword">macro</span>(get_WIN32_WINNT version)</span><br><span class="line">        <span class="keyword">if</span> (CMAKE_SYSTEM_VERSION)</span><br><span class="line">            <span class="keyword">set</span>(ver <span class="variable">$&#123;CMAKE_SYSTEM_VERSION&#125;</span>)</span><br><span class="line">            <span class="keyword">string</span>(REGEX MATCH <span class="string">&quot;^([0-9]+).([0-9])&quot;</span> ver <span class="variable">$&#123;ver&#125;</span>)</span><br><span class="line">            <span class="keyword">string</span>(REGEX MATCH <span class="string">&quot;^([0-9]+)&quot;</span> verMajor <span class="variable">$&#123;ver&#125;</span>)</span><br><span class="line">            <span class="comment"># Check for Windows 10, b/c we&#x27;ll need to convert to hex &#x27;A&#x27;.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;$&#123;verMajor&#125;&quot;</span> <span class="keyword">MATCHES</span> <span class="string">&quot;10&quot;</span>)</span><br><span class="line">                <span class="keyword">set</span>(verMajor <span class="string">&quot;A&quot;</span>)</span><br><span class="line">                <span class="keyword">string</span>(REGEX REPLACE <span class="string">&quot;^([0-9]+)&quot;</span> <span class="variable">$&#123;verMajor&#125;</span> ver <span class="variable">$&#123;ver&#125;</span>)</span><br><span class="line">            <span class="keyword">endif</span> (<span class="string">&quot;$&#123;verMajor&#125;&quot;</span> <span class="keyword">MATCHES</span> <span class="string">&quot;10&quot;</span>)</span><br><span class="line">            <span class="comment"># Remove all remaining &#x27;.&#x27; characters.</span></span><br><span class="line">            <span class="keyword">string</span>(REPLACE <span class="string">&quot;.&quot;</span> <span class="string">&quot;&quot;</span> ver <span class="variable">$&#123;ver&#125;</span>)</span><br><span class="line">            <span class="comment"># Prepend each digit with a zero.</span></span><br><span class="line">            <span class="keyword">string</span>(REGEX REPLACE <span class="string">&quot;([0-9A-Z])&quot;</span> <span class="string">&quot;0\\1&quot;</span> ver <span class="variable">$&#123;ver&#125;</span>)</span><br><span class="line">            <span class="keyword">set</span>(<span class="variable">$&#123;version&#125;</span> <span class="string">&quot;0x$&#123;ver&#125;&quot;</span>)</span><br><span class="line">        <span class="keyword">endif</span>(CMAKE_SYSTEM_VERSION)</span><br><span class="line">    <span class="keyword">endmacro</span>(get_WIN32_WINNT)</span><br><span class="line"></span><br><span class="line">    get_WIN32_WINNT(ver)</span><br><span class="line">    <span class="keyword">add_definitions</span>(-D_WIN32_WINNT=<span class="variable">$&#123;ver&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>(WIN32)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="尽量少包含头文件"><a href="#尽量少包含头文件" class="headerlink" title="尽量少包含头文件"></a>尽量少包含头文件</h3><ul>
<li>尽量不要直接包含大而全的 boost&#x2F;asio.hpp。 这样做，是为了帮助自己记忆哪个类源于哪个具体的头文件，以及避免包含那些不必要的头文件</li>
<li>在实际项目中，在你自己的某个「头文件」里简单粗暴的包含 boost&#x2F;asio.hpp 是很不妥的；当然，在你的「源文件」里包含 boost&#x2F;asio.hpp 是可以接受的，毕竟实际项目依赖的东西比较多，很难搞清楚每一个定义源自哪里</li>
</ul>
<h3 id="Handler签名问题"><a href="#Handler签名问题" class="headerlink" title="Handler签名问题"></a>Handler签名问题</h3><ul>
<li>虽然关于 Handler 的签名，文档里都有说明，但是直接定位到源码，更方便，也更精确</li>
<li>以 steady_timer.async_wait() 为例，在 IDE 里定位到 async_wait() 的定义，代码（片段）如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> WaitHandler&gt;</span><br><span class="line"><span class="built_in">BOOST_ASIO_INITFN_RESULT_TYPE</span>(WaitHandler,</span><br><span class="line">    <span class="built_in">void</span> (boost::system::error_code))</span><br><span class="line"><span class="built_in">async_wait</span>(<span class="built_in">BOOST_ASIO_MOVE_ARG</span>(WaitHandler) handler)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure></li>
<li>通过宏 BOOST_ASIO_INITFN_RESULT_TYPE，WaitHandler 的签名一目了然。</li>
</ul>
<h3 id="Handler-的-error-code-参数到底是不是引用？"><a href="#Handler-的-error-code-参数到底是不是引用？" class="headerlink" title="Handler 的 error_code 参数到底是不是引用？"></a>Handler 的 error_code 参数到底是不是引用？</h3><ul>
<li>其实，早期的版本应该是 const boost::system::error_code&amp;，现在文档和代码注释里还有这么写的，估计是没来得及更新。 前面在说 Handler 签名时，已经看到 BOOST_ASIO_INITFN_RESULT_TYPE 这个宏的提示作用，翻一翻 Asio 源码，error_code 其实都已经传值了</li>
<li>奇怪的是，即使你的 Handler 传 error_code 为引用，编译运行也都没有问题<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(ioc, std::chrono::seconds(<span class="number">3</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">  timer.<span class="built_in">async_wait</span>(&amp;Print);</span><br><span class="line"></span><br><span class="line">  ioc.<span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>而我发现，当 Handler 是成员函数时，就不行了。下面这个 timer 的例子，如果把 Print 的 error_code 改成引用，就不能编译了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    timer_.<span class="built_in">async_wait</span>(std::<span class="built_in">bind</span>(&amp;Printer::Print, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 不能用 const boost::system::error_code&amp;</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(boost::system::error_code ec)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  boost::asio::steady_timer timer_;</span><br><span class="line">  <span class="type">int</span> count_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这个问题在习惯了引用的情况下，害苦了我，真是百思不得其解！也算是 Boost 比较坑的一个地方吧。 2019&#x2F;08&#x2F;30: 实测 1.70 没有这个问题，可以用 const reference。也许是 1.66 的 bug 吧。</li>
</ul>
<h3 id="Bind-占位符"><a href="#Bind-占位符" class="headerlink" title="Bind 占位符"></a>Bind 占位符</h3><ul>
<li><p>调用 bind 时，使用了占位符（placeholder），其实下面四种写法都可以：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boost::<span class="built_in">bind</span>(Print, boost::asio::placeholders::error, &amp;timer, &amp;count)</span><br><span class="line">boost::<span class="built_in">bind</span>(Print, boost::placeholders::_1, &amp;timer, &amp;count);</span><br><span class="line">boost::<span class="built_in">bind</span>(Print, _1, &amp;timer, &amp;count);</span><br><span class="line">std::<span class="built_in">bind</span>(Print, std::placeholders::_1, &amp;timer, &amp;count);</span><br></pre></td></tr></table></figure></li>
<li><p>第一种，占位符是 Boost Asio 定义的。 </p>
</li>
<li><p>第二种，占位符是 Boost Bind 定义的。 </p>
</li>
<li><p>第三种，同第二种，之所以可行，是因为 boost&#x2F;bind.hpp 里有一句 using namespace boost::placeholders;。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// boost/bind.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/bind/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BOOST_BIND_NO_PLACEHOLDERS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::placeholders;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>第四种，STL Bind，类似于 Boost Bind，只是没有声明 using namespace std::placeholders;</p>
</li>
<li><p>四种写法，推荐使用二或四。至于是用 Boost Bind 还是 STL Bind，没那么重要。 此外，数字占位符共有 9 个，_1 - _9</p>
</li>
</ul>
<h3 id="Endpoint-是一个单词"><a href="#Endpoint-是一个单词" class="headerlink" title="Endpoint 是一个单词"></a>Endpoint 是一个单词</h3><ul>
<li>不要写成”end point”</li>
</ul>
<h3 id="Server-也可以用Resolver"><a href="#Server-也可以用Resolver" class="headerlink" title="Server 也可以用Resolver"></a>Server 也可以用Resolver</h3><ul>
<li><p>TCP Server 的 acceptor 一般是这样构造的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp::<span class="built_in">acceptor</span>(io_context, tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(), port))</span><br></pre></td></tr></table></figure></li>
<li><p>也就是说，指定 protocol (tcp::v4()) 和 port 就行了。</p>
</li>
<li><p>但是，Asio 的 http 这个例子，确实用了 resolver，根据 IP 地址 resolve 出 endpoint：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(io_context_)</span></span>;</span><br><span class="line">tcp::resolver::results_type endpoints = resolver.<span class="built_in">resolve</span>(address, port);</span><br><span class="line">tcp::endpoint endpoint = *endpoints.<span class="built_in">begin</span>();</span><br><span class="line">acceptor_.<span class="built_in">open</span>(endpoint.<span class="built_in">protocol</span>());</span><br><span class="line">acceptor_.<span class="built_in">set_option</span>(tcp::acceptor::<span class="built_in">reuse_address</span>(<span class="literal">true</span>));</span><br><span class="line">acceptor_.<span class="built_in">bind</span>(endpoint);</span><br><span class="line">acceptor_.<span class="built_in">listen</span>();</span><br><span class="line">acceptor_.<span class="built_in">async_accept</span>(...);</span><br></pre></td></tr></table></figure></li>
<li><p>http 这个例子之所以这么写，主要是初始化 acceptor_ 时，还拿不到 endpoint，否则可以直接用下面这个构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">basic_socket_acceptor</span>(boost::asio::io_context&amp; io_context,</span><br><span class="line">      <span class="type">const</span> endpoint_type&amp; endpoint, <span class="type">bool</span> reuse_addr = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>这个构造函数注释说它等价于下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">basic_socket_acceptor&lt;Protocol&gt; <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">open</span>(endpoint.<span class="built_in">protocol</span>());</span><br><span class="line"><span class="keyword">if</span> (reuse_addr)</span><br><span class="line">  acceptor.<span class="built_in">set_option</span>(socket_base::<span class="built_in">reuse_address</span>(<span class="literal">true</span>));</span><br><span class="line">acceptor.<span class="built_in">bind</span>(endpoint);</span><br><span class="line">acceptor.<span class="built_in">listen</span>(listen_backlog);</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面是不同的 address 对应的 endpoints 结果（假定 port 都是 8080）：</p>
<ul>
<li>“localhost”: [::1]:8080, v6; [127.0.0.1]:8080, v4</li>
<li>“0.0.0.0”: 0.0.0.0:8080, v4</li>
<li>“0::0”: [::]:8080, v6</li>
<li>本机实际 IP 地址 (e.g., IPv4 “10.123.164.142”): 10.123.164.142:8080, v4。这时候，本机 client 无法通过 “localhost” 连接到这个 server，通过具体的 IP 地址则可以。</li>
<li>一个具体的非本机地址 (e.g., IPv4 “10.123.164.145”): exception: bind: The requested address is not valid in its context</li>
</ul>
</li>
</ul>
<h3 id="Move-Acceptable-Handle"><a href="#Move-Acceptable-Handle" class="headerlink" title="Move Acceptable Handle"></a>Move Acceptable Handle</h3><ul>
<li><p>使用 acceptor.async_accept 时，发现了 Move Acceptable Handler。</p>
</li>
<li><p>简单来说，async_accept 接受两种 AcceptHandler，直接看源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MoveAcceptHandler&gt;</span><br><span class="line"><span class="built_in">BOOST_ASIO_INITFN_RESULT_TYPE</span>(MoveAcceptHandler,</span><br><span class="line">    <span class="built_in">void</span> (boost::system::error_code, <span class="keyword">typename</span> Protocol::socket))</span><br><span class="line"><span class="built_in">async_accept</span>(<span class="built_in">BOOST_ASIO_MOVE_ARG</span>(MoveAcceptHandler) handler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Protocol1, <span class="keyword">typename</span> AcceptHandler&gt;</span><br><span class="line"><span class="built_in">BOOST_ASIO_INITFN_RESULT_TYPE</span>(AcceptHandler,</span><br><span class="line">    <span class="built_in">void</span> (boost::system::error_code))</span><br><span class="line"><span class="built_in">async_accept</span>(basic_socket&lt;Protocol1&gt;&amp; peer,</span><br><span class="line">    <span class="built_in">BOOST_ASIO_MOVE_ARG</span>(AcceptHandler) handler,</span><br><span class="line">    <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;Protocol, Protocol1&gt;::value&gt;::type* = <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>第一种是 Move Acceptable Handler，它的第二个参数是新 accept 的 socket。 </p>
</li>
<li><p>第二种是普通的 Handler，它的第一个参数是预先构造的 socket</p>
</li>
<li><p>结论是，对于 Move Acceptable Handler，不要用 bind，直接用 lambda 表达式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  acceptor_.<span class="built_in">async_accept</span>(</span><br><span class="line">    [<span class="keyword">this</span>](boost::system::error_code ec, boost::asio::ip::tcp::socket socket) &#123;</span><br><span class="line">    <span class="comment">// Check whether the server was stopped by a signal before this</span></span><br><span class="line">    <span class="comment">// completion handler had a chance to run.</span></span><br><span class="line">    <span class="keyword">if</span> (!acceptor_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">      connection_manager_.<span class="built_in">Start</span>(</span><br><span class="line">        std::<span class="built_in">make_shared</span>&lt;Connection&gt;(std::<span class="built_in">move</span>(socket),</span><br><span class="line">        connection_manager_,</span><br><span class="line">        request_handler_));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DoAccept</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/beast/2024-05-22-tcp_stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/beast/2024-05-22-tcp_stream/" class="post-title-link" itemprop="url">tcp_stream</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>tcp_stream类</li>
</ul>
<h2 id="boost-beast-tcp-stream-详解"><a href="#boost-beast-tcp-stream-详解" class="headerlink" title="boost::beast::tcp_stream 详解"></a>boost::beast::tcp_stream 详解</h2><p><code>boost::beast::tcp_stream</code> 是 Boost.Beast 库中的一个类，用于简化基于 TCP 的异步通信。它提供了对底层 TCP 连接进行操作的功能，同时集成了 Boost.Asio 的异步操作模型。</p>
<p>以下是对 <code>boost::beast::tcp_stream</code> 的一些主要方面的简要说明：</p>
<ol>
<li><p><strong>构造函数：</strong> <code>tcp_stream</code> 的构造函数通常需要一个 <code>boost::asio::io_context</code> 对象，以便进行异步操作。可以通过构造函数或 <code>open()</code> 函数来设置底层的 <code>boost::asio::ip::tcp::socket</code>。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boost::asio::io_context io_context;</span><br><span class="line">boost::<span class="function">beast::tcp_stream <span class="title">stream</span><span class="params">(io_context)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>成员函数：</strong></p>
<ul>
<li><code>async_connect()</code>：用于异步发起连接。</li>
<li><code>async_read()</code> 和 <code>async_write()</code>：用于异步读取和写入数据。</li>
<li><code>expires_after()</code> 和 <code>expires_at()</code>：用于设置超时时间。</li>
<li><code>close()</code>：用于关闭连接。</li>
</ul>
</li>
<li><p><strong>使用示例：</strong> 以下是一个简单的使用示例，演示了如何使用 <code>tcp_stream</code> 进行异步连接和数据传输：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/ssl.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/websocket.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/connect.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/ip/tcp.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> beast = boost::beast;</span><br><span class="line"><span class="keyword">namespace</span> asio = boost::asio;</span><br><span class="line"><span class="keyword">namespace</span> ssl = boost::asio::ssl;</span><br><span class="line"><span class="keyword">using</span> tcp = boost::asio::ip::tcp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        asio::io_context io_context;</span><br><span class="line">        <span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(io_context)</span></span>;</span><br><span class="line">        <span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">        tcp::resolver::results_type results = resolver.<span class="built_in">resolve</span>(<span class="string">&quot;www.example.com&quot;</span>, <span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 tcp_stream 进行异步连接</span></span><br><span class="line">        boost::<span class="function">beast::tcp_stream <span class="title">stream</span><span class="params">(socket)</span></span>;</span><br><span class="line">        stream.<span class="built_in">expires_after</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">        asio::<span class="built_in">async_connect</span>(stream.<span class="built_in">next_layer</span>(), results.<span class="built_in">begin</span>(), results.<span class="built_in">end</span>(), [&amp;](boost::system::error_code ec, <span class="type">const</span> tcp::endpoint&amp;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Connected to server&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 异步写入数据</span></span><br><span class="line">                stream.<span class="built_in">async_write</span>(asio::<span class="built_in">buffer</span>(<span class="string">&quot;GET / HTTP/1.1\r\nHost: www.example.com\r\n\r\n&quot;</span>), [&amp;](boost::system::error_code ec, std::<span class="type">size_t</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                        std::cout &lt;&lt; <span class="string">&quot;Data sent successfully&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 异步读取响应</span></span><br><span class="line">                        boost::beast::flat_buffer buffer;</span><br><span class="line">                        stream.<span class="built_in">async_read</span>(buffer, [&amp;](boost::system::error_code ec, std::<span class="type">size_t</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">                                std::cout &lt;&lt; <span class="string">&quot;Received response:\n&quot;</span> &lt;&lt; beast::<span class="built_in">make_printable</span>(buffer.<span class="built_in">data</span>()) &lt;&lt; std::endl;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                std::cerr &lt;&lt; <span class="string">&quot;Error in async_read: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        std::cerr &lt;&lt; <span class="string">&quot;Error in async_write: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Error in async_connect: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        io_context.<span class="built_in">run</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 请注意，此示例中的 <code>tcp_stream</code> 用于异步连接和数据传输。在实际应用中，可能需要根据需要进行更复杂的错误处理和数据处理。此外，上述示例中使用了 Boost.Beast 的 <code>flat_buffer</code> 用于存储读取的数据。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/beast/2024-05-22-message_generator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/beast/2024-05-22-message_generator/" class="post-title-link" itemprop="url">message_generator</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>boost::beast::http::message_generator 类</li>
</ul>
<h2 id="boost-beast-http-message-generator"><a href="#boost-beast-http-message-generator" class="headerlink" title="boost::beast::http::message_generator"></a>boost::beast::http::message_generator</h2><p><code>boost::beast::http::message_generator</code> 是 Boost.Beast 库中的一个类，用于生成 HTTP 消息（请求或响应）。这个类提供了一个方便的接口，使得创建符合 HTTP 规范的消息变得更加简单。</p>
<p>以下是对 <code>boost::beast::http::message_generator</code> 类的主要方面的简要说明：</p>
<ol>
<li><p><strong>构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">bool</span> isRequest, <span class="keyword">class</span> Body, <span class="keyword">class</span> Fields&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">message_generator</span><span class="params">(message&lt;isRequest, Body, Fields&gt;&amp; m)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个构造函数接受一个 <code>message</code> 对象引用，用于初始化 <code>message_generator</code>。</p>
</li>
<li><p><strong>成员函数：</strong></p>
<ul>
<li><code>begin()</code>：返回一个迭代器，指向消息的开始位置。</li>
<li><code>end()</code>：返回一个迭代器，指向消息的结束位置。</li>
<li><code>is_done()</code>：返回一个布尔值，表示消息是否已经生成完毕。</li>
</ul>
</li>
<li><p><strong>使用场景：</strong></p>
<ul>
<li><strong>简化 HTTP 消息的创建：</strong> <code>message_generator</code> 提供了一个更高层次的接口，使得创建 HTTP 消息变得更加简单。你可以使用该类来构建 HTTP 请求或响应。</li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/beast/http.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> beast = boost::beast;</span><br><span class="line"><span class="keyword">namespace</span> http = beast::http;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 HTTP 请求消息</span></span><br><span class="line">    http::request&lt;http::string_body&gt; req;</span><br><span class="line">    req.<span class="built_in">method</span>(http::verb::get);</span><br><span class="line">    req.<span class="built_in">target</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    req.<span class="built_in">version</span>(<span class="number">11</span>);</span><br><span class="line">    req.<span class="built_in">set</span>(http::field::host, <span class="string">&quot;www.example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 message_generator 生成 HTTP 请求消息</span></span><br><span class="line">    <span class="function">http::message_generator&lt;<span class="literal">true</span>, http::string_body, http::fields&gt; <span class="title">reqGen</span><span class="params">(req)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出生成的 HTTP 请求消息</span></span><br><span class="line">    std::cout &lt;&lt; reqGen.<span class="built_in">begin</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 HTTP 响应消息</span></span><br><span class="line">    http::response&lt;http::string_body&gt; res;</span><br><span class="line">    res.<span class="built_in">version</span>(<span class="number">11</span>);</span><br><span class="line">    res.<span class="built_in">result</span>(http::status::ok);</span><br><span class="line">    res.<span class="built_in">set</span>(http::field::server, <span class="string">&quot;Boost.Beast&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 message_generator 生成 HTTP 响应消息</span></span><br><span class="line">    <span class="function">http::message_generator&lt;<span class="literal">false</span>, http::string_body, http::fields&gt; <span class="title">resGen</span><span class="params">(res)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出生成的 HTTP 响应消息</span></span><br><span class="line">    std::cout &lt;&lt; resGen.<span class="built_in">begin</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，首先创建了一个 HTTP 请求消息和一个 HTTP 响应消息，然后使用 <code>message_generator</code> 分别生成了这两个消息的字符串表示形式。</p>
</li>
</ol>
<p>总的来说，<code>boost::beast::http::message_generator</code> 是一个用于生成 HTTP 消息的方便工具，简化了 HTTP 消息的创建过程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_01_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2024-05-22-C++_01_2_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_01_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2024-05-22-C++_01_2_%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">C++_01_2_语言基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C&#x2F;C++ 编程语言理论基础</li>
</ul>
<h2 id="C-默认参数"><a href="#C-默认参数" class="headerlink" title="C++ 默认参数"></a>C++ 默认参数</h2><p>在 C++ 中，函数的默认参数是一种允许您为函数的参数提供默认值的机制。这意味着您可以在定义函数时指定某个参数的默认值，如果调用函数时未提供该参数的值，函数将使用默认值。这对于使函数更灵活且易于使用非常有用。</p>
<p>以下是一个简单的示例，演示了如何在 C++ 函数中使用默认参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义时指定默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">(std::string name = <span class="string">&quot;Guest&quot;</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用函数时未提供参数值，将使用默认值</span></span><br><span class="line">    <span class="built_in">greet</span>(); <span class="comment">// 输出 &quot;Hello, Guest!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以提供参数值，覆盖默认值</span></span><br><span class="line">    <span class="built_in">greet</span>(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 输出 &quot;Hello, Alice!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>greet</code> 函数接受一个名为 <code>name</code> 的参数，但它在函数定义中指定了默认值 <code>&quot;Guest&quot;</code>。因此，在调用函数时，如果不提供 <code>name</code> 参数的值，函数将使用默认值。但如果提供了参数值，它将覆盖默认值。</p>
<p>请注意以下几点关于默认参数的注意事项：</p>
<ol>
<li><p>默认参数必须从右向左添加。也就是说，<strong>如果您在函数参数列表中为某个参数指定默认值，那么该参数右侧的所有参数都必须有默认值</strong>。例如，<code>void func(int a, int b = 0)</code> 是有效的，但 <code>void func(int a = 0, int b)</code> 是无效的。</p>
</li>
<li><p>一旦为某个参数指定了默认值，后续的参数都必须有默认值，无法再定义没有默认值的参数。这是因为在函数调用时，如果您省略了参数，编译器无法确定省略的参数是哪个。</p>
</li>
<li><p>默认参数的值可以是常量、全局变量、静态变量或者常量表达式。</p>
</li>
<li><p>在函数声明和函数定义中都可以指定默认参数。通常，将默认参数放在函数声明中，而不是函数定义中，以便其他文件中的代码可以使用相同的默认参数。函数定义中通常省略默认参数的值，因为它已经在声明中定义过了。</p>
</li>
</ol>
<p>默认参数是一种提高函数灵活性和可用性的重要工具，它允许您为不同的情况提供合适的默认行为，同时允许调用者在需要时覆盖默认值。</p>
<h2 id="C-std-set-详解"><a href="#C-std-set-详解" class="headerlink" title="C++ std::set 详解"></a>C++ std::set 详解</h2><p><code>std::set</code> 是 C++ 标准库中的一个关联容器，它实现了有序不重复元素的集合。在 <code>std::set</code> 中，元素按照升序排序，并且不允许重复元素的存在。<code>std::set</code> 是基于红黑树（Red-Black Tree）数据结构实现的，因此插入、删除和查找操作都具有对数时间复杂度（O(log n)）。</p>
<p>以下是关于 <code>std::set</code> 的详解：</p>
<h3 id="包含头文件"><a href="#包含头文件" class="headerlink" title="包含头文件"></a>包含头文件</h3><p>要使用 <code>std::set</code>，你需要包含 <code>&lt;set&gt;</code> 头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="创建和初始化-std-set"><a href="#创建和初始化-std-set" class="headerlink" title="创建和初始化 std::set"></a>创建和初始化 <code>std::set</code></h3><p>你可以使用多种方式来创建和初始化 <code>std::set</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet; <span class="comment">// 创建一个空的 set，存储整数</span></span><br></pre></td></tr></table></figure>

<p>你还可以在创建时指定初始元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;; <span class="comment">// 创建并初始化 set</span></span><br></pre></td></tr></table></figure>

<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>可以使用 <code>insert()</code> 方法来向 <code>std::set</code> 中插入元素。插入操作会自动维护集合的有序性和不重复性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">40</span>); <span class="comment">// 向 set 中插入元素 40</span></span><br></pre></td></tr></table></figure>

<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>可以使用 <code>erase()</code> 方法来删除 <code>std::set</code> 中的元素。你可以指定要删除的元素值或迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mySet.<span class="built_in">erase</span>(<span class="number">20</span>); <span class="comment">// 删除值为 20 的元素</span></span><br></pre></td></tr></table></figure>

<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>你可以使用 <code>find()</code> 方法来查找 <code>std::set</code> 中的元素。如果元素存在，它会返回元素的迭代器；否则，返回 <code>end()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt;::iterator it = mySet.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 元素 30 存在</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 元素 30 不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h3><p>你可以使用迭代器来遍历 <code>std::set</code> 中的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (std::set&lt;<span class="type">int</span>&gt;::iterator it = mySet.<span class="built_in">begin</span>(); it != mySet.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="type">int</span> value = *it;</span><br><span class="line">    <span class="comment">// 处理元素 value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他常用操作"><a href="#其他常用操作" class="headerlink" title="其他常用操作"></a>其他常用操作</h3><p><code>std::set</code> 还支持其他一些常用操作，例如：</p>
<ul>
<li><code>size()</code>：获取集合中元素的数量。</li>
<li><code>empty()</code>：检查集合是否为空。</li>
<li><code>clear()</code>：清空集合中的所有元素。</li>
<li><code>lower_bound()</code> 和 <code>upper_bound()</code>：分别查找不小于（大于等于）和大于给定值的元素的迭代器。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>std::set</code> 中的元素是有序的，因此插入和删除操作相对较慢，但查找操作非常高效。</li>
<li><code>std::set</code> 不允许重复元素。如果你需要允许重复元素的集合，请考虑使用 <code>std::multiset</code>。</li>
<li>在 C++11 及更高版本中，你还可以使用范围迭代器和 C++11 范围循环来更方便地遍历 <code>std::set</code> 中的元素。</li>
</ul>
<p><code>std::set</code> 是一个强大的数据结构，特别适用于需要快速查找和有序存储不重复元素的情况。</p>
<h2 id="C-std-bind-详解"><a href="#C-std-bind-详解" class="headerlink" title="C++ std::bind 详解"></a>C++ std::bind 详解</h2><p><code>std::bind()</code> 是 C++11 中引入的函数，它允许你创建一个可调用对象（函数对象）并将参数绑定到该对象上。这在很多情况下非常有用，特别是在处理回调函数、函数对象、线程和 STL 算法时。</p>
<p><code>std::bind()</code> 函数位于 <code>&lt;functional&gt;</code> 头文件中，你需要包含该头文件才能使用它。以下是关于 <code>std::bind()</code> 的详细解释和示例用法：</p>
<h3 id="std-bind-函数签名"><a href="#std-bind-函数签名" class="headerlink" title="std::bind() 函数签名"></a><code>std::bind()</code> 函数签名</h3><p><code>std::bind()</code> 的一般函数签名如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Fn</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="comment">/*unspecified*/</span> <span class="built_in">bind</span>(Fn&amp;&amp; fn, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Fn</code>：要绑定的函数或可调用对象。</li>
<li><code>Args</code>：参数列表，这些参数将在调用时传递给 <code>Fn</code>。</li>
</ul>
<h3 id="std-bind-的返回值"><a href="#std-bind-的返回值" class="headerlink" title="std::bind() 的返回值"></a><code>std::bind()</code> 的返回值</h3><p><code>std::bind()</code> 返回一个可调用对象，该对象可以像函数一样被调用，调用时将使用提供的参数。返回类型不是一个具体的类型，因此通常需要使用 <code>auto</code> 或 <code>std::function</code> 来接受返回的对象。</p>
<h3 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h3><p>以下是一些示例，演示了 <code>std::bind()</code> 的用法：</p>
<h4 id="示例-1：绑定全局函数"><a href="#示例-1：绑定全局函数" class="headerlink" title="示例 1：绑定全局函数"></a>示例 1：绑定全局函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> greetFn = std::<span class="built_in">bind</span>(greet, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    <span class="built_in">greetFn</span>(); <span class="comment">// 调用 greet(&quot;Alice&quot;)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例-2：绑定成员函数"><a href="#示例-2：绑定成员函数" class="headerlink" title="示例 2：绑定成员函数"></a>示例 2：绑定成员函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printNumber</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Number: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">auto</span> printFn = std::<span class="built_in">bind</span>(&amp;MyClass::printNumber, &amp;obj, std::placeholders::_1);</span><br><span class="line">    <span class="built_in">printFn</span>(<span class="number">42</span>); <span class="comment">// 调用 obj.printNumber(42)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例-3：绑定函数对象"><a href="#示例-3：绑定函数对象" class="headerlink" title="示例 3：绑定函数对象"></a>示例 3：绑定函数对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Adder add;</span><br><span class="line">    <span class="keyword">auto</span> addFn = std::<span class="built_in">bind</span>(add, std::placeholders::_1, std::placeholders::_2);</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">addFn</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 调用 add(10, 20)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="占位符-std-placeholders-1-2-…"><a href="#占位符-std-placeholders-1-2-…" class="headerlink" title="占位符 std::placeholders::_1, _2, …"></a>占位符 <code>std::placeholders::_1</code>, <code>_2</code>, …</h3><p><code>std::bind()</code> 中的 <code>std::placeholders::_1</code>, <code>std::placeholders::_2</code>, … 是用来占位的特殊标记。它们表示参数的位置，允许你在绑定时指定哪些参数将被传递，哪些将保留以后填充。</p>
<h3 id="使用-std-function-来保存可调用对象"><a href="#使用-std-function-来保存可调用对象" class="headerlink" title="使用 std::function 来保存可调用对象"></a>使用 <code>std::function</code> 来保存可调用对象</h3><p>通常，你可以使用 <code>std::function</code> 来保存 <code>std::bind()</code> 返回的可调用对象，以便稍后调用它们。这允许你在运行时动态决定要调用哪个函数或函数对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; operation;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> useAddition = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (useAddition) &#123;</span><br><span class="line">        operation = std::<span class="built_in">bind</span>(add, std::placeholders::_1, std::placeholders::_2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        operation = std::<span class="built_in">bind</span>(subtract, std::placeholders::_1, std::placeholders::_2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">operation</span>(<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 动态调用 add() 或 subtract()</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些示例展示了 <code>std::bind()</code> 的一些基本用法，你可以根据需要灵活地绑定函数和参数，使代码更模块化和可复用。</p>
<h2 id="C-std-string-详解"><a href="#C-std-string-详解" class="headerlink" title="C++ std::string  详解"></a>C++ std::string  详解</h2><p><code>std::string</code> 是 C++ 标准库中的字符串类，提供了在处理字符串时非常方便和强大的功能。以下是关于 <code>std::string</code> 的详解：</p>
<ol>
<li><p><strong>包含头文件</strong>：</p>
<p>要使用 <code>std::string</code>，需要包含头文件 <code>&lt;string&gt;</code>，通常可以这样做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串的创建和初始化</strong>：</p>
<p>可以使用多种方式来创建和初始化 <code>std::string</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str1;           <span class="comment">// 创建一个空字符串</span></span><br><span class="line">std::string str2 = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 创建并初始化一个字符串</span></span><br><span class="line"><span class="function">std::string <span class="title">str3</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;   <span class="comment">// 创建一个包含 5 个 &#x27;a&#x27; 的字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串的基本操作</strong>：</p>
<p><code>std::string</code> 支持许多基本操作，包括连接、比较、子字符串等等。</p>
<ul>
<li><p>连接字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::string str2 = <span class="string">&quot; World&quot;</span>;</span><br><span class="line">std::string result = str1 + str2; <span class="comment">// 连接两个字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>比较字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">std::string str2 = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line"><span class="type">int</span> cmp = str<span class="number">1.</span><span class="built_in">compare</span>(str2); <span class="comment">// 比较两个字符串，返回负数、零或正数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>提取子字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">std::string sub = str.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 提取从索引 0 开始的 5 个字符</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>字符串的访问</strong>：</p>
<p><code>std::string</code> 可以像数组一样访问其字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> firstChar = str[<span class="number">0</span>]; <span class="comment">// 获取第一个字符 &#x27;H&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串的长度和大小</strong>：</p>
<p>可以使用 <code>length()</code> 或 <code>size()</code> 方法获取字符串的长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = str.<span class="built_in">length</span>(); <span class="comment">// 获取字符串长度</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串的搜索和替换</strong>：</p>
<p><code>std::string</code> 提供了查找和替换子字符串的方法。</p>
<ul>
<li><p>查找子字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> found = str.<span class="built_in">find</span>(<span class="string">&quot;World&quot;</span>); <span class="comment">// 查找子字符串的位置</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>替换子字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">7</span>, <span class="number">5</span>, <span class="string">&quot;C++&quot;</span>); <span class="comment">// 用 &quot;C++&quot; 替换从索引 7 开始的 5 个字符</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>字符串的迭代</strong>：</p>
<p>可以使用迭代器遍历字符串的字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="type">char</span> c = *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串的转换</strong>：</p>
<p><code>std::string</code> 可以与其他数据类型进行转换，例如整数和浮点数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;42&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = std::<span class="built_in">stoi</span>(str); <span class="comment">// 将字符串转换为整数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串的输入和输出</strong>：</p>
<p>可以使用流操作符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 来进行字符串的输入和输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str;</span><br><span class="line">std::cin &gt;&gt; str; <span class="comment">// 从标准输入读取字符串</span></span><br><span class="line">std::cout &lt;&lt; str; <span class="comment">// 输出字符串到标准输出</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态调整字符串大小</strong>：</p>
<p><code>std::string</code> 允许动态调整字符串的大小，以容纳更多或更少的字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str.<span class="built_in">resize</span>(<span class="number">8</span>, <span class="string">&#x27; &#x27;</span>); <span class="comment">// 调整字符串大小为 8，用空格填充</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>std::string</code> 提供了许多其他功能和方法，以方便地处理字符串。它是 C++ 中处理文本数据的重要工具，可以大大简化字符串操作的复杂性。</p>
<h2 id="C-查找表"><a href="#C-查找表" class="headerlink" title="C++ 查找表"></a>C++ 查找表</h2><p>C++ 中查找表通常使用数据结构来实现，其中最常用的数据结构之一是关联容器（Associative Containers）或哈希表（Hash Table）。这些数据结构可以用来存储键-值对，以便可以通过键来查找值。</p>
<p>以下是一些常见的 C++ 查找表数据结构和它们的用法：</p>
<ol>
<li><p><strong>std::map</strong>：<br><code>std::map</code> 是 C++ 标准库中的关联容器，它使用红黑树实现，可以用来存储键值对，并且按键进行排序。查找操作的时间复杂度是 O(log n)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line">myMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">myMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> age = myMap[<span class="string">&quot;Alice&quot;</span>];  <span class="comment">// 查找 Alice 的年龄</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::unordered_map</strong>：<br><code>std::unordered_map</code> 也是 C++ 标准库中的关联容器，它使用哈希表实现，查找操作的平均时间复杂度为 O(1)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line">myMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">myMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> age = myMap[<span class="string">&quot;Alice&quot;</span>];  <span class="comment">// 查找 Alice 的年龄</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::set</strong>：<br><code>std::set</code> 是一个有序的集合，用于存储唯一的元素。它使用红黑树实现，查找操作的时间复杂度是 O(log n)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line"><span class="type">bool</span> found = mySet.<span class="built_in">count</span>(<span class="number">10</span>);  <span class="comment">// 检查元素是否存在</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::unordered_set</strong>：<br><code>std::unordered_set</code> 是一个无序的集合，用于存储唯一的元素。它使用哈希表实现，查找操作的平均时间复杂度为 O(1)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line">std::unordered_set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">mySet.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line"><span class="type">bool</span> found = mySet.<span class="built_in">count</span>(<span class="number">10</span>);  <span class="comment">// 检查元素是否存在</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些是 C++ 中常用的查找表数据结构，你可以根据你的需求选择适合的数据结构来实现查找表功能。根据数据量、查找频率以及是否需要元素的排序等因素来选择合适的容器。</p>
<h2 id="C-哈希表-详解"><a href="#C-哈希表-详解" class="headerlink" title="C++ 哈希表 详解"></a>C++ 哈希表 详解</h2><p>哈希表（Hash Table），也称为散列表，是一种数据结构，用于高效地存储和检索数据。它通过将数据与一个哈希函数计算的索引关联起来，从而允许在常量时间内进行数据插入、查找和删除操作。C++ 中可以使用标准库提供的 <code>std::unordered_map</code> 实现哈希表，以下是哈希表的详细解释：</p>
<ol>
<li><p><strong>哈希函数</strong>：<br>哈希表的核心是哈希函数。这个函数将输入的数据（通常是键）转换成一个整数，该整数通常被称为哈希码或哈希值。这个哈希值用于确定数据在哈希表中的存储位置。一个好的哈希函数应该将数据均匀地分布到哈希表的不同位置，以避免冲突（多个数据映射到同一个位置）。</p>
</li>
<li><p><strong>哈希表的结构</strong>：<br>哈希表通常是一个数组，每个元素被称为一个“桶”或“槽”。每个桶可以存储一个数据项或多个数据项，具体取决于哈希函数和解决冲突的方法。</p>
</li>
<li><p><strong>解决冲突</strong>：<br>由于哈希函数的限制，可能会发生冲突，即多个数据项被映射到同一个桶中。解决冲突的常见方法包括：</p>
<ul>
<li><strong>链地址法</strong>（Chaining）：每个桶存储一个链表或其他数据结构，用于存储冲突的数据项。</li>
<li><strong>开放寻址法</strong>（Open Addressing）：当发生冲突时，继续尝试找到下一个可用的桶，直到找到一个空桶或遍历整个哈希表。</li>
</ul>
</li>
<li><p>**C++ 中的 <code>std::unordered_map</code>**：<br>C++ 标准库提供了 <code>std::unordered_map</code> 类模板，它是一个使用哈希表实现的关联容器，用于存储键值对。以下是 <code>std::unordered_map</code> 的一些常见操作：</p>
<ul>
<li>插入数据：使用 <code>insert</code> 或 <code>emplace</code> 方法插入键值对。</li>
<li>查找数据：使用 <code>find</code> 方法查找指定键的值。</li>
<li>删除数据：使用 <code>erase</code> 方法删除指定键的值。</li>
<li>迭代哈希表：可以使用迭代器遍历哈希表中的键值对。</li>
<li>获取大小：使用 <code>size</code> 方法获取哈希表中键值对的数量。</li>
</ul>
</li>
</ol>
<p>下面是一个简单示例，演示如何使用 <code>std::unordered_map</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个哈希表</span></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; hashMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    hashMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    hashMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键的值</span></span><br><span class="line">    <span class="keyword">if</span> (hashMap.<span class="built_in">find</span>(<span class="string">&quot;Alice&quot;</span>) != hashMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Alice&#x27;s age is &quot;</span> &lt;&lt; hashMap[<span class="string">&quot;Alice&quot;</span>] &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Alice not found in the map.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键值对</span></span><br><span class="line">    hashMap.<span class="built_in">erase</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历哈希表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : hashMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;&#x27;s age is &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是哈希表的基本概念和在C++中使用哈希表的简单示例。在实际应用中，选择合适的哈希函数和解决冲突的策略以及考虑性能是非常重要的。此外，C++标准库还提供了其他关联容器，如<code>std::map</code>，它使用红黑树实现，适用于一些特定的使用情况。</p>
<h2 id="C-哈希表"><a href="#C-哈希表" class="headerlink" title="C++ 哈希表"></a>C++ 哈希表</h2><p>C++中的哈希表是一种常用的数据结构，用于实现键值对的存储和检索。哈希表基于哈希函数将键映射到一个索引，然后在该索引处存储相应的值。这可以大大提高数据的访问速度，因为您可以通过键快速查找值，而不需要遍历整个数据集。</p>
<p>在C++中，可以使用标准库中的<code>std::unordered_map</code>来创建哈希表。以下是使用<code>std::unordered_map</code>的基本示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个哈希表，将字符串键映射到整数值</span></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    myMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找值</span></span><br><span class="line">    std::string name = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (myMap.<span class="built_in">find</span>(name) != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;的年龄是：&quot;</span> &lt;&lt; myMap[name] &lt;&lt; <span class="string">&quot;岁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;不在哈希表中&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历哈希表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;键: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, 值: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们首先包含了相关的头文件，然后创建了一个<code>std::unordered_map</code>对象，该对象将字符串映射到整数值。我们插入了几个键值对，然后使用<code>find</code>方法查找特定键的值，并遍历整个哈希表来访问所有键值对。</p>
<p>请注意，C++标准库中的<code>std::unordered_map</code>实现了哈希表，但在某些情况下，您可能需要自定义哈希函数或提供自定义比较函数来处理特殊数据类型。此外，C++11引入了<code>std::unordered_map</code>之外的一些其他哈希容器，例如<code>std::unordered_set</code>（用于存储唯一的值）和<code>std::unordered_multimap</code>（允许多个相同的键）。根据您的需求，您可以选择合适的容器类型。</p>
<h2 id="C-struct-termios-VMIN-标志"><a href="#C-struct-termios-VMIN-标志" class="headerlink" title="C struct termios VMIN 标志"></a>C struct termios VMIN 标志</h2><p>在C语言中，<code>struct termios</code> 结构体用于表示终端设备的配置参数。<code>VMIN</code> 是<code>struct termios</code> 结构体中的一个成员，用于配置终端设备的非规范模式下的最小字符数。</p>
<p><code>VMIN</code> 成员用于设置终端设备的非规范模式下的最小字符数要求。在终端设备打开的文件描述符上启用了非规范模式（通过 <code>c_lflag</code> 中的 <code>ICANON</code> 标志），并且设置了非零的 <code>VMIN</code> 值时，系统会等待输入的字符数达到指定的最小值后才返回读取操作。</p>
<p>当读取操作获取到指定的最小字符数后，不会等待超过 <code>VMIN</code> 值的字符数再返回。如果在达到最小字符数之前读取操作遇到文件末尾（EOF）或错误，读取操作也会返回。</p>
<p>以下是一个示例，展示如何使用 <code>VMIN</code> 成员来配置终端设备的非规范模式下的最小字符数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *devicePath = <span class="string">&quot;/dev/ttyS0&quot;</span>; <span class="comment">// 串口设备文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 O_RDWR 标志打开串口设备文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(devicePath, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening device file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前终端设备的配置参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">serialConfig</span>;</span></span><br><span class="line">    tcgetattr(fd, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置非规范模式</span></span><br><span class="line">    serialConfig.c_lflag &amp;= ~ICANON;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置非规范模式下的最小字符数为 5</span></span><br><span class="line">    serialConfig.c_cc[VMIN] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的配置参数应用到终端设备</span></span><br><span class="line">    tcsetattr(fd, TCSANOW, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行串口通信...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 <code>open()</code> 函数打开了一个串口设备文件 “&#x2F;dev&#x2F;ttyS0”，然后获取了当前终端设备的配置参数。我们将终端设备配置为非规范模式，并设置了非零的 <code>VMIN</code> 值来配置最小字符数要求为 5。</p>
<p>需要注意的是，<code>VMIN</code> 成员只在非规范模式下生效，即在设置了 <code>ICANON</code> 标志为 0 的情况下才会生效。在规范模式下，输入数据会等待达到终端设备的行缓冲大小或回车键才返回。</p>
<h2 id="C-struct-termios-VTIME-标志"><a href="#C-struct-termios-VTIME-标志" class="headerlink" title="C struct termios VTIME 标志"></a>C struct termios VTIME 标志</h2><p>在C语言中，<code>struct termios</code> 结构体用于表示终端设备的配置参数。<code>VTIME</code> 是<code>struct termios</code> 结构体中的一个成员，用于配置终端设备的读取超时。</p>
<p><code>VTIME</code> 成员用于设置终端设备的非规范模式下的读取超时。当在终端设备打开的文件描述符上启用了非规范模式（通过 <code>c_lflag</code> 中的 <code>ICANON</code> 标志），并且设置了非零的 <code>VTIME</code> 值时，系统会等待一段时间以等待输入数据。</p>
<p><code>VTIME</code> 值的单位是十分之一秒（1&#x2F;10 秒）。如果设置了非零的 <code>VTIME</code> 值，则在读取输入数据时，系统会等待指定的超时时间。如果在超时时间内没有数据可读，则读取操作会返回，如果有数据可读，读取操作会立即返回。</p>
<p>以下是一个示例，展示如何使用 <code>VTIME</code> 成员来配置终端设备的非规范模式下的读取超时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *devicePath = <span class="string">&quot;/dev/ttyS0&quot;</span>; <span class="comment">// 串口设备文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 O_RDWR 标志打开串口设备文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(devicePath, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening device file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前终端设备的配置参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">serialConfig</span>;</span></span><br><span class="line">    tcgetattr(fd, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置非规范模式</span></span><br><span class="line">    serialConfig.c_lflag &amp;= ~ICANON;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置读取超时为 2 秒（20 * 1/10 秒）</span></span><br><span class="line">    serialConfig.c_cc[VTIME] = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的配置参数应用到终端设备</span></span><br><span class="line">    tcsetattr(fd, TCSANOW, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行串口通信...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 <code>open()</code> 函数打开了一个串口设备文件 “&#x2F;dev&#x2F;ttyS0”，然后获取了当前终端设备的配置参数。我们将终端设备配置为非规范模式，并设置了非零的 <code>VTIME</code> 值来配置读取超时为 2 秒。</p>
<p>需要注意的是，<code>VTIME</code> 成员只在非规范模式下生效，即在设置了 <code>ICANON</code> 标志为 0 的情况下才会生效。在规范模式下，输入数据会立即返回，不会等待超时。</p>
<h2 id="C-struct-termios-CSTOPB-标志"><a href="#C-struct-termios-CSTOPB-标志" class="headerlink" title="C struct termios CSTOPB 标志"></a>C struct termios CSTOPB 标志</h2><p>在C语言中，<code>struct termios</code> 结构体用于表示终端设备的配置参数。<code>CSTOPB</code> 是<code>struct termios</code> 结构体中的一个标志，用于配置终端设备的停止位数。</p>
<p><code>CSTOPB</code> 标志用于设置终端设备的停止位数。当设置了这个标志时，终端设备会使用两个停止位作为数据帧的停止位。如果未设置这个标志，终端设备将使用一个停止位。</p>
<p>以下是一个示例，展示如何使用 <code>CSTOPB</code> 标志来配置终端设备的停止位数为两个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *devicePath = <span class="string">&quot;/dev/ttyS0&quot;</span>; <span class="comment">// 串口设备文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 O_RDWR 标志打开串口设备文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(devicePath, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening device file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前终端设备的配置参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">serialConfig</span>;</span></span><br><span class="line">    tcgetattr(fd, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置停止位数为两个</span></span><br><span class="line">    serialConfig.c_cflag |= CSTOPB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的配置参数应用到终端设备</span></span><br><span class="line">    tcsetattr(fd, TCSANOW, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行串口通信...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 <code>open()</code> 函数打开了一个串口设备文件 “&#x2F;dev&#x2F;ttyS0”，然后获取了当前终端设备的配置参数。通过使用 <code>CSTOPB</code> 标志，我们设置了终端设备的停止位数为两个。</p>
<p>需要注意的是，设置停止位数的选择取决于实际的通信需求和硬件要求。在大多数情况下，使用一个停止位已经足够，但在某些情况下，可能需要使用两个停止位以确保数据传输的可靠性。</p>
<h2 id="C-struct-termios-ISTRIP-标志"><a href="#C-struct-termios-ISTRIP-标志" class="headerlink" title="C struct termios ISTRIP 标志"></a>C struct termios ISTRIP 标志</h2><p>在C语言中，<code>struct termios</code> 结构体用于表示终端设备的配置参数。<code>ISTRIP</code> 是<code>struct termios</code> 结构体中的一个标志，用于配置终端设备的输入字符处理。</p>
<p><code>ISTRIP</code> 标志用于设置终端设备在接收数据时是否对输入的字符进行去掉第8位（最高位）的处理。当设置了这个标志时，终端设备会将接收到的字符的最高位设置为0。</p>
<p>以下是一个示例，展示如何使用 <code>ISTRIP</code> 标志来配置终端设备的输入字符处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *devicePath = <span class="string">&quot;/dev/ttyS0&quot;</span>; <span class="comment">// 串口设备文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 O_RDWR 标志打开串口设备文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(devicePath, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening device file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前终端设备的配置参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">serialConfig</span>;</span></span><br><span class="line">    tcgetattr(fd, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置输入字符处理，去掉第8位</span></span><br><span class="line">    serialConfig.c_iflag |= ISTRIP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的配置参数应用到终端设备</span></span><br><span class="line">    tcsetattr(fd, TCSANOW, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行串口通信...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 <code>open()</code> 函数打开了一个串口设备文件 “&#x2F;dev&#x2F;ttyS0”，然后获取了当前终端设备的配置参数。通过使用 <code>ISTRIP</code> 标志，我们设置了输入字符处理，使终端设备在接收数据时去掉输入字符的最高位。</p>
<p>需要注意的是，使用 <code>ISTRIP</code> 标志会改变接收到的字符的数据，因此在使用该标志时，需要根据实际需求来进行配置。在一些情况下，去掉输入字符的最高位可能是有意义的，但在其他情况下，可能需要保留字符的所有位。</p>
<h2 id="C-struct-termios-INPCK-标志"><a href="#C-struct-termios-INPCK-标志" class="headerlink" title="C struct termios INPCK 标志"></a>C struct termios INPCK 标志</h2><p>在C语言中，<code>struct termios</code> 结构体用于表示终端设备的配置参数。<code>INPCK</code> 是<code>struct termios</code> 结构体中的一个标志，用于配置终端设备的输入奇偶校验检测。</p>
<p><code>INPCK</code> 标志用于启用输入奇偶校验检测。当设置了这个标志时，终端设备会在接收数据时进行奇偶校验检测，以验证接收的数据的完整性。</p>
<p>以下是一个示例，展示如何使用 <code>INPCK</code> 标志来配置终端设备的输入奇偶校验检测功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *devicePath = <span class="string">&quot;/dev/ttyS0&quot;</span>; <span class="comment">// 串口设备文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 O_RDWR 标志打开串口设备文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(devicePath, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening device file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前终端设备的配置参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">serialConfig</span>;</span></span><br><span class="line">    tcgetattr(fd, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用输入奇偶校验检测</span></span><br><span class="line">    serialConfig.c_iflag |= INPCK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的配置参数应用到终端设备</span></span><br><span class="line">    tcsetattr(fd, TCSANOW, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行串口通信...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 <code>open()</code> 函数打开了一个串口设备文件 “&#x2F;dev&#x2F;ttyS0”，然后获取了当前终端设备的配置参数。通过使用 <code>INPCK</code> 标志，我们启用了输入奇偶校验检测功能。这将使终端设备在接收数据时进行奇偶校验检测，以确保接收到的数据的正确性。</p>
<p>需要注意的是，输入奇偶校验检测功能的使用取决于实际的通信需求和硬件要求。在某些情况下，启用输入奇偶校验检测可以增加数据传输的可靠性，但在其他情况下，可能不需要进行奇偶校验检测。</p>
<h2 id="C-struct-termios-PARODD-标志"><a href="#C-struct-termios-PARODD-标志" class="headerlink" title="C struct termios PARODD 标志"></a>C struct termios PARODD 标志</h2><p>在C语言中，<code>struct termios</code> 结构体用于表示终端设备的配置参数。<code>PARODD</code> 是<code>struct termios</code> 结构体中的一个标志，用于配置终端设备的奇偶校验模式。</p>
<p><code>PARODD</code> 标志用于设置奇偶校验的模式。当设置了这个标志时，终端设备会使用奇校验模式，即在每个数据字节中包括奇数个”1”位，从而保持数据字节的奇校验性。</p>
<p>以下是一个示例，展示如何使用 <code>PARODD</code> 标志来配置终端设备的奇偶校验模式为奇校验：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *devicePath = <span class="string">&quot;/dev/ttyS0&quot;</span>; <span class="comment">// 串口设备文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 O_RDWR 标志打开串口设备文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(devicePath, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening device file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前终端设备的配置参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">serialConfig</span>;</span></span><br><span class="line">    tcgetattr(fd, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置奇偶校验模式为奇校验</span></span><br><span class="line">    serialConfig.c_cflag |= PARENB; <span class="comment">// 启用奇偶校验功能</span></span><br><span class="line">    serialConfig.c_cflag |= PARODD; <span class="comment">// 设置为奇校验模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的配置参数应用到终端设备</span></span><br><span class="line">    tcsetattr(fd, TCSANOW, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行串口通信...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 <code>open()</code> 函数打开了一个串口设备文件 “&#x2F;dev&#x2F;ttyS0”，然后获取了当前终端设备的配置参数。通过使用 <code>PARENB</code> 和 <code>PARODD</code> 标志，我们启用了奇偶校验功能，并将奇偶校验模式设置为奇校验。</p>
<p>需要注意的是，奇偶校验模式的选择取决于实际的通信需求和硬件要求。在某些情况下，使用奇校验可以增加数据传输的可靠性，但在其他情况下，可能需要使用偶校验或者不使用奇偶校验。</p>
<h2 id="C-struct-termios-PARENB-标志"><a href="#C-struct-termios-PARENB-标志" class="headerlink" title="C struct termios PARENB 标志"></a>C struct termios PARENB 标志</h2><p>在C语言中，<code>struct termios</code> 结构体用于表示终端设备的配置参数。<code>PARENB</code> 是<code>struct termios</code> 结构体中的一个标志，用于配置终端设备的奇偶校验。</p>
<p><code>PARENB</code> 标志用于启用奇偶校验功能。当设置了这个标志时，终端设备会在发送和接收数据时进行奇偶校验。奇偶校验是一种数据完整性的检查机制，用于检测数据传输过程中的错误。</p>
<p>以下是一个示例，展示如何使用 <code>PARENB</code> 标志来配置终端设备的奇偶校验功能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *devicePath = <span class="string">&quot;/dev/ttyS0&quot;</span>; <span class="comment">// 串口设备文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 O_RDWR 标志打开串口设备文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(devicePath, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening device file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前终端设备的配置参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">serialConfig</span>;</span></span><br><span class="line">    tcgetattr(fd, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用奇偶校验功能</span></span><br><span class="line">    serialConfig.c_cflag |= PARENB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的配置参数应用到终端设备</span></span><br><span class="line">    tcsetattr(fd, TCSANOW, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行串口通信...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 <code>open()</code> 函数打开了一个串口设备文件 “&#x2F;dev&#x2F;ttyS0”，然后获取了当前终端设备的配置参数。通过使用 <code>PARENB</code> 标志，我们启用了奇偶校验功能。在这个示例中，数据将会在发送和接收时进行奇偶校验。</p>
<p>需要注意的是，奇偶校验功能的使用取决于实际的通信需求和硬件要求。在某些情况下，使用奇偶校验可以增加数据传输的可靠性，但在其他情况下，可能不需要使用奇偶校验。</p>
<h2 id="C-struct-termios-CSIZE-标志"><a href="#C-struct-termios-CSIZE-标志" class="headerlink" title="C struct termios CSIZE 标志"></a>C struct termios CSIZE 标志</h2><p>在C语言中，<code>struct termios</code> 结构体用于表示终端设备的配置参数。<code>CSIZE</code> 是<code>struct termios</code> 结构体中的一个标志，用于配置终端设备的数据位数。</p>
<p><code>CSIZE</code> 标志是一个位掩码，用于指定数据位的大小。在<code>struct termios</code> 结构体中，数据位的大小可以使用以下常量之一来设置：</p>
<ul>
<li><code>CS5</code>：5位数据位</li>
<li><code>CS6</code>：6位数据位</li>
<li><code>CS7</code>：7位数据位</li>
<li><code>CS8</code>：8位数据位</li>
</ul>
<p>以下是一个示例，展示如何使用 <code>CSIZE</code> 标志来配置终端设备的数据位大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *devicePath = <span class="string">&quot;/dev/ttyS0&quot;</span>; <span class="comment">// 串口设备文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 O_RDWR 标志打开串口设备文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(devicePath, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening device file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前终端设备的配置参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">serialConfig</span>;</span></span><br><span class="line">    tcgetattr(fd, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置数据位大小为 8 位</span></span><br><span class="line">    serialConfig.c_cflag &amp;= ~CSIZE; <span class="comment">// 清除现有的数据位设置</span></span><br><span class="line">    serialConfig.c_cflag |= CS8;    <span class="comment">// 设置数据位大小为 8 位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的配置参数应用到终端设备</span></span><br><span class="line">    tcsetattr(fd, TCSANOW, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行串口通信...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 <code>open()</code> 函数打开了一个串口设备文件 “&#x2F;dev&#x2F;ttyS0”，然后获取了当前终端设备的配置参数。通过使用 <code>CSIZE</code> 标志，我们可以设置数据位的大小。在这个示例中，我们将数据位的大小设置为 8 位。</p>
<p>需要注意的是，数据位的大小需要根据实际通信需求和硬件要求进行设置。不同的串口设备可能有不同的数据位大小要求。</p>
<h2 id="C-struct-termios-CLOCAL-标志"><a href="#C-struct-termios-CLOCAL-标志" class="headerlink" title="C struct termios CLOCAL 标志"></a>C struct termios CLOCAL 标志</h2><p>在C语言中，<code>struct termios</code> 结构体用于表示终端设备的配置参数。<code>CLOCAL</code> 是<code>struct termios</code> 结构体中的一个标志，用于在串口通信中配置终端设备的行为。</p>
<p><code>CLOCAL</code> 标志用于设置终端设备在串口通信中的本地连接模式。当设置了 <code>CLOCAL</code> 标志时，终端设备将不会考虑调制解调器（Modem）的状态，即终端设备不会关心调制解调器是否连接。</p>
<p>以下是一个示例，展示如何使用 <code>CLOCAL</code> 标志来配置终端设备：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *devicePath = <span class="string">&quot;/dev/ttyS0&quot;</span>; <span class="comment">// 串口设备文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 O_RDWR 标志打开串口设备文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(devicePath, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening device file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前终端设备的配置参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">serialConfig</span>;</span></span><br><span class="line">    tcgetattr(fd, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 CLOCAL 标志，忽略调制解调器状态</span></span><br><span class="line">    serialConfig.c_cflag |= CLOCAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的配置参数应用到终端设备</span></span><br><span class="line">    tcsetattr(fd, TCSANOW, &amp;serialConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行串口通信...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 <code>open()</code> 函数打开了一个串口设备文件 “&#x2F;dev&#x2F;ttyS0”，然后获取了当前终端设备的配置参数。我们通过设置 <code>CLOCAL</code> 标志，将其添加到 <code>c_cflag</code> 字段中，以忽略调制解调器的状态。最后，我们使用 <code>tcsetattr()</code> 函数将新的配置参数应用到终端设备。</p>
<p>需要注意的是，<code>CLOCAL</code> 标志的使用取决于实际的通信环境和需求。在某些情况下，忽略调制解调器状态可能是合适的，但在其他情况下，可能需要使用调制解调器状态来确保通信的稳定性。</p>
<h2 id="C-open-O-LARGEFILE-标志"><a href="#C-open-O-LARGEFILE-标志" class="headerlink" title="C open() O_LARGEFILE 标志"></a>C open() O_LARGEFILE 标志</h2><p>在C语言中，<code>open()</code> 函数用于打开文件，同时还可以通过添加一些标志来指定文件的打开方式和行为。<code>O_LARGEFILE</code> 是一个标志，用于在一些操作系统中支持大文件的功能。</p>
<p>在一些操作系统中，文件的大小可能受到限制，特别是在32位系统中。<code>O_LARGEFILE</code> 标志的作用是告诉操作系统在打开文件时使用64位的偏移量，以支持大文件。这意味着即使在32位系统中，你仍然可以处理超过2GB大小的文件。</p>
<p>以下是使用 <code>O_LARGEFILE</code> 标志的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;largefile.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 O_LARGEFILE 标志打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDWR | O_CREAT | O_LARGEFILE, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行文件操作...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用了 <code>O_LARGEFILE</code> 标志来打开文件。请注意，使用这个标志时，可能需要操作系统和文件系统的支持，否则这个标志可能不会产生预期的效果。</p>
<p>需要注意的是，现代操作系统和文件系统通常会自动处理大文件，因此在大多数情况下，你不需要显式地使用 <code>O_LARGEFILE</code> 标志来打开文件。只有在处理旧的或不常见的系统时，可能需要考虑这个标志。</p>
<h2 id="C-open-O-CLOEXEC-标志"><a href="#C-open-O-CLOEXEC-标志" class="headerlink" title="C open() O_CLOEXEC 标志"></a>C open() O_CLOEXEC 标志</h2><p>在C语言中，<code>open()</code> 函数用于打开文件，同时还可以通过添加一些标志来指定文件的打开方式和行为。<code>O_CLOEXEC</code> 是一个标志，用于在打开文件时设置文件描述符的 close-on-exec 标志。</p>
<p><code>close-on-exec</code> 是一个进程属性，当进程调用 <code>exec()</code> 系列函数执行一个新程序时，所有的文件描述符（除了标准输入、标准输出和标准错误）会被关闭。<code>O_CLOEXEC</code> 标志的作用是在打开文件时，将这个文件描述符设置为 close-on-exec，这样在执行 <code>exec()</code> 函数时会自动关闭它。</p>
<p>以下是使用 <code>O_CLOEXEC</code> 标志的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 O_CLOEXEC 标志打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDWR | O_CREAT | O_CLOEXEC, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行文件操作...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用了 <code>O_CLOEXEC</code> 标志来打开文件。这意味着在执行 <code>exec()</code> 函数时，文件描述符 <code>fd</code> 会自动关闭。</p>
<p>需要注意的是，<code>O_CLOEXEC</code> 标志通常用于在多进程环境中，通过设置文件描述符的 close-on-exec 标志，可以避免在执行 <code>exec()</code> 函数时造成不必要的文件描述符泄漏。这对于创建安全的、不会在子进程中意外共享文件描述符的程序非常有用。</p>
<h2 id="C-open-O-CREAT-标志"><a href="#C-open-O-CREAT-标志" class="headerlink" title="C open() O_CREAT 标志"></a>C open() O_CREAT 标志</h2><p>在C语言中，<code>open()</code> 函数用于打开文件，同时还可以通过添加一些标志来指定文件的打开方式和行为。<code>O_CREAT</code> 是一个标志，用于在打开文件时，如果文件不存在就创建文件。</p>
<p>当你使用 <code>O_CREAT</code> 标志打开一个文件时，如果文件已经存在，则打开现有文件；如果文件不存在，则创建一个新的文件。你通常还需要提供一个权限参数来设置新文件的权限。这个权限参数通常是八进制表示的权限位。</p>
<p>以下是使用 <code>O_CREAT</code> 标志的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 O_CREAT 标志创建文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening/creating file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行文件操作...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用了 <code>O_CREAT</code> 标志来创建文件。如果文件 “example.txt” 不存在，那么就会创建一个新的文件，并赋予其权限 0666。</p>
<p>需要注意的是，使用 <code>O_CREAT</code> 标志时，通常还需要提供一个权限参数，以确保新创建的文件拥有适当的权限。如果文件已经存在，那么 <code>O_CREAT</code> 标志不会影响文件的现有权限。</p>
<h2 id="C-open-O-NONBLOCK-标志"><a href="#C-open-O-NONBLOCK-标志" class="headerlink" title="C open() O_NONBLOCK 标志"></a>C open() O_NONBLOCK 标志</h2><p>在C语言中，<code>open()</code> 函数用于打开文件，同时还可以通过添加一些标志来指定文件的打开方式和行为。<code>O_NONBLOCK</code> 是一个标志，用于在打开文件时设置非阻塞模式。</p>
<p>使用 <code>O_NONBLOCK</code> 标志打开文件时，文件描述符会以非阻塞模式打开。在非阻塞模式下，当尝试读取或写入文件时，如果没有数据可读或没有足够的空间可写入，操作会立即返回，而不会阻塞等待。这对于需要处理非阻塞IO的情况非常有用，如网络编程和异步IO。</p>
<p>以下是使用 <code>O_NONBLOCK</code> 标志的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 O_NONBLOCK 标志以非阻塞模式打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDWR | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行非阻塞文件操作...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用了 <code>O_NONBLOCK</code> 标志来以非阻塞模式打开文件。这意味着在使用该文件描述符进行读写操作时，操作将立即返回，而不会阻塞等待。如果没有数据可读或没有足够的空间可写入，操作将返回一个适当的错误。</p>
<p>需要注意的是，在非阻塞模式下，读取和写入操作可能不会始终读取或写入预期的数据量。你需要在代码中处理返回值，以适应非阻塞操作可能遇到的情况。</p>
<h2 id="C-open-O-RDWR-标志"><a href="#C-open-O-RDWR-标志" class="headerlink" title="C open() O_RDWR 标志"></a>C open() O_RDWR 标志</h2><p>在C语言中，<code>open()</code> 函数用于打开文件，同时还可以通过添加一些标志来指定文件的打开方式和行为。<code>O_RDWR</code> 是一个标志，用于以读写方式打开文件，即可以读取和写入文件。</p>
<p>以下是使用 <code>O_RDWR</code> 标志的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 O_RDWR 标志以读写方式打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行文件读写操作...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用了 <code>O_RDWR</code> 标志来以读写方式打开文件。这意味着我们可以使用文件描述符进行读取和写入操作。如果文件不存在，将会返回错误。如果需要，可以使用 <code>O_CREAT</code> 标志来创建文件。</p>
<p>需要注意的是，使用 <code>O_RDWR</code> 标志打开文件时，你可以同时进行读取和写入操作，但你需要根据实际需要进行适当的读写操作管理和错误处理。同时，打开文件时也需要考虑文件权限和文件是否存在等因素。</p>
<h2 id="C-open-S-IWUSR-标志"><a href="#C-open-S-IWUSR-标志" class="headerlink" title="C open() S_IWUSR 标志"></a>C open() S_IWUSR 标志</h2><p>在C语言中，<code>open()</code> 函数用于打开文件，同时还可以通过添加一些标志来指定文件的打开方式和行为。<code>S_IWUSR</code> 是一个权限标志，用于指定用户可写权限。</p>
<p>在Linux系统中，文件权限通常由三个部分组成：所有者权限、所属组权限和其他用户权限。<code>S_IWUSR</code> 表示用户（所有者）可写权限。当你在使用 <code>open()</code> 函数创建文件时，可以使用这个权限标志来设置文件的所有者的写权限。</p>
<p>以下是使用 <code>S_IWUSR</code> 权限标志的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 S_IWUSR 标志创建具有用户可写权限的文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening/creating file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行文件操作...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用了 <code>S_IWUSR</code> 权限标志来创建一个文件，该文件具有用户可写权限。我们同时使用了 <code>S_IRUSR</code> 权限标志，以确保文件也具有用户可读权限。</p>
<p>需要注意的是，权限标志通常会与其他标志（如 <code>O_RDWR</code>、<code>O_CREAT</code> 等）一起使用。在使用权限标志时，你还需要考虑文件的其他属性，如文件所有者、所属组等。</p>
<h2 id="C-open-S-IRUSR-标志"><a href="#C-open-S-IRUSR-标志" class="headerlink" title="C open() S_IRUSR 标志"></a>C open() S_IRUSR 标志</h2><p>在C语言中，<code>open()</code> 函数用于打开文件，同时还可以通过添加一些标志来指定文件的打开方式和行为。<code>S_IRUSR</code> 是一个权限标志，用于指定用户可读权限。</p>
<p>在Linux系统中，文件权限通常由三个部分组成：所有者权限、所属组权限和其他用户权限。<code>S_IRUSR</code> 表示用户（所有者）可读权限。当你在使用 <code>open()</code> 函数创建文件时，可以使用这个权限标志来设置文件的所有者的读权限。</p>
<p>以下是使用 <code>S_IRUSR</code> 权限标志的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 S_IRUSR 标志创建具有用户可读权限的文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening/creating file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行文件操作...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用了 <code>S_IRUSR</code> 权限标志来创建一个文件，该文件具有用户可读权限。我们同时使用了 <code>S_IWUSR</code> 权限标志，以确保文件也具有用户可写权限。</p>
<p>需要注意的是，权限标志通常会与其他标志（如 <code>O_RDWR</code>、<code>O_CREAT</code> 等）一起使用。在使用权限标志时，你还需要考虑文件的其他属性，如文件所有者、所属组等。</p>
<h2 id="C-open-O-RDONLY-标志"><a href="#C-open-O-RDONLY-标志" class="headerlink" title="C open() O_RDONLY 标志"></a>C open() O_RDONLY 标志</h2><p>在C语言中，<code>open()</code> 函数用于打开文件，同时还可以通过添加一些标志来指定文件的打开方式和行为。<code>O_RDONLY</code> 是一个标志，用于以只读方式打开文件，即可以读取文件但无法写入文件。</p>
<p>以下是使用 <code>O_RDONLY</code> 标志的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 O_RDONLY 标志以只读方式打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行文件读操作...</span></span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用了 <code>O_RDONLY</code> 标志来以只读方式打开文件。这意味着我们可以使用文件描述符进行读取操作，但是无法使用该文件描述符进行写入操作。</p>
<p>需要注意的是，使用 <code>O_RDONLY</code> 标志打开文件时，文件只能以只读方式访问。如果你需要进行写入操作，你需要使用 <code>O_RDWR</code> 标志。同时，打开文件时还需要考虑文件的权限和文件是否存在等因素。</p>
<h2 id="C-数字转布尔值"><a href="#C-数字转布尔值" class="headerlink" title="C 数字转布尔值"></a>C 数字转布尔值</h2><p>在C语言中，整数可以被视为布尔值的一种表示方式，其中非零值被视为“真”（true），而零值被视为“假”（false）。这是因为C语言中的条件表达式要求返回一个真值（非零）或假值（零）。</p>
<p>如果你想将整数显式转换为布尔值，你可以使用条件表达式或逻辑运算符来实现。以下是一些示例：</p>
<ol>
<li><strong>使用条件表达式：</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> booleanValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转换为布尔值</span></span><br><span class="line">    booleanValue = (num != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (booleanValue) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The value is true.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The value is false.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用逻辑运算符：</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">-7</span>;</span><br><span class="line">    <span class="type">int</span> booleanValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转换为布尔值</span></span><br><span class="line">    booleanValue = (num != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (booleanValue) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The value is true.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The value is false.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这两个示例中，我们使用条件表达式 <code>(num != 0)</code> 将整数转换为布尔值。如果整数非零，那么条件表达式的结果为真（非零），布尔值为 true；如果整数为零，条件表达式的结果为假（零），布尔值为 false。</p>
<p>需要注意的是，C语言中没有明确的布尔类型，而是使用整数作为布尔值的表示，非零值为 true，零值为 false。所以在C语言中，你可以将非零的整数作为 true 值来使用。</p>
<h2 id="C-预处理指令详解"><a href="#C-预处理指令详解" class="headerlink" title="C++ 预处理指令详解"></a>C++ 预处理指令详解</h2><p>C++预处理器是一个在实际编译之前执行的阶段，它处理以 <code>#</code> 开头的预处理指令。这些指令用于在源代码中进行文本替换、条件编译、头文件包含等操作，以及定义宏和条件编译代码块。以下是一些常见的C++预处理指令以及它们的作用：</p>
<ol>
<li><p><strong>#include：</strong><br>用于包含其他文件中的内容。主要用于包含头文件，以便在源文件中使用头文件中的声明和定义。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>   <span class="comment">// 包含C++标准库的iostream头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span> <span class="comment">// 包含自定义头文件</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>#define：</strong><br>用于定义宏。预处理器会将宏名称替换为相应的文本。可以用于创建常量、函数宏等。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x) &gt; (y) ? (x) : (y))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>#ifdef &#x2F; #ifndef &#x2F; #else &#x2F; #endif：</strong><br>用于条件编译。根据指定的条件，决定是否编译某段代码。<code>#ifdef</code> 表示 “如果定义了宏”，<code>#ifndef</code> 表示 “如果未定义宏”，<code>#else</code> 表示 “否则”，<code>#endif</code> 表示结束条件块。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="comment">// 调试时执行的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 发布版本时执行的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>#if &#x2F; #elif &#x2F; #else &#x2F; #endif：</strong><br>类似于条件编译，但允许在代码中进行更复杂的条件判断，如使用预定义宏来确定编译路径。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_WIN32)</span></span><br><span class="line">    <span class="comment">// Windows平台下的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__linux__)</span></span><br><span class="line">    <span class="comment">// Linux平台下的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 其他平台下的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>#undef：</strong><br>用于取消宏定义。如果需要取消一个已定义的宏，可以使用 <code>#undef</code>。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MACRO 42</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> MY_MACRO</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>#pragma：</strong><br>用于在编译器中插入特定的指令。<code>#pragma</code> 指令的效果和语法会因编译器而异。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable : 1234)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>#error：</strong><br>用于生成编译错误消息。可以用于在特定条件下阻止编译，或者为开发者提供有用的错误信息。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OLD_COMPILER</span></span><br><span class="line">    <span class="meta">#<span class="keyword">error</span> <span class="string">&quot;This version is not supported by the old compiler&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>#line：</strong><br>用于改变编译器报告的行号和文件名，通常用于错误消息或调试信息的生成。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">line</span> 100 <span class="string">&quot;mycode.cpp&quot;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>C++预处理器的这些指令允许您在编译前进行一些文本操作和条件判断，以便根据不同的情况定制化代码的编译过程。它们在代码的可维护性和可配置性方面非常有用。</p>
<h2 id="友元-friend"><a href="#友元-friend" class="headerlink" title="友元 friend"></a>友元 friend</h2><p>在 C++ 中，<strong>友元</strong>（friend）是一种访问控制机制，它允许一个函数或类访问另一个类的私有成员。友元关系通过在类的定义中使用 <code>friend</code> 关键字来建立。</p>
<p>友元的主要用途是在一些特殊情况下提供灵活的访问权限，但也应该谨慎使用，因为它可能会破坏类的封装性和隔离性。</p>
<p>以下是关于 C++ 中友元的详细解释：</p>
<ol>
<li><p><strong>友元函数</strong>：在类定义中使用 <code>friend</code> 关键字声明一个函数为友元函数。这意味着友元函数可以访问该类的私有和受保护成员。友元函数不是类的成员函数，但它具有特殊的权限，可以直接访问私有成员。</p>
</li>
<li><p><strong>友元类</strong>：同样，可以使用 <code>friend</code> 关键字将一个类声明为另一个类的友元类。这意味着友元类的所有成员函数可以访问该类的私有和受保护成员。友元类可以访问另一个类的私有成员，但不会继承它的成员。</p>
</li>
</ol>
<p>友元关系是双向的：如果类 A 是类 B 的友元，那么类 B 也可以访问类 A 的私有成员。</p>
<p>下面是一个示例，演示了如何在 C++ 中使用友元函数和友元类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendExample</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FriendExample</span>(<span class="type">int</span> value) : <span class="built_in">privateValue</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">FriendFunction</span><span class="params">(FriendExample&amp; obj)</span></span>;  <span class="comment">// 友元函数声明</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendClass</span>;  <span class="comment">// 友元类声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FriendFunction</span><span class="params">(FriendExample&amp; obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Friend Function accessing privateValue: &quot;</span> &lt;&lt; obj.privateValue &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AccessPrivateValue</span><span class="params">(FriendExample&amp; obj)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Friend Class accessing privateValue: &quot;</span> &lt;&lt; obj.privateValue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">FriendExample <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="built_in">FriendFunction</span>(obj);</span><br><span class="line"></span><br><span class="line">    FriendClass friendObj;</span><br><span class="line">    friendObj.<span class="built_in">AccessPrivateValue</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>FriendExample</code> 类的 <code>privateValue</code> 是私有成员。<code>FriendFunction</code> 被声明为 <code>FriendExample</code> 类的友元函数，而 <code>FriendClass</code> 被声明为 <code>FriendExample</code> 类的友元类。因此，这两者都可以访问 <code>FriendExample</code> 类的私有成员。</p>
<p>友元机制在某些情况下很有用，例如在需要特定函数或类能够访问另一个类的私有成员时。然而，过度使用友元可能会破坏封装性，应该谨慎使用。</p>
<hr>
<h2 id="比特位-读写"><a href="#比特位-读写" class="headerlink" title="比特位 读写"></a>比特位 读写</h2><p>在C++中，可以使用位操作运算符来进行比特位的读写操作。位操作运算符允许你直接对变量的二进制位进行操作，从而有效地读取和写入单个比特位。</p>
<p>以下是一些常用的位操作运算符和示例：</p>
<ol>
<li><p>与运算符（&amp;）：<br>用于检查特定比特位的状态。将要检查的比特位置1，其他位置0，然后通过与运算得到结果。</p>
<p>示例：检查第3个比特位是否为1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isBitSet = (number &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>)) != <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>或运算符（|）：<br>用于设置特定比特位的状态。将要设置的比特位置1，其他位置保持不变，然后通过或运算得到结果。</p>
<p>示例：设置第5个比特位为1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number |= (<span class="number">1</span> &lt;&lt; <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>异或运算符（^）：<br>用于切换特定比特位的状态。将要切换的比特位置1，其他位置保持不变，然后通过异或运算得到结果。</p>
<p>示例：切换第2个比特位的状态</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number ^= (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>取反运算符（~）：<br>用于取反变量的所有比特位。</p>
<p>示例：将所有比特位取反</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number = ~number;</span><br></pre></td></tr></table></figure>
</li>
<li><p>左移运算符（&lt;&lt;）：<br>将一个数的所有比特位向左移动指定的位数。</p>
<p>示例：将number的比特位向左移动3位</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number = number &lt;&lt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>右移运算符（&gt;&gt;）：<br>将一个数的所有比特位向右移动指定的位数。对于无符号类型，左侧补0；对于有符号类型，左侧补符号位。</p>
<p>示例：将number的比特位向右移动2位</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number = number &gt;&gt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意事项：</p>
<ul>
<li>在进行位操作时，务必确保要操作的比特位在合法的范围内，避免访问未定义的行为。</li>
<li>使用无符号整数类型（例如<code>unsigned int</code>）可以避免在右移操作时出现符号位扩展的问题。</li>
</ul>
<p>请根据你的具体需求选择适合的位操作运算符来进行比特位的读写操作。</p>
<h2 id="C-常用容器-详解"><a href="#C-常用容器-详解" class="headerlink" title="C++ 常用容器 详解"></a>C++ 常用容器 详解</h2><p>C++ 标准模板库（Standard Template Library，STL）提供了许多常用的容器，这些容器是用于存储和管理数据的数据结构。STL 容器提供了各种不同类型的数据结构，以满足不同的需求。以下是 C++ 中常用的 STL 容器的详细解释：</p>
<ol>
<li><p><code>std::vector</code>：<br><code>std::vector</code> 是一个动态数组，可以在运行时调整大小。它支持高效的随机访问和在末尾插入&#x2F;删除元素，但插入&#x2F;删除操作在中间位置较慢。在使用时，通常使用 <code>push_back</code> 在末尾插入元素。</p>
</li>
<li><p><code>std::list</code>：<br><code>std::list</code> 是一个双向链表，支持在任意位置快速插入&#x2F;删除元素，但随机访问元素较慢。在使用时，通常使用 <code>push_back</code> 和 <code>push_front</code> 在末尾和头部插入元素。</p>
</li>
<li><p><code>std::deque</code>：<br><code>std::deque</code> 是一个双端队列，支持在头部和尾部快速插入&#x2F;删除元素，并支持高效的随机访问。在使用时，通常使用 <code>push_back</code> 和 <code>push_front</code> 在末尾和头部插入元素。</p>
</li>
<li><p><code>std::set</code>：<br><code>std::set</code> 是一个集合，它按照元素的键值自动排序，并且不允许重复的元素。它支持高效的插入&#x2F;删除操作，并可以在 O(log n) 时间内查找元素。</p>
</li>
<li><p><code>std::map</code>：<br><code>std::map</code> 是一个关联容器，它存储键值对，并按照键值自动排序。每个键只能对应一个值，因此不允许重复的键。</p>
</li>
<li><p><code>std::unordered_set</code>：<br><code>std::unordered_set</code> 是一个无序集合，它存储不重复的元素，并支持高效的插入&#x2F;删除操作和查找元素。由于它是无序的，不会进行排序。</p>
</li>
<li><p><code>std::unordered_map</code>：<br><code>std::unordered_map</code> 是一个无序关联容器，它存储键值对，并支持高效的插入&#x2F;删除操作和查找元素。由于它是无序的，不会进行排序。</p>
</li>
<li><p><code>std::stack</code>：<br><code>std::stack</code> 是一个后进先出（LIFO）的堆栈容器，它只允许在堆栈顶部插入和删除元素。</p>
</li>
<li><p><code>std::queue</code>：<br><code>std::queue</code> 是一个先进先出（FIFO）的队列容器，它只允许在队列的尾部插入元素，在队列的头部删除元素。</p>
</li>
<li><p><code>std::priority_queue</code>：<br><code>std::priority_queue</code> 是一个优先队列容器，它按照元素的优先级进行排序，并支持高效的插入&#x2F;删除操作。</p>
</li>
</ol>
<p>这些是 C++ 中常用的 STL 容器。选择适当的容器取决于您的具体需求，比如数据访问方式、插入&#x2F;删除操作的频率、是否需要排序等。STL 提供了这些容器以及丰富的算法和迭代器，使得在 C++ 中进行数据管理和处理变得非常方便和高效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/19/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/21/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
