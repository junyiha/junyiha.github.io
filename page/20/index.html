<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/20/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/20/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Windows/2024-09-09-windows_05_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Windows/2024-09-09-windows_05_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">Windows下C++编程常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index"><span itemprop="name">Windows</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>windows平台下C++编程常用函数笔记</li>
</ul>
<h2 id="C-WSAGetLastError-函数-详解"><a href="#C-WSAGetLastError-函数-详解" class="headerlink" title="C++ WSAGetLastError()函数 详解"></a>C++ WSAGetLastError()函数 详解</h2><p><code>WSAGetLastError()</code> 是用于在 Windows Sockets API (也称为 WinSock) 中获取上一次操作的错误代码的函数。它与标准 C 库中的 <code>GetLastError()</code> 类似，但专门用于处理与网络相关的错误。</p>
<p>在调用 WinSock 函数时，某些操作可能会失败，而这些函数通常会返回一个特殊的值（例如 <code>SOCKET_ERROR</code> 或 <code>INVALID_SOCKET</code>），以指示操作没有成功。在这种情况下，<code>WSAGetLastError()</code> 用于检索详细的错误代码，以帮助开发人员诊断问题。</p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAGetLastError</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回值：返回上一次失败的 WinSock 函数调用的错误代码。</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li><p><strong>错误处理</strong>：当调用诸如 <code>socket()</code>, <code>bind()</code>, <code>connect()</code>, <code>send()</code>, <code>recv()</code> 等网络函数时，如果返回值指示失败，您可以立即调用 <code>WSAGetLastError()</code> 来获取更详细的错误信息。</p>
</li>
<li><p><strong>排查问题</strong>：通过返回的错误代码，可以判断是什么原因导致操作失败，比如网络不可达、连接超时、权限不足等。</p>
</li>
</ol>
<h2 id="常见错误代码"><a href="#常见错误代码" class="headerlink" title="常见错误代码"></a>常见错误代码</h2><p>以下是一些常见的错误代码及其含义：</p>
<ul>
<li><code>WSAEACCES (10013)</code>：权限被拒绝。可能是由于防火墙或权限问题。</li>
<li><code>WSAEADDRINUSE (10048)</code>：地址已在使用中。尝试绑定一个已经被占用的端口。</li>
<li><code>WSAEADDRNOTAVAIL (10049)</code>：指定的地址无效，无法连接到指定的 IP 地址。</li>
<li><code>WSAENETDOWN (10050)</code>：网络子系统已失败。</li>
<li><code>WSAENETUNREACH (10051)</code>：网络无法到达。通常表示无法访问远程主机的网络。</li>
<li><code>WSAECONNABORTED (10053)</code>：软件导致的连接中止。通常是由于超时或其他问题导致连接中断。</li>
<li><code>WSAECONNRESET (10054)</code>：远程主机强行关闭连接。</li>
<li><code>WSAETIMEDOUT (10060)</code>：连接尝试超时。</li>
</ul>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面是一个简单的使用 <code>WSAGetLastError()</code> 的示例，展示如何处理网络函数失败时的错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>) <span class="comment">// 链接 winsock 库</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 WinSock 库</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;WSAStartup failed with error: &quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个套接字</span></span><br><span class="line">    SOCKET s = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (s == INVALID_SOCKET) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Socket creation failed with error: &quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">WSACleanup</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 socket 执行其他网络操作，如 bind() 或 connect()</span></span><br><span class="line">    <span class="comment">// 如果操作失败，可以立即调用 WSAGetLastError() 进行错误处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭 socket</span></span><br><span class="line">    <span class="built_in">closesocket</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理 WinSock 库</span></span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><strong>只获取最近的错误</strong>：<code>WSAGetLastError()</code> 只会返回最近一次失败的 WinSock 操作的错误代码。因此，它需要在失败操作后立即调用，延迟调用可能导致错误信息被覆盖。</li>
<li><strong>线程安全</strong>：<code>WSAGetLastError()</code> 是线程安全的，每个线程都有自己的错误代码，不会与其他线程冲突。</li>
</ul>
<p>通过 <code>WSAGetLastError()</code>，你可以获取到更加精确的错误信息，以便进行有效的网络调试和处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Windows/2024-05-22-windows_04_socket%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Windows/2024-05-22-windows_04_socket%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">windows_04_socket编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index"><span itemprop="name">Windows</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文介绍了在 Windows 系统下进行 socket 编程的基本方法和常用函数，包括 Winsock 的初始化、套接字的创建、绑定、监听、接受连接、数据传输和清理等操作。还提供了一个简单的 TCP 服务器和客户端示例代码。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/Windows/2024-05-22-windows_04_socket%E7%BC%96%E7%A8%8B/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_6_network_%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/2024-05-22-C_6_1_HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_6_network_%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/2024-05-22-C_6_1_HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="post-title-link" itemprop="url">C_6_1_HTTP服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>使用C语言实现HTTP服务器</li>
</ul>
<h2 id="Linux-C实现HTTP服务器"><a href="#Linux-C实现HTTP服务器" class="headerlink" title="Linux C实现HTTP服务器"></a>Linux C实现HTTP服务器</h2><p>您好！以下是一个简单的步骤，可以帮助您使用C语言在Linux上实现HTTP服务器：</p>
<ol>
<li>创建套接字并绑定到端口。</li>
<li>监听套接字以等待客户端连接。</li>
<li>接受客户端连接并处理HTTP请求。</li>
<li>从服务器上的文件系统中读取所需的文件并将其发送回客户端。</li>
<li>关闭套接字并退出。</li>
</ol>
<p>这是一个简单的步骤，但是实现HTTP服务器需要更多的细节和代码。您可以参考一些开源项目，例如<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/554876174">这个</a>知乎专栏文章中提到的一个基于Linux操作系统C语言实现的轻量级HTTP服务器。该文章提供了一个完整的代码示例，您可以在此基础上进行修改和扩展。</p>
<p>希望这可以帮助您入门HTTP服务器的实现。如果您有任何其他问题，请随时问我！</p>
<p>Source: Conversation with Bing, 12&#x2F;21&#x2F;2023<br>(1) 用C语言实现http服务器（Linux） - 知乎 - 知乎专栏. <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/554876174">https://zhuanlan.zhihu.com/p/554876174</a>.<br>(2) Linux C Http 文件服务器实现（含源码） - 知乎 - 知乎专栏. <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/109339385">https://zhuanlan.zhihu.com/p/109339385</a>.<br>(3) C&#x2F;C++编程日记：用C语言实现的简单Web服务器(Linux)，全代码分享！ - 哔哩哔哩. <a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv7985394/">https://www.bilibili.com/read/cv7985394/</a>.<br>(4) linux 搭建http文件服务器 - 业余砖家 - 博客园. <a target="_blank" rel="noopener" href="https://www.cnblogs.com/yeyuzhuanjia/p/16549008.html">https://www.cnblogs.com/yeyuzhuanjia/p/16549008.html</a>.<br>(5) Linux C 实现简单的HTTP服务器 - CSDN博客. <a target="_blank" rel="noopener" href="https://blog.csdn.net/wwxy1995/article/details/95517077">https://blog.csdn.net/wwxy1995/article/details/95517077</a>.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_4_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_04_4_string_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_4_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_04_4_string_h/" class="post-title-link" itemprop="url">C++_04_4_string_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>string.h头文件</li>
</ul>
<h2 id="C-string-h头文件-是什么"><a href="#C-string-h头文件-是什么" class="headerlink" title="C string.h头文件 是什么"></a>C string.h头文件 是什么</h2><p><code>string.h</code> 是C语言中的一个标准头文件，提供了一系列与字符串操作相关的函数原型和宏定义。这些函数允许程序员在处理字符数组（字符串）时进行各种操作，例如复制、连接、比较等。</p>
<p>一些常见的 <code>string.h</code> 中的函数和宏包括：</p>
<ol>
<li><p><strong>字符串复制：</strong></p>
<ul>
<li><code>strcpy</code>：复制一个字符串到另一个字符串。</li>
<li><code>strncpy</code>：安全地复制指定数量的字符到目标字符串。</li>
</ul>
</li>
<li><p><strong>字符串连接：</strong></p>
<ul>
<li><code>strcat</code>：连接两个字符串。</li>
<li><code>strncat</code>：安全地连接指定数量的字符到目标字符串。</li>
</ul>
</li>
<li><p><strong>字符串比较：</strong></p>
<ul>
<li><code>strcmp</code>：比较两个字符串。</li>
<li><code>strncmp</code>：安全地比较指定数量的字符。</li>
</ul>
</li>
<li><p><strong>字符串查找：</strong></p>
<ul>
<li><code>strchr</code>：在字符串中查找指定字符的第一次出现。</li>
<li><code>strrchr</code>：在字符串中查找指定字符的最后一次出现。</li>
<li><code>strstr</code>：在字符串中查找子串的第一次出现。</li>
</ul>
</li>
<li><p><strong>字符串长度：</strong></p>
<ul>
<li><code>strlen</code>：返回字符串的长度。</li>
</ul>
</li>
<li><p><strong>字符串转换：</strong></p>
<ul>
<li><code>atoi</code>、<code>atol</code>、<code>atof</code>：将字符串转换为整数、长整数或浮点数。</li>
</ul>
</li>
<li><p><strong>字符串操作：</strong></p>
<ul>
<li><code>memset</code>：将内存块设置为指定的值。</li>
<li><code>memcpy</code>：将一个内存块的内容复制到另一个内存块。</li>
<li><code>memmove</code>：安全地将一个内存块的内容复制到另一个内存块。</li>
</ul>
</li>
</ol>
<p>这些函数使得对字符串进行各种操作更加方便，并且在C语言中广泛使用。</p>
<h3 id="bcmp"><a href="#bcmp" class="headerlink" title="bcmp()"></a>bcmp()</h3><ul>
<li>简述：比较S1和S2的N个字节(与memcmp相同)</li>
<li>声明：<code>int bcmp (const void *s1, const void *s2, size_t n);</code></li>
<li>参数：</li>
<li>返回值：</li>
</ul>
<h3 id="bcopy"><a href="#bcopy" class="headerlink" title="bcopy()"></a>bcopy()</h3><ul>
<li>简述：复制N字节的SRC到DEST(类似于memmove，但参数是相反的)</li>
<li>声明：<code>int bcopy (const void *src, void *dest, size_t n);</code></li>
<li>参数：</li>
<li>返回值：</li>
</ul>
<h3 id="bzero"><a href="#bzero" class="headerlink" title="bzero()"></a>bzero()</h3><ul>
<li>简述：设置S的N个字节为0</li>
<li>声明：<code>void bzero (void *s, size_t n);</code></li>
<li>参数：</li>
<li>返回值：</li>
</ul>
<h3 id="ffs"><a href="#ffs" class="headerlink" title="ffs()"></a>ffs()</h3><ul>
<li>简述：返回<code>I</code>中设置的第一个比特位的位置，如果没有设置，则返回0。最低有效位是位置1，最高有效位是32</li>
<li>声明：<code>int ffs (int i);</code></li>
<li>参数：</li>
<li>返回值：</li>
</ul>
<h3 id="strcasecmp"><a href="#strcasecmp" class="headerlink" title="strcasecmp()"></a>strcasecmp()</h3><ul>
<li>简述：比较参数s1和s2字符串，比较时会自动忽略大小写的差异</li>
<li>声明：<code>extern int strcasecmp (const char *s1, const char *s2)</code></li>
<li>参数：<ul>
<li><code>__s1</code>  – 字符指针s1</li>
<li><code>__s2</code>  – 字符指针s2</li>
</ul>
</li>
<li>返回值：<ul>
<li>若参数s1和s2字符串相等则返回0；</li>
<li>s1大于s2，则返回大于0的值；</li>
<li>s1小于s2则返回小于0的值</li>
</ul>
</li>
</ul>
<h3 id="strncasecmp"><a href="#strncasecmp" class="headerlink" title="strncasecmp()"></a>strncasecmp()</h3><ul>
<li>简述：用来比较参数s1和s2字符串前n各字符，比较时会自动忽略大小写的差异</li>
<li>声明：<code> int strncasecmp (const char* s1, const char* s2, size_t n);</code></li>
<li>参数：<ul>
<li><code>s1</code>  – 字符指针s1</li>
<li><code>s2</code>  – 字符指针s2</li>
<li><code>n</code>   – 字符数n</li>
</ul>
</li>
<li>返回值<ul>
<li>如果参数s1和s2字符串相同，则返回0</li>
<li>s1若大于s2，则返回大于0的值</li>
<li>s1若小于s2，则返回小于0的值</li>
</ul>
</li>
</ul>
<h3 id="strcasecmp-l"><a href="#strcasecmp-l" class="headerlink" title="strcasecmp_l()"></a>strcasecmp_l()</h3><ul>
<li>简述：使用LOC中的排序规则比较S1和S2，忽略大小写</li>
<li>声明：<code>int strcasecmp_l (const char *s1, const char *s2, locale_t loc);</code></li>
<li>参数：</li>
<li>返回值：</li>
</ul>
<h3 id="strncasecmp-l"><a href="#strncasecmp-l" class="headerlink" title="strncasecmp_l()"></a>strncasecmp_l()</h3><ul>
<li>简述：使用LOC中的排序规则，不超过N个字符的S1和S2进行比较，忽略大小写</li>
<li>声明：<code>int strncasecmp_l (const char *s1, const char *s2, size_t n, locale_t loc);</code></li>
<li>参数：</li>
<li>返回值：</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_6_network_%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/2024-05-22-C_6_3_sys_poll_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_6_network_%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/2024-05-22-C_6_3_sys_poll_h/" class="post-title-link" itemprop="url">C_6_3_sys_poll_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>&lt;sys&#x2F;poll.h&gt; 是什么</li>
</ul>
<h2 id="linux-是什么"><a href="#linux-是什么" class="headerlink" title="linux &lt;sys&#x2F;poll.h&gt;是什么"></a>linux &lt;sys&#x2F;poll.h&gt;是什么</h2><p><code>&lt;sys/poll.h&gt;</code> 是一个 C&#x2F;C++ 中的头文件，它提供了用于使用 <code>poll()</code> 系统调用的相关函数和常量。</p>
<p><code>poll()</code> 是一种在多个文件描述符上进行 I&#x2F;O 多路复用的方法。它允许程序等待多个文件描述符中的一个或多个准备好进行 I&#x2F;O 操作，而无需阻塞任何描述符。</p>
<p><code>&lt;sys/poll.h&gt;</code> 头文件中包含了 <code>struct pollfd</code> 结构体以及与 <code>poll()</code> 函数相关的函数原型和宏定义。<code>struct pollfd</code> 结构体用于描述要检查状态的文件描述符以及它们的事件。</p>
<p>常用的函数和宏包括：</p>
<ul>
<li><code>poll()</code>：用于检查文件描述符的状态。</li>
<li><code>POLLIN</code>、<code>POLLOUT</code>、<code>POLLERR</code>、<code>POLLHUP</code> 等宏：用于描述文件描述符的不同事件类型。</li>
<li><code>struct pollfd</code>：用于传递和存储文件描述符的状态和事件信息。</li>
</ul>
<p>使用 <code>&lt;sys/poll.h&gt;</code> 可以实现更高效的 I&#x2F;O 多路复用，特别是在需要管理大量文件描述符时。</p>
<h2 id="linux-详解"><a href="#linux-详解" class="headerlink" title="linux &lt;sys&#x2F;poll.h&gt;详解"></a>linux &lt;sys&#x2F;poll.h&gt;详解</h2><p><code>&lt;sys/poll.h&gt;</code> 是 Linux 中用于进行 I&#x2F;O 多路复用的头文件，提供了 <code>poll()</code> 系统调用及相关的数据结构和常量。<code>poll()</code> 函数可以同时监视多个文件描述符的状态，以确定它们是否可以进行读取、写入或是否发生错误等事件。下面详细介绍 <code>&lt;sys/poll.h&gt;</code> 中的一些关键概念和内容：</p>
<h3 id="struct-pollfd"><a href="#struct-pollfd" class="headerlink" title="struct pollfd"></a><code>struct pollfd</code></h3><p><code>&lt;sys/poll.h&gt;</code> 中定义了 <code>struct pollfd</code> 结构体，它用于描述单个文件描述符的状态和事件。该结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 要监视的事件（输入/输出/错误等）</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 实际发生的事件（由系统设置）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fd</code> 是要监视的文件描述符。</li>
<li><code>events</code> 是需要监视的事件，可以使用以下标志进行设置：<ul>
<li><code>POLLIN</code>：数据可以从文件描述符读取。</li>
<li><code>POLLOUT</code>：数据可以写入文件描述符。</li>
<li><code>POLLERR</code>：发生错误。</li>
<li><code>POLLHUP</code>：挂起（连接断开）。</li>
<li>等等，还有其他可用的标志。</li>
</ul>
</li>
<li><code>revents</code> 是实际发生的事件，由系统在调用 <code>poll()</code> 后设置。它表示发生了哪些事件。</li>
</ul>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll()"></a><code>poll()</code></h3><p><code>poll()</code> 是 <code>&lt;sys/poll.h&gt;</code> 中的主要函数，用于监视一组文件描述符的状态。其原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fds</code> 是一个指向 <code>struct pollfd</code> 数组的指针，该数组包含要监视的文件描述符及其相应的事件和结果。</li>
<li><code>nfds</code> 是 <code>fds</code> 数组中的文件描述符数量。</li>
<li><code>timeout</code> 是等待的超时时间（以毫秒为单位），如果设置为负数则表示无限等待，如果设置为零则表示立即返回。</li>
</ul>
<p><code>poll()</code> 函数会阻塞程序，直到文件描述符中的一个或多个发生了指定的事件，或者等待超时。</p>
<h3 id="事件宏"><a href="#事件宏" class="headerlink" title="事件宏"></a>事件宏</h3><p>除了 <code>POLLIN</code>、<code>POLLOUT</code>、<code>POLLERR</code> 和 <code>POLLHUP</code> 外，<code>&lt;sys/poll.h&gt;</code> 还提供了其他用于描述事件的宏，以便更精细地监视文件描述符的状态，例如：</p>
<ul>
<li><code>POLLPRI</code>：高优先级数据可以从文件描述符读取。</li>
<li><code>POLLNVAL</code>：文件描述符非法。</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>要使用 <code>&lt;sys/poll.h&gt;</code>，您需要包含该头文件，并根据需要设置 <code>struct pollfd</code> 数组的成员，然后调用 <code>poll()</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个用于监视的 pollfd 结构体数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line">fds[<span class="number">0</span>].fd = your_file_descriptor; <span class="comment">// 设置文件描述符</span></span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;          <span class="comment">// 设置要监视的事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 poll() 函数</span></span><br><span class="line"><span class="type">int</span> ret = poll(fds, <span class="number">1</span>, your_timeout); <span class="comment">// your_timeout 为超时时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// poll() 返回值大于 0 表示有文件描述符发生了事件</span></span><br><span class="line">    <span class="comment">// 可以检查 fds[0].revents 获取实际发生的事件</span></span><br><span class="line">    <span class="comment">// 处理文件描述符的可读/可写/错误等情况</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 超时，没有文件描述符发生事件</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// poll() 返回值小于 0 表示出现错误</span></span><br><span class="line">    <span class="comment">// 可以通过 perror() 或其他方式获取错误信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，<code>&lt;sys/poll.h&gt;</code> 提供了一种基于事件的 I&#x2F;O 多路复用机制，允许程序有效地监视多个文件描述符，等待它们中任何一个准备好进行 I&#x2F;O 操作或者发生特定的事件。</p>
<h2 id="linux-struct-pollfd详解"><a href="#linux-struct-pollfd详解" class="headerlink" title="linux &lt;sys&#x2F;poll.h&gt; struct pollfd详解"></a>linux &lt;sys&#x2F;poll.h&gt; struct pollfd详解</h2><p><code>struct pollfd</code> 是 <code>&lt;sys/poll.h&gt;</code> 中定义的结构体，用于在使用 <code>poll()</code> 系统调用时描述要监视的文件描述符及其事件。该结构体提供了必要的信息，让 <code>poll()</code> 函数能够监视和报告文件描述符的状态和事件。</p>
<p>以下是 <code>struct pollfd</code> 结构体的详细说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 要监视的事件掩码</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 实际发生的事件掩码（由内核设置）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fd</code>：表示要监视的文件描述符。</li>
<li><code>events</code>：是一个掩码，用于指定 <code>poll()</code> 函数在调用时应该监视的事件。可以使用以下标志进行设置：<ul>
<li><code>POLLIN</code>：可读事件。表示数据可以从文件描述符读取而不会被阻塞。</li>
<li><code>POLLOUT</code>：可写事件。表示数据可以写入文件描述符而不会被阻塞。</li>
<li><code>POLLERR</code>：错误事件。表示发生了错误，需要处理。</li>
<li><code>POLLHUP</code>：挂起事件。表示连接断开或文件描述符被挂起。</li>
<li>还有其他可用的标志，例如 <code>POLLPRI</code>（高优先级可读事件）等。</li>
</ul>
</li>
<li><code>revents</code>：是由内核在 <code>poll()</code> 函数调用返回后设置的掩码，表示实际发生了哪些事件。<code>revents</code> 字段中的位掩码是 <code>events</code> 字段的子集。例如，如果设置了 <code>POLLIN</code> 标志并且有可读数据可用，那么在返回时 <code>revents</code> 将设置 <code>POLLIN</code> 位。</li>
</ul>
<p>结构体中的 <code>events</code> 字段用于指定所感兴趣的事件，而 <code>revents</code> 字段则由内核在调用 <code>poll()</code> 后设置以指示发生的事件。</p>
<p>使用 <code>struct pollfd</code> 可以实现对多个文件描述符同时进行 I&#x2F;O 多路复用的监视，以便有效地处理多个 I&#x2F;O 事件。通过在 <code>events</code> 字段中指定感兴趣的事件，程序可以在调用 <code>poll()</code> 后检查 <code>revents</code> 字段以了解实际发生的事件，并相应地处理文件描述符的状态。</p>
<h2 id="linux-poll-详解"><a href="#linux-poll-详解" class="headerlink" title="linux &lt;sys&#x2F;poll.h&gt; poll()详解"></a>linux &lt;sys&#x2F;poll.h&gt; poll()详解</h2><p><code>&lt;sys/poll.h&gt;</code> 头文件提供了 <code>poll()</code> 系统调用，用于在 Linux 中进行 I&#x2F;O 多路复用。<code>poll()</code> 函数允许程序同时监视多个文件描述符，并在它们之一准备好进行读取、写入或发生错误等事件时进行通知。以下是 <code>poll()</code> 函数的详细解释：</p>
<h3 id="poll-函数原型："><a href="#poll-函数原型：" class="headerlink" title="poll() 函数原型："></a><code>poll()</code> 函数原型：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fds</code> 是一个指向 <code>struct pollfd</code> 结构体数组的指针，数组中存储了待监视的文件描述符及其事件。</li>
<li><code>nfds</code> 是 <code>fds</code> 数组中的文件描述符数量。</li>
<li><code>timeout</code> 是等待的超时时间（以毫秒为单位）。它可以有三种情况：<ul>
<li>如果 <code>timeout</code> 为正数，表示 <code>poll()</code> 在超时之前等待事件就绪。</li>
<li>如果 <code>timeout</code> 为 0，表示 <code>poll()</code> 在调用后立即返回。</li>
<li>如果 <code>timeout</code> 为负数，表示 <code>poll()</code> 将无限期地等待事件就绪。</li>
</ul>
</li>
</ul>
<h3 id="struct-pollfd-1"><a href="#struct-pollfd-1" class="headerlink" title="struct pollfd"></a><code>struct pollfd</code></h3><p>在调用 <code>poll()</code> 之前，需要设置 <code>struct pollfd</code> 结构体数组的成员，以描述要监视的文件描述符及其所关注的事件。这些成员包括：</p>
<ul>
<li><code>fd</code>：文件描述符。</li>
<li><code>events</code>：监视的事件，使用位掩码指定。</li>
<li><code>revents</code>：实际发生的事件，由 <code>poll()</code> 调用后填充。</li>
</ul>
<h3 id="poll-函数的作用"><a href="#poll-函数的作用" class="headerlink" title="poll() 函数的作用"></a><code>poll()</code> 函数的作用</h3><ul>
<li><code>poll()</code> 调用会阻塞程序，直到指定的文件描述符中的一个或多个准备好进行 I&#x2F;O 操作或发生了指定的事件。</li>
<li>当任一文件描述符准备就绪或超时时，<code>poll()</code> 将返回一个大于 0 的值。返回值表示发生事件的文件描述符的数量。</li>
<li>当 <code>poll()</code> 超时时，返回值为 0。</li>
<li>如果 <code>poll()</code> 调用失败，返回值为 -1，并设置 <code>errno</code> 表示错误的类型。</li>
</ul>
<h3 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line">    fds[<span class="number">0</span>].fd = <span class="comment">/* Your file descriptor */</span>;</span><br><span class="line">    fds[<span class="number">0</span>].events = POLLIN; <span class="comment">// 监视可读事件</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = poll(fds, <span class="number">1</span>, <span class="number">1000</span>); <span class="comment">// 等待 1000 毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            <span class="comment">// 文件描述符可读，处理读取操作</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;File descriptor is ready for reading.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他事件检查和处理</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超时</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Timeout occurred.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 错误发生</span></span><br><span class="line">        perror(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，<code>poll()</code> 函数允许程序有效地监视多个文件描述符，等待它们之一准备好进行 I&#x2F;O 操作或发生特定事件。通过设置 <code>struct pollfd</code> 结构体数组的成员，并在调用 <code>poll()</code> 后检查相应的 <code>revents</code> 字段，可以实现对文件描述符的有效监视和处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_4_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C_4_1_%E6%A0%87%E5%87%86%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_4_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C_4_1_%E6%A0%87%E5%87%86%E5%BA%93/" class="post-title-link" itemprop="url">C_4_1_标准库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C语言标准库</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title="&lt;assert.h&gt;"></a>&lt;assert.h&gt;</h2><ul>
<li><p>简介</p>
<ul>
<li>C 标准库的 assert.h头文件提供了一个名为 assert 的宏，它可用于验证程序做出的假设，并在假设为假时输出诊断消息。</li>
<li>已定义的宏 assert 指向另一个宏 NDEBUG，宏 NDEBUG 不是 &lt;assert.h&gt; 的一部分。如果已在引用 &lt;assert.h&gt; 的源文件中定义 NDEBUG 为宏名称，则 assert 宏的定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> assert(ignore) ((void)0)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>void assert(int expression)</p>
<ul>
<li>这实际上是一个宏，不是一个函数，可用于在 C 程序中添加诊断。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_4_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_04_3_arpa_inet_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_4_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_04_3_arpa_inet_h/" class="post-title-link" itemprop="url">C++_04_3_arpa_inet_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>arpa&#x2F;inet.h头文件</li>
</ul>
<h2 id="arpa-inet-h-头文件是什么"><a href="#arpa-inet-h-头文件是什么" class="headerlink" title="arpa&#x2F;inet.h 头文件是什么"></a>arpa&#x2F;inet.h 头文件是什么</h2><p><code>arpa/inet.h</code> 是一个C语言中的头文件，它提供了一些函数原型和宏定义，用于处理网络地址和协议转换。在网络编程中，这个头文件通常用于IPv4和IPv6地址的转换、网络字节序和主机字节序之间的转换等操作。</p>
<p>一些常见的函数和宏定义包括：</p>
<ol>
<li><p><strong><code>htonl</code>、<code>htons</code>、<code>ntohl</code>、<code>ntohs</code>：</strong> 用于在主机字节序和网络字节序之间进行32位和16位整数的转换。</p>
</li>
<li><p><strong><code>inet_addr</code>、<code>inet_aton</code>、<code>inet_ntoa</code>：</strong> 用于IPv4地址的转换。</p>
</li>
<li><p><strong><code>inet_pton</code>、<code>inet_ntop</code>：</strong> 用于IPv4和IPv6地址的转换。</p>
</li>
<li><p><strong><code>INADDR_ANY</code>、<code>INADDR_BROADCAST</code>：</strong> 定义了IPv4中的特殊地址。</p>
</li>
<li><p><strong><code>sockaddr_in</code> 结构体：</strong> 用于表示IPv4地址和端口的结构体。</p>
</li>
</ol>
<p>这些函数和定义帮助程序员在网络编程中方便地进行地址和数据格式的转换，以确保正确的数据传输和通信。</p>
<h3 id="inet-addr"><a href="#inet-addr" class="headerlink" title="inet_addr()"></a>inet_addr()</h3><ul>
<li>简述：将互联网主机地址从数字和点符号在CP转换成二进制数据在网络字节顺序</li>
<li>声明：<code>in_addr_t inet_addr (const char *cp);</code></li>
<li>参数：</li>
<li>返回值：</li>
</ul>
<h3 id="inet-lnaof"><a href="#inet-lnaof" class="headerlink" title="inet_lnaof()"></a>inet_lnaof()</h3><ul>
<li>简述：在<code>in</code>返回Internet地址的本地主机地址部分。</li>
<li>声明：<code>in_addr_t inet_lnaof(struct in_addr in);</code></li>
<li>参数：</li>
<li>返回值：</li>
</ul>
<h3 id="inet-makeaddr"><a href="#inet-makeaddr" class="headerlink" title="inet_makeaddr()"></a>inet_makeaddr()</h3><ul>
<li>简述：将网络编号NET与本机地址主机相结合，使Internet主机地址按网络字节序排列</li>
<li>声明：<code>struct in_addr inet_makeaddr (in_addr_t net, in_addr_t host);</code></li>
<li>参数：</li>
<li>返回值：</li>
</ul>
<h3 id="inet-netof"><a href="#inet-netof" class="headerlink" title="inet_netof()"></a>inet_netof()</h3><ul>
<li>简述：返回网络号码部分的互联网地址</li>
<li>声明：<code>in_addr_t inet_netof (struct in_addr in);</code></li>
<li>参数：</li>
<li>返回值：</li>
</ul>
<h3 id="inet-network"><a href="#inet-network" class="headerlink" title="inet_network()"></a>inet_network()</h3><ul>
<li>简述：从CP开始的数字加点格式的地址中提取网络字节顺序的网络号</li>
<li>声明：<code>in_addr_t inet_network (const char *cp);</code></li>
<li>参数：</li>
<li>返回值：</li>
</ul>
<h3 id="inet-ntoa"><a href="#inet-ntoa" class="headerlink" title="inet_ntoa()"></a>inet_ntoa()</h3><ul>
<li>简述：将<code>in</code>中的因特网数字转换为<code>ASCII</code>表示。返回值是一个指向包含该字符串的内部数组的指针</li>
<li>声明：<code>char *inet_ntoa (struct in_addr in);</code></li>
<li>参数：</li>
<li>返回值：</li>
</ul>
<h3 id="inet-pton"><a href="#inet-pton" class="headerlink" title="inet_pton()"></a>inet_pton()</h3><ul>
<li>简述：从CP开始的缓冲区中Internet数字的表示格式转换为二进制网络格式，并将接口类型AF的结果存储在从BUF开始的缓冲区中</li>
<li>声明：<code>int inet_pton (int af, const char *cp, void *buf);</code></li>
<li>参数：</li>
<li>返回值：</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-C_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-C_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">C_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C语言相关的理论基础知识笔记</li>
</ul>
<h2 id="C-简介"><a href="#C-简介" class="headerlink" title="C 简介"></a>C 简介</h2><ul>
<li><p>C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。</p>
</li>
<li><p>在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&amp;R 标准。</p>
</li>
<li><p>UNIX 操作系统，C编译器，和几乎所有的 UNIX 应用程序都是用 C 语言编写的。由于各种原因，C 语言现在已经成为一种广泛使用的专业语言。</p>
</li>
<li><p>优点</p>
<ul>
<li>易于学习</li>
<li>结构化语言</li>
<li>它产生高效率的程序</li>
<li>它可以处理底层的活动</li>
<li>它可以在多种计算平台上编译</li>
</ul>
</li>
<li><p>关于 C</p>
<ul>
<li>C 语言是为了编写 UNIX 操作系统而被发明的。</li>
<li>C 语言是以 B 语言为基础的，B 语言大概是在 1970 年被引进的。</li>
<li>C 语言标准是于 1988 年由美国国家标准协会（ANSI，全称 American National Standard Institute）制定的。</li>
<li>截至 1973 年，UNIX 操作系统完全使用 C 语言编写。</li>
<li>目前，C 语言是最广泛使用的系统程序设计语言。</li>
<li>大多数先进的软件都是使用 C 语言实现的。</li>
<li>当今最流行的 Linux 操作系统和 RDBMS（Relational Database Management System：关系数据库管理系统） MySQL 都是使用 C 语言编写的。</li>
</ul>
</li>
<li><p>为什么要使用 C</p>
<ul>
<li>C 语言最初是用于系统开发工作，特别是组成操作系统的程序。由于 C 语言所产生的代码运行速度与汇编语言编写的代码运行速度几乎一样，所以采用 C 语言作为系统开发语言。下面列举几个使用 C 的实例：<ul>
<li>操作系统</li>
<li>语言编译器</li>
<li>汇编器</li>
<li>文本编辑器</li>
<li>打印机</li>
<li>网络驱动器</li>
<li>现代程序</li>
<li>数据库</li>
<li>语言解释器</li>
<li>实体工具</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C 程序结构"></a>C 程序结构</h2><ul>
<li>C 程序主要包括以下部分<ul>
<li>预处理器指令</li>
<li>函数</li>
<li>变量</li>
<li>语句 &amp; 表达式</li>
<li>注释</li>
</ul>
</li>
</ul>
<h2 id="C-基本语法"><a href="#C-基本语法" class="headerlink" title="C 基本语法"></a>C 基本语法</h2><ul>
<li><p>C 程序由各种令牌组成，令牌可以是关键字，标识符，常量，字符串值，或者是一个符号。</p>
</li>
<li><p>分号 ；</p>
<ul>
<li>在 C 程序中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。</li>
</ul>
</li>
<li><p>注释</p>
<ul>
<li>C 语言有两种注释方式<ul>
<li>以 &#x2F;&#x2F; 开始的单行注释，这种注释可以单独占一行</li>
<li>&#x2F;* *&#x2F; 这种格式的注释可以单行或多行。</li>
</ul>
</li>
<li>您不能在注释内嵌套注释，注释也不能出现在字符串或字符值中</li>
</ul>
</li>
<li><p>标识符</p>
<ul>
<li>C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</li>
<li>C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是区分大小写的编程语言。因此，在 C 中，Manpower 和 manpower 是两个不同的标识符</li>
</ul>
</li>
<li><p>关键字</p>
<ul>
<li>下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称<ul>
<li>auto      	声明自动变量</li>
<li>break     	跳出当前循环</li>
<li>case      	开关语句分支</li>
<li>char      	声明字符型变量或函数返回值类型</li>
<li>const     	定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变</li>
<li>continue      结束当前循环，开始下一轮循环</li>
<li>default       开关语句中的”其它”分支</li>
<li>do        	循环语句的循环体</li>
<li>double        声明双精度浮点型变量或函数返回值类型</li>
<li>else      	条件语句否定分支（与 if 连用）</li>
<li>enum      	声明枚举类型</li>
<li>extern        声明变量或函数是在其它文件或本文件的其他位置定义</li>
<li>float     	声明浮点型变量或函数返回值类型</li>
<li>for       	一种循环语句</li>
<li>goto      	无条件跳转语句</li>
<li>if        	条件语句</li>
<li>int       	声明整型变量或函数</li>
<li>long      	声明长整型变量或函数返回值类型</li>
<li>register      声明寄存器变量</li>
<li>return        子程序返回语句（可以带参数，也可不带参数）</li>
<li>short     	声明短整型变量或函数</li>
<li>signed        声明有符号类型变量或函数</li>
<li>sizeof        计算数据类型或变量长度（即所占字节数）</li>
<li>static        声明静态变量</li>
<li>struct        声明结构体类型</li>
<li>switch        用于开关语句</li>
<li>typedef       用以给数据类型取别名</li>
<li>unsigned      声明无符号类型变量或函数</li>
<li>union     	声明共用体类型</li>
<li>void      	声明函数无返回值或无参数，声明无类型指针</li>
<li>volatile      说明变量在程序执行中可被隐含地改变</li>
<li>while     	循环语句的循环条件</li>
</ul>
</li>
<li>C99 新增关键字<ul>
<li>_Bool	_Complex	_Imaginary	inline	restrict</li>
</ul>
</li>
<li>C11 新增关键字<ul>
<li>_Alignas	_Alignof	_Atomic	_Generic	_Noreturn  _Static_assert	_Thread_local</li>
</ul>
</li>
</ul>
</li>
<li><p>C 中的空格</p>
<ul>
<li>只包含空格的行，被称为空白行，可能带有注释，C 编译器会完全忽略它。</li>
<li>在 C 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始</li>
</ul>
</li>
</ul>
<h2 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C 数据类型"></a>C 数据类型</h2><ul>
<li><p>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式</p>
</li>
<li><p>C 中的类型可分为以下几种：</p>
</li>
<li><p>基本数据类型</p>
<ul>
<li>它们是算术类型，包括整型（int）、字符型（char）、浮点型（float）和双精度浮点型（double）。</li>
<li>枚举类型：<ul>
<li>它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</li>
</ul>
</li>
<li>void 类型：<ul>
<li>类型说明符 void 表示没有值的数据类型，通常用于函数返回值。</li>
</ul>
</li>
<li>派生类型：<ul>
<li>：包括数组类型、指针类型和结构体类型。</li>
</ul>
</li>
</ul>
</li>
<li><p>数组类型和结构类型统称为聚合类型。函数的类型指的是函数返回值的类型</p>
</li>
<li><p>char	            1 字节	        -128 到 127 或 0 到 255</p>
</li>
<li><p>unsigned char	    1 字节	        0 到 255</p>
</li>
<li><p>signed char	    1 字节	        -128 到 127</p>
</li>
<li><p>int	            2 或 4 字节	    -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</p>
</li>
<li><p>unsigned int	    2 或 4 字节	    0 到 65,535 或 0 到 4,294,967,295</p>
</li>
<li><p>short	            2 字节	        -32,768 到 32,767</p>
</li>
<li><p>unsigned short	2 字节	        0 到 65,535</p>
</li>
<li><p>long	            4 字节	        -2,147,483,648 到 2,147,483,647</p>
</li>
<li><p>unsigned long	    4 字节	        0 到 4,294,967,295</p>
</li>
<li><p>void 类型</p>
<ul>
<li>void 类型指定没有可用的值。它通常用于以下三种情况下<ul>
<li>函数返回为空<ul>
<li>C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);</li>
</ul>
</li>
<li>函数参数为空<ul>
<li>C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);</li>
</ul>
</li>
<li>指针指向 void<ul>
<li>类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>类型转换</p>
<ul>
<li>类型转换是将一个数据类型的值转换为另一种数据类型的值</li>
<li>C 语言中有两种类型转换<ul>
<li>隐式类型转换：隐式类型转换是在表达式中自动发生的，无需进行任何明确的指令或函数调用。它通常是将一种较小的类型自动转换为较大的类型，例如，将int类型转换为long类型或float类型转换为double类型。隐式类型转换也可能会导致数据精度丢失或数据截断</li>
<li>显式类型转换：显式类型转换需要使用强制类型转换运算符（type casting operator），它可以将一个数据类型的值强制转换为另一种数据类型的值。强制类型转换可以使程序员在必要时对数据类型进行更精确的控制，但也可能会导致数据丢失或截断</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="C-变量"><a href="#C-变量" class="headerlink" title="C 变量"></a>C 变量</h2><ul>
<li><p>变量，只不过是程序可操作的存储区的名称。C中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p>
</li>
<li><p>变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。基于前一章讲解的基本类型，有以下几种基本的变量类型：</p>
<ul>
<li>char : 通常是一个字节（八位）, 这是一个整数类型。</li>
<li>int : 整型，4 个字节，取值范围 -2147483648 到 2147483647</li>
<li>float : 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数</li>
<li>double : 双精度浮点值。双精度是1位符号，11位指数，52位小数</li>
<li>void : 表示类型的缺失。</li>
</ul>
</li>
<li><p>C 中的变量定义</p>
<ul>
<li>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：<ul>
<li>type variable_list;</li>
</ul>
</li>
<li>type 表示变量的数据类型，可以是整型、浮点型、字符型、指针等，也可以是用户自定义的对象</li>
<li>variable_list 可以由一个或多个变量的名称组成，多个变量之间用逗号,分隔，变量由字母、数字和下划线组成，且以字母或下划线开头。</li>
</ul>
</li>
<li><p>变量的初始化</p>
<ul>
<li>在 C 语言中，变量的初始化是在定义变量的同时为其赋予一个初始值。变量的初始化可以在定义时进行，也可以在后续的代码中进行。</li>
<li>初始化器由一个等号，后跟一个常量表达式组成，如下所示：<ul>
<li>type variable_name &#x3D; value;</li>
</ul>
</li>
<li>其中，type 表示变量的数据类型，variable_name 是变量的名称，value 是变量的初始值。</li>
<li>后续初始化变量：<ul>
<li>在变量定义后的代码中，可以使用赋值运算符 &#x3D; 为变量赋予一个新的值。<ul>
<li>type variable_name;    &#x2F;&#x2F; 变量定义</li>
<li>variable_name &#x3D; new_value;    &#x2F;&#x2F; 变量初始化</li>
</ul>
</li>
</ul>
</li>
<li>需要注意的是，变量在使用之前应该被初始化。未初始化的变量的值是未定义的，可能包含任意的垃圾值。因此，为了避免不确定的行为和错误，建议在使用变量之前进行初始化。</li>
</ul>
</li>
<li><p>变量不初始化</p>
<ul>
<li>在 C 语言中，如果变量没有显式初始化，那么它的默认值将取决于该变量的类型和其所在的作用域。</li>
<li>对于全局变量和静态变量（在函数内部定义的静态变量和在函数外部定义的全局变量），它们的默认初始值为零。</li>
<li>以下是不同类型的变量在没有显式初始化时的默认值：<ul>
<li>整型变量（int、short、long等）：默认值为0。</li>
<li>浮点型变量（float、double等）：默认值为0.0。</li>
<li>字符型变量（char）：默认值为’\0’，即空字符</li>
<li>指针变量：默认值为NULL，表示指针不指向任何有效的内存地址</li>
<li>数组、结构体、联合等复合类型的变量：它们的元素或成员将按照相应的规则进行默认初始化，这可能包括对元素递归应用默认规则。</li>
</ul>
</li>
<li>需要注意的是，局部变量（在函数内部定义的非静态变量）不会自动初始化为默认值，它们的初始值是未定义的（包含垃圾值）。因此，在使用局部变量之前，应该显式地为其赋予一个初始值。</li>
<li>总结起来，C 语言中变量的默认值取决于其类型和作用域。全局变量和静态变量的默认值为 0，字符型变量的默认值为 \0，指针变量的默认值为 NULL，而局部变量没有默认值，其初始值是未定义的</li>
</ul>
</li>
<li><p>C 中的变量声明</p>
<ul>
<li>变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</li>
<li>变量的声明有两种情况：<ul>
<li>一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。</li>
<li>另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的</li>
<li>除非有extern关键字，否则都是变量的定义。<ul>
<li>extern int i; &#x2F;&#x2F;声明，不是定义</li>
<li>int i; &#x2F;&#x2F;声明，也是定义</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>C 中的左值(Lvalues)和右值(Rvalues)</p>
<ul>
<li>C 中有两种类型的表达式：<ul>
<li>左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边</li>
<li>右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边</li>
</ul>
</li>
<li>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边</li>
</ul>
</li>
</ul>
<h2 id="C-常量"><a href="#C-常量" class="headerlink" title="C 常量"></a>C 常量</h2><ul>
<li><p>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量</p>
</li>
<li><p>常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量</p>
</li>
<li><p>常量就像是常规的变量，只不过常量的值在定义后不能进行修改</p>
</li>
<li><p>常量可以直接在代码中使用，也可以通过定义常量来使用</p>
</li>
<li><p>整数常量</p>
<ul>
<li>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制</li>
<li>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意</li>
</ul>
</li>
<li><p>浮点常量</p>
<ul>
<li>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</li>
<li>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</li>
</ul>
</li>
<li><p>字符常量</p>
<ul>
<li>字符常量是括在单引号中，例如，’x’ 可以存储在 char 类型的简单变量中</li>
<li>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\t’），或一个通用的字符（例如 ‘\u02C0’）</li>
<li>在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：</li>
</ul>
</li>
<li><p>字符串常量</p>
<ul>
<li>字符串字面值或常量是括在双引号 “ “ 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符</li>
<li>您可以使用空格做分隔符，把一个很长的字符串常量进行分行</li>
<li>字符串常量在内存中以 null 终止符 \0 结尾</li>
</ul>
</li>
<li><p>定义常量</p>
<ul>
<li>在 C 中，有两种简单的定义常量的方式：<ul>
<li>使用 #define 预处理器： #define 可以在程序中定义一个常量，它在编译时会被替换为其对应的值</li>
<li>使用 const 关键字：const 关键字用于声明一个只读变量，即该变量的值不能在程序运行时修改</li>
</ul>
</li>
</ul>
</li>
<li><p>#define预处理器</p>
<ul>
<li>下面是使用 #define 预处理器定义常量的形式：<ul>
<li>#define 常量名 常量值</li>
</ul>
</li>
</ul>
</li>
<li><p>const 关键字</p>
<ul>
<li>您可以使用 const 前缀声明指定类型的常量，如下所示：<ul>
<li>const 数据类型 常量名 &#x3D; 常量值;</li>
</ul>
</li>
</ul>
</li>
<li><p>请注意，把常量定义为大写字母形式，是一个很好的编程习惯。</p>
</li>
<li><p>#define 与 const 区别</p>
<ul>
<li>#define 与 const 这两种方式都可以用来定义常量，选择哪种方式取决于具体的需求和编程习惯。通常情况下，建议使用 const 关键字来定义常量，因为它具有类型检查和作用域的优势，而 #define 仅进行简单的文本替换，可能会导致一些意外的问题。</li>
<li>#define 预处理指令和 const 关键字在定义常量时有一些区别：<ul>
<li>替换机制：#define 是进行简单的文本替换，而 const 是声明一个具有类型的常量。#define 定义的常量在编译时会被直接替换为其对应的值，而 const 定义的常量在程序运行时会分配内存，并且具有类型信息。</li>
<li>类型检查：#define 不进行类型检查，因为它只是进行简单的文本替换。而 const 定义的常量具有类型信息，编译器可以对其进行类型检查。这可以帮助捕获一些潜在的类型错误。</li>
<li>作用域：#define 定义的常量没有作用域限制，它在定义之后的整个代码中都有效。而 const 定义的常量具有块级作用域，只在其定义所在的作用域内有效。</li>
<li>调试和符号表：使用 #define 定义的常量在符号表中不会有相应的条目，因为它只是进行文本替换。而使用 const 定义的常量会在符号表中有相应的条目，有助于调试和可读性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C 存储类"></a>C 存储类</h2><ul>
<li><p>存储类定义 C 程序中变量&#x2F;函数的存储位置、生命周期和作用域</p>
</li>
<li><p>这些说明符放置在它们所修饰的类型之前</p>
</li>
<li><p>下面列出 C 程序中可用的存储类：</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
</ul>
</li>
<li><p>auto 存储类</p>
<ul>
<li>auto 存储类是所有局部变量默认的存储类</li>
<li>定义在函数中的变量默认为 auto 存储类，这意味着它们在函数开始时被创建，在函数结束时被销毁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> mount;</span><br><span class="line">   <span class="keyword">auto</span> <span class="type">int</span> month;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。</li>
</ul>
</li>
<li><p>register 存储类</p>
<ul>
<li>register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）</li>
<li>register 存储类定义存储在寄存器，所以变量的访问速度更快，但是它不能直接取地址，因为它不是存储在 RAM 中的。在需要频繁访问的变量上使用 register 存储类可以提高程序的运行速度<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">register</span> <span class="type">int</span>  miles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</li>
</ul>
</li>
<li><p>static 存储类</p>
<ul>
<li>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</li>
<li>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内</li>
<li>全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中</li>
<li>静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置</li>
</ul>
</li>
<li><p>extern 存储类</p>
<ul>
<li>extern 存储类用于定义在其他文件中声明的全局变量或函数。当使用 extern 关键字时，不会为变量分配任何存储空间，而只是指示编译器该变量在其他文件中定义</li>
<li>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置</li>
<li>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数</li>
<li>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候</li>
</ul>
</li>
</ul>
<h2 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C 运算符"></a>C 运算符</h2><ul>
<li><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>杂项运算符</li>
</ul>
</li>
<li><p>算术运算符</p>
<ul>
<li><code>+</code> 	把两个操作数相加	              A + B 将得到 30</li>
<li><code>-</code> 	从第一个操作数中减去第二个操作数	A - B 将得到 -10</li>
<li><code>*</code> 	把两个操作数相乘	              A * B 将得到 200</li>
<li><code>/</code> 	分子除以分母	                  B &#x2F; A 将得到 2</li>
<li><code>%</code> 	取模运算符，整除后的余数	       B % A 将得到 0</li>
<li><code>++</code> 	自增运算符，整数值增加 1	       A++ 将得到 11</li>
<li><code>--</code> 	自减运算符，整数值减少 1	       A– 将得到 9</li>
</ul>
</li>
<li><p>关系运算符</p>
<ul>
<li><code>==</code> 	检查两个操作数的值是否相等，如果相等则条件为真。	             (A &#x3D;&#x3D; B) 为假。</li>
<li><code>!=</code> 	检查两个操作数的值是否相等，如果不相等则条件为真。	           (A !&#x3D; B) 为真。</li>
<li><code>&gt;</code> 	检查左操作数的值是否大于右操作数的值，如果是则条件为真。	     (A &gt; B) 为假。</li>
<li><code>&lt;</code> 	检查左操作数的值是否小于右操作数的值，如果是则条件为真。	     (A &lt; B) 为真。</li>
<li><code>&gt;=</code> 	检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。	(A &gt;&#x3D; B) 为假。</li>
<li><code>&lt;=</code> 	检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。	(A &lt;&#x3D; B) 为真。</li>
</ul>
</li>
<li><p>逻辑运算符</p>
<ul>
<li><code>&amp;&amp;</code> 	称为逻辑与运算符。如果两个操作数都非零，则条件为真。	                            (A &amp;&amp; B) 为假。</li>
<li><code>||</code> 	称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。	                  (A || B) 为真。</li>
<li><code>!</code> 	称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。	!(A &amp;&amp; B) 为真。</li>
</ul>
</li>
<li><p>赋值运算符</p>
<ul>
<li><code>=</code>  	  简单的赋值运算符，把右边操作数的值赋给左边操作数	               C &#x3D; A + B 将把 A + B 的值赋给 C</li>
<li><code>+=</code>  	加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数	C +&#x3D; A 相当于 C &#x3D; C + A</li>
<li><code>-=</code>  	减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数	C -&#x3D; A 相当于 C &#x3D; C - A</li>
<li><code>*=</code>  	乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数	C *&#x3D; A 相当于 C &#x3D; C * A</li>
<li><code>/=</code>  	除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数	C &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A</li>
<li><code>%=</code>  	求模且赋值运算符，求两个操作数的模赋值给左边操作数	             C %&#x3D; A 相当于 C &#x3D; C % A</li>
<li><code>&lt;&lt;=</code>  	左移且赋值运算符	                                            C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2</li>
<li><code>&gt;&gt;=</code>  	右移且赋值运算符	                                            C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2</li>
<li><code>&amp;=</code>  	按位与且赋值运算符	                                          C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2</li>
<li><code>^=</code>  	按位异或且赋值运算符	                                        C ^&#x3D; 2 等同于 C &#x3D; C ^ 2</li>
<li><code>|=</code>  	按位或且赋值运算符	                                          C |&#x3D; 2 等同于 C &#x3D; C | 2</li>
</ul>
</li>
<li><p>杂项运算符 ↦ sizeof &amp; 三元</p>
<ul>
<li><code>sizeof()</code>	返回变量的大小。	<code>sizeof(a)</code> 将返回 4，其中 a 是整数。</li>
<li><code>&amp;</code> 	      返回变量的地址。	<code>&amp;a;</code> 将给出变量的实际地址。</li>
<li><code>*</code> 	      指向一个变量。	  <code>*a;</code> 将指向一个变量。</li>
<li><code>?:</code>        条件表达式	如果条件为真 ? 则值为 X : 否则值为 Y</li>
</ul>
</li>
</ul>
<h2 id="C-判断"><a href="#C-判断" class="headerlink" title="C 判断"></a>C 判断</h2><ul>
<li><p>判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）</p>
</li>
<li><p>C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。</p>
</li>
<li><p>?: 运算符(三元运算符)</p>
<ul>
<li>我们已经在前面的章节中讲解了 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下：<ul>
<li>Exp1 ? Exp2 : Exp3;</li>
</ul>
</li>
<li>其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。</li>
<li>? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个表达式的值。</li>
</ul>
</li>
</ul>
<h2 id="C-循环"><a href="#C-循环" class="headerlink" title="C 循环"></a>C 循环</h2><ul>
<li>有的时候，我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。</li>
<li>编程语言提供了更为复杂执行路径的多种控制结构。</li>
<li>循环语句允许我们多次执行一个语句或语句组</li>
</ul>
<h2 id="C-函数"><a href="#C-函数" class="headerlink" title="C 函数"></a>C 函数</h2><ul>
<li><p>函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。</p>
</li>
<li><p>您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。</p>
</li>
<li><p>函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。</p>
</li>
<li><p>C 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。</p>
</li>
<li><p>函数还有很多叫法，比如方法、子例程或程序，等等</p>
</li>
<li><p>定义函数</p>
<ul>
<li>C 语言中的函数定义的一般形式如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return_type function_name( parameter list )</span><br><span class="line">&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：<ul>
<li>返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。</li>
<li>函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>
<li>参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>
<li>函数主体：函数主体包含一组定义函数执行任务的语句。</li>
</ul>
</li>
</ul>
</li>
<li><p>函数声明</p>
<ul>
<li>函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</li>
<li>函数声明包括以下几个部分：<ul>
<li>return_type function_name( parameter list );</li>
</ul>
</li>
</ul>
</li>
<li><p>调用函数</p>
<ul>
<li>创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。</li>
<li>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</li>
<li>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值</li>
</ul>
</li>
<li><p>函数参数</p>
<ul>
<li>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。</li>
<li>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</li>
<li>当调用函数时，有两种向函数传递参数的方式：<ul>
<li>传值调用	该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</li>
<li>引用调用	通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</li>
</ul>
</li>
<li>默认情况下，C 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。</li>
</ul>
</li>
</ul>
<h2 id="C-作用域规则"><a href="#C-作用域规则" class="headerlink" title="C 作用域规则"></a>C 作用域规则</h2><ul>
<li><p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：</p>
<ul>
<li>在函数或块内部的局部变量</li>
<li>在所有函数外部的全局变量</li>
<li>在形式参数的函数参数定义中</li>
</ul>
</li>
<li><p>局部变量</p>
<ul>
<li>在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。</li>
</ul>
</li>
<li><p>全局变量</p>
<ul>
<li>全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。</li>
<li>全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。</li>
<li>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用。</li>
</ul>
</li>
<li><p>形式参数</p>
<ul>
<li>函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用</li>
</ul>
</li>
<li><p>全局变量与局部变量在内存中的区别：</p>
<ul>
<li>全局变量保存在内存的全局存储区中，占用静态的存储单元；</li>
<li>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</li>
</ul>
</li>
</ul>
<h2 id="C-数组"><a href="#C-数组" class="headerlink" title="C 数组"></a>C 数组</h2><ul>
<li><p>C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。</p>
</li>
<li><p>所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素</p>
</li>
<li><p>数组中的特定元素可以通过索引访问，第一个索引值为 0</p>
</li>
<li><p>C 语言还允许我们使用指针来处理数组，这使得对数组的操作更加灵活和高效</p>
</li>
<li><p>声明数组</p>
<ul>
<li>在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示<ul>
<li>type arrayName [ arraySize ];</li>
</ul>
</li>
<li>这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C 数据类型</li>
</ul>
</li>
<li><p>初始化数组</p>
<ul>
<li>在 C 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：<ul>
<li>double balance[5] &#x3D; {1000.0, 2.0, 3.4, 7.0, 50.0};</li>
</ul>
</li>
<li>大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目</li>
<li>如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数</li>
</ul>
</li>
<li><p>访问数组元素</p>
<ul>
<li>数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边</li>
</ul>
</li>
<li><p>获取数组长度</p>
<ul>
<li>数组长度可以使用 sizeof 运算符来获取数组的长度，例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numbers[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> length = <span class="keyword">sizeof</span>(numbers) / <span class="keyword">sizeof</span>(numbers[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></li>
<li>使用宏定义：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH(array) (sizeof(array) / sizeof(array[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = LENGTH(<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组长度为: %d\n&quot;</span>, length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数组名</p>
<ul>
<li>在 C 语言中，数组名表示数组的地址，即数组首元素的地址。当我们在声明和定义一个数组时，该数组名就代表着该数组的地址</li>
<li>例如，在以下代码中：<ul>
<li>int myArray[5] &#x3D; {10, 20, 30, 40, 50};</li>
</ul>
</li>
<li>在这里，myArray 是数组名，它表示整数类型的数组，包含 5 个元素。myArray 也代表着数组的地址，即第一个元素的地址</li>
<li>数组名本身是一个常量指针，意味着它的值是不能被改变的，一旦确定，就不能再指向其他地方</li>
<li>我们可以使用&amp;运算符来获取数组的地址，如下所示<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> myArray[<span class="number">5</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;myArray[<span class="number">0</span>]; <span class="comment">// 或者直接写作 int *ptr = myArray;</span></span><br></pre></td></tr></table></figure></li>
<li>在上面的例子中，ptr 指针变量被初始化为 myArray 的地址，即数组的第一个元素的地址。</li>
<li>需要注意的是，虽然数组名表示数组的地址，但在大多数情况下，数组名会自动转换为指向数组首元素的指针。这意味着我们可以直接将数组名用于指针运算</li>
</ul>
</li>
<li><p>C 中数组详解</p>
<ul>
<li>在 C 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C 程序员必须清楚的一些与数组相关的重要概念<ul>
<li>多维数组	          C 支持多维数组。多维数组最简单的形式是二维数组。</li>
<li>传递数组给函数	    您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</li>
<li>从函数返回数组	    C 允许从函数返回数组。</li>
<li>指向数组的指针	    您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。</li>
<li>静态数组与动态数组  静态数组在编译时分配内存，大小固定，而动态数组在运行时手动分配内存，大小可变。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="C-enum-枚举"><a href="#C-enum-枚举" class="headerlink" title="C enum(枚举)"></a>C enum(枚举)</h2><ul>
<li><p>枚举是 C 语言中的一种基本数据类型，用于定义一组具有离散值的常量，它可以让数据更简洁，更易读</p>
</li>
<li><p>枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性</p>
</li>
<li><p>定义一个枚举类型，需要使用 enum 关键字，后面跟着枚举类型的名称，以及用大括号 {} 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从 0 开始递增</p>
</li>
<li><p>枚举语法定义格式为：</p>
<ul>
<li>enum　枚举名　{枚举元素1,枚举元素2,……};</li>
</ul>
</li>
<li><p>注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推</p>
</li>
<li><p>枚举变量的定义</p>
<ul>
<li>前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量</li>
<li>我们可以通过以下三种方式来定义枚举变量</li>
<li>先定义枚举类型，再定义枚举变量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span> <span class="title">day</span>;</span></span><br></pre></td></tr></table></figure></li>
<li>定义枚举类型的同时定义枚举变量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure></li>
<li>省略枚举名称，直接定义枚举变量<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure></li>
<li>在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。</li>
<li>不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历</li>
</ul>
</li>
</ul>
<h2 id="C-指针"><a href="#C-指针" class="headerlink" title="C 指针"></a>C 指针</h2><ul>
<li><p>学习 C 语言的指针既简单又有趣。通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C 程序员，学习指针是很有必要的</p>
</li>
<li><p>正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用 &amp; 运算符访问的地址，它表示了在内存中的一个地址。</p>
</li>
<li><p>什么是指针</p>
<ul>
<li>指针也就是内存地址，指针变量是用来存放内存地址的变量。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</li>
<li>type *var_name;</li>
<li>在这里，type 是指针的基类型，它必须是一个有效的 C 数据类型，var_name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针</li>
<li>所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数</li>
<li>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同</li>
</ul>
</li>
<li><p>如何使用指针</p>
<ul>
<li>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值</li>
</ul>
</li>
<li><p>C 中的NULL指针</p>
<ul>
<li>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。</li>
<li>NULL 指针是一个定义在标准库中的值为零的常量</li>
<li>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</li>
<li>如需检查一个空指针，您可以使用 if 语句，如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ptr)     <span class="comment">/* 如果 p 非空，则完成 */</span></span><br><span class="line"><span class="keyword">if</span>(!ptr)    <span class="comment">/* 如果 p 为空，则完成 */</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>C 指针详解</p>
<ul>
<li>在 C 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C 程序员必须清楚的一些与指针相关的重要概念：</li>
<li>指针的算术运算	可以对指针进行四种算术运算：++、–、+、-</li>
<li>指针数组	     可以定义用来存储指针的数组。</li>
<li>指向指针的指针	C 允许指向指针的指针。</li>
<li>传递指针给函数	通过引用或地址传递参数，使传递的参数在调用函数中被改变。</li>
<li>从函数返回指针	C 允许函数返回指针到局部变量、静态变量和动态内存分配。</li>
</ul>
</li>
</ul>
<h2 id="C-函数指针与回调函数"><a href="#C-函数指针与回调函数" class="headerlink" title="C 函数指针与回调函数"></a>C 函数指针与回调函数</h2><ul>
<li><p>函数指针</p>
<ul>
<li>函数指针是指向函数的指针变量</li>
<li>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数</li>
<li>函数指针可以像一般函数一样，用于调用函数、传递参数</li>
<li>函数指针变量的声明<ul>
<li>typedef int (*fun_ptr)(int,int); &#x2F;&#x2F; 声明一个指向同样参数、返回值的函数指针类型</li>
</ul>
</li>
</ul>
</li>
<li><p>回调函数</p>
<ul>
<li>函数指针作为某个函数的参数</li>
<li>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数</li>
<li>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</li>
<li>以下是来自知乎作者常溪玲的解说：<ul>
<li>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C 字符串"></a>C 字符串</h2><ul>
<li>在 C 语言中，字符串实际上是使用空字符 \0 结尾的一维字符数组。因此，\0 是用于标记字符串的结束</li>
<li>空字符（Null character）又称结束符，缩写 NUL，是一个数值为 0 的控制字符，\0 是转义字符，意思是告诉编译器，这不是字符 0，而是空字符</li>
<li>其实，您不需要把 null 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 \0 放在字符串的末尾</li>
<li>C 中有大量操作字符串的函数：<ul>
<li>strcpy(s1, s2);<ul>
<li>复制字符串 s2 到字符串 s1。</li>
</ul>
</li>
<li>strcat(s1, s2);<ul>
<li>连接字符串 s2 到字符串 s1 的末尾。</li>
</ul>
</li>
<li>strlen(s1);<ul>
<li>返回字符串 s1 的长度。</li>
</ul>
</li>
<li>strcmp(s1, s2);<ul>
<li>如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</li>
</ul>
</li>
<li>strchr(s1, ch);<ul>
<li>返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</li>
</ul>
</li>
<li>strstr(s1, s2);<ul>
<li>返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="C-结构体"><a href="#C-结构体" class="headerlink" title="C 结构体"></a>C 结构体</h2><ul>
<li><p>C 数组允许定义可存储相同类型数据项的变量，结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项</p>
</li>
<li><p>结构体中的数据成员可以是基本数据类型（如 int、float、char 等），也可以是其他结构体类型、指针类型等。</p>
</li>
<li><p>定义结构</p>
<ul>
<li>结构体定义由关键字 struct 和结构体名组成，结构体名可以根据需要自行定义</li>
<li>struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct tag &#123; </span><br><span class="line">    member-list</span><br><span class="line">    member-list </span><br><span class="line">    member-list  </span><br><span class="line">    ...</span><br><span class="line">&#125; variable-list ;</span><br></pre></td></tr></table></figure></li>
<li>tag 是结构体标签。</li>
<li>member-list 是标准的变量定义，比如 int i; 或者 float f;，或者其他有效的变量定义</li>
<li>variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="type">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="type">int</span>   book_id;</span><br><span class="line">&#125; book;</span><br></pre></td></tr></table></figure></li>
<li>在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个</li>
<li>如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span>    <span class="comment">//对结构体B进行不完整声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体A中包含指向结构体B的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>访问结构成员</p>
<ul>
<li>为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 struct 关键字来定义结构类型的变量。</li>
</ul>
</li>
<li><p>结构作为函数参数</p>
<ul>
<li>您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似</li>
</ul>
</li>
<li><p>指向结构的指针</p>
<ul>
<li>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似。</li>
<li>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面</li>
<li>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符</li>
</ul>
</li>
<li><p>结构体大小的计算</p>
<ul>
<li>C 语言中，我们可以使用 sizeof 运算符来计算结构体的大小，sizeof 返回的是给定类型或变量的字节大小</li>
<li>对于结构体，sizeof 将返回结构体的总字节数，包括所有成员变量的大小以及可能的填充字节。</li>
<li>结构体的大小可能会受到编译器的优化和对齐规则的影响，编译器可能会在结构体中插入一些额外的填充字节以对齐结构体的成员变量，以提高内存访问效率。因此，结构体的实际大小可能会大于成员变量大小的总和，如果你需要确切地了解结构体的内存布局和对齐方式，可以使用 offsetof 宏和 <strong>attribute</strong>((packed)) 属性等进一步控制和查询结构体的大小和对齐方式。</li>
</ul>
</li>
</ul>
<h2 id="C-共用体"><a href="#C-共用体" class="headerlink" title="C 共用体"></a>C 共用体</h2><ul>
<li><p>共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</p>
</li>
<li><p>定义共用体</p>
<ul>
<li>为了定义共用体，您必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> [<span class="title">union</span> <span class="title">tag</span>]</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125; [one or more <span class="class"><span class="keyword">union</span> <span class="title">variables</span>];</span></span><br></pre></td></tr></table></figure></li>
<li>union tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">float</span> f;</span><br><span class="line">   <span class="type">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125; data;</span><br></pre></td></tr></table></figure></li>
<li>现在，Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。</li>
<li>共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的</li>
</ul>
</li>
<li><p>访问共用体成员</p>
<ul>
<li>为了访问共用体的成员，我们使用成员访问运算符（.）。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 union 关键字来定义共用体类型的变量。</li>
</ul>
</li>
</ul>
<h2 id="C-位域"><a href="#C-位域" class="headerlink" title="C 位域"></a>C 位域</h2><ul>
<li><p>C 语言的位域（bit-field）是一种特殊的结构体成员，允许我们按位对成员进行定义，指定其占用的位数。</p>
</li>
<li><p>如果程序的结构中包含多个开关的变量，即变量值为 TRUE&#x2F;FALSE，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> widthValidated;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> heightValidated;</span><br><span class="line">&#125; status;</span><br></pre></td></tr></table></figure></li>
<li><p>这种结构需要 8 字节的内存空间，但在实际上，在每个变量中，我们只存储 0 或 1，在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，您可以定义变量的宽度来告诉编译器，您将只使用这些字节。例如，上面的结构可以重写成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> widthValidated : <span class="number">1</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> heightValidated : <span class="number">1</span>;</span><br><span class="line">&#125; status;</span><br></pre></td></tr></table></figure></li>
<li><p>现在，上面的结构中，status 变量将占用 4 个字节的内存空间，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 status 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。</p>
</li>
<li><p>位域的特点和使用方法如下：</p>
<ul>
<li>定义位域时，可以指定成员的位域宽度，即成员所占用的位数。</li>
<li>位域的宽度不能超过其数据类型的大小，因为位域必须适应所使用的整数类型。</li>
<li>位域的数据类型可以是 int、unsigned int、signed int 等整数类型，也可以是枚举类型。</li>
<li>位域可以单独使用，也可以与其他成员一起组成结构体。</li>
<li>位域的访问是通过点运算符（.）来实现的，与普通的结构体成员访问方式相同。</li>
</ul>
</li>
<li><p>位域声明</p>
<ul>
<li>有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为”位域”或”位段”。</li>
<li>所谓”位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。</li>
<li>典型的实例：<ul>
<li>用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。</li>
<li>读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数</li>
</ul>
</li>
</ul>
</li>
<li><p>位域的定义和位域变量的说明</p>
<ul>
<li>位域定义与结构定义相仿，其形式为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct 位域结构名 </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> 位域列表</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>其中位域列表的形式为：<ul>
<li>type [member_name] : width ;</li>
</ul>
</li>
<li>下面是有关位域中变量元素的描述：<ul>
<li>type	只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。</li>
<li>member_name	位域的名称。</li>
<li>width	位域中位的数量。宽度必须小于或等于指定类型的位宽度。</li>
</ul>
</li>
<li>带有预定义宽度的变量被称为位域。位域可以存储多于 1 位的数</li>
</ul>
</li>
<li><p>对于位域的定义尚有以下几点说明：</p>
<ul>
<li>一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> a:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span>  :<span class="number">4</span>;    <span class="comment">/* 空域 */</span></span><br><span class="line">    <span class="type">unsigned</span> b:<span class="number">4</span>;    <span class="comment">/* 从下一单元开始存放 */</span></span><br><span class="line">    <span class="type">unsigned</span> c:<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位</li>
<li>位域的宽度不能超过它所依附的数据类型的长度，成员变量都是有类型的，这个类型限制了成员变量的最大长度，: 后面的数字不能超过这个长度</li>
<li>位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> a:<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>  :<span class="number">2</span>;    <span class="comment">/* 该 2 位不能使用 */</span></span><br><span class="line">    <span class="type">int</span> b:<span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> c:<span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的</li>
</ul>
</li>
<li><p>位域的使用</p>
<ul>
<li>位域的使用和结构成员的使用相同，其一般形式为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">位域变量名.位域名</span><br><span class="line">位域变量名-&gt;位域名</span><br></pre></td></tr></table></figure></li>
<li>位域允许用各种格式输出。</li>
</ul>
</li>
</ul>
<h2 id="C-typedef"><a href="#C-typedef" class="headerlink" title="C typedef"></a>C typedef</h2><ul>
<li><p>C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE</p>
<ul>
<li>typedef unsigned char BYTE;</li>
</ul>
</li>
<li><p>在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如：</p>
<ul>
<li>BYTE  b1, b2;</li>
</ul>
</li>
<li><p>按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下：</p>
<ul>
<li>typedef unsigned char byte;</li>
</ul>
</li>
<li><p>您也可以使用 typedef 来为用户自定义的数据类型取一个新的名字。</p>
</li>
<li><p>typedef vs #define</p>
<ul>
<li>#define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同：<ul>
<li>typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE</li>
<li>typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="C-输入-输出"><a href="#C-输入-输出" class="headerlink" title="C 输入 &amp; 输出"></a>C 输入 &amp; 输出</h2><ul>
<li><p>当我们提到输入时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。C 语言提供了一系列内置的函数来读取给定的输入，并根据需要填充到程序中</p>
</li>
<li><p>当我们提到输出时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。C 语言提供了一系列内置的函数来输出数据到计算机屏幕上和保存数据到文本文件或二进制文件中</p>
</li>
<li><p>标准文件</p>
<ul>
<li>C 语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。<ul>
<li>标准输入	stdin	键盘</li>
<li>标准输出	stdout	屏幕</li>
<li>标准错误	stderr	您的屏幕</li>
</ul>
</li>
<li>文件指针是访问文件的方式，本节将讲解如何从键盘上读取值以及如何把结果输出到屏幕上</li>
<li>C 语言中的 I&#x2F;O (输入&#x2F;输出) 通常使用 printf() 和 scanf() 两个函数</li>
<li>scanf() 函数用于从标准输入（键盘）读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕）。</li>
</ul>
</li>
<li><p>getchar() &amp; putchar() 函数</p>
<ul>
<li>int getchar(void) 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符</li>
<li>int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符</li>
</ul>
</li>
<li><p>gets() &amp; puts 函数</p>
<ul>
<li>char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。</li>
<li>int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout</li>
</ul>
</li>
<li><p>scanf() 和 printf() 函数</p>
<ul>
<li>int scanf(const char *format, …) 函数从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入</li>
<li>int printf(const char *format, …) 函数把输出写入到标准输出流 stdout ，并根据提供的格式产生输出</li>
<li>format 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用</li>
</ul>
</li>
</ul>
<h2 id="C-文件读写"><a href="#C-文件读写" class="headerlink" title="C 文件读写"></a>C 文件读写</h2><ul>
<li><p>一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C 语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件</p>
</li>
<li><p>打开文件</p>
<ul>
<li>您可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：<ul>
<li>FILE *fopen( const char *filename, const char *mode );</li>
</ul>
</li>
<li>在这里，filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个<ul>
<li>r	打开一个已有的文本文件，允许读取文件。</li>
<li>w	打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</li>
<li>a	打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</li>
<li>r+	打开一个文本文件，允许读写文件。</li>
<li>w+	打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</li>
<li>a+	打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</li>
</ul>
</li>
<li>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：<ul>
<li>“rb”, “wb”, “ab”, “rb+”, “r+b”, “wb+”, “w+b”, “ab+”, “a+b”</li>
</ul>
</li>
</ul>
</li>
<li><p>关闭文件</p>
<ul>
<li>为了关闭文件，请使用 fclose( ) 函数。函数的原型如下<ul>
<li>int fclose( FILE *fp );</li>
</ul>
</li>
<li>如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量</li>
<li>C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件</li>
</ul>
</li>
<li><p>写入文件</p>
<ul>
<li>下面是把字符写入到流中的最简单的函数：<ul>
<li>int fputc( int c, FILE *fp );</li>
</ul>
</li>
<li>函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：<ul>
<li>int fputs( const char *s, FILE *fp );</li>
</ul>
</li>
<li>函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。您也可以使用 int fprintf(FILE *fp,const char *format, …) 函数把一个字符串写入到文件中。尝试下面的实例：</li>
</ul>
</li>
<li><p>读取文件</p>
<ul>
<li>下面是从文件读取单个字符的最简单的函数：</li>
<li>int fgetc( FILE * fp );</li>
<li>fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF。下面的函数允许您从流中读取一个字符串：</li>
<li>char *fgets( char *buf, int n, FILE *fp );</li>
<li>函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。</li>
<li>如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。您也可以使用 int fscanf(FILE *fp, const char *format, …) 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取</li>
</ul>
</li>
<li><p>二进制 I&#x2F;O 函数</p>
<ul>
<li>下面两个函数用于二进制输入和输出：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size_of_elements, </span></span><br><span class="line"><span class="params">             <span class="type">size_t</span> number_of_elements, FILE *a_file)</span>;</span><br><span class="line">              </span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size_of_elements, </span></span><br><span class="line"><span class="params">             <span class="type">size_t</span> number_of_elements, FILE *a_file)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="C-预处理器"><a href="#C-预处理器" class="headerlink" title="C 预处理器"></a>C 预处理器</h2><ul>
<li><p>C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。</p>
</li>
<li><p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：</p>
<ul>
<li>#define	定义宏</li>
<li>#include	包含一个源代码文件</li>
<li>#undef	取消已定义的宏</li>
<li>#ifdef	如果宏已经定义，则返回真</li>
<li>#ifndef	如果宏没有定义，则返回真</li>
<li>#if	如果给定条件为真，则编译下面代码</li>
<li>#else	#if 的替代方案</li>
<li>#elif	如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</li>
<li>#endif	结束一个 #if……#else 条件编译块</li>
<li>#error	当遇到标准错误时，输出错误消息</li>
<li>#pragma	使用标准化方法，向编译器发布特殊的命令到编译器中</li>
</ul>
</li>
<li><p>预处理器示例</p>
<ul>
<li>#define MAX_ARRAY_LENGTH 20<ul>
<li>这个指令告诉 CPP 把所有的 MAX_ARRAY_LENGTH 定义为 20。使用 #define 定义常量来增强可读性。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>这些指令告诉 CPP 从系统库中获取 stdio.h，并添加文本到当前的源文件中。下一行告诉 CPP 从本地目录中获取 myheader.h，并添加内容到当前的源文件中。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span>  FILE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_SIZE 42</span></span><br></pre></td></tr></table></figure></li>
<li>这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MESSAGE</span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> MESSAGE <span class="string">&quot;You wish!&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">   <span class="comment">/* Your debugging statements here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 -DDEBUG 开关量，这个指令就非常有用。它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。</li>
</ul>
</li>
<li><p>预定义宏</p>
<ul>
<li>ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏<ul>
<li><code>__DATE__</code>	当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。</li>
<li><code>__TIME__</code>	当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。</li>
<li><code>__FILE__</code>	这会包含当前文件名，一个字符串常量。</li>
<li><code>__LINE__</code>	这会包含当前行号，一个十进制常量。</li>
<li><code>__STDC__</code>	当编译器以 ANSI 标准编译时，则定义为 1。</li>
</ul>
</li>
</ul>
</li>
<li><p>预处理器运算符</p>
<ul>
<li>C 预处理器提供了下列的运算符来帮助您创建宏：<ul>
<li>宏延续运算符（\）</li>
</ul>
</li>
<li>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  message_for(a, b)  \</span></span><br><span class="line"><span class="meta">    printf(#a <span class="string">&quot; and &quot;</span> #b <span class="string">&quot;: We love you!\n&quot;</span>)</span></span><br></pre></td></tr></table></figure></li>
<li>标记粘贴运算符（##）<ul>
<li>宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tokenpaster(n) printf (<span class="string">&quot;token&quot;</span> #n <span class="string">&quot; = %d&quot;</span>, token##n)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> token34 = <span class="number">40</span>;</span><br><span class="line">   </span><br><span class="line">   tokenpaster(<span class="number">34</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了字符串常量化运算符（#）和标记粘贴运算符（##）。</li>
<li>defined() 运算符<ul>
<li>预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined (MESSAGE)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> MESSAGE <span class="string">&quot;You wish!&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Here is the message: %s\n&quot;</span>, MESSAGE);  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>参数化的宏</p>
<ul>
<li>CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>我们可以使用宏重写上面的代码，如下：<ul>
<li>#define square(x) ((x) * (x))</li>
</ul>
</li>
<li>在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Max between 20 and 10 is %d\n&quot;</span>, MAX(<span class="number">10</span>, <span class="number">20</span>));  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="C-头文件"><a href="#C-头文件" class="headerlink" title="C 头文件"></a>C 头文件</h2><ul>
<li><p>头文件是扩展名为 .h 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。</p>
</li>
<li><p>在程序中要使用头文件，需要使用 C 预处理指令 #include 来引用它。前面我们已经看过 stdio.h 头文件，它是编译器自带的头文件。</p>
</li>
<li><p>引用头文件相当于复制头文件的内容，但是我们不会直接在源文件中复制头文件的内容，因为这么做很容易出错，特别在程序是由多个源文件组成的时候。</p>
</li>
<li><p>A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。</p>
</li>
<li><p>引用头文件的语法</p>
<ul>
<li>使用预处理指令 #include 可以引用用户和系统头文件。它的形式有以下两种：</li>
<li>#include <file><ul>
<li>这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</li>
</ul>
</li>
<li>#include “file”<ul>
<li>这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</li>
</ul>
</li>
</ul>
</li>
<li><p>只引用一次头文件</p>
<ul>
<li>如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEADER_FILE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEADER_FILE</span></span><br><span class="line"></span><br><span class="line">the entire header file file</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>这种结构就是通常所说的包装器 #ifndef。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它</li>
</ul>
</li>
<li><p>有条件引用</p>
<ul>
<li>有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> SYSTEM_1</span></span><br><span class="line">   <span class="meta"># <span class="keyword">include</span> <span class="string">&quot;system_1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> SYSTEM_2</span></span><br><span class="line">   <span class="meta"># <span class="keyword">include</span> <span class="string">&quot;system_2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> SYSTEM_3</span></span><br><span class="line">   ...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的有条件引用。它不是用头文件的名称作为 #include 的直接参数，您只需要使用宏名称代替即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYSTEM_H <span class="string">&quot;system_1.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> SYSTEM_H</span></span><br></pre></td></tr></table></figure>
<ul>
<li>SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 #include 最初编写的那样。SYSTEM_H 可通过 -D 选项被您的 Makefile 定义。</li>
</ul>
</li>
<li><p>在有多个 .h 文件和多个 .c 文件的时候，往往我们会用一个 global.h 的头文件来包括所有的 .h 文件，然后在除 global.h 文件外的头文件中 包含 global.h 就可以实现所有头文件的包含，同时不会乱。方便在各个文件里面调用其他文件的函数或者变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GLOBAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GLOBAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Config.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="C-强制类型转换"><a href="#C-强制类型转换" class="headerlink" title="C 强制类型转换"></a>C 强制类型转换</h2><ul>
<li><p>强制类型转换是把变量从一种类型转换为另一种数据类型。例如，如果您想存储一个 long 类型的值到一个简单的整型中，您需要把 long 类型强制转换为 int 类型。您可以使用强制类型转换运算符来把值显式地从一种类型转换为另一种类型，如下所示：</p>
<ul>
<li>(type_name) expression</li>
</ul>
</li>
<li><p>类型转换可以是隐式的，由编译器自动执行，也可以是显式的，通过使用强制类型转换运算符来指定。在编程时，有需要类型转换的时候都用上强制类型转换运算符，是一种良好的编程习惯。</p>
</li>
<li><p>整数提升</p>
<ul>
<li>整数提升是指把小于 int 或 unsigned int 的整数类型转换为 int 或 unsigned int 的过程。</li>
</ul>
</li>
<li><p>常用的算术转换</p>
<ul>
<li>int -&gt; unsigned int -&gt; long -&gt; unsigned long -&gt; long long -&gt; unsigned long long -&gt; float -&gt; double -&gt; long double</li>
<li>常用的算术转换不适用于赋值运算符、逻辑运算符 &amp;&amp; 和 ||。</li>
</ul>
</li>
</ul>
<h2 id="C-错误处理"><a href="#C-错误处理" class="headerlink" title="C 错误处理"></a>C 错误处理</h2><ul>
<li><p>C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。</p>
</li>
<li><p>所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。</p>
</li>
<li><p>errno、perror() 和 strerror()</p>
<ul>
<li>C 语言提供了 perror() 和 strerror() 函数来显示与 errno 相关的文本消息。<ul>
<li>perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。</li>
<li>strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。</li>
</ul>
</li>
</ul>
</li>
<li><p>被零除的错误</p>
<ul>
<li>在进行除法运算时，如果不检查除数是否为零，则会导致一个运行时错误。</li>
</ul>
</li>
<li><p>程序退出状态</p>
<ul>
<li>通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。</li>
<li>如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。</li>
</ul>
</li>
</ul>
<h2 id="C-递归"><a href="#C-递归" class="headerlink" title="C 递归"></a>C 递归</h2><ul>
<li>递归指的是在函数的定义中使用函数自身的方法</li>
<li>C 语言支持递归，即一个函数可以调用其自身。但在使用递归时，程序员需要注意定义一个从函数退出的条件，否则会进入死循环。</li>
<li>递归函数在解决许多数学问题上起了至关重要的作用，比如计算一个数的阶乘、生成斐波那契数列，等等</li>
</ul>
<h2 id="C-可变参数"><a href="#C-可变参数" class="headerlink" title="C 可变参数"></a>C 可变参数</h2><ul>
<li>有时，您可能会碰到这样的情况，您希望函数带有可变数量的参数，而不是预定义数量的参数。</li>
<li>C 语言为这种情况提供了一个解决方案，它允许您定义一个函数，能根据具体的需求接受可变数量的参数。</li>
<li>声明方式为：<ul>
<li>int func_name(int arg1, …);</li>
</ul>
</li>
<li>其中，省略号 … 表示可变参数列表。</li>
<li>下面的实例演示了这种函数的使用：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>, ... )</span>  &#123;</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   func(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">   func(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>请注意，函数 func() 最后一个参数写成省略号，即三个点号（…），省略号之前的那个参数是 int，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 stdarg.h 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：<ul>
<li>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</li>
<li>在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。</li>
<li>使用 int 参数和 va_start() 宏来初始化 va_list 变量为一个参数列表。宏 va_start() 是在 stdarg.h 头文件中定义的。</li>
<li>使用 va_arg() 宏和 va_list 变量来访问参数列表中的每个项。</li>
<li>使用宏 va_end() 来清理赋予 va_list 变量的内存。</li>
</ul>
</li>
<li>常用的宏有：<ul>
<li>va_start(ap, last_arg)：初始化可变参数列表。ap 是一个 va_list 类型的变量，last_arg 是最后一个固定参数的名称（也就是可变参数列表之前的参数）。该宏将 ap 指向可变参数列表中的第一个参数。</li>
<li>va_arg(ap, type)：获取可变参数列表中的下一个参数。ap 是一个 va_list 类型的变量，type 是下一个参数的类型。该宏返回类型为 type 的值，并将 ap 指向下一个参数。</li>
<li>va_end(ap)：结束可变参数列表的访问。ap 是一个 va_list 类型的变量。该宏将 ap 置为 NULL。</li>
</ul>
</li>
<li>现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">int</span> num,...)</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    va_list valist;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 为 num 个参数初始化 valist */</span></span><br><span class="line">    va_start(valist, num);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 访问所有赋给 valist 的参数 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       sum += va_arg(valist, <span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清理为 valist 保留的内存 */</span></span><br><span class="line">    va_end(valist);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sum/num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Average of 2, 3, 4, 5 = %f\n&quot;</span>, average(<span class="number">4</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Average of 5, 10, 15 = %f\n&quot;</span>, average(<span class="number">3</span>, <span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C 内存管理"></a>C 内存管理</h2><ul>
<li><p>本章将讲解 C 中的动态内存管理。C 语言为内存的分配和管理提供了几个函数。这些函数可以在 &lt;stdlib.h&gt; 头文件中找到。</p>
</li>
<li><p>在 C 语言中，内存是通过指针变量来管理的。指针是一个变量，它存储了一个内存地址，这个内存地址可以指向任何数据类型的变量，包括整数、浮点数、字符和数组等。C 语言提供了一些函数和运算符，使得程序员可以对内存进行操作，包括分配、释放、移动和复制等。</p>
</li>
<li><p>void <em>calloc(int num, int size);<br>在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num</em>size 个字节长度的内存空间，并且每个字节的值都是 0。</p>
</li>
<li><p>void free(void *address);<br>该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</p>
</li>
<li><p>void *malloc(int num);<br>在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</p>
</li>
<li><p>void *realloc(void *address, int newsize);<br>该函数重新分配内存，把内存扩展到 newsize。</p>
</li>
<li><p>注意：void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。</p>
</li>
<li><p>重新调整内存的大小和释放内存</p>
<ul>
<li>当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，都应该调用函数 free() 来释放内存。</li>
<li>或者，您可以通过调用函数 realloc() 来增加或减少已分配的内存块的大小</li>
</ul>
</li>
<li><p>C 语言中常用的内存管理函数和运算符</p>
<ul>
<li>malloc() 函数：用于动态分配内存。它接受一个参数，即需要分配的内存大小（以字节为单位），并返回一个指向分配内存的指针。</li>
<li>free() 函数：用于释放先前分配的内存。它接受一个指向要释放内存的指针作为参数，并将该内存标记为未使用状态。</li>
<li>calloc() 函数：用于动态分配内存，并将其初始化为零。它接受两个参数，即需要分配的内存块数和每个内存块的大小（以字节为单位），并返回一个指向分配内存的指针。</li>
<li>realloc() 函数：用于重新分配内存。它接受两个参数，即一个先前分配的指针和一个新的内存大小，然后尝试重新调整先前分配的内存块的大小。如果调整成功，它将返回一个指  + 向重新分配内存的指针，否则返回一个空指针。</li>
<li>sizeof 运算符：用于获取数据类型或变量的大小（以字节为单位）。</li>
<li>指针运算符：用于获取指针所指向的内存地址或变量的值。</li>
<li>&amp; 运算符：用于获取变量的内存地址。</li>
<li><ul>
<li>运算符：用于获取指针所指向的变量的值。</li>
</ul>
</li>
<li>-&gt; 运算符：用于指针访问结构体成员，语法为 pointer-&gt;member，等价于 (*pointer).member。</li>
<li>memcpy() 函数：用于从源内存区域复制数据到目标内存区域。它接受三个参数，即目标内存区域的指针、源内存区域的指针和要复制的数据大小（以字节为单位）。</li>
<li>memmove() 函数：类似于 memcpy() 函数，但它可以处理重叠的内存区域。它接受三个参数，即目标内存区域的指针、源内存区域的指针和要复制的数据大小（以字节为单位）</li>
</ul>
</li>
</ul>
<h2 id="C-命令行参数"><a href="#C-命令行参数" class="headerlink" title="C 命令行参数"></a>C 命令行参数</h2><ul>
<li>执行程序时，可以从命令行传值给 C 程序。这些值被称为命令行参数，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。</li>
<li>命令行参数是使用 main() 函数参数来处理的，其中，argc 是指传入参数的个数，argv[] 是一个指针数组，指向传递给程序的每个参数。</li>
<li>应当指出的是，argv[0] 存储程序的名称，argv[1] 是一个指向第一个命令行参数的指针，*argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，argc 将被设置为 2</li>
<li>多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号 “” 或单引号 ‘’ 内部。让我们重新编写上面的实例，有一个空间，那么你可以通过这样的观点，把它们放在双引号或单引号””””。让我们重新编写上面的实例，向程序传递一个放置在双引号内部的命令行参数：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span>  </span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Program name %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>( argc == <span class="number">2</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The argument supplied is %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>( argc &gt; <span class="number">2</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Too many arguments supplied.\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;One argument expected.\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="C-排序算法"><a href="#C-排序算法" class="headerlink" title="C 排序算法"></a>C 排序算法</h2><ul>
<li><p>冒泡排序</p>
<ul>
<li>冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    bubble_sort(arr, len);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>选择排序</p>
<ul>
<li>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">selection_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> min = i;                  <span class="comment">// 记录最小值，第一个元素默认最小</span></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)     <span class="comment">// 访问未排序的元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[min])    <span class="comment">// 找到目前最小值</span></span><br><span class="line">            &#123;</span><br><span class="line">                min = j;    <span class="comment">// 记录最小值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min != i)</span><br><span class="line">        &#123;</span><br><span class="line">            temp=a[min];  <span class="comment">// 交换两个变量</span></span><br><span class="line">            a[min]=a[i];</span><br><span class="line">            a[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* swap(&amp;a[min], &amp;a[i]);  */</span>   <span class="comment">// 使用自定义函数交換</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void swap(int *a,int *b) // 交换两个变量</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int temp = *a;</span></span><br><span class="line"><span class="comment">    *a = *b;</span></span><br><span class="line"><span class="comment">    *b = temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>插入排序</p>
<ul>
<li>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\displaystyle O(1)} {\displaystyle O(1)}的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertion_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j=i;j&gt;<span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>]&gt;temp;j--)</span><br><span class="line">                    arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>希尔排序</p>
<ul>
<li>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法</li>
<li>希尔排序是基于插入排序的以下两点性质而提出改进方法的<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shell_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> gap, i, j;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (gap = len &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap = gap &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>归并排序</p>
<ul>
<li>把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。</li>
<li>可从上到下或从下到上进行。</li>
</ul>
</li>
<li><p>迭代法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* a = arr;</span><br><span class="line">    <span class="type">int</span>* b = (<span class="type">int</span>*) <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> seg, start;</span><br><span class="line">    <span class="keyword">for</span> (seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line">        <span class="keyword">for</span> (start = <span class="number">0</span>; start &lt; len; start += seg + seg) &#123;</span><br><span class="line">            <span class="type">int</span> low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);</span><br><span class="line">            <span class="type">int</span> k = low;</span><br><span class="line">            <span class="type">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="type">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">                b[k++] = a[start1++];</span><br><span class="line">            <span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>* temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>递归法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge_sort_recursive</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> reg[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> len = end - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">    <span class="type">int</span> start1 = start, end1 = mid;</span><br><span class="line">    <span class="type">int</span> start2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line">    merge_sort_recursive(arr, reg, start1, end1);</span><br><span class="line">    merge_sort_recursive(arr, reg, start2, end2);</span><br><span class="line">    <span class="type">int</span> k = start;</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">        reg[k++] = arr[start1++];</span><br><span class="line">    <span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start2++];</span><br><span class="line">    <span class="keyword">for</span> (k = start; k &lt;= end; k++)</span><br><span class="line">        arr[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">const</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> reg[len];</span><br><span class="line">    merge_sort_recursive(arr, reg, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>快速排序</p>
<ul>
<li>在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。</li>
</ul>
</li>
<li><p>迭代法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Range</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line">&#125; Range;</span><br><span class="line">Range <span class="title function_">new_Range</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    Range r;</span><br><span class="line">    r.start = s;</span><br><span class="line">    r.end = e;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">const</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 避免len等於負值時引發段錯誤（Segment Fault）</span></span><br><span class="line">    <span class="comment">// r[]模擬列表,p為數量,r[p++]為push,r[--p]為pop且取得元素</span></span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = new_Range(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.end)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> mid = arr[(range.start + range.end) / <span class="number">2</span>]; <span class="comment">// 選取中間點為基準點</span></span><br><span class="line">        <span class="type">int</span> left = range.start, right = range.end;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid) ++left;   <span class="comment">// 檢測基準點左側是否符合要求</span></span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt; mid) --right; <span class="comment">//檢測基準點右側是否符合要求</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(&amp;arr[left],&amp;arr[right]);</span><br><span class="line">                left++;right--;               <span class="comment">// 移動指針以繼續</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (left &lt;= right);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (range.start &lt; right) r[p++] = new_Range(range.start, right);</span><br><span class="line">        <span class="keyword">if</span> (range.end &gt; left) r[p++] = new_Range(left, range.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>递归法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort_recursive</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = arr[end];</span><br><span class="line">    <span class="type">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right)</span><br><span class="line">            right--;</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[left] &gt;= arr[end])</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left++;</span><br><span class="line">    <span class="keyword">if</span> (left)</span><br><span class="line">        quick_sort_recursive(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    quick_sort_recursive(arr, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_6_network_%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/2024-05-22-C_6_4_sys_epoll_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_6_network_%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/2024-05-22-C_6_4_sys_epoll_h/" class="post-title-link" itemprop="url">C_6_4_sys_epoll_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>&lt;sys&#x2F;epoll.h&gt;笔记</li>
</ul>
<h2 id="linux-是什么"><a href="#linux-是什么" class="headerlink" title="linux &lt;sys&#x2F;epoll.h&gt;是什么"></a>linux &lt;sys&#x2F;epoll.h&gt;是什么</h2><p><code>&lt;sys/epoll.h&gt;</code> 是 Linux 系统中用于使用 <code>epoll()</code> 系统调用的头文件。<code>epoll</code> 是一种高效的 I&#x2F;O 多路复用机制，用于监视大量文件描述符上的事件。该头文件中包含了 <code>epoll()</code> 系统调用所需的函数原型和相关宏定义。</p>
<p><code>&lt;sys/epoll.h&gt;</code> 提供了以下重要的函数和数据结构：</p>
<h3 id="1-epoll-create"><a href="#1-epoll-create" class="headerlink" title="1. epoll_create()"></a>1. <code>epoll_create()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个 epoll 实例，返回一个文件描述符用于操作 epoll 实例。<code>size</code> 参数已经不再起到作用，只是一个提示值。</li>
</ul>
<h3 id="2-epoll-ctl"><a href="#2-epoll-ctl" class="headerlink" title="2. epoll_ctl()"></a>2. <code>epoll_ctl()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>用于在 epoll 实例中注册、修改或删除文件描述符和事件。</li>
<li><code>epfd</code> 是 epoll 实例的文件描述符。</li>
<li><code>op</code> 是操作类型，可以是 <code>EPOLL_CTL_ADD</code>、<code>EPOLL_CTL_MOD</code> 或 <code>EPOLL_CTL_DEL</code>，分别用于添加、修改或删除文件描述符和事件。</li>
<li><code>fd</code> 是要监视的文件描述符。</li>
<li><code>event</code> 是 <code>struct epoll_event</code> 结构体，用于描述要监视的事件类型。</li>
</ul>
<h3 id="3-epoll-wait"><a href="#3-epoll-wait" class="headerlink" title="3. epoll_wait()"></a>3. <code>epoll_wait()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>等待文件描述符上的事件发生。</li>
<li><code>epfd</code> 是 epoll 实例的文件描述符。</li>
<li><code>events</code> 是一个用于存储事件的数组。</li>
<li><code>maxevents</code> 是 <code>events</code> 数组的大小，表示最多可以存储多少个事件。</li>
<li><code>timeout</code> 是等待的超时时间（以毫秒为单位），如果设置为 -1 则表示一直等待直到有事件发生。</li>
</ul>
<h3 id="4-struct-epoll-event"><a href="#4-struct-epoll-event" class="headerlink" title="4. struct epoll_event"></a>4. <code>struct epoll_event</code></h3><p>该头文件中还定义了 <code>struct epoll_event</code> 结构体，用于描述要监视的事件。该结构体包含了两个成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> events;       <span class="comment">// 事件类型</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;    <span class="comment">// 用户数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>events</code> 是要监视的事件类型，可以是 <code>EPOLLIN</code>、<code>EPOLLOUT</code>、<code>EPOLLERR</code>、<code>EPOLLHUP</code> 等。</li>
<li><code>data</code> 是一个 union 类型，可以存储文件描述符或者用户自定义的指针等信息。</li>
</ul>
<p>总的来说，<code>&lt;sys/epoll.h&gt;</code> 头文件提供了使用 <code>epoll()</code> 系统调用所需的函数原型和相关数据结构。它是在 Linux 中实现高效的 I&#x2F;O 多路复用机制的关键头文件之一。</p>
<h2 id="linux-详解"><a href="#linux-详解" class="headerlink" title="linux &lt;sys&#x2F;epoll.h&gt;详解"></a>linux &lt;sys&#x2F;epoll.h&gt;详解</h2><p><code>&lt;sys/epoll.h&gt;</code> 是 Linux 系统中用于使用 <code>epoll()</code> 系统调用的头文件。<code>epoll</code> 是一种高效的 I&#x2F;O 多路复用机制，允许程序有效地管理大量文件描述符上的事件，特别适用于高并发的网络编程场景。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><code>&lt;sys/epoll.h&gt;</code> 头文件中包含了 <code>epoll_event</code> 结构体，用于描述要监视的事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> events;     <span class="comment">// 表示要监视的事件类型</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;   <span class="comment">// 与事件相关的用户数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>events</code> 是一个位掩码，表示要监视的事件类型，例如 <code>EPOLLIN</code>、<code>EPOLLOUT</code>、<code>EPOLLERR</code>、<code>EPOLLHUP</code> 等。</li>
<li><code>data</code> 是一个 union 类型，可以存储文件描述符或者用户定义的指针等数据。</li>
</ul>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><p><code>&lt;sys/epoll.h&gt;</code> 包含了以下关键的函数原型：</p>
<h4 id="1-int-epoll-create-int-size"><a href="#1-int-epoll-create-int-size" class="headerlink" title="1. int epoll_create(int size);"></a>1. <code>int epoll_create(int size);</code></h4><ul>
<li>创建一个 epoll 实例，返回一个文件描述符以供操作 epoll 实例。<code>size</code> 参数已经不再起到作用，只是一个提示值。</li>
</ul>
<h4 id="2-int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event"><a href="#2-int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event" class="headerlink" title="2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);"></a>2. <code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code></h4><ul>
<li>用于在 epoll 实例中注册、修改或删除文件描述符和事件。</li>
<li><code>epfd</code> 是 epoll 实例的文件描述符。</li>
<li><code>op</code> 是操作类型，可以是 <code>EPOLL_CTL_ADD</code>、<code>EPOLL_CTL_MOD</code> 或 <code>EPOLL_CTL_DEL</code>，分别用于添加、修改或删除文件描述符和事件。</li>
<li><code>fd</code> 是要监视的文件描述符。</li>
<li><code>event</code> 是 <code>struct epoll_event</code> 结构体，用于描述要监视的事件类型。</li>
</ul>
<h4 id="3-int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout"><a href="#3-int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout" class="headerlink" title="3. int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);"></a>3. <code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</code></h4><ul>
<li>等待文件描述符上的事件发生。</li>
<li><code>epfd</code> 是 epoll 实例的文件描述符。</li>
<li><code>events</code> 是一个用于存储事件的数组。</li>
<li><code>maxevents</code> 是 <code>events</code> 数组的大小，表示最多可以存储多少个事件。</li>
<li><code>timeout</code> 是等待的超时时间（以毫秒为单位），如果设置为 -1 则表示一直等待直到有事件发生。</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>创建一个 epoll 实例：<code>int epfd = epoll_create(size);</code></li>
<li>通过 <code>epoll_ctl()</code> 将文件描述符添加到 epoll 实例中：<code>epoll_ctl(epfd, op, fd, &amp;event);</code></li>
<li>使用 <code>epoll_wait()</code> 等待文件描述符上的事件：<code>int nfds = epoll_wait(epfd, events, maxevents, timeout);</code></li>
</ol>
<p><code>&lt;sys/epoll.h&gt;</code> 提供了使用 <code>epoll()</code> 系统调用所需的函数原型和相关数据结构，允许程序更有效地管理和监视大量文件描述符上的事件。这是一种适用于高性能网络编程和并发处理的重要机制。</p>
<h2 id="linux-struct-epoll-event详解"><a href="#linux-struct-epoll-event详解" class="headerlink" title="linux &lt;sys&#x2F;epoll.h&gt; struct epoll_event详解"></a>linux &lt;sys&#x2F;epoll.h&gt; struct epoll_event详解</h2><p><code>struct epoll_event</code> 是 <code>&lt;sys/epoll.h&gt;</code> 中定义的数据结构，用于描述 <code>epoll</code> 实例中的事件，它包含了要监视的事件类型以及与事件相关的数据。</p>
<p>以下是 <code>struct epoll_event</code> 结构体的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> events;     <span class="comment">// 表示要监视的事件类型</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;   <span class="comment">// 与事件相关的用户数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>events</code> 是一个 32 位的无符号整数，表示要监视的事件类型。它是一个位掩码，可以是以下事件类型的组合：</p>
<ul>
<li><code>EPOLLIN</code>：表示对应的文件描述符上有数据可读。</li>
<li><code>EPOLLOUT</code>：表示对应的文件描述符可以写入。</li>
<li><code>EPOLLERR</code>：表示对应的文件描述符发生错误。</li>
<li><code>EPOLLHUP</code>：表示对应的文件描述符挂起，可能是连接断开或者被关闭。</li>
<li>等等，还有其他类型的事件。</li>
</ul>
</li>
<li><p><code>data</code> 是一个 <code>epoll_data_t</code> 类型的 union。它可以存储文件描述符或者用户定义的指针等数据。具体定义如下：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *ptr;           <span class="comment">// 用户定义的数据指针</span></span><br><span class="line">    <span class="type">int</span> fd;              <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>

<p>这个 union 可以存储不同类型的数据，具体存储什么样的数据取决于应用程序中的使用方式。</p>
<p><code>struct epoll_event</code> 结构体用于向 <code>epoll</code> 实例中注册文件描述符并指定要监视的事件类型，以及关联额外的数据。在调用 <code>epoll_ctl()</code> 向 <code>epoll</code> 实例中添加、修改或删除文件描述符时，会用到这个结构体。</p>
<p>这个结构体是在使用 <code>epoll</code> 实现高效的 I&#x2F;O 多路复用时必不可少的一部分，它描述了应用程序感兴趣的事件类型以及与之关联的数据。</p>
<h2 id="linux-epoll-create-详解"><a href="#linux-epoll-create-详解" class="headerlink" title="linux &lt;sys&#x2F;epoll.h&gt; epoll_create()详解"></a>linux &lt;sys&#x2F;epoll.h&gt; epoll_create()详解</h2><p><code>epoll_create()</code> 是 Linux 中用于创建 epoll 实例的系统调用之一，它返回一个文件描述符，用于对 epoll 实例进行操作。</p>
<h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>size</code> 是一个已被废弃的参数，代表要监视的文件描述符数量的一个提示。该参数在现代内核中已经不再起作用，仅作为一个历史遗留而保留。</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li>如果成功，<code>epoll_create()</code> 返回一个新的文件描述符，用于对 epoll 实例进行操作。</li>
<li>如果失败，返回值为 -1，并且设置 <code>errno</code> 表示错误的原因。</li>
</ul>
<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> epoll_fd = epoll_create(<span class="number">10</span>); <span class="comment">// 创建 epoll 实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 epoll 实例进行操作，例如使用 epoll_ctl() 注册文件描述符等</span></span><br><span class="line"></span><br><span class="line">    close(epoll_fd); <span class="comment">// 关闭 epoll 实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><code>epoll_create()</code> 用于创建一个 epoll 实例，该实例允许程序监视文件描述符上的事件。</li>
<li>它返回一个文件描述符，后续可以使用 <code>epoll_ctl()</code> 向这个 epoll 实例中添加、修改或删除文件描述符和事件，并使用 <code>epoll_wait()</code> 等待文件描述符上的事件发生。</li>
</ul>
<p>总的来说，<code>epoll_create()</code> 创建一个 epoll 实例，并返回一个文件描述符，该文件描述符用于对 epoll 实例进行操作。这是使用 epoll 实现高效 I&#x2F;O 多路复用的第一步。</p>
<h2 id="linux-epoll-ctl-详解"><a href="#linux-epoll-ctl-详解" class="headerlink" title="linux &lt;sys&#x2F;epoll.h&gt; epoll_ctl()详解"></a>linux &lt;sys&#x2F;epoll.h&gt; epoll_ctl()详解</h2><p><code>epoll_ctl()</code> 是 Linux 中 <code>&lt;sys/epoll.h&gt;</code> 头文件中定义的函数，用于控制（管理） epoll 实例中的文件描述符和事件，可以实现添加、修改或删除文件描述符和事件的操作。</p>
<h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>epfd</code> 是 epoll 实例的文件描述符，由 <code>epoll_create()</code> 创建。</li>
<li><code>op</code> 是控制操作的类型，可以是以下之一：<ul>
<li><code>EPOLL_CTL_ADD</code>：将文件描述符添加到 epoll 实例中。</li>
<li><code>EPOLL_CTL_MOD</code>：修改已经注册的文件描述符的事件。</li>
<li><code>EPOLL_CTL_DEL</code>：从 epoll 实例中删除文件描述符。</li>
</ul>
</li>
<li><code>fd</code> 是要操作的文件描述符。</li>
<li><code>event</code> 是一个指向 <code>struct epoll_event</code> 结构体的指针，用于指定要监视的事件类型。</li>
</ul>
<h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li>如果操作成功，<code>epoll_ctl()</code> 返回 0。</li>
<li>如果出现错误，返回值为 -1，并设置 <code>errno</code> 表示错误的原因。</li>
</ul>
<h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> epoll_fd = epoll_create(<span class="number">10</span>); <span class="comment">// 创建 epoll 实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.events = EPOLLIN; <span class="comment">// 监视可读事件</span></span><br><span class="line">    event.data.fd = <span class="comment">/* Your file descriptor */</span>; <span class="comment">// 设置要监视的文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, <span class="comment">/*fd*/</span>, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行其他的 epoll_ctl() 操作，如修改事件、删除文件描述符等</span></span><br><span class="line"></span><br><span class="line">    close(epoll_fd); <span class="comment">// 关闭 epoll 实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul>
<li><code>epoll_ctl()</code> 用于向 epoll 实例中注册、修改或删除文件描述符和事件。</li>
<li>通过 <code>EPOLL_CTL_ADD</code>，可以将文件描述符添加到 epoll 实例中，并指定要监视的事件类型。</li>
<li><code>EPOLL_CTL_MOD</code> 可用于修改已经注册的文件描述符的事件。</li>
<li><code>EPOLL_CTL_DEL</code> 可以从 epoll 实例中删除文件描述符。</li>
</ul>
<p>总之，<code>epoll_ctl()</code> 允许程序员控制 epoll 实例，对文件描述符进行添加、修改或删除操作，并定义要监视的事件类型，以便在调用 <code>epoll_wait()</code> 等待事件发生时得到相应的通知。</p>
<h2 id="linux-epoll-wait-详解"><a href="#linux-epoll-wait-详解" class="headerlink" title="linux &lt;sys&#x2F;epoll.h&gt; epoll_wait()详解"></a>linux &lt;sys&#x2F;epoll.h&gt; epoll_wait()详解</h2><p><code>epoll_wait()</code> 是 Linux 中 <code>&lt;sys/epoll.h&gt;</code> 头文件中定义的函数，用于等待文件描述符上的事件发生，是使用 epoll 实现 I&#x2F;O 多路复用的核心之一。</p>
<h3 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>epfd</code> 是 epoll 实例的文件描述符，由 <code>epoll_create()</code> 创建。</li>
<li><code>events</code> 是一个用于存储事件的数组。</li>
<li><code>maxevents</code> 是 <code>events</code> 数组的大小，表示最多可以存储多少个事件。</li>
<li><code>timeout</code> 是等待的超时时间（以毫秒为单位）：<ul>
<li>如果设置为 -1，表示一直等待直到有事件发生。</li>
<li>如果设置为 0，表示立即返回。</li>
<li>如果设置为一个正整数，表示等待指定的毫秒数。</li>
</ul>
</li>
</ul>
<h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li>如果有事件发生，<code>epoll_wait()</code> 返回发生事件的文件描述符数量（大于 0）。</li>
<li>如果超时时间到达或者没有事件发生，返回值为 0。</li>
<li>如果出现错误，返回值为 -1，并设置 <code>errno</code> 表示错误的原因。</li>
</ul>
<h3 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> epoll_fd = epoll_create(<span class="number">10</span>); <span class="comment">// 创建 epoll 实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span> <span class="comment">// 存放事件的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待事件发生</span></span><br><span class="line">    <span class="type">int</span> num_events = epoll_wait(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (num_events == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理发生的事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_events; ++i) &#123;</span><br><span class="line">        <span class="comment">// 根据 events[i] 中的信息处理事件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(epoll_fd); <span class="comment">// 关闭 epoll 实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><ul>
<li><code>epoll_wait()</code> 用于等待文件描述符上的事件发生。</li>
<li>它会阻塞程序，直到指定文件描述符上有事件发生，或者超时时间到达。</li>
<li>当有事件发生时，将会填充 <code>events</code> 数组，程序可以遍历数组处理发生的事件。</li>
</ul>
<p><code>epoll_wait()</code> 是使用 epoll 实现高效 I&#x2F;O 多路复用的重要部分，它允许程序等待多个文件描述符上的事件发生，并有效地处理这些事件。</p>
<h2 id="sys-epoll-h"><a href="#sys-epoll-h" class="headerlink" title="sys&#x2F;epoll.h"></a>sys&#x2F;epoll.h</h2><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create()"></a>epoll_create()</h3><ul>
<li>简述：创建一个关联<code>size</code>个文件的epoll实例</li>
<li>声明：<code>int epoll_create(int size);</code></li>
<li>参数：<ul>
<li><code>size</code>  –  关联文件的个数</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回一个文件描述符<code>fd</code></li>
<li>失败  –</li>
</ul>
</li>
</ul>
<h3 id="epoll-create1"><a href="#epoll-create1" class="headerlink" title="epoll_create1()"></a>epoll_create1()</h3><ul>
<li>简述：创建一个标记为<code>flag</code>的epoll实例</li>
<li>声明：<code>int epoll_create1(int flags);</code></li>
<li>参数：<ul>
<li><code>flag</code>  –</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回一个文件描述符</li>
<li>失败  –</li>
</ul>
</li>
<li>注意：<ul>
<li>与epoll_create()一样，只不过size参数弃用了</li>
</ul>
</li>
</ul>
<h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl()"></a>epoll_ctl()</h3><ul>
<li>简述：修改一个<code>epfd</code> epoll实例</li>
<li>声明：<code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code></li>
<li>参数：<ul>
<li><code>epfd</code>  –  要操作的epoll实例</li>
<li><code>op</code>    –  要执行的行为<ul>
<li><code>/* Valid opcodes ( &quot;op&quot; parameter ) to issue to epoll_ctl().  */</code></li>
<li><code>#define EPOLL_CTL_ADD 1	/* Add a file descriptor to the interface.  */</code></li>
<li><code>#define EPOLL_CTL_DEL 2	/* Remove a file descriptor from the interface.  */</code></li>
<li><code>#define EPOLL_CTL_MOD 3	/* Change file descriptor epoll_event structure.  */</code></li>
</ul>
</li>
<li><code>fd</code>    –  操作的目标</li>
<li><code>event</code> –  用户数据和触发该调用的事件</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回0</li>
<li>失败  –  返回-1，并设置errno</li>
</ul>
</li>
</ul>
<h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait()"></a>epoll_wait()</h3><ul>
<li>简述：在一个epoll实例<code>opfd</code>中等待某一事件发生</li>
<li>声明：<code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</code></li>
<li>参数：<ul>
<li><code>epfd</code>  –  要操作的epoll实例</li>
<li><code>events</code> – 指向存放触发事件的缓冲区的结构体指针</li>
<li><code>maxevents</code>  –  返回事件的最大数量</li>
<li><code>timeout</code>  –  超时时间</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回触发事件在缓冲区<code>events</code>中的数字</li>
<li>失败  –  返回-1，并设置errno</li>
</ul>
</li>
</ul>
<h3 id="epoll-pwait"><a href="#epoll-pwait" class="headerlink" title="epoll_pwait()"></a>epoll_pwait()</h3><ul>
<li>简述：和<code>epoll_wait()</code>相似，增加了信号掩码，临时且原子</li>
<li>声明：<code>int epoll_pwait(int epfd, struct epoll_event *events, int maxevents, int timeout, const sigset_t *ss);</code></li>
<li>参数：<ul>
<li><code>epfd</code>  –  要操作的epoll实例</li>
<li><code>events</code> – 指向存放触发事件的缓冲区的结构体指针</li>
<li><code>maxevents</code>  –  返回事件的最大数量</li>
<li><code>timeout</code>  –  超时时间</li>
<li><code>ss</code>   –  信号集指针</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回触发事件在缓冲区<code>events</code>中的数字</li>
<li>失败  –  返回-1，并设置errno</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_6_network_%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/2024-05-22-C_6_2_sys_socket_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_6_network_%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF/2024-05-22-C_6_2_sys_socket_h/" class="post-title-link" itemprop="url">C_6_2_sys_socket_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>&lt;sys&#x2F;socket.h&gt;头文件 笔记</li>
</ul>
<h2 id="linux-是什么"><a href="#linux-是什么" class="headerlink" title="linux &lt;sys&#x2F;socket.h&gt;是什么"></a>linux &lt;sys&#x2F;socket.h&gt;是什么</h2><p><code>&lt;sys/socket.h&gt;</code> 是一个 C&#x2F;C++ 语言中的头文件，通常用于在 Linux 系统上进行网络编程。该头文件包含了一系列用于创建、操作网络套接字（socket）的函数、结构体和宏定义。</p>
<p>套接字是网络通信的基础，它允许进程通过网络进行通信。<code>&lt;sys/socket.h&gt;</code> 中定义了创建套接字、绑定地址、监听连接、接受连接等操作所需的函数和相关的常量、数据结构。这些函数和常量允许开发者在 Linux 系统上编写网络应用程序，实现各种网络通信，如 TCP、UDP、IPv4、IPv6 等。</p>
<p>一些常用的函数包括 <code>socket()</code>（创建套接字）、<code>bind()</code>（绑定套接字地址）、<code>listen()</code>（监听连接）、<code>accept()</code>（接受连接请求）、<code>connect()</code>（建立连接）、<code>send()</code> 和 <code>recv()</code>（发送和接收数据）等。</p>
<p>这个头文件以及相关的系统调用和函数提供了程序员在 Linux 平台上进行网络编程的基础，使得开发者能够编写网络应用程序来实现数据通信和网络服务。</p>
<h2 id="linux-详解"><a href="#linux-详解" class="headerlink" title="linux &lt;sys&#x2F;socket.h&gt;详解"></a>linux &lt;sys&#x2F;socket.h&gt;详解</h2><p><code>&lt;sys/socket.h&gt;</code> 是 Linux 系统中用于网络编程的头文件之一，它包含了一系列用于处理套接字（socket）的系统调用、结构体和宏定义。</p>
<p>套接字是一种抽象的通信端点，允许不同计算机之间进行数据通信。<code>&lt;sys/socket.h&gt;</code> 提供了创建、配置和操作套接字的函数和常量，使得开发者能够进行网络通信。以下是该头文件中常用的一些函数、数据结构和宏定义：</p>
<h3 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h3><ul>
<li><code>struct sockaddr</code>：用于表示通用的套接字地址信息。</li>
<li><code>struct sockaddr_in</code>：用于表示 IPv4 的套接字地址信息。</li>
<li><code>struct sockaddr_in6</code>：用于表示 IPv6 的套接字地址信息。</li>
<li><code>struct sockaddr_storage</code>：用于存储任意类型套接字地址的结构体。</li>
</ul>
<h3 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h3><ul>
<li><code>socket()</code>：创建一个新的套接字，返回一个文件描述符。</li>
<li><code>bind()</code>：将一个套接字绑定到特定的地址和端口。</li>
<li><code>listen()</code>：开始监听传入的连接请求。</li>
<li><code>accept()</code>：接受传入的连接请求并返回新的套接字。</li>
<li><code>connect()</code>：建立与远程套接字的连接。</li>
<li><code>send()</code> 和 <code>recv()</code>：发送和接收数据。</li>
<li><code>close()</code>：关闭套接字连接。</li>
</ul>
<h3 id="常量和宏定义："><a href="#常量和宏定义：" class="headerlink" title="常量和宏定义："></a>常量和宏定义：</h3><ul>
<li>套接字类型：<code>SOCK_STREAM</code>（流套接字，提供面向连接的、可靠的字节流服务，如 TCP）、<code>SOCK_DGRAM</code>（数据报套接字，提供无连接的数据传输，如 UDP）等。</li>
<li>地址族：<code>AF_INET</code>（IPv4 地址族）、<code>AF_INET6</code>（IPv6 地址族）等。</li>
<li>套接字选项：如 <code>SO_REUSEADDR</code>（允许地址重用）、<code>SO_KEEPALIVE</code>（启用保活机制）等。</li>
</ul>
<p>使用 <code>&lt;sys/socket.h&gt;</code> 中提供的函数和常量，开发者可以实现各种网络应用，包括客户端-服务器模型、网络通信、数据传输等。这些函数和常量为 Linux 下的网络编程提供了基础设施。</p>
<h2 id="linux-struct-sockaddr详解"><a href="#linux-struct-sockaddr详解" class="headerlink" title="linux &lt;sys&#x2F;socket.h&gt; struct sockaddr详解"></a>linux &lt;sys&#x2F;socket.h&gt; struct sockaddr详解</h2><p>在 Linux 的 <code>&lt;sys/socket.h&gt;</code> 头文件中，<code>struct sockaddr</code> 是用于表示通用的套接字地址信息的结构体。它是一个通用的地址结构，用于在网络编程中传递和存储各种类型的套接字地址信息，无论是 IPv4、IPv6 还是其他协议族的地址信息。</p>
<p><code>struct sockaddr</code> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sa_family; <span class="comment">// 地址族，例如 AF_INET、AF_INET6</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];         <span class="comment">// 实际的地址信息，大小取决于不同的协议族</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构体的主要成员有：</p>
<ul>
<li><p><code>sa_family</code>：表示地址族（address family），用于指示地址的类型，例如 <code>AF_INET</code> 表示 IPv4 地址族，<code>AF_INET6</code> 表示 IPv6 地址族。这个字段的大小为 2 个字节（<code>unsigned short</code>）。</p>
</li>
<li><p><code>sa_data</code>：这是一个包含实际地址信息的字符数组，大小为 14 字节。在实际使用中，这个字段会被强制转换为不同类型的结构体，以便于存储特定地址族的信息。例如，对于 IPv4 地址族 (<code>AF_INET</code>)，会将 <code>struct sockaddr</code> 转换为 <code>struct sockaddr_in</code>，而对于 IPv6 地址族 (<code>AF_INET6</code>)，会转换为 <code>struct sockaddr_in6</code>。</p>
</li>
</ul>
<p>由于 <code>struct sockaddr</code> 是一个通用的结构体，它通常与类型转换结合使用，以适应不同的地址族和套接字操作。例如，在使用时，你可能会使用类型转换来将 <code>struct sockaddr</code> 转换为 <code>struct sockaddr_in</code> 或 <code>struct sockaddr_in6</code>，这样就可以操作 IPv4 或 IPv6 地址信息。</p>
<p>网络编程中经常使用的函数，如 <code>bind()</code>、<code>connect()</code>、<code>accept()</code> 等，通常需要 <code>struct sockaddr</code> 类型的地址作为参数，以指定套接字的地址信息。在这些函数中，<code>struct sockaddr</code> 以及其不同的转换类型用于存储和传递相关的地址信息。</p>
<h2 id="linux-struct-sockaddr-in详解"><a href="#linux-struct-sockaddr-in详解" class="headerlink" title="linux &lt;sys&#x2F;socket.h&gt; struct sockaddr_in详解"></a>linux &lt;sys&#x2F;socket.h&gt; struct sockaddr_in详解</h2><p>在 Linux 的 <code>&lt;sys/socket.h&gt;</code> 头文件中，<code>struct sockaddr_in</code> 是用于表示 IPv4 套接字地址信息的结构体。它是对通用的 <code>struct sockaddr</code> 结构的扩展，专门用于存储和处理 IPv4 地址信息。</p>
<p><code>struct sockaddr_in</code> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">// 地址族，一般为 AF_INET</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;     <span class="comment">// 16 位端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">// IPv4 地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr) - <span class="keyword">sizeof</span>(<span class="type">sa_family_t</span>) - <span class="keyword">sizeof</span>(<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr)]; <span class="comment">// 用于填充使结构体大小与 sockaddr 一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构体的主要成员包括：</p>
<ul>
<li><p><code>sin_family</code>：与通用的 <code>struct sockaddr</code> 相同，表示地址族，通常设置为 <code>AF_INET</code> 表示 IPv4 地址族。</p>
</li>
<li><p><code>sin_port</code>：一个 16 位的整数，表示端口号。在网络编程中，端口号用于标识进程在主机上运行的服务。</p>
</li>
<li><p><code>sin_addr</code>：一个 <code>struct in_addr</code> 类型的结构体成员，用于存储 IPv4 地址信息。</p>
</li>
<li><p><code>sin_zero</code>：用于填充，使得 <code>struct sockaddr_in</code> 的大小与 <code>struct sockaddr</code> 保持一致。这样做是为了与旧版代码兼容，新的套接字地址结构体 <code>struct sockaddr_in</code> 虽然有自己的大小，但是要与通用的 <code>struct sockaddr</code> 大小一致以便于类型转换和处理。</p>
</li>
</ul>
<p>在实际使用中，<code>struct sockaddr_in</code> 结构体通常与其他函数和数据类型一起使用，例如 <code>bind()</code>、<code>connect()</code> 和 <code>accept()</code> 等函数需要将 <code>struct sockaddr_in</code> 类型的地址信息作为参数传递。</p>
<p>这个结构体和相关的函数使得开发者可以在 Linux 系统上进行 IPv4 网络编程，并能够方便地处理 IPv4 地址和端口信息。</p>
<h2 id="linux-struct-sockaddr-in6详解"><a href="#linux-struct-sockaddr-in6详解" class="headerlink" title="linux &lt;sys&#x2F;socket.h&gt; struct sockaddr_in6详解"></a>linux &lt;sys&#x2F;socket.h&gt; struct sockaddr_in6详解</h2><p>在 Linux 的 <code>&lt;sys/socket.h&gt;</code> 头文件中，<code>struct sockaddr_in6</code> 是用于表示 IPv6 套接字地址信息的结构体。与 <code>struct sockaddr_in</code> 类似，<code>struct sockaddr_in6</code> 是对通用的 <code>struct sockaddr</code> 结构的扩展，专门用于存储和处理 IPv6 地址信息。</p>
<p><code>struct sockaddr_in6</code> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin6_family;   <span class="comment">// 地址族，一般为 AF_INET6</span></span><br><span class="line">    <span class="type">in_port_t</span> sin6_port;       <span class="comment">// 16 位端口号</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_flowinfo;    <span class="comment">// 流标识和流级别</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span> <span class="comment">// IPv6 地址</span></span><br><span class="line">    <span class="type">uint32_t</span> sin6_scope_id;    <span class="comment">// 用于设置接口的标识符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构体的主要成员包括：</p>
<ul>
<li><p><code>sin6_family</code>：与通用的 <code>struct sockaddr</code> 相同，表示地址族，通常设置为 <code>AF_INET6</code> 表示 IPv6 地址族。</p>
</li>
<li><p><code>sin6_port</code>：一个 16 位的整数，表示端口号。在网络编程中，端口号用于标识进程在主机上运行的服务。</p>
</li>
<li><p><code>sin6_flowinfo</code>：用于指定数据包的流信息。</p>
</li>
<li><p><code>sin6_addr</code>：一个 <code>struct in6_addr</code> 类型的结构体成员，用于存储 IPv6 地址信息。</p>
</li>
<li><p><code>sin6_scope_id</code>：用于设置接口的标识符，以标识某个特定接口。</p>
</li>
</ul>
<p>与 <code>struct sockaddr_in</code> 类似，<code>struct sockaddr_in6</code> 结构体也会用于与各种函数和数据类型一起使用，例如 <code>bind()</code>、<code>connect()</code> 和 <code>accept()</code> 等函数需要将 <code>struct sockaddr_in6</code> 类型的地址信息作为参数传递。</p>
<p>这个结构体和相关的函数使得开发者可以在 Linux 系统上进行 IPv6 网络编程，并能够方便地处理 IPv6 地址和端口信息。</p>
<h2 id="linux-struct-sockaddr-storage详解"><a href="#linux-struct-sockaddr-storage详解" class="headerlink" title="linux &lt;sys&#x2F;socket.h&gt; struct sockaddr_storage详解"></a>linux &lt;sys&#x2F;socket.h&gt; struct sockaddr_storage详解</h2><p>在 Linux 的 <code>&lt;sys/socket.h&gt;</code> 头文件中，<code>struct sockaddr_storage</code> 是一个通用的、足够大以容纳任何套接字地址结构的结构体。它被设计为一个泛型的套接字地址结构，可用于存储各种不同类型的套接字地址信息，包括 IPv4、IPv6 或其他协议族的地址信息。</p>
<p><code>struct sockaddr_storage</code> 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> ss_family;  <span class="comment">// 地址族，用于指示地址的类型</span></span><br><span class="line">    <span class="type">char</span> __ss_pad1[_SS_PAD1SIZE]; <span class="comment">// 结构体填充，确保内存对齐</span></span><br><span class="line">    <span class="type">int64_t</span> __ss_align; <span class="comment">// 结构体对齐</span></span><br><span class="line">    <span class="type">char</span> __ss_pad2[_SS_PAD2SIZE]; <span class="comment">// 结构体填充，确保内存对齐</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>_SS_PAD1SIZE</code> 和 <code>_SS_PAD2SIZE</code> 是为了内存对齐而填充的大小。</p>
<p><code>struct sockaddr_storage</code> 结构体最主要的成员是 <code>ss_family</code>，用于指示实际地址结构的类型。根据 <code>ss_family</code> 的值，可以进行类型转换，将 <code>struct sockaddr_storage</code> 转换为相应的地址结构（例如 <code>struct sockaddr_in</code> 或 <code>struct sockaddr_in6</code>），以便于处理特定类型的套接字地址。</p>
<p><code>struct sockaddr_storage</code> 通常用于网络编程中，当你需要处理不同类型的套接字地址时，可以将不同的地址类型都转换为 <code>struct sockaddr_storage</code>，以便于统一地进行存储和传递。</p>
<p>这个结构体的设计使得它成为一个通用的容器，可以存储不同类型的套接字地址，为网络编程提供了一定的灵活性和扩展性。</p>
<h2 id="linux-setsockopt-详解"><a href="#linux-setsockopt-详解" class="headerlink" title="linux &lt;sys&#x2F;socket.h&gt; setsockopt()详解"></a>linux &lt;sys&#x2F;socket.h&gt; setsockopt()详解</h2><p><code>setsockopt()</code> 是 Linux 中 <code>&lt;sys/socket.h&gt;</code> 头文件中定义的函数，用于设置 socket 的选项参数。它允许对打开的 socket 进行配置和控制，以适应特定的网络通信需求。</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sockfd</code> 是要设置选项的 socket 文件描述符。</li>
<li><code>level</code> 是选项的协议级别，通常是 <code>SOL_SOCKET</code>（表示通用 socket 选项），也可以是特定协议的级别，如 <code>IPPROTO_TCP</code> 或 <code>IPPROTO_IP</code>。</li>
<li><code>optname</code> 是要设置的选项名称。</li>
<li><code>optval</code> 是一个指向存放选项值的缓冲区的指针。</li>
<li><code>optlen</code> 是选项值的长度。</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li>如果设置选项成功，返回值为 0。</li>
<li>如果失败，返回值为 -1，并设置 <code>errno</code> 表示错误的原因。</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 socket 选项，例如设置 SO_REUSEADDR 选项</span></span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class="keyword">sizeof</span>(optval)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行其他操作</span></span><br><span class="line"></span><br><span class="line">    close(sockfd); <span class="comment">// 关闭 socket</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><code>setsockopt()</code> 函数允许在创建 socket 后，通过设置选项对 socket 进行配置，如修改 socket 的属性、调整 socket 的行为等。</li>
<li>例如，可以通过设置 <code>SO_REUSEADDR</code> 选项来允许地址重用，允许多个 socket 绑定到相同的地址和端口。</li>
<li>还可以使用其他选项来调整缓冲区大小、设置超时、启用或禁用协议特性等。</li>
</ul>
<p>总之，<code>setsockopt()</code> 是一个用于设置 socket 选项的函数，可以根据需要配置和控制 socket 的行为，以满足特定的网络通信需求。</p>
<h2 id="linux-socket详解"><a href="#linux-socket详解" class="headerlink" title="linux &lt;sys&#x2F;socket.h&gt; socket详解"></a>linux &lt;sys&#x2F;socket.h&gt; socket详解</h2><p>在 Linux 中，<code>&lt;sys/socket.h&gt;</code> 头文件提供了在网络编程中使用的套接字（socket）相关的函数和宏定义。其中最重要的函数之一就是 <code>socket()</code>。</p>
<p><code>socket()</code> 函数用于创建一个新的套接字，并返回一个文件描述符，该文件描述符用于后续对该套接字的操作，比如发送和接收数据、连接等。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><code>domain</code>：指定套接字的协议族（例如 <code>AF_INET</code> 表示 IPv4，<code>AF_INET6</code> 表示 IPv6 等）。</li>
<li><code>type</code>：指定套接字的类型（例如 <code>SOCK_STREAM</code> 表示流套接字，提供可靠的、面向连接的服务，如 TCP；<code>SOCK_DGRAM</code> 表示数据报套接字，提供无连接的服务，如 UDP）。</li>
<li><code>protocol</code>：指定协议，通常设置为 0，表示使用 <code>domain</code> 和 <code>type</code> 参数默认的协议。</li>
</ul>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对新创建的套接字进行后续操作，比如绑定地址、监听连接、接受连接等</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>socket()</code> 函数，你可以在 Linux 系统上创建不同类型的套接字，根据指定的协议族、类型和协议进行网络编程。接下来，可以使用返回的文件描述符对套接字进行各种操作，比如绑定地址、建立连接、发送和接收数据等。</p>
<h2 id="linux-bind-详解"><a href="#linux-bind-详解" class="headerlink" title="linux &lt;sys&#x2F;socket.h&gt; bind()详解"></a>linux &lt;sys&#x2F;socket.h&gt; bind()详解</h2><p>在 Linux 的 <code>&lt;sys/socket.h&gt;</code> 头文件中，<code>bind()</code> 函数用于将一个套接字（socket）与一个特定的地址（IP 地址和端口号）绑定在一起。这个函数主要用于服务器端程序，在服务器启动时指定它所在的 IP 地址和端口号，以便客户端能够连接到该地址。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><code>sockfd</code>：套接字文件描述符，通过 <code>socket()</code> 函数创建的套接字描述符。</li>
<li><code>addr</code>：指向 <code>struct sockaddr</code> 结构体的指针，包含要绑定的地址信息。</li>
<li><code>addrlen</code>：<code>addr</code> 结构体的长度。</li>
</ul>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(PORT); <span class="comment">// 设置端口号</span></span><br><span class="line">server_addr.sin_addr.s_addr = INADDR_ANY; <span class="comment">// 将套接字绑定到任何可用的地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bind_status = bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"><span class="keyword">if</span> (bind_status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>bind()</code> 函数将创建的套接字 <code>sockfd</code> 与 <code>struct sockaddr_in</code> 结构体中指定的 IP 地址和端口号绑定在一起。对于服务器程序，<code>bind()</code> 通常在 <code>socket()</code> 之后立即调用，以指定服务器将要监听的地址和端口。</p>
<p>绑定成功后，服务器可以使用该地址接收来自客户端的连接请求。如果绑定失败，<code>bind()</code> 将返回一个负值，并且可以通过 <code>perror()</code> 函数打印错误信息。</p>
<p>需要注意的是，在使用 <code>bind()</code> 函数之前，确保指定的端口号没有被其他进程占用，并且有足够的权限来绑定该地址。</p>
<h2 id="linux-listen-详解"><a href="#linux-listen-详解" class="headerlink" title="linux &lt;sys&#x2F;socket.h&gt; listen()详解"></a>linux &lt;sys&#x2F;socket.h&gt; listen()详解</h2><p>在 Linux 的 <code>&lt;sys/socket.h&gt;</code> 头文件中，<code>listen()</code> 函数用于将指定的套接字（socket）转换为被动监听套接字，即将套接字用于接受连接请求，并指定服务器套接字可以排队等待的最大连接请求数量。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><code>sockfd</code>：套接字文件描述符，通过 <code>socket()</code> 函数创建的套接字描述符。</li>
<li><code>backlog</code>：指定等待连接队列的最大长度，即允许排队等待的最大连接请求数量。</li>
</ul>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"><span class="comment">// 填充 server_addr 结构体...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bind_status = bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"><span class="keyword">if</span> (bind_status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> listen_status = listen(sockfd, <span class="number">5</span>); <span class="comment">// 允许最多 5 个连接请求排队等待处理</span></span><br><span class="line"><span class="keyword">if</span> (listen_status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;listen failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>listen()</code> 函数将创建的套接字 <code>sockfd</code> 转换为一个被动监听套接字，允许最多 5 个连接请求排队等待处理。这表示如果有更多的连接请求到达服务器但尚未被处理，它们将被拒绝或者等待，直到服务器处理当前排队的连接请求。</p>
<p><code>listen()</code> 函数通常在调用 <code>bind()</code> 函数之后，并且在调用 <code>accept()</code> 函数之前调用。当套接字处于监听状态时，服务器可以使用 <code>accept()</code> 函数接受连接请求并创建新的套接字用于与客户端通信。</p>
<h2 id="linux-accept-详解"><a href="#linux-accept-详解" class="headerlink" title="linux &lt;sys&#x2F;socket.h&gt; accept()详解"></a>linux &lt;sys&#x2F;socket.h&gt; accept()详解</h2><p>在 Linux 的 <code>&lt;sys/socket.h&gt;</code> 头文件中，<code>accept()</code> 函数用于从被动监听套接字（listening socket）接受客户端的连接请求，创建一个新的连接套接字，并返回一个新的文件描述符，通过该文件描述符可以与客户端进行通信。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><code>sockfd</code>：被监听的套接字文件描述符，通过 <code>socket()</code> 函数创建并经过 <code>bind()</code> 和 <code>listen()</code> 的设置。</li>
<li><code>addr</code>：用于存储客户端地址信息的结构体指针，当成功建立连接时，此结构体将填充为客户端的地址信息。</li>
<li><code>addrlen</code>：<code>addr</code> 结构体的长度指针，接受的客户端地址信息的长度。</li>
</ul>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"><span class="comment">// 填充 server_addr 结构体...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bind_status = bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"><span class="keyword">if</span> (bind_status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;bind failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> listen_status = listen(sockfd, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (listen_status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;listen failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> new_socket = accept(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_addrlen);</span><br><span class="line"><span class="keyword">if</span> (new_socket &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;accept failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>accept()</code> 函数从被监听套接字 <code>sockfd</code> 中接受连接请求，并创建了一个新的套接字 <code>new_socket</code>，用于与客户端进行通信。同时，<code>accept()</code> 将填充 <code>client_addr</code> 结构体，包含客户端的地址信息。</p>
<p><code>accept()</code> 函数在服务器端通常用于循环中，每次调用 <code>accept()</code> 都会接受一个新的连接请求，返回一个新的套接字用于与新客户端进行通信。这样服务器可以同时处理多个客户端的连接请求。</p>
<h2 id="linux-connect-详解"><a href="#linux-connect-详解" class="headerlink" title="linux &lt;sys&#x2F;socket.h&gt; connect()详解"></a>linux &lt;sys&#x2F;socket.h&gt; connect()详解</h2><p>在 Linux 的 <code>&lt;sys/socket.h&gt;</code> 头文件中，<code>connect()</code> 函数用于建立与远程服务器的连接。它被用于客户端程序，用于向服务器发起连接请求。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><code>sockfd</code>：客户端套接字文件描述符，通过 <code>socket()</code> 函数创建的套接字描述符。</li>
<li><code>addr</code>：指向 <code>struct sockaddr</code> 结构体的指针，包含要连接的目标地址信息。</li>
<li><code>addrlen</code>：<code>addr</code> 结构体的长度。</li>
</ul>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"><span class="comment">// 填充 server_addr 结构体...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> connect_status = connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"><span class="keyword">if</span> (connect_status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;connection failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>connect()</code> 函数用于将客户端套接字 <code>sockfd</code> 连接到指定的服务器地址 <code>server_addr</code>。如果连接成功，<code>connect()</code> 函数返回 0，如果连接失败，它会返回 -1，并可以通过 <code>perror()</code> 函数输出错误信息。</p>
<p><code>connect()</code> 在客户端通常用于发起连接，如果连接成功建立，客户端可以随后使用 <code>send()</code> 和 <code>recv()</code> 函数发送和接收数据。连接失败可能由多种原因引起，例如服务器不可达、连接超时等，因此在实际使用时，通常需要适当处理连接失败的情况。</p>
<h2 id="linux-send-详解"><a href="#linux-send-详解" class="headerlink" title="linux &lt;sys&#x2F;socket.h&gt; send()详解"></a>linux &lt;sys&#x2F;socket.h&gt; send()详解</h2><p>在 Linux 的 <code>&lt;sys/socket.h&gt;</code> 头文件中，<code>send()</code> 函数用于通过套接字发送数据到连接的另一端（对于面向连接的套接字，如 TCP 套接字）。这个函数通常用于客户端和服务器之间进行数据通信。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><code>sockfd</code>：套接字文件描述符，通过 <code>socket()</code> 函数创建的套接字描述符。</li>
<li><code>buf</code>：指向包含要发送数据的缓冲区的指针。</li>
<li><code>len</code>：要发送的数据的长度。</li>
<li><code>flags</code>：用于指定发送操作的附加选项，通常设置为 0。</li>
</ul>
<p>返回值是发送的字节数。如果出现错误，返回 -1，并可以通过 <code>errno</code> 全局变量获取错误码。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设 buffer 已经包含了要发送的数据</span></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>] = <span class="string">&quot;Hello, server!&quot;</span>;</span><br><span class="line"><span class="type">int</span> send_status = send(sockfd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (send_status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;send failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>send()</code> 函数用于将存储在 <code>buffer</code> 中的数据通过套接字 <code>sockfd</code> 发送给连接的另一端。如果发送成功，<code>send()</code> 函数返回发送的字节数，如果发送失败，它会返回 -1，并可以通过 <code>perror()</code> 函数输出错误信息。</p>
<p><code>send()</code> 函数通常与 <code>recv()</code> 函数一起使用，在客户端和服务器之间进行双向数据传输。</p>
<h2 id="linux-recv-详解"><a href="#linux-recv-详解" class="headerlink" title="linux &lt;sys&#x2F;socket.h&gt; recv()详解"></a>linux &lt;sys&#x2F;socket.h&gt; recv()详解</h2><p>在 Linux 的 <code>&lt;sys/socket.h&gt;</code> 头文件中，<code>recv()</code> 函数用于从套接字接收数据，即从连接的另一端（对于面向连接的套接字，如 TCP 套接字）接收数据。这个函数通常用于客户端和服务器之间进行数据通信。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><code>sockfd</code>：套接字文件描述符，通过 <code>socket()</code> 函数创建的套接字描述符。</li>
<li><code>buf</code>：指向存储接收数据的缓冲区的指针。</li>
<li><code>len</code>：缓冲区的长度，即要接收的数据的最大字节数。</li>
<li><code>flags</code>：用于指定接收操作的附加选项，通常设置为 0。</li>
</ul>
<p>返回值是接收的字节数。如果出现错误，返回 -1，并可以通过 <code>errno</code> 全局变量获取错误码。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> recv_status = recv(sockfd, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (recv_status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;receive failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (recv_status == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Connection closed by peer\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received data: %s\n&quot;</span>, buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>recv()</code> 函数用于从套接字 <code>sockfd</code> 接收数据，并将接收到的数据存储在 <code>buffer</code> 缓冲区中。如果接收成功，<code>recv()</code> 函数返回接收到的字节数，如果接收失败，它会返回 -1，并可以通过 <code>perror()</code> 函数输出错误信息。</p>
<p>需要注意的是，<code>recv()</code> 函数在接收数据时会阻塞程序的执行，直到有数据可用或者发生错误。因此，通常在实际应用中，需要结合其他逻辑或者循环来处理接收数据的情况。</p>
<h2 id="linux-close-详解"><a href="#linux-close-详解" class="headerlink" title="linux &lt;sys&#x2F;socket.h&gt; close()详解"></a>linux &lt;sys&#x2F;socket.h&gt; close()详解</h2><p>在 Linux 的 <code>&lt;sys/socket.h&gt;</code> 头文件中，<code>close()</code> 函数用于关闭一个文件描述符，包括套接字描述符。在网络编程中，当不再需要使用一个套接字时，应该通过 <code>close()</code> 函数来关闭它，释放资源并结束与该套接字相关联的连接。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> sockfd)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>sockfd</code> 是要关闭的套接字文件描述符。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;socket creation failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他操作，比如连接、数据传输等...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> close_status = close(sockfd);</span><br><span class="line"><span class="keyword">if</span> (close_status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;close failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>close()</code> 函数被用于关闭之前通过 <code>socket()</code> 函数创建的套接字描述符 <code>sockfd</code>。如果关闭成功，<code>close()</code> 函数返回 0，如果关闭失败，它会返回 -1，并可以通过 <code>perror()</code> 函数输出错误信息。</p>
<p>在网络编程中，及时关闭不再使用的套接字是很重要的，这可以防止资源泄漏和不必要的资源占用。</p>
<h2 id="sys-socket-h"><a href="#sys-socket-h" class="headerlink" title="sys&#x2F;socket.h"></a>sys&#x2F;socket.h</h2><ul>
<li>套接字常量、类型和函数的声明。</li>
</ul>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h3><ul>
<li>简述：创建一个<code>type</code>类型，<code>domain</code>协议簇，<code>protocol</code>通信协议的socket，并返回一个文件描述符</li>
<li>声明：<code>int socket(int domain, int type, int protocol);</code></li>
<li>参数：<ul>
<li><code>domain</code>  –  选择所用的协议族<ul>
<li><code>AF_INET</code>，代表IPv4</li>
<li><code>AF_INET6</code>，代表IPv6</li>
</ul>
</li>
<li><code>type</code>    –  <ul>
<li><code>SOCK_STREAM</code>, 表示有序，可靠，双工，面向连接的字节流，通常由TCP实现</li>
<li><code>SOCK_DGRAM</code>,  通过定长的，不可靠消息提供无连接通信，通常由UDP实现</li>
</ul>
</li>
<li><code>protocol</code> – 指定特定的通信type使用的协议。<ul>
<li>在大多数实现中，每个type参数只能使用一种协议。</li>
<li><code>SOCK_STREAM</code>,使用<code>IPPROTO_TCP</code></li>
<li><code>SOCK_DGRAM</code>, 使用<code>IPPROTO_UDP</code></li>
<li>如果参数为0，则默认设置为1</li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回文件描述符</li>
<li>失败  –</li>
</ul>
</li>
</ul>
<h3 id="socketpair"><a href="#socketpair" class="headerlink" title="socketpair()"></a>socketpair()</h3><ul>
<li>简述：创建两个<code>type</code>类型，<code>domain</code>协议簇，<code>protocol</code>通信协议的，互相连接的socket，将文件描述符放在<code>fds[0]</code>和<code>fds[1]</code></li>
<li>声明：<code>int socketpair(int domain, int type, int protocol, int fds[2]);</code></li>
<li>参数：<ul>
<li><code>domain</code>  –  选择所用的协议族<ul>
<li><code>AF_INET</code>，代表IPv4</li>
<li><code>AF_INET6</code>，代表IPv6</li>
</ul>
</li>
<li><code>type</code>    –  <ul>
<li><code>SOCK_STREAM</code>, 表示有序，可靠，双工，面向连接的字节流，通常由TCP实现</li>
<li><code>SOCK_DGRAM</code>,  通过定长的，不可靠消息提供无连接通信，通常由UDP实现</li>
</ul>
</li>
<li><code>protocol</code> – 指定特定的通信type使用的协议。<ul>
<li>在大多数实现中，每个type参数只能使用一种协议。</li>
<li><code>SOCK_STREAM</code>,使用<code>IPPROTO_TCP</code></li>
<li><code>SOCK_DGRAM</code>, 使用<code>IPPROTO_UDP</code></li>
<li>如果参数为0，则默认设置为1</li>
</ul>
</li>
<li><code>fds[2]</code>  –  存放两个文件描述符的数组  –  Input&#x2F;Output</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回0</li>
<li>失败  –  返回-1</li>
</ul>
</li>
</ul>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><ul>
<li>简述：将套接字通信端点的句柄(<code>socket FD</code>)与一个特定的逻辑网络连接关联起来</li>
<li>声明：<code>int bind(int fd, const struct sockaddr *address, socklen_t address_len);</code></li>
<li>参数：<ul>
<li><code>fd</code>       –  通信端点的文件描述符</li>
<li><code>address</code>  –  关联的地址</li>
<li><code>len</code>      –  地址字节长度(the local address which is LEN bytes long)</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回0</li>
<li>失败  –  返回-1，并设置errno</li>
</ul>
</li>
</ul>
<h3 id="getsockname"><a href="#getsockname" class="headerlink" title="getsockname()"></a>getsockname()</h3><ul>
<li>简述：通过本地文件描述符的地址和长度(单位:byte)，获取socket名字</li>
<li>声明：<code>int getsockname(int fd, const struct sockaddr *address, socklent *len);</code></li>
<li>参数：<ul>
<li><code>fd</code>  –  文件描述符</li>
<li><code>address</code>  –  地址</li>
<li><code>len</code>      –  长度</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  – </li>
<li>失败  –</li>
</ul>
</li>
</ul>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h3><ul>
<li>简述：创建一个socket文件描述符和地址的连接</li>
<li>声明：<code>int connect(int fd, const struct sockaddr *addr, socklent_t len);</code></li>
<li>参数：<ul>
<li><code>fd</code>  –  文件描述符</li>
<li><code>addr</code> –  要连接的地址</li>
<li><code>len</code>  –  地址的长度(单位：字节)</li>
</ul>
</li>
<li>返回值：  <ul>
<li>成功  –  返回0</li>
<li>失败  –  返回-1</li>
</ul>
</li>
</ul>
<h3 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h3><ul>
<li>简述：发送N字节的BUF到socket FD。返回发送的数字或-1。</li>
<li>声明：<code>ssize_t send (int fd, const void *buf, size_t n, int flags);</code></li>
<li>参数：</li>
<li>返回值：</li>
</ul>
<h3 id="recv"><a href="#recv" class="headerlink" title="recv()"></a>recv()</h3><ul>
<li>简述：从socket FD中读取N个字节，并输入到BUF中</li>
<li>声明：<code>ssize_t recv(int fd, void *buf, size_t n, int flags);</code></li>
<li>参数：<ul>
<li><code>fd</code>  –  文件描述符</li>
<li><code>buf</code> –  要存放的缓冲区</li>
<li><code>n</code>   –  读取的数据大小</li>
<li><code>flags</code> –</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回读取的字节数</li>
<li>失败  –  返回-1</li>
</ul>
</li>
</ul>
<h3 id="sendto"><a href="#sendto" class="headerlink" title="sendto()"></a>sendto()</h3><ul>
<li>简述：在socket FD上向地址ADDR(长度为ADDR_LEN)发送N个字节的BUF</li>
<li>声明：<ul>
<li><code>ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct *addr, socklen_t addr_len);</code></li>
</ul>
</li>
<li>参数：</li>
<li>返回值：<ul>
<li>成功  –  返回发送的字节数</li>
<li>失败  –  返回-1</li>
</ul>
</li>
</ul>
<h3 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom()"></a>recvfrom()</h3><ul>
<li>简述：通过socket FD读取N个字节到BUF</li>
<li>声明：<code>ssize_t recvfrom(int fd, void *buf, size_t n, int flags, const struct *addr, socklen_t addr_len);</code></li>
<li>参数：</li>
<li>返回值：<ul>
<li>成功  –  返回读取的字节数</li>
<li>失败  –  返回-1</li>
</ul>
</li>
<li>注意：<ul>
<li>如果ADDR不为空，将其<code>*ADDR_LEN</code>字节填充为发送方的地址，并将地址的实际大小存储在<code>*ADDR_LEN</code>中。返回读取的字节数或-1错误</li>
</ul>
</li>
</ul>
<h3 id="sendmsg"><a href="#sendmsg" class="headerlink" title="sendmsg()"></a>sendmsg()</h3><ul>
<li>简述：在socket FD上发送一个由MESSAGE描述的信息</li>
<li>声明：<code>ssize_t sendmsg(int fd, const struct msghdr *message, int flags);</code></li>
<li>参数：</li>
<li>返回值：<ul>
<li>成功  –  返回发送的字节数</li>
<li>失败  –  返回-1</li>
</ul>
</li>
</ul>
<h3 id="recvmsg"><a href="#recvmsg" class="headerlink" title="recvmsg()"></a>recvmsg()</h3><ul>
<li>简述：从socket FD接收一个由MESSAGE描述的信息</li>
<li>声明：<code>ssize_t recvmsg(int fd, struct msghdr *message, int flags);</code></li>
<li>参数：</li>
<li>返回值：<ul>
<li>成功  –  返回接收到的字节数</li>
<li>失败  –  返回-1</li>
</ul>
</li>
</ul>
<h3 id="getsockopt"><a href="#getsockopt" class="headerlink" title="getsockopt()"></a>getsockopt()</h3><ul>
<li>简述：将套接字<code>FD</code>的选项<code>OPTNAME</code>在协议级别<code>level</code>上的当前值放入<code>OPTVAL</code> (<code>*OPTLEN</code>字节长)，并将<code>*OPTLEN</code>设置为该值的实际长度</li>
<li>声明：<code>int getsockopt(int fd, int level, int optname, void *optval, socklen_t *optlen);</code></li>
<li>返回值：<ul>
<li>成功  –  返回接收到的字节数</li>
<li>失败  –  返回-1</li>
</ul>
</li>
</ul>
<h3 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt()"></a>setsockopt()</h3><ul>
<li>简述：设置套接字<code>FD</code>的选项<code>OPTNAME</code>在协议级别<code>level</code>为<code>*OPTVAL</code> (<code>OPTLEN</code>字节长)</li>
<li>声明：<code>int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);</code></li>
<li>返回值：<ul>
<li>成功  –  返回接收到的字节数</li>
<li>失败  –  返回-1</li>
</ul>
</li>
</ul>
<h3 id="listen"><a href="#listen" class="headerlink" title="listen()"></a>listen()</h3><ul>
<li>简述：准备接受套接字FD上的连接。在进一步的请求被拒绝之前，将有N个连接请求排队</li>
<li>声明：<code>int listen(int fd, int n);</code></li>
<li>返回值：<ul>
<li>成功  –  返回接收到的字节数</li>
<li>失败  –  返回-1</li>
</ul>
</li>
</ul>
<h3 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h3><ul>
<li>简述：在套接字FD上等待连接.<ul>
<li>当连接到达时，打开一个新的套接字与之通信，将<code>*ADDR (*ADDR_LEN字节长)</code>设置为连接对等体的地址，将<code>*ADDR_LEN</code>设置为地址的实际长度，</li>
<li>并返回新套接字的描述符，错误则返回-1</li>
</ul>
</li>
<li>声明：<code>int accept(int fd, const struct sockaddr *addr, socklen_t *addr_len);</code></li>
<li>返回值：<ul>
<li>成功  –  新套接字的描述符</li>
<li>失败  –  返回-1</li>
</ul>
</li>
</ul>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h3><ul>
<li>简述：关闭套接字FD上打开的全部或部分连接</li>
<li>声明：<code>int shutdown(int fd, int how);</code></li>
<li>参数：<ul>
<li><code>fd</code>  –  套接字文件描述符</li>
<li><code>how</code>  –<ul>
<li><code>SHUT_RD</code>  –  不再接收连接</li>
<li><code>SHUT_WR</code>  –  不再传输数据</li>
<li><code>SHUT_RDWR</code>  –  不再传输数据和接收连接</li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功  –  返回0</li>
<li>失败  –  返回-1</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_10_sys_types_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_10_sys_types_h/" class="post-title-link" itemprop="url">C_5_10_sys_types_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Linux POSIX &lt;sys&#x2F;types.h&gt; 详解</li>
</ul>
<h2 id="Linux-POSIX-详解"><a href="#Linux-POSIX-详解" class="headerlink" title="Linux POSIX &lt;sys&#x2F;types.h&gt; 详解"></a>Linux POSIX &lt;sys&#x2F;types.h&gt; 详解</h2><p><code>&lt;sys/types.h&gt;</code> 是 POSIX 标准中的头文件，用于定义各种基本系统数据类型。该头文件通常包含了对数据类型的定义，这些类型在编写跨平台的程序时非常有用，因为它们的大小和特性在不同的系统上可能会有所不同。</p>
<p>以下是一些在 <code>&lt;sys/types.h&gt;</code> 中常见的数据类型：</p>
<h3 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h3><ul>
<li>**<code>size_t</code>**：无符号整数类型，用于表示对象的大小（以字节为单位）。</li>
<li>**<code>ssize_t</code>**：有符号整数类型，用于表示对象的大小（以字节为单位）。</li>
<li>**<code>time_t</code>**：有符号整数类型，用于表示从 Epoch（通常为 1970 年 1 月 1 日）起的秒数。</li>
<li>**<code>off_t</code>**：有符号整数类型，用于表示文件偏移量（文件中的位置）。</li>
</ul>
<h3 id="特殊数据类型："><a href="#特殊数据类型：" class="headerlink" title="特殊数据类型："></a>特殊数据类型：</h3><ul>
<li>**<code>pid_t</code>**：进程标识符类型，用于表示进程 ID。</li>
<li>**<code>uid_t</code>**：用户标识符类型，用于表示用户 ID。</li>
<li>**<code>gid_t</code>**：组标识符类型，用于表示组 ID。</li>
</ul>
<h3 id="其他类型："><a href="#其他类型：" class="headerlink" title="其他类型："></a>其他类型：</h3><p>还可能包含其他一些特定于系统的数据类型或宏定义，这取决于不同的操作系统和平台。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="keyword">sizeof</span>(<span class="type">int</span>); <span class="comment">// 获取 int 类型的大小（以字节为单位）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of int: %zu bytes\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">    <span class="type">off_t</span> offset = <span class="number">1024</span>; <span class="comment">// 声明一个文件偏移量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File offset: %jd\n&quot;</span>, (<span class="type">intmax_t</span>)offset);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = getpid(); <span class="comment">// 获取当前进程的进程 ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Process ID: %d\n&quot;</span>, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>&lt;sys/types.h&gt;</code> 中的数据类型定义可以使程序更具可移植性，因为它们在不同的系统上通常都有相应的定义。</li>
<li>在使用特定于操作系统或平台的功能时，可能需要包含 <code>&lt;sys/types.h&gt;</code> 来访问相应的数据类型或宏定义。</li>
</ul>
<p>该头文件中定义的数据类型是为了在编写跨平台程序时提供统一的数据类型接口，使得代码在不同系统上具有更好的兼容性和可移植性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_11_sys_stat_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_11_sys_stat_h/" class="post-title-link" itemprop="url">C_5_11_sys_stat_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Linux POSIX &lt;sys&#x2F;stat.h&gt; 详解</li>
</ul>
<h2 id="Linux-POSIX-详解"><a href="#Linux-POSIX-详解" class="headerlink" title="Linux POSIX &lt;sys&#x2F;stat.h&gt; 详解"></a>Linux POSIX &lt;sys&#x2F;stat.h&gt; 详解</h2><p><code>&lt;sys/stat.h&gt;</code> 是 POSIX 操作系统中的一个头文件，用于处理文件状态信息和文件系统属性。它包含了一些在文件和文件系统方面的函数、宏和数据结构的定义。</p>
<h3 id="一些常见的函数和宏："><a href="#一些常见的函数和宏：" class="headerlink" title="一些常见的函数和宏："></a>一些常见的函数和宏：</h3><ul>
<li>**<code>stat()</code> 和 <code>fstat()</code>**：用于获取文件的状态信息，包括文件的大小、权限、所有者信息等。</li>
<li><strong><code>S_IFMT</code>、<code>S_IFREG</code>、<code>S_IFDIR</code></strong> 等宏：用于检查文件类型（常规文件、目录等）的位掩码。</li>
<li><strong><code>chmod()</code>、<code>chown()</code>、<code>utime()</code></strong> 等函数：用于改变文件的权限、所有者或者修改文件的访问和修改时间。</li>
<li><strong>文件访问权限掩码（例如 <code>S_IRUSR</code>、<code>S_IWGRP</code> 等）</strong>：用于设置文件的读、写、执行权限。</li>
</ul>
<h3 id="一些常见的数据结构："><a href="#一些常见的数据结构：" class="headerlink" title="一些常见的数据结构："></a>一些常见的数据结构：</h3><ul>
<li>**<code>struct stat</code>**：用于存储文件的状态信息。该结构包含了文件的各种属性，如大小、权限、时间戳等。</li>
</ul>
<h3 id="示例（使用-stat-获取文件状态信息）："><a href="#示例（使用-stat-获取文件状态信息）：" class="headerlink" title="示例（使用 stat() 获取文件状态信息）："></a>示例（使用 <code>stat()</code> 获取文件状态信息）：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileInfo</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;example.txt&quot;</span>; <span class="comment">// 假设存在的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件状态信息并存储在 fileInfo 结构体中</span></span><br><span class="line">    <span class="keyword">if</span> (stat(filename, &amp;fileInfo) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件大小：%lld 字节\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)fileInfo.st_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;访问权限：%o\n&quot;</span>, fileInfo.st_mode &amp; (S_IRWXU | S_IRWXG | S_IRWXO));</span><br><span class="line">        <span class="comment">// 更多的文件状态信息可通过 struct stat 中的其他成员获取，如 st_mode、st_uid、st_gid、st_atime 等</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>&lt;sys/stat.h&gt;</code> 中包含的函数和数据结构允许程序员获取和修改文件的属性信息，如权限、所有者、文件大小等。</li>
<li>该头文件中定义了一些宏，用于检查文件类型和设置文件权限，以及一些函数，用于修改文件的属性信息。</li>
<li>使用这些函数和数据结构可以在编写文件处理相关的程序时获取文件的状态信息，并进行相应的操作。</li>
</ul>
<p>总的来说，<code>&lt;sys/stat.h&gt;</code> 提供了一系列函数、宏和数据结构，用于获取和修改文件的状态信息，对文件的操作和文件系统属性进行处理。</p>
<h2 id="Linux-POSIX-stat-详解"><a href="#Linux-POSIX-stat-详解" class="headerlink" title="Linux POSIX &lt;sys&#x2F;stat.h&gt; stat() 详解"></a>Linux POSIX &lt;sys&#x2F;stat.h&gt; stat() 详解</h2><p><code>stat()</code> 是 POSIX 操作系统中 <code>&lt;sys/stat.h&gt;</code> 头文件中定义的一个函数，用于获取指定文件的状态信息，并将其存储在 <code>struct stat</code> 结构体中。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：若成功，返回 0；失败则返回 -1，并设置 <code>errno</code> 表示错误类型。</li>
<li><strong>参数</strong>：<ul>
<li><code>pathname</code>：字符串，表示要查询状态的文件路径。</li>
<li><code>statbuf</code>：<code>struct stat</code> 类型的指针，用于存储获取到的文件状态信息。</li>
</ul>
</li>
</ul>
<h3 id="struct-stat-结构体："><a href="#struct-stat-结构体：" class="headerlink" title="struct stat 结构体："></a><code>struct stat</code> 结构体：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>     st_dev;         <span class="comment">// 设备 ID</span></span><br><span class="line">    <span class="type">ino_t</span>     st_ino;         <span class="comment">// inode 号</span></span><br><span class="line">    <span class="type">mode_t</span>    st_mode;        <span class="comment">// 文件类型和访问权限</span></span><br><span class="line">    <span class="type">nlink_t</span>   st_nlink;       <span class="comment">// 链接数</span></span><br><span class="line">    <span class="type">uid_t</span>     st_uid;         <span class="comment">// 用户 ID</span></span><br><span class="line">    <span class="type">gid_t</span>     st_gid;         <span class="comment">// 组 ID</span></span><br><span class="line">    <span class="type">off_t</span>     st_size;        <span class="comment">// 文件大小（字节数）</span></span><br><span class="line">    <span class="type">time_t</span>    st_atime;       <span class="comment">// 最后访问时间</span></span><br><span class="line">    <span class="type">time_t</span>    st_mtime;       <span class="comment">// 最后修改时间</span></span><br><span class="line">    <span class="type">time_t</span>    st_ctime;       <span class="comment">// 最后状态改变时间</span></span><br><span class="line">    <span class="type">blksize_t</span> st_blksize;     <span class="comment">// 文件系统 I/O 缓冲区大小</span></span><br><span class="line">    <span class="type">blkcnt_t</span>  st_blocks;      <span class="comment">// 分配的文件块数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileInfo</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;example.txt&quot;</span>; <span class="comment">// 假设存在的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件状态信息并存储在 fileInfo 结构体中</span></span><br><span class="line">    <span class="keyword">if</span> (stat(filename, &amp;fileInfo) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件大小：%lld 字节\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)fileInfo.st_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;访问权限：%o\n&quot;</span>, fileInfo.st_mode &amp; (S_IRWXU | S_IRWXG | S_IRWXO));</span><br><span class="line">        <span class="comment">// 更多的文件状态信息可通过 struct stat 中的其他成员获取，如 st_mode、st_uid、st_gid、st_atime 等</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>stat()</code> 函数用于获取指定文件的详细状态信息，如文件大小、访问权限、所有者信息、最后访问时间等。</li>
<li>要使用 <code>stat()</code> 函数，需要包含 <code>&lt;sys/stat.h&gt;</code> 头文件。</li>
<li>在调用 <code>stat()</code> 函数时，需要传递文件路径和一个指向 <code>struct stat</code> 结构体的指针，该结构体将会被填充为文件的状态信息。</li>
<li>如果函数执行成功，返回值为 0；否则返回 -1，并设置 <code>errno</code> 表示错误类型。</li>
</ul>
<p><code>stat()</code> 函数是用于获取文件状态信息的重要函数之一，它允许程序员获取文件的详细属性和状态，以便在程序中进行相应的操作。</p>
<h2 id="Linux-POSIX-fstat-详解"><a href="#Linux-POSIX-fstat-详解" class="headerlink" title="Linux POSIX &lt;sys&#x2F;stat.h&gt; fstat() 详解"></a>Linux POSIX &lt;sys&#x2F;stat.h&gt; fstat() 详解</h2><p><code>fstat()</code> 是 POSIX 操作系统中 <code>&lt;sys/stat.h&gt;</code> 头文件中定义的一个函数，用于获取一个已打开文件的状态信息，并将其存储在 <code>struct stat</code> 结构体中。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> filedes, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：若成功，返回 0；失败则返回 -1，并设置 <code>errno</code> 表示错误类型。</li>
<li><strong>参数</strong>：<ul>
<li><code>filedes</code>：文件描述符，表示已经打开的文件。</li>
<li><code>buf</code>：<code>struct stat</code> 类型的指针，用于存储获取到的文件状态信息。</li>
</ul>
</li>
</ul>
<h3 id="struct-stat-结构体：-1"><a href="#struct-stat-结构体：-1" class="headerlink" title="struct stat 结构体："></a><code>struct stat</code> 结构体：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>     st_dev;         <span class="comment">// 设备 ID</span></span><br><span class="line">    <span class="type">ino_t</span>     st_ino;         <span class="comment">// inode 号</span></span><br><span class="line">    <span class="type">mode_t</span>    st_mode;        <span class="comment">// 文件类型和访问权限</span></span><br><span class="line">    <span class="type">nlink_t</span>   st_nlink;       <span class="comment">// 链接数</span></span><br><span class="line">    <span class="type">uid_t</span>     st_uid;         <span class="comment">// 用户 ID</span></span><br><span class="line">    <span class="type">gid_t</span>     st_gid;         <span class="comment">// 组 ID</span></span><br><span class="line">    <span class="type">off_t</span>     st_size;        <span class="comment">// 文件大小（字节数）</span></span><br><span class="line">    <span class="type">time_t</span>    st_atime;       <span class="comment">// 最后访问时间</span></span><br><span class="line">    <span class="type">time_t</span>    st_mtime;       <span class="comment">// 最后修改时间</span></span><br><span class="line">    <span class="type">time_t</span>    st_ctime;       <span class="comment">// 最后状态改变时间</span></span><br><span class="line">    <span class="type">blksize_t</span> st_blksize;     <span class="comment">// 文件系统 I/O 缓冲区大小</span></span><br><span class="line">    <span class="type">blkcnt_t</span>  st_blocks;      <span class="comment">// 分配的文件块数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">fileInfo</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;example.txt&quot;</span>; <span class="comment">// 假设存在的文件名</span></span><br><span class="line">    <span class="type">int</span> fileDescriptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fileDescriptor = open(filename, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fileDescriptor &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件状态信息并存储在 fileInfo 结构体中</span></span><br><span class="line">    <span class="keyword">if</span> (fstat(fileDescriptor, &amp;fileInfo) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件大小：%lld 字节\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)fileInfo.st_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;访问权限：%o\n&quot;</span>, fileInfo.st_mode &amp; (S_IRWXU | S_IRWXG | S_IRWXO));</span><br><span class="line">        <span class="comment">// 更多的文件状态信息可通过 struct stat 中的其他成员获取，如 st_mode、st_uid、st_gid、st_atime 等</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fileDescriptor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项：-2"><a href="#注意事项：-2" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>fstat()</code> 函数用于获取一个已经打开文件的详细状态信息，如文件大小、访问权限、所有者信息、最后访问时间等。</li>
<li>要使用 <code>fstat()</code> 函数，需要包含 <code>&lt;sys/stat.h&gt;</code> 和 <code>&lt;fcntl.h&gt;</code> 头文件。</li>
<li>在调用 <code>fstat()</code> 函数时，需要传递文件描述符和一个指向 <code>struct stat</code> 结构体的指针，该结构体将会被填充为文件的状态信息。</li>
<li>如果函数执行成功，返回值为 0；否则返回 -1，并设置 <code>errno</code> 表示错误类型。</li>
</ul>
<p><code>fstat()</code> 函数允许程序员在已经打开的文件上获取详细的状态信息，这对于进行文件操作和管理非常有用。</p>
<h2 id="Linux-POSIX-chmod-详解"><a href="#Linux-POSIX-chmod-详解" class="headerlink" title="Linux POSIX &lt;sys&#x2F;stat.h&gt; chmod() 详解"></a>Linux POSIX &lt;sys&#x2F;stat.h&gt; chmod() 详解</h2><p><code>chmod()</code> 是 POSIX 操作系统中 <code>&lt;sys/stat.h&gt;</code> 头文件中定义的一个函数，用于改变文件的访问权限。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：若成功，返回 0；失败则返回 -1，并设置 <code>errno</code> 表示错误类型。</li>
<li><strong>参数</strong>：<ul>
<li><code>pathname</code>：字符串，表示要修改权限的文件路径。</li>
<li><code>mode</code>：<code>mode_t</code> 类型，表示新的访问权限，使用八进制表示。</li>
</ul>
</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;example.txt&quot;</span>; <span class="comment">// 假设存在的文件名</span></span><br><span class="line">    <span class="type">mode_t</span> newMode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH; <span class="comment">// 新的权限，只允许所有者读写，组和其他用户只允许读</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改文件权限</span></span><br><span class="line">    <span class="keyword">if</span> (chmod(filename, newMode) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件权限修改成功\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;chmod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项：-3"><a href="#注意事项：-3" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>chmod()</code> 函数用于改变指定文件的访问权限。</li>
<li><code>mode</code> 参数用 <code>mode_t</code> 类型表示，可以使用 <code>S_IRUSR</code>（所有者读权限）、<code>S_IWUSR</code>（所有者写权限）、<code>S_IXUSR</code>（所有者执行权限）等宏定义。</li>
<li>使用位掩码运算符 <code>|</code> 来组合权限选项，然后传递给 <code>chmod()</code> 函数来设置文件的新权限。</li>
<li>要使用 <code>chmod()</code> 函数，需要对指定的文件有合适的权限。</li>
</ul>
<p><code>chmod()</code> 函数允许程序员根据需要修改文件的访问权限，以控制文件的读、写、执行等操作，对于安全性和权限管理非常重要。</p>
<h2 id="Linux-POSIX-chown-详解"><a href="#Linux-POSIX-chown-详解" class="headerlink" title="Linux POSIX &lt;sys&#x2F;stat.h&gt; chown() 详解"></a>Linux POSIX &lt;sys&#x2F;stat.h&gt; chown() 详解</h2><p><code>chown()</code> 是 POSIX 操作系统中 <code>&lt;sys/stat.h&gt;</code> 头文件中定义的一个函数，用于修改文件的所有者和所属组。</p>
<h3 id="函数签名：-3"><a href="#函数签名：-3" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：若成功，返回 0；失败则返回 -1，并设置 <code>errno</code> 表示错误类型。</li>
<li><strong>参数</strong>：<ul>
<li><code>pathname</code>：字符串，表示要修改所有者和所属组的文件路径。</li>
<li><code>owner</code>：<code>uid_t</code> 类型，表示文件的新所有者 ID。</li>
<li><code>group</code>：<code>gid_t</code> 类型，表示文件的新所属组 ID。</li>
</ul>
</li>
</ul>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;example.txt&quot;</span>; <span class="comment">// 假设存在的文件名</span></span><br><span class="line">    <span class="type">uid_t</span> newOwner = <span class="number">1000</span>; <span class="comment">// 新的所有者 ID</span></span><br><span class="line">    <span class="type">gid_t</span> newGroup = <span class="number">1000</span>; <span class="comment">// 新的所属组 ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改文件所有者和所属组</span></span><br><span class="line">    <span class="keyword">if</span> (chown(filename, newOwner, newGroup) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件所有者和所属组修改成功\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;chown&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项：-4"><a href="#注意事项：-4" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>chown()</code> 函数用于修改指定文件的所有者和所属组。</li>
<li><code>owner</code> 参数表示文件的新所有者 ID，<code>group</code> 参数表示文件的新所属组 ID。</li>
<li>要使用 <code>chown()</code> 函数，需要对指定的文件有适当的权限，通常只有超级用户或文件的当前所有者可以修改文件的所有者和所属组。</li>
</ul>
<p><code>chown()</code> 函数允许程序员根据需要更改文件的所有者和所属组，这对于管理文件系统权限和安全性是非常重要的。</p>
<h2 id="Linux-POSIX-utime-详解"><a href="#Linux-POSIX-utime-详解" class="headerlink" title="Linux POSIX &lt;sys&#x2F;stat.h&gt; utime() 详解"></a>Linux POSIX &lt;sys&#x2F;stat.h&gt; utime() 详解</h2><p><code>utime()</code> 是 POSIX 操作系统中 <code>&lt;sys/stat.h&gt;</code> 头文件中定义的一个函数，用于修改文件的访问时间和修改时间。</p>
<h3 id="函数签名：-4"><a href="#函数签名：-4" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">utime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> utimbuf *times)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：若成功，返回 0；失败则返回 -1，并设置 <code>errno</code> 表示错误类型。</li>
<li><strong>参数</strong>：<ul>
<li><code>filename</code>：字符串，表示要修改访问时间和修改时间的文件路径。</li>
<li><code>times</code>：<code>struct utimbuf</code> 类型的指针，指向包含访问时间和修改时间信息的结构体。</li>
</ul>
</li>
</ul>
<h3 id="struct-utimbuf-结构体："><a href="#struct-utimbuf-结构体：" class="headerlink" title="struct utimbuf 结构体："></a><code>struct utimbuf</code> 结构体：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> actime;  <span class="comment">// 访问时间</span></span><br><span class="line">    <span class="type">time_t</span> modtime; <span class="comment">// 修改时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;example.txt&quot;</span>; <span class="comment">// 假设存在的文件名</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span> <span class="title">newTimes</span>;</span></span><br><span class="line"></span><br><span class="line">    newTimes.actime = <span class="number">1640260800</span>; <span class="comment">// 2022-12-24 00:00:00 的时间戳，作为新的访问时间</span></span><br><span class="line">    newTimes.modtime = <span class="number">1640264400</span>; <span class="comment">// 2022-12-24 01:00:00 的时间戳，作为新的修改时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改文件的访问时间和修改时间</span></span><br><span class="line">    <span class="keyword">if</span> (utime(filename, &amp;newTimes) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件访问时间和修改时间修改成功\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;utime&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项：-5"><a href="#注意事项：-5" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>utime()</code> 函数用于修改指定文件的访问时间和修改时间。</li>
<li><code>struct utimbuf</code> 结构体包含了要设置的访问时间和修改时间的值，以秒为单位。</li>
<li>要使用 <code>utime()</code> 函数，需要对指定的文件有适当的权限。</li>
</ul>
<p><code>utime()</code> 函数允许程序员根据需要更改文件的访问时间和修改时间，这对于模拟文件访问和修改时间、文件同步等操作是非常有用的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_1_posix_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_1_posix_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">C_5_1_posix_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>POSIX 相关的理论基础</li>
</ul>
<h2 id="POSIX-是什么"><a href="#POSIX-是什么" class="headerlink" title="POSIX 是什么"></a>POSIX 是什么</h2><p>POSIX（Portable Operating System Interface，可移植操作系统接口）是一个定义了操作系统接口标准的系列规范。它的目的是促进不同操作系统之间软件的可移植性，使得在遵循 POSIX 标准的系统上编写的程序能够在其他符合该标准的系统上无需或只需少量修改就能运行。</p>
<p>POSIX 标准最初由 IEEE（Institute of Electrical and Electronics Engineers）开发，并于 1988 年首次正式发布。它基于 UNIX 操作系统的一些基本设计原则，但并不局限于 UNIX。该标准定义了系统调用、命令解释器（shell）、系统函数、头文件以及工具等，旨在提供通用的操作系统接口。</p>
<p>POSIX 标准涵盖了诸多方面，其中包括但不限于以下几个关键领域：</p>
<ol>
<li><p><strong>文件系统操作</strong>：定义了文件访问、目录操作、文件属性等方面的接口，例如 <code>&lt;stdio.h&gt;</code>、<code>&lt;stdlib.h&gt;</code>、<code>&lt;fcntl.h&gt;</code> 等头文件。</p>
</li>
<li><p><strong>进程管理</strong>：包括进程创建、调度、信号处理等，例如 <code>&lt;unistd.h&gt;</code>、<code>&lt;sys/types.h&gt;</code>、<code>&lt;signal.h&gt;</code> 等头文件。</p>
</li>
<li><p><strong>用户和组管理</strong>：定义了用户和组的管理、访问控制等，例如 <code>&lt;pwd.h&gt;</code>、<code>&lt;grp.h&gt;</code> 等头文件。</p>
</li>
<li><p><strong>线程和同步</strong>：包括多线程支持、同步原语等，例如 <code>&lt;pthread.h&gt;</code> 头文件。</p>
</li>
<li><p><strong>网络和通信</strong>：定义了网络接口、套接字操作等，例如 <code>&lt;sys/socket.h&gt;</code>、<code>&lt;netinet/in.h&gt;</code> 等头文件。</p>
</li>
</ol>
<p>POSIX 标准的遵循对于编写可移植的系统级程序和工具非常重要。尽管不是所有的操作系统都完全符合 POSIX 标准，但它仍然是确保跨平台软件移植性的一个关键框架。</p>
<h2 id="POSIX-详解"><a href="#POSIX-详解" class="headerlink" title="POSIX 详解"></a>POSIX 详解</h2><p>POSIX（Portable Operating System Interface，可移植操作系统接口）是一个定义了操作系统接口标准的系列规范。它的主要目的是为不同的操作系统提供一个一致的编程接口，从而使得在遵循 POSIX 标准的系统上编写的程序能够在其他符合该标准的系统上无需或只需少量修改就能运行。</p>
<p>以下是 POSIX 标准的一些主要特征和内容：</p>
<ol>
<li><p><strong>历史背景</strong>：<br>POSIX 最初由 IEEE（Institute of Electrical and Electronics Engineers）标准化，并在 1988 年首次发布。它基于 UNIX 操作系统的一些基本设计原则，旨在提供一个通用的操作系统接口。</p>
</li>
<li><p><strong>标准化</strong>：<br>POSIX 标准不是针对特定操作系统的，而是为了使得不同的操作系统在核心接口层面上能够保持兼容。这意味着符合 POSIX 标准的操作系统应该提供一致的系统调用、头文件、库函数等。</p>
</li>
<li><p><strong>POSIX 规范的组成部分</strong>：<br>POSIX 规范包括了许多不同的部分，每个部分都针对特定领域提供了接口规范。这些部分涵盖了文件系统操作、进程管理、用户和组管理、线程和同步、网络和通信等方面。其中一些关键的头文件已经在之前的回答中提及。</p>
</li>
<li><p><strong>标准的扩展和变体</strong>：<br>尽管 POSIX 旨在提供通用的标准接口，但是并不是所有的操作系统都完全符合标准。有些系统可能提供了对标准的扩展，或者可能并未完全实现 POSIX 中的所有功能。</p>
</li>
<li><p><strong>影响和重要性</strong>：<br>POSIX 标准对于系统级编程、跨平台软件开发以及软件移植性具有重要意义。符合 POSIX 标准的程序可以在不同的 POSIX 兼容系统上进行编译和运行，而无需进行大量修改。</p>
</li>
<li><p><strong>持续发展</strong>：<br>随着时间的推移，POSIX 标准也在不断发展和更新，以适应新的技术和需求。不同的 POSIX 版本和扩展版本不断涌现，为不同领域的技术带来了更多的功能和特性。</p>
</li>
</ol>
<p>总的来说，POSIX 标准提供了一套通用的操作系统接口，有助于提高软件的可移植性和跨平台兼容性。虽然它并不是所有操作系统的完全实现，但是作为一个标准框架，它为开发者提供了一个基本的参考和依据，有助于编写更具可移植性的代码。</p>
<h2 id="POSIX标准头文件有哪些"><a href="#POSIX标准头文件有哪些" class="headerlink" title="POSIX标准头文件有哪些"></a>POSIX标准头文件有哪些</h2><p>POSIX（Portable Operating System Interface）标准定义了操作系统接口，包括了一系列头文件以及函数、数据类型、宏等的规范，旨在提高不同操作系统间软件的可移植性。以下是一些常见的 POSIX 标准头文件：</p>
<ol>
<li><p>**&lt;unistd.h&gt;**：定义了符号常量、类型和函数原型，提供对 POSIX 操作系统 API 的访问，包括文件操作、进程控制、系统调用等。</p>
</li>
<li><p>**&lt;stdlib.h&gt;**：包含了通用工具函数的声明，例如内存分配函数 <code>malloc()</code>、<code>free()</code>，以及一些其他的常用函数。</p>
</li>
<li><p>**&lt;stdio.h&gt;**：提供了输入和输出函数的声明，如 <code>printf()</code>、<code>scanf()</code>，以及文件操作相关的函数 <code>fopen()</code>、<code>fclose()</code> 等。</p>
</li>
<li><p>**&lt;errno.h&gt;**：定义了 <code>errno</code> 变量和一系列错误码，用于报告函数调用中发生的错误。</p>
</li>
<li><p>**&lt;signal.h&gt;**：定义了信号处理相关的函数和宏，用于处理进程间的通信和控制。</p>
</li>
<li><p>**&lt;pthread.h&gt;**：多线程支持头文件，包含了创建、同步和管理 POSIX 线程的函数和数据类型。</p>
</li>
<li><p>**&lt;time.h&gt;**：包含了时间和日期处理函数的声明，用于处理系统时间和日期。</p>
</li>
<li><p>**&lt;sys&#x2F;types.h&gt;**：定义了各种系统数据类型，例如 <code>size_t</code>、<code>off_t</code>，以及其他与系统相关的类型定义。</p>
</li>
<li><p>**&lt;sys&#x2F;stat.h&gt;**：包含了文件状态相关的宏和函数，如 <code>stat()</code>、<code>chmod()</code>，用于获取和设置文件属性。</p>
</li>
<li><p>**&lt;dirent.h&gt;**：用于操作目录和目录条目的头文件，提供对目录结构的访问。</p>
</li>
</ol>
<p>这些头文件以及其中所包含的函数和宏定义为程序员提供了在 POSIX 兼容系统上进行系统级编程和应用开发所需的接口。请注意，虽然这些头文件在 POSIX 系统上通常是标准的，但在特定系统中可能会有所不同或者补充其他特定的头文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_3_unistd_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_3_unistd_h/" class="post-title-link" itemprop="url">C_5_3_unistd_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Linux POSIX &lt;unistd.h&gt;</li>
</ul>
<h2 id="Linux-POSIX-详解"><a href="#Linux-POSIX-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; 详解"></a>Linux POSIX &lt;unistd.h&gt; 详解</h2><p>在 POSIX 系统中，<code>&lt;unistd.h&gt;</code> 是一个重要的头文件，提供了许多对系统进行访问的标准符号常量、类型和函数原型。这个头文件对于系统级编程非常重要，它定义了 POSIX 操作系统 API 的许多核心功能。</p>
<p>以下是 <code>&lt;unistd.h&gt;</code> 中常见的一些功能和内容：</p>
<ol>
<li><p><strong>符号常量</strong>：</p>
<ul>
<li><code>STDIN_FILENO</code>、<code>STDOUT_FILENO</code>、<code>STDERR_FILENO</code>：标准输入、标准输出和标准错误的文件描述符。</li>
<li><code>F_OK</code>、<code>R_OK</code>、<code>W_OK</code>、<code>X_OK</code>：用于文件访问权限的标志常量。</li>
<li>其他常量用于系统调用、文件操作等。</li>
</ul>
</li>
<li><p><strong>数据类型</strong>：</p>
<ul>
<li><code>ssize_t</code>：用于表示字节大小的有符号整数类型。</li>
<li><code>off_t</code>：用于表示文件偏移量的类型。</li>
<li><code>pid_t</code>：用于表示进程 ID 的类型。</li>
<li>其他与系统相关的类型。</li>
</ul>
</li>
<li><p><strong>函数原型</strong>：</p>
<ul>
<li>文件操作：<code>read()</code>、<code>write()</code>、<code>close()</code> 等。</li>
<li>进程控制：<code>fork()</code>、<code>exec()</code>、<code>wait()</code>、<code>exit()</code> 等。</li>
<li>文件和目录操作：<code>access()</code>、<code>mkdir()</code>、<code>rmdir()</code>、<code>chdir()</code> 等。</li>
<li>系统调用和资源管理：<code>sleep()</code>、<code>getpid()</code>、<code>getcwd()</code>、<code>getuid()</code> 等。</li>
</ul>
</li>
</ol>
<p><code>&lt;unistd.h&gt;</code> 头文件中的函数和符号常量是进行系统级编程的关键工具。这些函数和常量允许程序员对文件、进程、系统调用等进行操作，使得在 POSIX 系统上进行更底层的系统编程变得更加容易和标准化。</p>
<h2 id="Linux-POSIX-open-详解"><a href="#Linux-POSIX-open-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; open() 详解"></a>Linux POSIX &lt;unistd.h&gt; open() 详解</h2><p>在 POSIX 系统中，<code>open()</code> 是 <code>&lt;unistd.h&gt;</code> 头文件中定义的函数之一，用于打开或创建文件，并返回一个文件描述符，以便后续对文件进行读写操作。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>pathname</code>：要打开或创建的文件的路径名。</li>
<li><code>flags</code>：用于指定打开文件的标志，可以是 <code>O_RDONLY</code>（只读）、<code>O_WRONLY</code>（只写）、<code>O_RDWR</code>（读写）、<code>O_CREAT</code>（若文件不存在则创建）、<code>O_TRUNC</code>（清空文件内容）等标志的组合。</li>
<li><code>mode</code>：用于指定创建文件时的权限，仅在 <code>O_CREAT</code> 标志被指定时有效，通常以八进制数表示，比如 <code>0644</code>。</li>
</ul>
<p>返回值为文件描述符 <code>int</code> 类型，表示打开文件的引用，如果出错则返回 -1。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;file.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>); <span class="comment">// 打开或创建文件</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File opened with file descriptor: %d\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">    close(fd); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>open()</code> 函数打开或创建文件，并获取文件描述符。在这个例子中，<code>file.txt</code> 是要打开或创建的文件名。使用 <code>O_WRONLY</code> 表示只写模式，<code>O_CREAT</code> 表示若文件不存在则创建，<code>O_TRUNC</code> 表示清空文件内容。<code>0644</code> 是文件权限，指定文件所有者有读写权限，其他用户只有读权限。</p>
<p><code>open()</code> 函数在实际应用中用于打开文件或创建文件，返回文件描述符以便后续对文件进行读写操作。</p>
<h2 id="Linux-POSIX-read-详解"><a href="#Linux-POSIX-read-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; read() 详解"></a>Linux POSIX &lt;unistd.h&gt; read() 详解</h2><p>在 POSIX 系统中，<code>read()</code> 是 <code>&lt;unistd.h&gt;</code> 头文件中定义的函数之一，用于从文件描述符中读取数据。该函数通常用于从文件、管道、套接字或其他 I&#x2F;O 对象中读取数据。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>fd</code>：要读取的文件描述符。</li>
<li><code>buf</code>：用于存储读取数据的缓冲区。</li>
<li><code>count</code>：要读取的字节数。</li>
</ul>
<p><code>read()</code> 函数的返回值 <code>ssize_t</code> 表示实际读取的字节数，或者在出错时返回负数。返回值为 0 表示已到达文件末尾（对于文件描述符到达末尾或连接被关闭的情况）。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytes_read;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;file.txt&quot;</span>, O_RDONLY); <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes_read = read(fd, buffer, <span class="keyword">sizeof</span>(buffer)); <span class="comment">// 从文件中读取数据</span></span><br><span class="line">    <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read %zd bytes: %s\n&quot;</span>, bytes_read, buffer);</span><br><span class="line"></span><br><span class="line">    close(fd); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>read()</code> 函数从文件中读取数据。首先，通过 <code>open()</code> 函数打开一个文件，并获取文件描述符。然后，使用 <code>read()</code> 函数从该文件中读取数据，并将读取的内容存储在 <code>buffer</code> 缓冲区中。最后，使用 <code>printf()</code> 函数打印读取的字节数和内容。</p>
<p><code>read()</code> 函数在实际应用中经常用于从文件或其他 I&#x2F;O 对象中读取数据，并将数据存储到指定的缓冲区中。</p>
<h2 id="Linux-POSIX-write-详解"><a href="#Linux-POSIX-write-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; write() 详解"></a>Linux POSIX &lt;unistd.h&gt; write() 详解</h2><p>在 POSIX 系统中，<code>write()</code> 是 <code>&lt;unistd.h&gt;</code> 头文件中定义的函数之一，用于向文件描述符中写入数据。这个函数通常用于将数据写入文件、管道、套接字或其他 I&#x2F;O 对象。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>fd</code>：要写入的文件描述符。</li>
<li><code>buf</code>：要写入的数据的缓冲区。</li>
<li><code>count</code>：要写入的字节数。</li>
</ul>
<p><code>write()</code> 函数的返回值 <code>ssize_t</code> 表示实际写入的字节数，或者在出错时返回负数。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> *data = <span class="string">&quot;Hello, this is a test!&quot;</span>;</span><br><span class="line">    <span class="type">ssize_t</span> bytes_written;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>); <span class="comment">// 打开或创建文件</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes_written = write(fd, data, <span class="built_in">strlen</span>(data)); <span class="comment">// 向文件中写入数据</span></span><br><span class="line">    <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Written %zd bytes to the file.\n&quot;</span>, bytes_written);</span><br><span class="line"></span><br><span class="line">    close(fd); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>write()</code> 函数向文件中写入数据。首先，通过 <code>open()</code> 函数打开一个文件或创建一个新文件，并获取文件描述符。然后，使用 <code>write()</code> 函数将数据写入文件中。在这个例子中，字符串 “Hello, this is a test!” 被写入到文件中。最后，使用 <code>printf()</code> 函数打印写入的字节数。</p>
<p><code>write()</code> 函数在实际应用中通常用于将数据写入到文件中，执行输入&#x2F;输出操作。</p>
<h2 id="Linux-POSIX-close-详解"><a href="#Linux-POSIX-close-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; close() 详解"></a>Linux POSIX &lt;unistd.h&gt; close() 详解</h2><p>在 POSIX 系统中，<code>close()</code> 是 <code>&lt;unistd.h&gt;</code> 头文件中定义的函数之一，用于关闭先前打开的文件描述符，释放文件描述符所占用的资源。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>fd</code> 是要关闭的文件描述符。</p>
<p><code>close()</code> 函数的返回值为整型。成功关闭文件描述符时返回 0，失败时返回 -1，并设置全局变量 <code>errno</code> 以指示错误类型。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;file.txt&quot;</span>, O_RDONLY); <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此对文件进行读取、写入等操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (close(fd) == <span class="number">-1</span>) &#123; <span class="comment">// 关闭文件</span></span><br><span class="line">        perror(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>close()</code> 函数用于关闭先前使用 <code>open()</code> 打开的文件描述符 <code>fd</code>。关闭文件描述符后，应用程序不再具有对文件的访问权限。</p>
<p><code>close()</code> 函数在文件操作中是一个重要的步骤，它负责释放文件描述符所占用的资源，因此在使用完文件后，一般都会使用 <code>close()</code> 来关闭文件描述符，以避免资源泄漏。</p>
<h2 id="Linux-POSIX-lseek-详解"><a href="#Linux-POSIX-lseek-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; lseek() 详解"></a>Linux POSIX &lt;unistd.h&gt; lseek() 详解</h2><p>在 POSIX 系统中，<code>lseek()</code> 是 <code>&lt;unistd.h&gt;</code> 头文件中定义的函数之一，用于在文件中移动文件读写指针，以便定位到文件中的特定位置。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>fd</code>：文件描述符，指示要操作的文件。</li>
<li><code>offset</code>：偏移量，指定相对于 <code>whence</code> 参数的位置进行偏移。</li>
<li><code>whence</code>：指定偏移量的基准位置，可以是 <code>SEEK_SET</code>（从文件开头开始）、<code>SEEK_CUR</code>（从当前位置开始）、<code>SEEK_END</code>（从文件末尾开始）。</li>
</ul>
<p><code>lseek()</code> 函数返回 <code>off_t</code> 类型，表示从文件开头到指定位置的偏移量，或者在出错时返回 <code>-1</code>。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">off_t</span> new_offset;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;file.txt&quot;</span>, O_RDONLY); <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动文件读写指针到文件末尾</span></span><br><span class="line">    new_offset = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span> (new_offset == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File size: %lld bytes\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)new_offset);</span><br><span class="line"></span><br><span class="line">    close(fd); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>lseek()</code> 函数被用于将文件读写指针移动到文件末尾。通过将 <code>whence</code> 参数设置为 <code>SEEK_END</code> 并将 <code>offset</code> 设置为 0，<code>lseek()</code> 将读写指针移动到文件末尾，并返回文件大小。然后，使用 <code>printf()</code> 打印文件的大小。</p>
<p><code>lseek()</code> 函数在文件操作中可以用于定位到文件的特定位置，比如读取文件末尾、从指定位置开始读取等操作。</p>
<h2 id="Linux-POSIX-fork-详解"><a href="#Linux-POSIX-fork-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; fork() 详解"></a>Linux POSIX &lt;unistd.h&gt; fork() 详解</h2><p>在 POSIX 系统中，<code>fork()</code> 是 <code>&lt;unistd.h&gt;</code> 头文件中定义的函数之一，用于创建一个新的进程，该进程是调用进程的副本，被称为子进程。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><code>fork()</code> 函数不接收任何参数，返回值是一个 <code>pid_t</code> 类型的值，表示进程 ID。在父进程中，<code>fork()</code> 返回子进程的进程 ID；而在子进程中，<code>fork()</code> 返回 0。如果出现错误，<code>fork()</code> 返回一个负数。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> child_pid;</span><br><span class="line"></span><br><span class="line">    child_pid = fork(); <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程执行的代码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is the child process (PID: %d)\n&quot;</span>, getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程执行的代码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is the parent process (Child PID: %d, Parent PID: %d)\n&quot;</span>, child_pid, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>fork()</code> 被调用后会创建一个新的子进程。父进程中的 <code>child_pid</code> 变量存储了子进程的进程 ID。在父进程中，<code>fork()</code> 返回子进程的进程 ID；在子进程中，<code>fork()</code> 返回 0。通过检查返回值，可以区分父进程和子进程。</p>
<p><code>fork()</code> 在创建子进程时，会复制父进程的内存映像。子进程是父进程的副本，但它有自己独立的内存空间。父子进程会同时执行 <code>fork()</code> 调用之后的代码，但在不同的进程上下文中。这使得通过 <code>fork()</code> 创建新进程成为了一种常见的并行执行代码的方式。</p>
<h2 id="Linux-POSIX-exec-详解"><a href="#Linux-POSIX-exec-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; exec() 详解"></a>Linux POSIX &lt;unistd.h&gt; exec() 详解</h2><p>在 POSIX 系统中，<code>exec()</code> 函数族包括一组函数，用于在当前进程中执行新的程序，替换当前进程的内存映像为新程序的代码和数据。<code>exec()</code> 函数族包括多个变体，如 <code>execl()</code>, <code>execv()</code>, <code>execle()</code>, <code>execve()</code>, 等等。</p>
<p>这些函数允许程序动态地在当前进程中加载新的程序，并执行该程序的代码，取代当前进程的内容。</p>
<p>以下是其中两个常用的函数原型：</p>
<ol>
<li><p><strong><code>int execl(const char *path, const char *arg0, ... /* (char *) NULL */ );</code></strong></p>
<ul>
<li><code>path</code>：新程序的路径。</li>
<li><code>arg0</code>：新程序的名称，通常被赋予被执行程序的名称。</li>
<li><code>...</code>：可变数量的参数，用来传递给新程序的命令行参数，最后一个参数必须是 <code>(char *) NULL</code>。</li>
</ul>
</li>
<li><p><strong><code>int execv(const char *path, char *const argv[]);</code></strong></p>
<ul>
<li><code>path</code>：新程序的路径。</li>
<li><code>argv</code>：一个字符指针数组，用于传递给新程序的命令行参数，以 NULL 结尾。</li>
</ul>
</li>
</ol>
<p>这些函数的返回值在执行成功时一般不会返回，如果返回，通常表示发生了错误。</p>
<p>示例用法（<code>execv()</code>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *args[] = &#123;<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;; <span class="comment">// 命令行参数数组</span></span><br><span class="line">    <span class="keyword">if</span> (execv(<span class="string">&quot;/bin/ls&quot;</span>, args) == <span class="number">-1</span>) &#123; <span class="comment">// 执行 ls 命令</span></span><br><span class="line">        perror(<span class="string">&quot;execv&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This line will not be executed because of execv()\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>execv()</code> 函数用于执行 <code>/bin/ls</code> 命令，传递了命令行参数 <code>-l</code>。如果 <code>execv()</code> 执行成功，则会替换当前进程的内存映像为 <code>ls</code> 命令，并显示相应的输出。如果执行失败，则会输出错误信息。需要注意的是，如果 <code>execv()</code> 函数执行成功，则后续代码不会被执行，因为当前进程的内容已经被新程序替换。</p>
<h2 id="Linux-POSIX-wait-详解"><a href="#Linux-POSIX-wait-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; wait() 详解"></a>Linux POSIX &lt;unistd.h&gt; wait() 详解</h2><p>在 POSIX 系统中，<code>wait()</code> 是 <code>&lt;unistd.h&gt;</code> 头文件中定义的函数之一，用于父进程等待子进程的终止。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>status</code> 是一个指向整型的指针，用于存储子进程的退出状态信息。如果不关心子进程的退出状态，可以传入 <code>NULL</code>。</p>
<p><code>wait()</code> 函数的返回值为子进程的进程 ID，如果出错则返回 -1。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork(); <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程执行的代码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process with PID: %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">42</span>); <span class="comment">// 子进程退出，退出状态为 42</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程执行的代码</span></span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="type">pid_t</span> child_pid = wait(&amp;status); <span class="comment">// 等待子进程退出</span></span><br><span class="line">        <span class="keyword">if</span> (child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status)) &#123; <span class="comment">// 检查子进程是否正常终止</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child process %d exited with status: %d\n&quot;</span>, child_pid, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，父进程使用 <code>fork()</code> 创建了一个子进程。在子进程中，使用 <code>exit(42)</code> 退出，并返回状态码 42。在父进程中，使用 <code>wait()</code> 函数等待子进程退出，并获取子进程的退出状态信息。<code>WIFEXITED(status)</code> 用于检查子进程是否正常终止，<code>WEXITSTATUS(status)</code> 获取子进程的退出状态。</p>
<p><code>wait()</code> 函数允许父进程等待子进程的终止，以便获取子进程的退出状态。</p>
<h2 id="Linux-POSIX-exit-详解"><a href="#Linux-POSIX-exit-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; exit() 详解"></a>Linux POSIX &lt;unistd.h&gt; exit() 详解</h2><p>在 POSIX 系统中，<code>exit()</code> 是 <code>&lt;unistd.h&gt;</code> 头文件中定义的函数之一，用于正常终止当前进程。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>status</code> 是整数类型，表示进程的退出状态。通常情况下，0 表示正常终止，非零值表示出现了错误。</p>
<p><code>exit()</code> 函数没有返回值，它会终止当前进程的执行，并将进程的退出状态传递给父进程。进程终止后，操作系统会进行清理工作，包括关闭文件描述符、释放内存等。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before calling exit()\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 正常终止进程，退出状态为 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This line will not be executed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>exit()</code> 函数被调用来正常终止进程。在调用 <code>exit()</code> 后的代码将不会被执行，因为进程已经终止。</p>
<p><code>exit()</code> 函数用于结束当前进程的执行，常见的使用情况包括程序执行成功时返回 0，出现错误时返回非零值，以及在程序中遇到不可恢复的错误时终止程序。</p>
<h2 id="Linux-POSIX-access-详解"><a href="#Linux-POSIX-access-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; access() 详解"></a>Linux POSIX &lt;unistd.h&gt; access() 详解</h2><p>在 POSIX 系统中，<code>access()</code> 是 <code>&lt;unistd.h&gt;</code> 头文件中定义的函数之一，用于检查文件的权限。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>pathname</code> 是要检查权限的文件路径名，<code>mode</code> 是要检查的权限。<code>mode</code> 可以是以下值的按位或组合：</p>
<ul>
<li><code>F_OK</code>：用于检查文件是否存在。</li>
<li><code>R_OK</code>：用于检查文件是否可读。</li>
<li><code>W_OK</code>：用于检查文件是否可写。</li>
<li><code>X_OK</code>：用于检查文件是否可执行。</li>
</ul>
<p><code>access()</code> 函数返回整型值，表示文件权限检查的结果。如果权限检查成功，返回 0；否则返回 -1，并设置 <code>errno</code> 来指示具体的错误类型。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filename = <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (access(filename, F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s exists\n&quot;</span>, filename);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s does not exist\n&quot;</span>, filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件是否可读</span></span><br><span class="line">    <span class="keyword">if</span> (access(filename, R_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s is readable\n&quot;</span>, filename);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s is not readable\n&quot;</span>, filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件是否可写</span></span><br><span class="line">    <span class="keyword">if</span> (access(filename, W_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s is writable\n&quot;</span>, filename);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s is not writable\n&quot;</span>, filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件是否可执行</span></span><br><span class="line">    <span class="keyword">if</span> (access(filename, X_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s is executable\n&quot;</span>, filename);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s is not executable\n&quot;</span>, filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>access()</code> 函数被用于检查文件 <code>example.txt</code> 的存在性、可读性、可写性和可执行性。根据权限检查的结果，打印相应的信息。</p>
<h2 id="Linux-POSIX-mkir-详解"><a href="#Linux-POSIX-mkir-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; mkir() 详解"></a>Linux POSIX &lt;unistd.h&gt; mkir() 详解</h2><p>在 POSIX 系统中，创建新目录的函数是 <code>mkdir()</code>，而不是 <code>mkir()</code>。</p>
<p><code>mkdir()</code> 函数用于创建新目录，其原型定义在 <code>&lt;sys/stat.h&gt;</code> 头文件中，而不是 <code>&lt;unistd.h&gt;</code>。它的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pathname</code> 是新目录的路径名。</li>
<li><code>mode</code> 是新目录的权限模式，通常以八进制表示，比如 <code>0755</code>。</li>
</ul>
<p>函数返回值为整型，如果创建成功返回 0，创建失败返回 -1，并设置相应的错误码，可以通过 <code>errno</code> 查看具体错误信息。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dirname = <span class="string">&quot;new_directory&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新目录</span></span><br><span class="line">    <span class="keyword">if</span> (mkdir(dirname, <span class="number">0755</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Directory \&quot;%s\&quot; created successfully.\n&quot;</span>, dirname);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>mkdir()</code> 函数创建一个名为 <code>new_directory</code> 的新目录，并指定了权限为 <code>0755</code>。如果目录创建成功，则会输出相应的成功信息，否则会输出相应的错误信息。</p>
<p><code>mkdir()</code> 函数是 POSIX 系统中用于创建目录的常用函数之一。</p>
<h2 id="Linux-POSIX-rmdir-详解"><a href="#Linux-POSIX-rmdir-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; rmdir() 详解"></a>Linux POSIX &lt;unistd.h&gt; rmdir() 详解</h2><p>在 POSIX 系统中，<code>rmdir()</code> 是 <code>&lt;unistd.h&gt;</code> 头文件中定义的函数之一，用于删除目录。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>pathname</code> 是要删除的目录的路径名。</p>
<p><code>rmdir()</code> 函数的返回值为整型，如果删除成功返回 0，删除失败返回 -1，并设置相应的错误码，可以通过 <code>errno</code> 查看具体错误信息。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dirname = <span class="string">&quot;directory_to_delete&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除目录</span></span><br><span class="line">    <span class="keyword">if</span> (rmdir(dirname) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Directory \&quot;%s\&quot; deleted successfully.\n&quot;</span>, dirname);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;rmdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>rmdir()</code> 函数删除一个名为 <code>directory_to_delete</code> 的目录。如果目录删除成功，则会输出相应的成功信息，否则会输出相应的错误信息。</p>
<p>需要注意的是，使用 <code>rmdir()</code> 删除目录时，目录必须为空。如果目录中包含文件或其他目录，则无法成功删除目录。因此，在删除目录之前，通常需要确保目录为空。</p>
<h2 id="Linux-POSIX-chdir-详解"><a href="#Linux-POSIX-chdir-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; chdir() 详解"></a>Linux POSIX &lt;unistd.h&gt; chdir() 详解</h2><p>在 POSIX 系统中，<code>chdir()</code> 是 <code>&lt;unistd.h&gt;</code> 头文件中定义的函数之一，用于改变当前工作目录。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>path</code> 是要设置为当前工作目录的路径名。</p>
<p><code>chdir()</code> 函数的返回值为整型，如果成功改变工作目录则返回 0，失败返回 -1，并设置相应的错误码，可以通过 <code>errno</code> 查看具体错误信息。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *new_directory = <span class="string">&quot;/path/to/new_directory&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变当前工作目录</span></span><br><span class="line">    <span class="keyword">if</span> (chdir(new_directory) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Changed current working directory to: %s\n&quot;</span>, new_directory);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>chdir()</code> 函数将当前工作目录更改为 <code>/path/to/new_directory</code>。如果成功更改当前工作目录，则会输出相应的成功信息，否则会输出相应的错误信息。</p>
<p><code>chdir()</code> 函数在 POSIX 系统中是用来改变当前工作目录的常用函数之一。</p>
<h2 id="Linux-POSIX-sleep-详解"><a href="#Linux-POSIX-sleep-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; sleep() 详解"></a>Linux POSIX &lt;unistd.h&gt; sleep() 详解</h2><p>在 POSIX 系统中，<code>sleep()</code> 是 <code>&lt;unistd.h&gt;</code> 头文件中定义的函数之一，用于让当前进程挂起指定的时间。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>seconds</code> 是要挂起的时间长度，单位为秒。该函数会使当前进程挂起指定的秒数，并且在等待的时间内会让出 CPU，直到指定的时间过去为止。</p>
<p><code>sleep()</code> 函数的返回值为未休眠完的时间（剩余的时间）。如果休眠时间到期，则返回 0。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sleeping for 3 seconds...\n&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> remaining_time = sleep(<span class="number">3</span>); <span class="comment">// 休眠 3 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (remaining_time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sleep interrupted, remaining time: %u seconds\n&quot;</span>, remaining_time);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Woke up after 3 seconds\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>sleep(3)</code> 使当前进程挂起 3 秒钟。如果休眠时间到期，则程序会打印”Woke up after 3 seconds”，否则如果在等待期间发生了信号中断或其他情况，则会打印”Sleep interrupted, remaining time: [剩余秒数] seconds”。</p>
<p><code>sleep()</code> 函数通常用于需要暂停执行一段时间的情况，比如在程序中设置定时任务或者等待某些条件达成的情况下。</p>
<h2 id="Linux-POSIX-getpid-详解"><a href="#Linux-POSIX-getpid-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; getpid() 详解"></a>Linux POSIX &lt;unistd.h&gt; getpid() 详解</h2><p>在 POSIX 系统中，<code>getpid()</code> 是 <code>&lt;unistd.h&gt;</code> 头文件中定义的函数之一，用于获取当前进程的进程 ID（PID）。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><code>getpid()</code> 函数不接受任何参数，直接返回调用进程的进程 ID（PID）。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> process_id = getpid(); <span class="comment">// 获取当前进程的 PID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Current process ID (PID): %d\n&quot;</span>, process_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>getpid()</code> 函数被调用以获取当前进程的 PID，并将其打印输出。通常情况下，每个运行的进程都有一个唯一的 PID，可以用来标识和跟踪进程。</p>
<h2 id="Linux-POSIX-getcwd-详解"><a href="#Linux-POSIX-getcwd-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; getcwd() 详解"></a>Linux POSIX &lt;unistd.h&gt; getcwd() 详解</h2><p>在 POSIX 系统中，<code>getcwd()</code> 是 <code>&lt;unistd.h&gt;</code> 头文件中定义的函数之一，用于获取当前工作目录的路径名。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>buf</code> 是一个字符指针，用于存储当前工作目录的路径名。</li>
<li><code>size</code> 是要存储路径名的缓冲区的大小。</li>
</ul>
<p><code>getcwd()</code> 函数的返回值是一个指向当前工作目录路径名的字符串指针，即 <code>buf</code> 参数的值。如果出现错误，则返回 NULL，并设置 <code>errno</code> 来指示具体的错误类型。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">4096</span>]; <span class="comment">// 缓冲区大小</span></span><br><span class="line">    <span class="type">char</span> *cwd = getcwd(buffer, <span class="keyword">sizeof</span>(buffer)); <span class="comment">// 获取当前工作目录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cwd != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Current working directory: %s\n&quot;</span>, cwd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;getcwd&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>getcwd()</code> 函数被调用以获取当前工作目录的路径名，并将其存储在 <code>buffer</code> 缓冲区中。然后，通过判断返回值是否为 NULL，来输出当前工作目录的路径名。这个函数通常用于获取当前工作目录，以便程序在需要时操作特定的文件或目录。</p>
<h2 id="Linux-POSIX-getuid-详解"><a href="#Linux-POSIX-getuid-详解" class="headerlink" title="Linux POSIX &lt;unistd.h&gt; getuid() 详解"></a>Linux POSIX &lt;unistd.h&gt; getuid() 详解</h2><p>在 POSIX 系统中，<code>getuid()</code> 是 <code>&lt;unistd.h&gt;</code> 头文件中定义的函数之一，用于获取当前进程的实际用户 ID。</p>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><code>getuid()</code> 函数不接受任何参数，直接返回调用进程的实际用户 ID（UID）。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uid_t</span> user_id = getuid(); <span class="comment">// 获取当前进程的实际用户 ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Current user ID: %d\n&quot;</span>, user_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>getuid()</code> 函数被调用以获取当前进程的实际用户 ID，并将其打印输出。实际用户 ID 是唯一标识一个用户的整数值，用于在系统中识别和区分不同的用户。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_6_errno_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_6_errno_h/" class="post-title-link" itemprop="url">C_5_6_errno_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Linux POSIX &lt;errno.h&gt; 详解</li>
</ul>
<h2 id="Linux-POSIX-详解"><a href="#Linux-POSIX-详解" class="headerlink" title="Linux POSIX &lt;errno.h&gt; 详解"></a>Linux POSIX &lt;errno.h&gt; 详解</h2><p>在 Linux POSIX 系统中，<code>&lt;errno.h&gt;</code> 头文件定义了 <code>errno</code>，这是一个特殊的全局变量，用于指示发生错误时的错误码。<code>errno</code> 提供了对发生错误的类型进行识别的机制。</p>
<p>以下是关于 <code>&lt;errno.h&gt;</code> 头文件和 <code>errno</code> 变量的详细解释：</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li><code>&lt;errno.h&gt;</code> 头文件定义了一组可能的错误码，每个错误码对应一个特定的错误情况。</li>
<li>当系统函数或库函数出现错误时，会设置 <code>errno</code> 变量，以表示特定类型的错误。</li>
</ul>
<h3 id="errno-变量"><a href="#errno-变量" class="headerlink" title="errno 变量"></a><code>errno</code> 变量</h3><ul>
<li><code>errno</code> 是一个全局的 <code>int</code> 类型变量，存储了最近一次发生错误的错误码。</li>
<li>错误码的值可以是 POSIX 定义的标准错误码，也可以是特定的系统错误码。</li>
</ul>
<h3 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;nonexistent_file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件，错误码: %d\n&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 perror 打印出错误信息</span></span><br><span class="line">        perror(<span class="string">&quot;fopen() 错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据错误码输出错误信息</span></span><br><span class="line">        <span class="keyword">switch</span> (errno) &#123;</span><br><span class="line">            <span class="keyword">case</span> ENOENT:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;文件不存在\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EACCES:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;权限不足\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;未知错误\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>错误码的值在不同的系统中可能会有所不同，但 POSIX 标准定义了一组常见的错误码，通常在不同的系统中保持一致性。</li>
<li>在检测系统调用或库函数是否失败后，可以通过检查 <code>errno</code> 变量来获取特定的错误码，以便对错误类型进行判断和处理。</li>
</ul>
<p><code>&lt;errno.h&gt;</code> 头文件中的 <code>errno</code> 变量是处理错误的重要机制，可以帮助程序员识别和处理在执行系统调用或库函数时发生的错误。</p>
<h2 id="Linux-POSIX-常用错误码"><a href="#Linux-POSIX-常用错误码" class="headerlink" title="Linux POSIX &lt;errno.h&gt; 常用错误码"></a>Linux POSIX &lt;errno.h&gt; 常用错误码</h2><p>在 Linux POSIX 系统中，<code>&lt;errno.h&gt;</code> 头文件定义了一组常见的错误码，用于标识在系统调用或库函数执行过程中可能发生的各种错误情况。以下是一些常见的错误码及其含义：</p>
<ol>
<li><p>**<code>EACCES</code>**（13）：权限不足，表示访问权限被拒绝。</p>
</li>
<li><p>**<code>EEXIST</code>**（17）：文件已存在，通常用于创建文件时，指定了一个已经存在的文件名。</p>
</li>
<li><p>**<code>EINVAL</code>**（22）：无效的参数，表示传递给函数的参数无效或不合法。</p>
</li>
<li><p>**<code>ENOENT</code>**（2）：文件或目录不存在，用于指示找不到指定的文件或路径。</p>
</li>
<li><p>**<code>ENOMEM</code>**（12）：内存不足，表示没有足够的内存可用。</p>
</li>
<li><p>**<code>ENOSPC</code>**（28）：空间不足，用于指示磁盘空间不足。</p>
</li>
<li><p>**<code>EIO</code>**（5）：输入&#x2F;输出错误，表示发生了与设备或文件系统I&#x2F;O相关的错误。</p>
</li>
<li><p>**<code>EFAULT</code>**（14）：地址错误，表示传递给函数的地址无效。</p>
</li>
<li><p>**<code>EBADF</code>**（9）：无效的文件描述符，用于表示传递给函数的文件描述符无效。</p>
</li>
<li><p>**<code>EPIPE</code>**（32）：管道破裂，表示尝试向一个已关闭的管道写入数据。</p>
</li>
<li><p>**<code>EINTR</code>**（4）：中断的系统调用，表示一个系统调用被中断。</p>
</li>
<li><p>**<code>ETIMEDOUT</code>**（110）：操作超时，指示操作超出了预定的时间限制。</p>
</li>
</ol>
<p>这些错误码代表了可能在程序执行中遇到的常见错误情况。当系统调用或库函数返回一个失败状态时，通过检查 <code>errno</code> 变量并根据相应的错误码进行处理，可以更好地识别和解决程序中的问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_2_dirent_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_2_dirent_h/" class="post-title-link" itemprop="url">C_5_2_dirent_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>&lt;dirent.h&gt;标准头文件</li>
</ul>
<h2 id="Linux-POSIX-详解"><a href="#Linux-POSIX-详解" class="headerlink" title="Linux POSIX &lt;dirent.h&gt; 详解"></a>Linux POSIX &lt;dirent.h&gt; 详解</h2><p>在 POSIX 系统中（如 Linux），<code>&lt;dirent.h&gt;</code> 头文件提供了访问目录及其条目的函数和数据结构，允许程序对目录进行操作，比如遍历目录、读取目录下的文件等。</p>
<p>以下是 <code>&lt;dirent.h&gt;</code> 中常见的一些功能和相关的数据结构：</p>
<ol>
<li><p>**数据结构 <code>struct dirent</code>**：<br><code>struct dirent</code> 是 <code>&lt;dirent.h&gt;</code> 中定义的结构体，用于表示目录中的一个条目（文件或子目录）。它通常包含以下成员：</p>
<ul>
<li><code>ino_t d_ino</code>：表示目录条目的 inode 号。</li>
<li><code>char d_name[]</code>：表示目录条目的名称。</li>
</ul>
</li>
<li><p>**函数 <code>opendir()</code>**：<br><code>opendir()</code> 函数用于打开一个目录，它接收目录路径作为参数，并返回一个指向 <code>DIR</code> 结构的指针。示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DIR *dir = opendir(<span class="string">&quot;/path/to/directory&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**函数 <code>readdir()</code>**：<br><code>readdir()</code> 函数用于读取打开的目录中的条目。它接收 <code>opendir()</code> 返回的 <code>DIR</code> 结构指针作为参数，并返回指向 <code>struct dirent</code> 结构的指针。示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line"><span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, entry-&gt;d_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**函数 <code>closedir()</code>**：<br><code>closedir()</code> 函数用于关闭先前由 <code>opendir()</code> 打开的目录流。示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closedir(dir);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>使用这些函数，你可以在程序中对目录进行操作，例如打开目录、遍历目录中的文件或子目录，读取它们的属性，然后进行相应的操作。这些函数使得在 POSIX 兼容系统上进行文件和目录处理更加方便和灵活。</p>
<h2 id="Linux-POSIX-struct-dirent-详解"><a href="#Linux-POSIX-struct-dirent-详解" class="headerlink" title="Linux POSIX &lt;dirent.h&gt; struct dirent 详解"></a>Linux POSIX &lt;dirent.h&gt; struct dirent 详解</h2><p>在 POSIX 系统中，<code>&lt;dirent.h&gt;</code> 头文件定义了用于访问目录及其条目的函数和数据结构。其中，<code>struct dirent</code> 是该头文件中定义的结构体，用于表示目录中的单个条目（即文件或子目录）的信息。</p>
<p><code>struct dirent</code> 结构体通常包含以下成员：</p>
<ol>
<li><p><code>ino_t d_ino</code>：这是目录项的 inode 号码（在文件系统中唯一标识文件或目录）。使用 inode 号码可以唯一地标识文件系统中的特定文件或目录。</p>
</li>
<li><p><code>off_t d_off</code>：这是目录项在目录中的偏移量，通常在一些特定的文件系统中有用。</p>
</li>
<li><p><code>unsigned short d_reclen</code>：这是目录项的长度。</p>
</li>
<li><p><code>unsigned char d_type</code>：这是目录项的类型。这个成员通常在 POSIX 系统中非标准化，因此在不同系统上可能会有不同的值，表示文件类型（比如普通文件、目录、链接等）。</p>
</li>
<li><p><code>char d_name[]</code>：这是一个字符数组，表示目录项的名称。该数组的大小通常是可变的，因为文件名的长度可能不同。</p>
</li>
</ol>
<p><code>struct dirent</code> 结构体的定义可能会因系统而异，因为不同的操作系统或文件系统可能具有不同的字段或实现。在 POSIX 兼容系统上，通常会使用这个结构体来在程序中读取目录中的条目，并获取每个条目的名称和其他基本信息。</p>
<p>在使用 <code>&lt;dirent.h&gt;</code> 头文件中的函数（如 <code>readdir()</code>）读取目录内容时，通常会创建 <code>struct dirent</code> 类型的变量来存储每个读取到的目录项的信息，然后进一步处理这些信息，比如打印文件名、获取文件属性等操作。</p>
<h2 id="Linux-POSIX-opendir-详解"><a href="#Linux-POSIX-opendir-详解" class="headerlink" title="Linux POSIX &lt;dirent.h&gt; opendir() 详解"></a>Linux POSIX &lt;dirent.h&gt; opendir() 详解</h2><p>在 POSIX 系统中，<code>opendir()</code> 函数是 <code>&lt;dirent.h&gt;</code> 头文件中用于打开目录的函数之一。它允许程序员打开一个目录流，并返回一个指向 <code>DIR</code> 结构的指针，以便后续对该目录进行操作。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dirname)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dirname</code> 是一个字符串，表示目标目录的路径名。函数返回一个指向 <code>DIR</code> 结构的指针，或者在出错时返回 <code>NULL</code>。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    dir = opendir(<span class="string">&quot;/path/to/directory&quot;</span>); <span class="comment">// 打开目录流</span></span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123; <span class="comment">// 读取目录中的条目</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, entry-&gt;d_name); <span class="comment">// 打印条目名称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(dir); <span class="comment">// 关闭目录流</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该示例演示了如何使用 <code>opendir()</code> 打开目录流，然后使用 <code>readdir()</code> 读取目录中的条目，最后使用 <code>closedir()</code> 关闭目录流。在这个例子中，<code>readdir()</code> 用于读取目录中的每个条目，并通过 <code>entry-&gt;d_name</code> 打印出每个条目的名称。</p>
<p>需要注意的是，如果 <code>opendir()</code> 执行成功，它会返回一个指向 <code>DIR</code> 结构的指针，该指针可以用于后续的目录操作。而在出错时，它会返回 <code>NULL</code>，此时可以使用 <code>perror()</code> 或其他错误处理函数来输出错误信息或进行处理。</p>
<h2 id="Linux-POSIX-readdir-详解"><a href="#Linux-POSIX-readdir-详解" class="headerlink" title="Linux POSIX &lt;dirent.h&gt; readdir() 详解"></a>Linux POSIX &lt;dirent.h&gt; readdir() 详解</h2><p>在 POSIX 系统中，<code>readdir()</code> 函数是 <code>&lt;dirent.h&gt;</code> 头文件中用于读取目录中条目的函数之一。它允许程序员逐个读取打开的目录流中的目录项，并返回指向 <code>struct dirent</code> 结构的指针，指向每个目录项的信息。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dir)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dir</code> 是一个指向先前由 <code>opendir()</code> 打开的目录流的指针。函数返回一个指向 <code>struct dirent</code> 结构的指针，或者在读取到目录末尾或出错时返回 <code>NULL</code>。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    dir = opendir(<span class="string">&quot;/path/to/directory&quot;</span>); <span class="comment">// 打开目录流</span></span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((entry = readdir(dir)) != <span class="literal">NULL</span>) &#123; <span class="comment">// 读取目录中的条目</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, entry-&gt;d_name); <span class="comment">// 打印条目名称</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    closedir(dir); <span class="comment">// 关闭目录流</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>readdir()</code> 用于读取目录中的每个条目，并将其存储在类型为 <code>struct dirent</code> 的结构体指针 <code>entry</code> 中。<code>entry-&gt;d_name</code> 包含每个条目的名称，可以用于打印或进一步处理。</p>
<p>循环中的条件 <code>(entry = readdir(dir)) != NULL</code> 表示只要 <code>readdir()</code> 返回的指针不是 <code>NULL</code>，就会继续读取并处理目录中的下一个条目。当读取到目录末尾或出现错误时，<code>readdir()</code> 将返回 <code>NULL</code>，循环结束。</p>
<p>最后，使用 <code>closedir()</code> 函数关闭先前由 <code>opendir()</code> 打开的目录流，释放资源并结束操作。</p>
<p>通过 <code>readdir()</code> 函数，你可以逐个读取目录中的条目，从而获取目录下文件和子目录的信息，并进行相应的处理。</p>
<h2 id="Linux-POSIX-closedir-详解"><a href="#Linux-POSIX-closedir-详解" class="headerlink" title="Linux POSIX &lt;dirent.h&gt; closedir() 详解"></a>Linux POSIX &lt;dirent.h&gt; closedir() 详解</h2><p>在 POSIX 系统中，<code>closedir()</code> 函数是 <code>&lt;dirent.h&gt;</code> 头文件中用于关闭先前打开的目录流的函数。它用于释放由 <code>opendir()</code> 打开的目录流所占用的资源，并清理相关的内存，以防止资源泄漏。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dir)</span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>dir</code> 是一个指向先前由 <code>opendir()</code> 打开的目录流的指针。函数返回整型值，通常在成功关闭目录流时返回 0，出错时返回 -1。</p>
<p>示例用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    DIR *dir;</span><br><span class="line"></span><br><span class="line">    dir = opendir(<span class="string">&quot;/path/to/directory&quot;</span>); <span class="comment">// 打开目录流</span></span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对目录进行操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (closedir(dir) == <span class="number">-1</span>) &#123; <span class="comment">// 关闭目录流</span></span><br><span class="line">        perror(<span class="string">&quot;closedir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>closedir()</code> 函数用于关闭先前由 <code>opendir()</code> 打开的目录流 <code>dir</code>。它应该在对目录进行操作后使用，以释放相关资源。</p>
<p>如果成功关闭目录流，<code>closedir()</code> 返回 0。如果出现错误，它会返回 -1，并且你可以使用 <code>perror()</code> 或其他错误处理方法来输出错误信息。</p>
<p>使用 <code>closedir()</code> 是一个良好的编程实践，以确保在不再需要目录流时正确释放相关资源，避免资源泄漏和其他问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_5_stdio_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_5_stdio_h/" class="post-title-link" itemprop="url">C_5_5_stdio_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>&lt;stdio.h&gt;标准头文件</li>
</ul>
<h2 id="Linux-POSIX-详解"><a href="#Linux-POSIX-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; 详解"></a>Linux POSIX &lt;stdio.h&gt; 详解</h2><p><code>&lt;stdio.h&gt;</code> 是 C 标准库的头文件之一，在 Linux POSIX 系统中提供了对标准输入和输出的支持。</p>
<h3 id="主要功能和常见函数："><a href="#主要功能和常见函数：" class="headerlink" title="主要功能和常见函数："></a>主要功能和常见函数：</h3><ol>
<li><p><strong>标准输入输出函数</strong>：</p>
<ul>
<li><code>printf()</code>：用于将格式化数据打印到标准输出（终端）。</li>
<li><code>scanf()</code>：用于从标准输入（键盘）读取格式化的数据。</li>
<li><code>fprintf()</code>：将格式化数据打印到指定文件流中。</li>
<li><code>fscanf()</code>：从指定文件流中读取格式化的数据。</li>
<li><code>getchar()</code>：从标准输入中读取一个字符。</li>
<li><code>putchar()</code>：将一个字符输出到标准输出。</li>
</ul>
</li>
<li><p><strong>文件操作函数</strong>：</p>
<ul>
<li><code>fopen()</code>：打开文件并返回文件指针。</li>
<li><code>fclose()</code>：关闭文件。</li>
<li><code>fgets()</code>：从文件中读取一行数据。</li>
<li><code>fputs()</code>：将字符串写入文件。</li>
<li><code>fgetc()</code> 和 <code>fputc()</code>：用于读取和写入单个字符到文件。</li>
<li><code>feof()</code> 和 <code>ferror()</code>：检查文件结束和错误标志。</li>
</ul>
</li>
<li><p><strong>文件定位函数</strong>：</p>
<ul>
<li><code>fseek()</code> 和 <code>ftell()</code>：用于在文件中定位和获取当前位置。</li>
</ul>
</li>
<li><p><strong>格式化输出函数</strong>：</p>
<ul>
<li><code>sprintf()</code>：将格式化的数据写入字符串中。</li>
<li><code>snprintf()</code>：类似于 <code>sprintf()</code>，但提供了字符数限制，避免缓冲区溢出。</li>
</ul>
</li>
<li><p><strong>标准流</strong>：</p>
<ul>
<li><code>stdin</code>：标准输入流，通常代表键盘输入。</li>
<li><code>stdout</code>：标准输出流，通常代表终端输出。</li>
<li><code>stderr</code>：标准错误流，通常用于输出错误消息。</li>
</ul>
</li>
<li><p><strong>宏定义</strong>：</p>
<ul>
<li><code>EOF</code>：表示文件结束。</li>
<li><code>NULL</code>：表示空指针。</li>
</ul>
</li>
</ol>
<h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(file, <span class="string">&quot;这是一个示例文件\n&quot;</span>);</span><br><span class="line">        fclose(file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取文件内容：\n&quot;</span>);</span><br><span class="line">    FILE *fileRead = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fileRead != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), fileRead) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fileRead);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>&lt;stdio.h&gt;</code> 中的函数进行文件的写入和读取操作。其中，<code>fopen()</code> 用于打开文件，<code>fprintf()</code> 用于将内容写入文件，<code>fgets()</code> 用于从文件中读取内容并打印到控制台上。</p>
<h2 id="Linux-POSIX-printf-详解"><a href="#Linux-POSIX-printf-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; printf() 详解"></a>Linux POSIX &lt;stdio.h&gt; printf() 详解</h2><p><code>&lt;stdio.h&gt;</code> 是 C 语言中的一个头文件，用于提供标准输入输出功能。其中的 <code>printf()</code> 函数是用于格式化输出的一个重要函数。</p>
<h3 id="printf-函数"><a href="#printf-函数" class="headerlink" title="printf() 函数"></a><code>printf()</code> 函数</h3><p><code>printf()</code> 用于将格式化的数据输出到标准输出（通常是控制台），其功能是“打印格式化的内容”，可以按指定格式在屏幕上显示信息。</p>
<h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>format</code>**：一个字符串，用于指定输出的格式，可以包含普通字符（按原样输出）和格式说明符。</li>
<li>**<code>...</code>**：额外的参数（可选），对应于 <code>format</code> 字符串中的格式说明符。</li>
</ul>
<h4 id="格式说明符："><a href="#格式说明符：" class="headerlink" title="格式说明符："></a>格式说明符：</h4><p><code>format</code> 字符串中的格式说明符以百分号 <code>%</code> 开始，后跟一个表示要打印数据类型的字符。</p>
<p>常见的格式说明符包括：</p>
<ul>
<li><code>%d</code>：整数</li>
<li><code>%f</code>：浮点数</li>
<li><code>%c</code>：字符</li>
<li><code>%s</code>：字符串</li>
<li><code>%p</code>：指针地址</li>
<li><code>%x</code>、<code>%X</code>：十六进制整数</li>
<li><code>%o</code>：八进制整数</li>
<li><code>%u</code>：无符号整数</li>
</ul>
<h4 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">float</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;整数：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;浮点数：%f\n&quot;</span>, pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符：%c\n&quot;</span>, ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串：%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><ul>
<li><code>%d</code>、<code>%f</code>、<code>%c</code>、<code>%s</code> 是用于打印不同数据类型变量的格式说明符。</li>
<li>每个 <code>printf()</code> 调用中，格式说明符会被对应的变量值替换，作为额外的参数提供给 <code>printf()</code> 函数。</li>
</ul>
<h4 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h4><ul>
<li><code>printf()</code> 返回打印的字符数（不包括用于结束字符串输出的空字节）。如果发生错误，它将返回负值。</li>
</ul>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul>
<li><code>printf()</code> 函数在格式化输出方面非常强大和灵活，允许精确控制数据的显示方式。</li>
<li>如果格式说明符使用不正确，可能会导致未定义的行为或错误，如打印错误的值或使程序崩溃。</li>
</ul>
<h2 id="Linux-POSIX-scanf-详解"><a href="#Linux-POSIX-scanf-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; scanf() 详解"></a>Linux POSIX &lt;stdio.h&gt; scanf() 详解</h2><p><code>&lt;stdio.h&gt;</code> 是 C 语言中的一个头文件，提供了输入输出操作的函数和宏。<code>scanf()</code> 是其中用于输入的函数之一。</p>
<h3 id="scanf-函数"><a href="#scanf-函数" class="headerlink" title="scanf() 函数"></a><code>scanf()</code> 函数</h3><p><code>scanf()</code> 函数用于从标准输入（通常是键盘）获取输入，并根据指定的格式将数据存储到指定的变量中。</p>
<h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>format</code>**：包含格式说明符的字符串，用于指定输入的格式。</li>
<li>**<code>...</code>**：用于接收输入数据的变量列表，按照 <code>format</code> 字符串中的格式进行匹配。</li>
</ul>
<h4 id="格式说明符：-1"><a href="#格式说明符：-1" class="headerlink" title="格式说明符："></a>格式说明符：</h4><p>格式说明符在 <code>format</code> 字符串中，用于指定输入的数据类型。</p>
<p>常见的格式说明符与 <code>printf()</code> 相似，包括：</p>
<ul>
<li><code>%d</code>：整数</li>
<li><code>%f</code>：浮点数</li>
<li><code>%c</code>：字符</li>
<li><code>%s</code>：字符串</li>
<li><code>%p</code>：指针地址</li>
<li><code>%x</code>、<code>%X</code>：十六进制整数</li>
<li><code>%o</code>：八进制整数</li>
<li><code>%u</code>：无符号整数</li>
</ul>
<h4 id="示例用法：-1"><a href="#示例用法：-1" class="headerlink" title="示例用法："></a>示例用法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">float</span> pi;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个浮点数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;pi);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个字符：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;ch);  <span class="comment">// 注意空格，避免读取上一个输入后的回车符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您输入的整数是：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您输入的浮点数是：%f\n&quot;</span>, pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您输入的字符是：%c\n&quot;</span>, ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您输入的字符串是：%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a>解释：</h4><ul>
<li><code>scanf()</code> 函数按照指定的格式说明符从标准输入中读取输入，并将输入的数据存储到相应的变量中。</li>
<li>格式说明符 <code>%d</code>、<code>%f</code>、<code>%c</code>、<code>%s</code> 分别用于读取不同类型的数据。</li>
<li><code>&amp;</code> 运算符用于传递变量的地址，使得 <code>scanf()</code> 函数可以将输入的值存储到相应变量的内存位置中。</li>
</ul>
<h4 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h4><ul>
<li><code>scanf()</code> 返回成功读取的参数数目。如果发生读取失败或到达文件结束，则返回值可能会少于指定的参数数目。</li>
</ul>
<h3 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h3><ul>
<li>使用 <code>scanf()</code> 时要确保提供正确的格式说明符，否则可能导致输入解析错误或意外行为。</li>
<li>对于字符串 <code>%s</code>，它会在空白字符（如空格、制表符、换行符等）处停止读取，可以使用其他函数（如 <code>fgets()</code>）更安全地读取一行字符串。</li>
</ul>
<p>使用 <code>scanf()</code> 需要谨慎，确保输入与格式匹配，以避免潜在的问题。</p>
<h2 id="Linux-POSIX-fprintf-详解"><a href="#Linux-POSIX-fprintf-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fprintf() 详解"></a>Linux POSIX &lt;stdio.h&gt; fprintf() 详解</h2><p><code>&lt;stdio.h&gt;</code> 中的 <code>fprintf()</code> 函数与 <code>printf()</code> 函数类似，但不是将输出发送到标准输出（通常是屏幕），而是将格式化的输出发送到指定的文件流中。这允许将格式化的数据写入文件而不是控制台。</p>
<h3 id="fprintf-函数"><a href="#fprintf-函数" class="headerlink" title="fprintf() 函数"></a><code>fprintf()</code> 函数</h3><h4 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>stream</code>**：指向文件的指针，表示要写入的文件流。</li>
<li>**<code>format</code>**：一个字符串，用于指定输出的格式，可以包含普通字符和格式说明符。</li>
<li>**<code>...</code>**：额外的参数（可选），对应于 <code>format</code> 字符串中的格式说明符。</li>
</ul>
<h4 id="格式说明符和用法与-printf-相同。"><a href="#格式说明符和用法与-printf-相同。" class="headerlink" title="格式说明符和用法与 printf() 相同。"></a>格式说明符和用法与 <code>printf()</code> 相同。</h4><h4 id="示例用法：-2"><a href="#示例用法：-2" class="headerlink" title="示例用法："></a>示例用法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *filePointer;</span><br><span class="line">    <span class="type">char</span> data[] = <span class="string">&quot;Hello, File I/O!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    filePointer = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>); <span class="comment">// 打开文件以写入模式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filePointer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(filePointer, <span class="string">&quot;这是 fprintf() 写入的内容：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(filePointer, <span class="string">&quot;字符串：%s\n&quot;</span>, data);</span><br><span class="line">    <span class="built_in">fprintf</span>(filePointer, <span class="string">&quot;整数：%d\n&quot;</span>, <span class="number">12345</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(filePointer, <span class="string">&quot;浮点数：%f\n&quot;</span>, <span class="number">3.14159</span>);</span><br><span class="line"></span><br><span class="line">    fclose(filePointer); <span class="comment">// 关闭文件流</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据已写入文件\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解释：-2"><a href="#解释：-2" class="headerlink" title="解释："></a>解释：</h4><ul>
<li><code>fprintf()</code> 将格式化的输出写入指定的文件流（在此示例中是名为 “output.txt” 的文件）。</li>
<li>使用 <code>fopen()</code> 函数打开文件，指定 “w”（写入）模式。</li>
<li>检查文件指针是否为 <code>NULL</code>，以确保文件成功打开。</li>
<li>然后，<code>fprintf()</code> 将数据写入文件，格式与 <code>printf()</code> 相同。</li>
<li>使用 <code>fclose()</code> 关闭文件流。</li>
</ul>
<h4 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h4><ul>
<li><code>fprintf()</code> 返回写入文件的字符数。如果发生错误，则返回负值。</li>
</ul>
<h3 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h3><ul>
<li>使用 <code>fprintf()</code> 时要确保提供正确的文件指针以及正确的格式说明符，否则可能导致写入文件错误或意外结果。</li>
<li>在完成对文件的操作后，务必关闭文件流以释放资源。</li>
</ul>
<p><code>fprintf()</code> 提供了一种将格式化数据写入文件的方法，可以根据需要指定不同的文件流，并将数据写入文件而不是标准输出。</p>
<h2 id="Linux-POSIX-fscanf-详解"><a href="#Linux-POSIX-fscanf-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fscanf() 详解"></a>Linux POSIX &lt;stdio.h&gt; fscanf() 详解</h2><p><code>&lt;stdio.h&gt;</code> 中的 <code>fscanf()</code> 函数与 <code>scanf()</code> 函数类似，但它从指定的文件流中读取格式化的输入，而不是从标准输入（键盘）中读取输入。</p>
<h3 id="fscanf-函数"><a href="#fscanf-函数" class="headerlink" title="fscanf() 函数"></a><code>fscanf()</code> 函数</h3><h4 id="语法：-3"><a href="#语法：-3" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>stream</code>**：指向文件的指针，表示要从中读取数据的文件流。</li>
<li>**<code>format</code>**：包含格式说明符的字符串，用于指定输入的格式。</li>
<li>**<code>...</code>**：用于接收读取数据的变量列表，按照 <code>format</code> 字符串中的格式进行匹配。</li>
</ul>
<h4 id="格式说明符和用法与-scanf-相同。"><a href="#格式说明符和用法与-scanf-相同。" class="headerlink" title="格式说明符和用法与 scanf() 相同。"></a>格式说明符和用法与 <code>scanf()</code> 相同。</h4><h4 id="示例用法：-3"><a href="#示例用法：-3" class="headerlink" title="示例用法："></a>示例用法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *filePointer;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">float</span> pi;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    filePointer = fopen(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="comment">// 以读取模式打开文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filePointer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fscanf</span>(filePointer, <span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="built_in">fscanf</span>(filePointer, <span class="string">&quot;%f&quot;</span>, &amp;pi);</span><br><span class="line">    <span class="built_in">fscanf</span>(filePointer, <span class="string">&quot; %c&quot;</span>, &amp;ch); <span class="comment">// 注意空格，避免读取上一个输入后的回车符</span></span><br><span class="line">    <span class="built_in">fscanf</span>(filePointer, <span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从文件中读取的整数是：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从文件中读取的浮点数是：%f\n&quot;</span>, pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从文件中读取的字符是：%c\n&quot;</span>, ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从文件中读取的字符串是：%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    fclose(filePointer); <span class="comment">// 关闭文件流</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解释：-3"><a href="#解释：-3" class="headerlink" title="解释："></a>解释：</h4><ul>
<li><code>fscanf()</code> 函数按照指定的格式说明符从指定文件流中读取输入，并将数据存储到相应的变量中。</li>
<li>使用 <code>fopen()</code> 函数以 “r”（读取）模式打开文件流。</li>
<li>检查文件指针是否为 <code>NULL</code>，以确保文件成功打开。</li>
<li>然后，<code>fscanf()</code> 从文件中读取数据，格式与 <code>scanf()</code> 相同。</li>
<li>最后，使用 <code>fclose()</code> 关闭文件流。</li>
</ul>
<h4 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a>返回值：</h4><ul>
<li><code>fscanf()</code> 返回成功读取的参数数目。如果发生读取失败或到达文件结束，则返回值可能会少于指定的参数数目。</li>
</ul>
<h3 id="注意：-3"><a href="#注意：-3" class="headerlink" title="注意："></a>注意：</h3><ul>
<li>使用 <code>fscanf()</code> 时要确保提供正确的文件指针以及正确的格式说明符，否则可能导致读取文件错误或意外结果。</li>
<li>在完成对文件的操作后，务必关闭文件流以释放资源。</li>
</ul>
<p><code>fscanf()</code> 提供了一种从文件流中读取格式化数据的方法，可以根据需要从不同的文件流读取数据而不是标准输入。</p>
<h2 id="Linux-POSIX-getchar-详解"><a href="#Linux-POSIX-getchar-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; getchar() 详解"></a>Linux POSIX &lt;stdio.h&gt; getchar() 详解</h2><p><code>getchar()</code> 是 <code>&lt;stdio.h&gt;</code> 头文件中的函数，用于从标准输入（通常是键盘）获取一个字符。</p>
<h3 id="getchar-函数"><a href="#getchar-函数" class="headerlink" title="getchar() 函数"></a><code>getchar()</code> 函数</h3><h4 id="语法：-4"><a href="#语法：-4" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>无参数</strong>：<code>getchar()</code> 不接受任何参数。</li>
<li><strong>返回值</strong>：返回一个整数值，表示获取的字符的 ASCII 值（或者在遇到文件结束或错误时返回特殊值 <code>EOF</code>）。</li>
</ul>
<h4 id="示例用法：-4"><a href="#示例用法：-4" class="headerlink" title="示例用法："></a>示例用法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个字符：\n&quot;</span>);</span><br><span class="line">    ch = getchar();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您输入的字符是：%c\n&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解释：-4"><a href="#解释：-4" class="headerlink" title="解释："></a>解释：</h4><ul>
<li><code>getchar()</code> 函数用于从标准输入中获取一个字符，并将其作为整数返回。</li>
<li><code>getchar()</code> 在用户输入一个字符后，程序会等待用户按下回车键以表示输入完成，然后才会返回该字符的 ASCII 值。</li>
</ul>
<h4 id="返回值：-4"><a href="#返回值：-4" class="headerlink" title="返回值："></a>返回值：</h4><ul>
<li>如果成功获取字符，则返回该字符的 ASCII 值（0 到 255 之间的整数）。</li>
<li>如果在获取字符时出现错误或者达到文件结束（End of File，EOF），则返回特殊值 <code>EOF</code>（一般为 <code>-1</code>）。</li>
</ul>
<h3 id="注意：-4"><a href="#注意：-4" class="headerlink" title="注意："></a>注意：</h3><ul>
<li><code>getchar()</code> 函数每次只能获取一个字符，即使用户输入多个字符也只返回第一个字符的 ASCII 值。</li>
<li>在需要连续获取多个字符的情况下，通常需要循环调用 <code>getchar()</code>。</li>
</ul>
<p><code>getchar()</code> 是一个简单且常用的函数，适用于获取单个字符的输入。如果需要读取整行文本或者处理大量输入，可能需要考虑其他输入函数或循环来获取和处理数据。</p>
<h2 id="Linux-POSIX-putchar-详解"><a href="#Linux-POSIX-putchar-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; putchar() 详解"></a>Linux POSIX &lt;stdio.h&gt; putchar() 详解</h2><p><code>putchar()</code> 是 C 标准库 <code>&lt;stdio.h&gt;</code> 中的函数，用于将一个字符输出到标准输出设备（通常是屏幕）。</p>
<h3 id="putchar-函数"><a href="#putchar-函数" class="headerlink" title="putchar() 函数"></a><code>putchar()</code> 函数</h3><h4 id="语法：-5"><a href="#语法：-5" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> character)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>character</code>**：要输出的字符，以整数形式传递（ASCII 值）。</li>
<li><strong>返回值</strong>：如果成功输出字符，则返回输出的字符（<code>character</code> 参数的值）。如果发生错误，返回特殊值 <code>EOF</code>。</li>
</ul>
<h4 id="示例用法：-5"><a href="#示例用法：-5" class="headerlink" title="示例用法："></a>示例用法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输出一个字符：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解释：-5"><a href="#解释：-5" class="headerlink" title="解释："></a>解释：</h4><ul>
<li><code>putchar()</code> 函数用于将指定的字符输出到标准输出设备（通常是屏幕）上。</li>
<li>在示例中，<code>putchar(ch)</code> 将字符 <code>&#39;A&#39;</code>（ASCII 值为 65）输出到屏幕上。</li>
</ul>
<h4 id="返回值：-5"><a href="#返回值：-5" class="headerlink" title="返回值："></a>返回值：</h4><ul>
<li>如果成功输出字符，则返回输出的字符的 ASCII 值（即 <code>character</code> 参数的值）。</li>
<li>如果发生错误，返回特殊值 <code>EOF</code>（一般为 <code>-1</code>）。</li>
</ul>
<h3 id="注意：-5"><a href="#注意：-5" class="headerlink" title="注意："></a>注意：</h3><ul>
<li><code>putchar()</code> 函数每次只能输出一个字符。</li>
<li>如果需要输出多个字符，通常需要循环调用 <code>putchar()</code> 或者结合使用其他输出函数进行输出。</li>
</ul>
<p><code>putchar()</code> 是一个简单且常用的函数，用于将单个字符输出到标准输出设备。如果需要输出整个字符串或进行大量输出，可能需要考虑其他输出函数或循环来实现。</p>
<h2 id="Linux-POSIX-fopen-详解"><a href="#Linux-POSIX-fopen-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fopen() 详解"></a>Linux POSIX &lt;stdio.h&gt; fopen() 详解</h2><p>在 POSIX 标准中，<code>&lt;stdio.h&gt;</code> 头文件提供了处理文件输入输出的函数和宏定义。其中之一是 <code>fopen()</code> 函数，用于打开文件并返回一个文件指针，可以在文件中执行读取或写入操作。</p>
<p>以下是关于 <code>fopen()</code> 函数的详细解释：</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>filename</code>：要打开的文件的路径和名称。</li>
<li><code>mode</code>：文件打开模式，定义了文件如何被打开。模式字符串包括：<ul>
<li><code>&quot;r&quot;</code>：只读模式，文件必须存在，从文件的开头开始。</li>
<li><code>&quot;w&quot;</code>：写入模式，如果文件不存在则创建，如果文件已存在则截断为零长度，从文件的开头开始。</li>
<li><code>&quot;a&quot;</code>：追加模式，如果文件不存在则创建，从文件末尾开始写入。</li>
<li><code>&quot;r+&quot;</code>：读写模式，文件必须存在，从文件的开头开始。</li>
<li><code>&quot;w+&quot;</code>：读写模式，如果文件不存在则创建，如果文件已存在则截断为零长度，从文件的开头开始。</li>
<li><code>&quot;a+&quot;</code>：读写模式，如果文件不存在则创建，从文件末尾开始写入。</li>
</ul>
</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>fopen()</code> 函数返回一个指向 <code>FILE</code> 结构的指针，如果文件打开成功，则返回指向文件的指针。如果打开失败，则返回 <code>NULL</code>。</li>
</ul>
<h3 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); <span class="comment">// 以只读模式打开文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 对文件执行读取或其他操作</span></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>在使用 <code>fopen()</code> 函数后，始终应该检查返回的文件指针是否为 <code>NULL</code>，以确保文件是否成功打开。</li>
<li>打开文件后，使用完毕应该使用 <code>fclose()</code> 函数关闭文件，以释放资源并确保写入缓冲区的数据被刷新到文件中。</li>
<li>在使用文件操作相关函数时，应该检查每个函数的返回值以确保操作成功。</li>
</ul>
<p><code>fopen()</code> 是处理文件输入输出中常用的函数之一，使用正确的打开模式并检查返回值是确保文件操作正确执行的重要步骤。</p>
<h2 id="Linux-POSIX-fclose-详解"><a href="#Linux-POSIX-fclose-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fclose() 详解"></a>Linux POSIX &lt;stdio.h&gt; fclose() 详解</h2><p>在 Linux POSIX 系统中，<code>&lt;stdio.h&gt;</code> 头文件提供了许多用于文件操作的函数。<code>fclose()</code> 是其中一个函数，用于关闭先前使用 <code>fopen()</code> 打开的文件流。这个函数的作用是关闭指定文件流，并确保在关闭文件之前将所有的缓冲区数据刷新到文件中。</p>
<p>以下是关于 <code>fclose()</code> 函数的详细解释：</p>
<h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，它标识了要关闭的文件流。</li>
</ul>
<h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>fclose()</code> 函数返回整型值。若关闭成功，则返回 <code>0</code>；若出现错误，则返回 <code>EOF</code>。</li>
</ul>
<h3 id="示例用法-1"><a href="#示例用法-1" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 对文件执行读取或其他操作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fclose(file) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;文件关闭成功\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;文件关闭失败\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>fclose()</code> 函数关闭文件后，应该确保不再对该文件执行读取或写入操作，否则可能会导致未定义的行为。</li>
<li>关闭文件时，系统会清理所有与该文件相关的资源，并将缓冲区的数据刷新到磁盘中。因此，关闭文件是一个重要的操作，以确保数据完整性和释放资源。</li>
</ul>
<p><code>fclose()</code> 函数是在文件操作中非常重要的一个函数，用于安全地关闭文件流并清理相应的资源。使用时，应该注意检查其返回值，确保文件被成功关闭。</p>
<h2 id="Linux-POSIX-fgets-详解"><a href="#Linux-POSIX-fgets-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fgets() 详解"></a>Linux POSIX &lt;stdio.h&gt; fgets() 详解</h2><p>在 POSIX 标准的 <code>&lt;stdio.h&gt;</code> 头文件中，<code>fgets()</code> 是用于从文件中读取一行数据的函数。它可以读取指定长度的字符或直到遇到换行符（<code>\n</code>）为止，并将结果存储到一个字符串缓冲区中。</p>
<p>以下是关于 <code>fgets()</code> 函数的详细解释：</p>
<h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> size, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>str</code>：指向字符数组的指针，用于存储读取的字符串数据。</li>
<li><code>size</code>：要读取的最大字符数（包括结尾的空字符 ‘\0’）。</li>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，表示要读取的文件流。</li>
</ul>
<h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>fgets()</code> 函数返回一个指向存储读取的字符串的指针，如果读取成功，则返回 <code>str</code>；如果达到文件尾或发生错误，则返回 <code>NULL</code>。</li>
</ul>
<h3 id="示例用法-2"><a href="#示例用法-2" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>]; <span class="comment">// 定义一个缓冲区来存储读取的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取文件中的一行数据</span></span><br><span class="line">        <span class="keyword">while</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), file) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;读取的内容：%s&quot;</span>, buffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>fgets()</code> 函数从文件中读取一行文本数据，并在读取的数据中保留换行符（如果存在的话）。如果一行数据超过了指定的 <code>size - 1</code> 大小，则只会读取部分数据，剩余部分会在下一次读取时继续获取。</li>
<li>使用 <code>fgets()</code> 时应该检查返回值是否为 <code>NULL</code>，以便判断是否读取到文件末尾或发生错误。</li>
</ul>
<p><code>fgets()</code> 函数在从文件中逐行读取数据时非常有用，特别是对于文本文件的处理。它允许你逐行读取文件内容并对每一行进行处理。</p>
<h2 id="Linux-POSIX-fputs-详解"><a href="#Linux-POSIX-fputs-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fputs() 详解"></a>Linux POSIX &lt;stdio.h&gt; fputs() 详解</h2><p>在 POSIX 标准的 <code>&lt;stdio.h&gt;</code> 头文件中，<code>fputs()</code> 是用于向文件写入字符串的函数。它将字符串写入到指定的文件流中，不包括字符串结尾的空字符 (‘\0’)。</p>
<p>以下是关于 <code>fputs()</code> 函数的详细解释：</p>
<h3 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>str</code>：要写入的字符串，以 null 结尾。</li>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，表示要写入的文件流。</li>
</ul>
<h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>fputs()</code> 函数返回一个非负整数值来表示成功写入的字符数。如果发生错误，则返回 <code>EOF</code>。</li>
</ul>
<h3 id="示例用法-3"><a href="#示例用法-3" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入字符串到文件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fputs</span>(<span class="string">&quot;Hello, fputs!\n&quot;</span>, file) != EOF) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;字符串写入成功\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;字符串写入失败\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>fputs()</code> 函数写入字符串时，不会自动添加换行符。如果需要换行，需要在字符串中包含 <code>\n</code>。</li>
<li>需要检查 <code>fputs()</code> 的返回值，以确保写入操作成功完成。返回值为 <code>EOF</code> 表示写入发生错误。</li>
</ul>
<p><code>fputs()</code> 函数是一个常用的文件操作函数，用于将字符串写入到指定的文件中。在使用时应该注意检查返回值，确保写入操作成功。</p>
<h2 id="Linux-POSIX-fgetc-详解"><a href="#Linux-POSIX-fgetc-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fgetc() 详解"></a>Linux POSIX &lt;stdio.h&gt; fgetc() 详解</h2><p>在 Linux POSIX 标准的 <code>&lt;stdio.h&gt;</code> 头文件中，<code>fgetc()</code> 函数用于从指定文件流中读取一个字符。它可以逐个字符地读取文件内容。</p>
<p>以下是关于 <code>fgetc()</code> 函数的详细解释：</p>
<h3 id="函数原型-4"><a href="#函数原型-4" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，表示要读取的文件流。</li>
</ul>
<h3 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>fgetc()</code> 函数返回一个整型值，即所读取的字符的 ASCII 值。如果到达文件结尾或发生错误，则返回 <code>EOF</code>（End of File）。</li>
</ul>
<h3 id="示例用法-4"><a href="#示例用法-4" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">int</span> character;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐字符读取文件内容</span></span><br><span class="line">        <span class="keyword">while</span> ((character = fgetc(file)) != EOF) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, character); <span class="comment">// 打印所读取的字符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>fgetc()</code> 函数逐个字符地读取文件内容时，返回值是一个整数（ASCII 值），需要将其转换为字符或进行相应的处理。</li>
<li>在使用文件流的读取函数时，应该检查返回值是否为 <code>EOF</code>，以判断是否到达文件结尾或发生了错误。</li>
</ul>
<p><code>fgetc()</code> 函数允许你逐个字符地读取文件内容，适用于需要对文件内容逐个字符进行处理的场景。在读取文件时要确保文件能够成功打开，并在读取过程中对返回值进行适当的检查。</p>
<h2 id="Linux-POSIX-fputc-详解"><a href="#Linux-POSIX-fputc-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fputc() 详解"></a>Linux POSIX &lt;stdio.h&gt; fputc() 详解</h2><p>在 Linux POSIX 标准的 <code>&lt;stdio.h&gt;</code> 头文件中，<code>fputc()</code> 函数用于将一个字符写入到指定的文件流中。</p>
<p>以下是关于 <code>fputc()</code> 函数的详细解释：</p>
<h3 id="函数原型-5"><a href="#函数原型-5" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>c</code>：要写入的字符，以整数形式传入，会被转换为相应的字符。</li>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，表示要写入的文件流。</li>
</ul>
<h3 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>fputc()</code> 函数返回写入的字符，如果写入成功，则返回写入的字符；如果出现错误，则返回 <code>EOF</code>。</li>
</ul>
<h3 id="示例用法-5"><a href="#示例用法-5" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入字符到文件</span></span><br><span class="line">        <span class="keyword">if</span> (fputc(<span class="string">&#x27;A&#x27;</span>, file) != EOF) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;字符写入成功\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;字符写入失败\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>fputc()</code> 函数写入字符时，会将整数参数 <code>c</code> 转换为相应的字符写入到文件中。</li>
<li>需要检查 <code>fputc()</code> 的返回值，以确保写入操作成功完成。返回值为 <code>EOF</code> 表示写入发生错误。</li>
</ul>
<p><code>fputc()</code> 函数用于将单个字符写入到文件中。在使用时应该注意检查返回值，确保写入操作成功。</p>
<h2 id="Linux-POSIX-feof-详解"><a href="#Linux-POSIX-feof-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; feof() 详解"></a>Linux POSIX &lt;stdio.h&gt; feof() 详解</h2><p>在 Linux POSIX 中，<code>&lt;stdio.h&gt;</code> 头文件中的 <code>feof()</code> 函数用于检查文件流的结束标志（End-of-File）。这个函数允许你判断文件指针当前是否位于文件结束位置。</p>
<p>以下是关于 <code>feof()</code> 函数的详细解释：</p>
<h3 id="函数原型-6"><a href="#函数原型-6" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，表示要检查的文件流。</li>
</ul>
<h3 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>feof()</code> 函数返回一个非零值（通常是整数1），表示已经到达文件的结束位置（End-of-File）。如果未到达文件结尾，则返回0。</li>
</ul>
<h3 id="示例用法-6"><a href="#示例用法-6" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取文件内容</span></span><br><span class="line">        <span class="type">int</span> character;</span><br><span class="line">        <span class="keyword">while</span> ((character = fgetc(file)) != EOF) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, character); <span class="comment">// 输出读取的字符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否到达文件结尾</span></span><br><span class="line">        <span class="keyword">if</span> (feof(file)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n已到达文件结尾\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n未到达文件结尾\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>feof()</code> 函数并不会主动读取文件流，它只是返回文件流的结束标志状态。</li>
<li>通常在读取文件时，读取循环结束后可以使用 <code>feof()</code> 函数来检查文件是否已经读取到了结束位置。</li>
</ul>
<p><code>feof()</code> 函数是一个用于检查文件流状态的工具，特别适用于循环读取文件并在文件末尾做出相应处理的情况。在使用时应该了解其返回值的含义，以正确判断文件的结束状态。</p>
<h2 id="Linux-POSIX-ferror-详解"><a href="#Linux-POSIX-ferror-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; ferror() 详解"></a>Linux POSIX &lt;stdio.h&gt; ferror() 详解</h2><p>在 Linux POSIX 中，<code>&lt;stdio.h&gt;</code> 头文件中的 <code>ferror()</code> 函数用于检查文件流的错误标志。这个函数允许你判断文件指针相关的错误状态。</p>
<p>以下是关于 <code>ferror()</code> 函数的详细解释：</p>
<h3 id="函数原型-7"><a href="#函数原型-7" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，表示要检查的文件流。</li>
</ul>
<h3 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>ferror()</code> 函数返回一个非零值（通常是整数1），表示指定的文件流上发生了错误。如果没有发生错误，则返回0。</li>
</ul>
<h3 id="示例用法-7"><a href="#示例用法-7" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取文件内容</span></span><br><span class="line">        <span class="type">int</span> character;</span><br><span class="line">        <span class="keyword">while</span> ((character = fgetc(file)) != EOF) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, character); <span class="comment">// 输出读取的字符</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查文件流是否发生错误</span></span><br><span class="line">        <span class="keyword">if</span> (ferror(file)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n发生了文件流错误\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n文件流无错误\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>ferror()</code> 函数用于检查文件流的错误状态，通常在读写文件时进行检查，以确保文件操作没有发生意外的错误。</li>
<li>如果在文件流上发生了错误，<code>ferror()</code> 将返回非零值。这可能是由于设备错误、磁盘空间不足、权限问题等引起的文件流错误。</li>
</ul>
<p><code>ferror()</code> 函数是用于检查文件流错误状态的工具。在进行文件操作时，特别是在读写文件的过程中，建议在适当的位置使用 <code>ferror()</code> 来检查文件流是否发生了错误。</p>
<h2 id="Linux-POSIX-fseek-详解"><a href="#Linux-POSIX-fseek-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; fseek() 详解"></a>Linux POSIX &lt;stdio.h&gt; fseek() 详解</h2><p>在 Linux POSIX 中，<code>&lt;stdio.h&gt;</code> 头文件中的 <code>fseek()</code> 函数用于设置文件流的位置指针。这个函数可以在文件中移动文件位置指针，以便进行读写文件的操作。</p>
<p>以下是关于 <code>fseek()</code> 函数的详细解释：</p>
<h3 id="函数原型-8"><a href="#函数原型-8" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，表示要设置位置的文件流。</li>
<li><code>offset</code>：表示偏移量，即要移动的字节数，可以为正数、负数或零。</li>
<li><code>whence</code>：表示起始点，可以取以下值：<ul>
<li><code>SEEK_SET</code>：从文件起始位置开始偏移。</li>
<li><code>SEEK_CUR</code>：从当前位置开始偏移。</li>
<li><code>SEEK_END</code>：从文件末尾位置开始偏移。</li>
</ul>
</li>
</ul>
<h3 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>fseek()</code> 函数返回一个非零值表示失败，返回0表示成功。</li>
</ul>
<h3 id="示例用法-8"><a href="#示例用法-8" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将文件指针移动到文件末尾</span></span><br><span class="line">        <span class="keyword">if</span> (fseek(file, <span class="number">0</span>, SEEK_END) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;文件指针移动到文件末尾\n&quot;</span>);</span><br><span class="line">            <span class="type">long</span> fileSize = ftell(file); <span class="comment">// 获取文件大小</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;文件大小为 %ld 字节\n&quot;</span>, fileSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;文件指针移动失败\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用 <code>fseek()</code> 函数时应该注意文件流的打开模式是否支持定位操作，例如，只读模式可能不允许随意移动文件指针。</li>
<li><code>fseek()</code> 可以用来移动文件指针到文件的特定位置，以便进行读取或写入操作。</li>
<li>在使用 <code>fseek()</code> 函数后应该检查返回值，确保文件指针移动操作是否成功。</li>
</ul>
<p><code>fseek()</code> 函数是一个用于定位文件指针的重要工具，可以在文件中定位到特定位置进行读写操作。在使用时应该了解 <code>offset</code> 和 <code>whence</code> 参数的用法，并检查返回值以确保操作成功。</p>
<h2 id="Linux-POSIX-ftell-详解"><a href="#Linux-POSIX-ftell-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; ftell() 详解"></a>Linux POSIX &lt;stdio.h&gt; ftell() 详解</h2><p>在 Linux POSIX 中，<code>&lt;stdio.h&gt;</code> 头文件中的 <code>ftell()</code> 函数用于获取文件流的当前位置指针相对于文件起始位置的偏移量，即返回当前文件指针的位置。</p>
<p>以下是关于 <code>ftell()</code> 函数的详细解释：</p>
<h3 id="函数原型-9"><a href="#函数原型-9" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>stream</code>：指向 <code>FILE</code> 结构的指针，表示要获取位置的文件流。</li>
</ul>
<h3 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>ftell()</code> 函数返回一个 <code>long</code> 类型值，表示文件指针的当前位置。如果发生错误，则返回 <code>-1L</code>。</li>
</ul>
<h3 id="示例用法-9"><a href="#示例用法-9" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取文件指针当前位置</span></span><br><span class="line">        <span class="type">long</span> position = ftell(file);</span><br><span class="line">        <span class="keyword">if</span> (position != <span class="number">-1L</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;文件指针当前位置：%ld\n&quot;</span>, position);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;获取文件指针位置失败\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(file); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-9"><a href="#注意事项-9" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>ftell()</code> 函数返回文件指针相对于文件起始位置的偏移量，以字节为单位。</li>
<li>返回值 <code>-1L</code> 表示获取文件指针位置时出现了错误。</li>
<li><code>ftell()</code> 返回的值可以用于标识当前文件指针的位置，通常用于记录或控制文件的读写位置。</li>
</ul>
<p><code>ftell()</code> 函数用于获取文件指针的当前位置，允许你知道文件指针在文件中的偏移量。在文件处理时，了解当前文件指针的位置对于读取或写入文件非常有用。</p>
<h2 id="Linux-POSIX-sprintf-详解"><a href="#Linux-POSIX-sprintf-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; sprintf() 详解"></a>Linux POSIX &lt;stdio.h&gt; sprintf() 详解</h2><p>在 Linux POSIX 系统中，<code>&lt;stdio.h&gt;</code> 头文件中的 <code>sprintf()</code> 函数用于将格式化的数据写入到字符串中。它类似于 <code>printf()</code> 函数，但是将格式化的输出写入到一个字符串中，而不是输出到标准输出流（屏幕）上。</p>
<p>以下是关于 <code>sprintf()</code> 函数的详细解释：</p>
<h3 id="函数原型-10"><a href="#函数原型-10" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>str</code>：指向字符数组的指针，用于存储格式化后的字符串。</li>
<li><code>format</code>：一个格式化字符串，包含要写入字符串的文本以及格式化指示符，与 <code>printf()</code> 中的格式化字符串相同。</li>
<li><code>...</code>：可变数量的参数，用于替换格式化字符串中的格式化指示符。</li>
</ul>
<h3 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>sprintf()</code> 函数返回一个整数值，表示写入到 <code>str</code> 中的字符数（不包括终止 null 字符 <code>\0</code>）。如果发生错误，则返回一个负数。</li>
</ul>
<h3 id="示例用法-10"><a href="#示例用法-10" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="type">float</span> floatValue = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化数据并将结果存储到字符串中</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;The number is %d and the float value is %.2f&quot;</span>, number, floatValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;格式化后的字符串：%s\n&quot;</span>, buffer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入的字符数：%d\n&quot;</span>, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发生了错误\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-10"><a href="#注意事项-10" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>sprintf()</code> 函数将格式化后的数据写入到一个字符数组中，并在末尾自动添加 null 终止符 <code>\0</code>。</li>
<li>需要确保目标字符数组足够大，以存储格式化后的数据，防止溢出问题。</li>
<li><code>sprintf()</code> 函数是一个强大的工具，但要注意避免缓冲区溢出，可以考虑使用安全版本的函数（如 <code>snprintf()</code>），该函数允许指定要写入的最大字符数。</li>
</ul>
<p><code>sprintf()</code> 函数在需要将格式化的数据写入到字符串中时非常有用，能够对数据进行格式化并存储到一个指定的字符数组中。</p>
<h2 id="Linux-POSIX-snprintf-详解"><a href="#Linux-POSIX-snprintf-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; snprintf() 详解"></a>Linux POSIX &lt;stdio.h&gt; snprintf() 详解</h2><p>在 Linux POSIX 中，<code>&lt;stdio.h&gt;</code> 头文件中的 <code>snprintf()</code> 函数类似于 <code>sprintf()</code> 函数，但是增加了对输出字符数量的控制。<code>snprintf()</code> 允许你指定要写入的最大字符数，以避免缓冲区溢出问题。</p>
<p>以下是关于 <code>snprintf()</code> 函数的详细解释：</p>
<h3 id="函数原型-11"><a href="#函数原型-11" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数-11"><a href="#参数-11" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>str</code>：指向字符数组的指针，用于存储格式化后的字符串。</li>
<li><code>size</code>：要写入的最大字符数（包括终止 null 字符 <code>\0</code>）。</li>
<li><code>format</code>：格式化字符串，包含要写入字符串的文本以及格式化指示符，与 <code>printf()</code> 中的格式化字符串相同。</li>
<li><code>...</code>：可变数量的参数，用于替换格式化字符串中的格式化指示符。</li>
</ul>
<h3 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>snprintf()</code> 函数返回一个整数值，表示实际写入到 <code>str</code> 中的字符数（不包括终止 null 字符 <code>\0</code>）。</li>
</ul>
<h3 id="示例用法-11"><a href="#示例用法-11" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="type">float</span> floatValue = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化数据并将结果存储到字符串中，最大存储字符数为 50</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;The number is %d and the float value is %.2f&quot;</span>, number, floatValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result &gt;= <span class="number">0</span> &amp;&amp; result &lt; <span class="keyword">sizeof</span>(buffer)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;格式化后的字符串：%s\n&quot;</span>, buffer);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入的字符数：%d\n&quot;</span>, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发生了错误或缓冲区不足\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-11"><a href="#注意事项-11" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>snprintf()</code> 函数与 <code>sprintf()</code> 类似，但允许指定要写入的最大字符数，以防止缓冲区溢出。</li>
<li>函数返回值表示实际写入到 <code>str</code> 中的字符数，如果返回值等于传入的 <code>size</code> 参数，表示字符串被截断。</li>
<li>使用 <code>snprintf()</code> 可以更加安全地处理格式化数据，确保不会超出目标字符数组的大小。</li>
</ul>
<p><code>snprintf()</code> 函数是一个安全版本的格式化输出函数，允许指定最大写入字符数，避免了缓冲区溢出问题。</p>
<h2 id="Linux-POSIX-stdin-详解"><a href="#Linux-POSIX-stdin-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; stdin 详解"></a>Linux POSIX &lt;stdio.h&gt; stdin 详解</h2><p>在 Linux POSIX 系统中，<code>&lt;stdio.h&gt;</code> 头文件中定义了三个标准的文件流指针：<code>stdin</code>、<code>stdout</code> 和 <code>stderr</code>。这些指针用于标准输入、标准输出和标准错误流。</p>
<h3 id="stdin-概述"><a href="#stdin-概述" class="headerlink" title="stdin 概述"></a><code>stdin</code> 概述</h3><ul>
<li><code>stdin</code> 是一个指向标准输入流的 <code>FILE</code> 结构指针，用于从用户输入设备（通常是键盘）读取数据。</li>
<li><code>stdin</code> 是一个预定义的常量，无需额外定义即可使用。</li>
<li>在程序中使用 <code>stdin</code> 可以实现从标准输入读取用户输入的数据。</li>
</ul>
<h3 id="示例用法-12"><a href="#示例用法-12" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number); <span class="comment">// 从标准输入(stdin)读取整数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;您输入的整数是: %d\n&quot;</span>, number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-12"><a href="#注意事项-12" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>stdin</code> 是一个标准输入流指针，通常用于读取用户输入。使用标准输入时，可以通过函数如 <code>scanf()</code>、<code>fgets()</code> 等从键盘读取数据。</li>
<li><code>stdin</code> 是一个常量指针，不允许修改，因为它指向标准输入流。</li>
</ul>
<p><code>stdin</code> 在 Linux POSIX 系统中是一个重要的标准输入流指针，允许程序从标准输入中读取用户输入。</p>
<h2 id="Linux-POSIX-stdout-详解"><a href="#Linux-POSIX-stdout-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; stdout 详解"></a>Linux POSIX &lt;stdio.h&gt; stdout 详解</h2><p>在 Linux POSIX 系统中，<code>&lt;stdio.h&gt;</code> 头文件中定义了三个标准的文件流指针：<code>stdin</code>、<code>stdout</code> 和 <code>stderr</code>。这些指针用于标准输入、标准输出和标准错误流。</p>
<h3 id="stdout-概述"><a href="#stdout-概述" class="headerlink" title="stdout 概述"></a><code>stdout</code> 概述</h3><ul>
<li><code>stdout</code> 是一个指向标准输出流的 <code>FILE</code> 结构指针，用于向标准输出设备（通常是屏幕）写入数据。</li>
<li><code>stdout</code> 是一个预定义的常量，无需额外定义即可使用。</li>
<li>在程序中使用 <code>stdout</code> 可以实现向标准输出打印数据。</li>
</ul>
<h3 id="示例用法-13"><a href="#示例用法-13" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是标准输出示例\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;这也是标准输出示例\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Hello, %s!\n&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;The number is: %d\n&quot;</span>, number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-13"><a href="#注意事项-13" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>stdout</code> 是一个标准输出流指针，通常用于输出程序的结果到屏幕。使用标准输出时，可以通过函数如 <code>printf()</code>、<code>fprintf()</code> 等向屏幕打印数据。</li>
<li><code>stdout</code> 是一个常量指针，不允许修改，因为它指向标准输出流。</li>
</ul>
<p><code>stdout</code> 在 Linux POSIX 系统中是一个重要的标准输出流指针，允许程序向标准输出设备（通常是屏幕）打印数据。</p>
<h2 id="Linux-POSIX-stderr-详解"><a href="#Linux-POSIX-stderr-详解" class="headerlink" title="Linux POSIX &lt;stdio.h&gt; stderr 详解"></a>Linux POSIX &lt;stdio.h&gt; stderr 详解</h2><p>在 Linux POSIX 系统中，<code>&lt;stdio.h&gt;</code> 头文件中定义了三个标准的文件流指针：<code>stdin</code>、<code>stdout</code> 和 <code>stderr</code>。这些指针用于标准输入、标准输出和标准错误流。</p>
<h3 id="stderr-概述"><a href="#stderr-概述" class="headerlink" title="stderr 概述"></a><code>stderr</code> 概述</h3><ul>
<li><code>stderr</code> 是一个指向标准错误流的 <code>FILE</code> 结构指针，用于向标准错误设备（通常也是屏幕）输出错误信息。</li>
<li><code>stderr</code> 是一个预定义的常量，无需额外定义即可使用。</li>
<li>在程序中使用 <code>stderr</code> 可以实现向标准错误流输出错误信息。</li>
</ul>
<h3 id="示例用法-14"><a href="#示例用法-14" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;发生了错误：数字太小\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;nonexistent_file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;无法打开文件\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-14"><a href="#注意事项-14" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>stderr</code> 是一个标准错误流指针，通常用于输出程序运行时的错误信息到屏幕。使用标准错误流时，可以通过函数如 <code>fprintf()</code> 向屏幕输出错误信息。</li>
<li><code>stderr</code> 是一个常量指针，不允许修改，因为它指向标准错误流。</li>
</ul>
<p><code>stderr</code> 在 Linux POSIX 系统中是一个重要的标准错误流指针，允许程序输出错误信息到标准错误设备（通常是屏幕）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_7_signal_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_7_signal_h/" class="post-title-link" itemprop="url">C_5_7_signal_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Linux POSIX &lt;signal.h&gt; 详解</li>
</ul>
<h2 id="Linux-POSIX-详解"><a href="#Linux-POSIX-详解" class="headerlink" title="Linux POSIX &lt;signal.h&gt; 详解"></a>Linux POSIX &lt;signal.h&gt; 详解</h2><p>在 Linux POSIX 系统中，<code>&lt;signal.h&gt;</code> 头文件用于处理信号（signals）。信号是一种异步通知机制，用于通知进程发生了特定的事件。</p>
<p>以下是关于 <code>&lt;signal.h&gt;</code> 头文件的详细解释：</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li><code>&lt;signal.h&gt;</code> 头文件声明了与信号处理相关的函数和宏。</li>
<li>它允许程序注册信号处理函数、发送信号以及处理由操作系统或其他进程发送的信号。</li>
</ul>
<h3 id="一些常见的信号"><a href="#一些常见的信号" class="headerlink" title="一些常见的信号"></a>一些常见的信号</h3><p>在 POSIX 系统中，有一些常见的信号及其含义如下：</p>
<ol>
<li><p>**<code>SIGINT</code>**：终端中断信号，通常由用户在终端按下 Ctrl+C 产生，用于终止正在运行的进程。</p>
</li>
<li><p>**<code>SIGKILL</code>**：终止进程信号，用于强制终止进程，无法被捕获或忽略。</p>
</li>
<li><p>**<code>SIGTERM</code>**：终止信号，通常用于请求进程自己优雅地终止运行。</p>
</li>
<li><p>**<code>SIGSEGV</code>**：段错误信号，表示进程访问了无效的内存地址，通常是因为内存访问越界或者操作未分配的内存导致。</p>
</li>
<li><p><strong><code>SIGUSR1</code></strong> 和 **<code>SIGUSR2</code>**：用户自定义信号。</p>
</li>
</ol>
<h3 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h3><ul>
<li>使用 <code>signal()</code> 函数来注册信号处理函数，语法如下：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signum, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>
  这个函数用于设置 <code>signum</code> 信号的处理函数为 <code>handler</code>，当收到信号时执行该处理函数。</li>
</ul>
<h3 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收到 SIGINT 信号，按下 Ctrl+C。\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGINT, sigint_handler); <span class="comment">// 注册 SIGINT 信号的处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下 Ctrl+C 终止程序...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 进程保持运行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>信号处理函数需要快速执行，不要包含太多耗时操作。</li>
<li>信号是异步事件，可以在任何时候发生。因此，处理信号的时候需要小心并确保安全性。</li>
</ul>
<p><code>&lt;signal.h&gt;</code> 头文件允许程序员处理信号，以响应进程发生的特定事件。通过信号处理，程序可以捕获并处理异步发生的事件，使得程序具有更好的鲁棒性和可靠性。</p>
<h2 id="Linux-POSIX-signal-详解"><a href="#Linux-POSIX-signal-详解" class="headerlink" title="Linux POSIX &lt;signal.h&gt; signal() 详解"></a>Linux POSIX &lt;signal.h&gt; signal() 详解</h2><p>在 Linux POSIX 系统中，<code>&lt;signal.h&gt;</code> 头文件中的 <code>signal()</code> 函数用于设置信号的处理函数。</p>
<p>以下是关于 <code>signal()</code> 函数的详细解释：</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signum, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>signum</code>：表示要处理的信号的编号。它可以是预定义的信号常量，如 <code>SIGINT</code>、<code>SIGTERM</code> 等。</li>
<li><code>handler</code>：是一个函数指针，表示要与 <code>signum</code> 信号相关联的处理函数。可以是自定义的函数指针，用于处理接收到的信号。</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li><code>signal()</code> 函数返回一个函数指针，表示之前与 <code>signum</code> 相关联的信号处理函数。如果之前没有设置过信号处理函数，则返回 <code>SIG_ERR</code>。</li>
</ul>
<h3 id="示例用法-1"><a href="#示例用法-1" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收到 SIGINT 信号，按下 Ctrl+C。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注册 SIGINT 信号的处理函数</span></span><br><span class="line">    signal(SIGINT, sigint_handler);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下 Ctrl+C 终止程序...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 进程保持运行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>signal()</code> 函数用于设置对指定信号的处理方式。</li>
<li>可以设置 <code>SIG_IGN</code> 来忽略某个信号，或者设置 <code>SIG_DFL</code> 恢复该信号的默认处理方式。</li>
<li>调用 <code>signal()</code> 函数设置信号处理函数后，一旦接收到相应信号，就会调用注册的信号处理函数。</li>
</ul>
<p><code>signal()</code> 函数允许程序员为指定的信号设置自定义的处理函数，从而可以在程序中对接收到的信号做出相应的响应和处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_4_stdlib_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_4_stdlib_h/" class="post-title-link" itemprop="url">C_5_4_stdlib_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>&lt;stdlib.h&gt;标准头文件</li>
</ul>
<h2 id="Linux-POSIX-详解"><a href="#Linux-POSIX-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; 详解"></a>Linux POSIX &lt;stdlib.h&gt; 详解</h2><p><code>&lt;stdlib.h&gt;</code> 是 POSIX（可移植操作系统接口）规范中针对类 Unix 操作系统的 C 标准库中的一个头文件。它提供了一些标准函数、类型和宏，用于内存分配、转换、随机数生成等各种操作。</p>
<p>以下是 <code>&lt;stdlib.h&gt;</code> 中常用的一些函数和类型的概述：</p>
<h3 id="内存分配与管理："><a href="#内存分配与管理：" class="headerlink" title="内存分配与管理："></a>内存分配与管理：</h3><ul>
<li><code>malloc()</code>: 分配一块内存。</li>
<li><code>calloc()</code>: 分配一块内存并将其初始化为零。</li>
<li><code>realloc()</code>: 调整之前分配的内存块的大小。</li>
<li><code>free()</code>: 释放之前分配的内存块。</li>
</ul>
<h3 id="字符串转换："><a href="#字符串转换：" class="headerlink" title="字符串转换："></a>字符串转换：</h3><ul>
<li><code>atoi()</code>, <code>atol()</code>, <code>atoll()</code>: 将字符串转换为整数。</li>
<li><code>atof()</code>: 将字符串转换为浮点数。</li>
<li><code>itoa()</code>: 将整数转换为字符串（不是标准 C 的一部分，但在某些实现中可用）。</li>
</ul>
<h3 id="伪随机数生成："><a href="#伪随机数生成：" class="headerlink" title="伪随机数生成："></a>伪随机数生成：</h3><ul>
<li><code>rand()</code>: 生成伪随机整数。</li>
<li><code>srand()</code>: 种子初始化随机数生成器。</li>
</ul>
<h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><ul>
<li><code>getenv()</code>: 获取环境变量的值。</li>
<li><code>system()</code>: 执行 shell 命令。</li>
</ul>
<h3 id="实用函数："><a href="#实用函数：" class="headerlink" title="实用函数："></a>实用函数：</h3><ul>
<li><code>exit()</code>: 终止程序执行。</li>
<li><code>abort()</code>: 中止程序执行。</li>
<li><code>qsort()</code>: 对数组进行排序。</li>
<li><code>bsearch()</code>: 在排序数组中执行二分查找。</li>
</ul>
<h3 id="其他常量和类型："><a href="#其他常量和类型：" class="headerlink" title="其他常量和类型："></a>其他常量和类型：</h3><ul>
<li><code>EXIT_SUCCESS</code>, <code>EXIT_FAILURE</code>: 标准的退出状态码。</li>
<li><code>NULL</code>: 空指针常量。</li>
<li><code>size_t</code>: 用于对象大小的无符号整数类型。</li>
</ul>
<p>需要注意的是，<code>&lt;stdlib.h&gt;</code> 中的这些功能是 C 的标准功能，在不同的实现中可能会有系统特定的变化或扩展。此外，POSIX 的兼容性确保了这些函数和宏在各种类 Unix 系统中都是可用的。</p>
<p>要使用这些函数，需要在 C 程序的开头包含 <code>&lt;stdlib.h&gt;</code>，以便访问其定义和原型。</p>
<h2 id="Linux-POSIX-malloc-详解"><a href="#Linux-POSIX-malloc-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; malloc() 详解"></a>Linux POSIX &lt;stdlib.h&gt; malloc() 详解</h2><p>在 Linux POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>malloc()</code> 函数是用于动态内存分配的关键函数之一。它允许程序在运行时请求分配一块指定大小的内存空间，并返回一个指向分配内存的指针。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>size_t size</code>: 要分配的内存块的大小（以字节为单位）。</li>
</ul>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>malloc()</code> 返回一个指向分配内存的指针。如果分配失败，则返回 <code>NULL</code>。</li>
</ul>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>malloc()</code> 用于动态地分配内存。它在堆上分配一块指定大小的连续内存块，并返回一个指向此内存块的指针。</li>
</ul>
<h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个包含5个整数的内存块</span></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对分配的内存进行操作...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            ptr[i] = i * <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] = %d\n&quot;</span>, i, ptr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放分配的内存</span></span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>malloc()</code> 被用来分配一个包含5个整数的内存块。然后，分配的内存被使用，最后通过 <code>free()</code> 函数释放了已分配的内存。此外，在使用 <code>malloc()</code> 分配内存后，通常需要检查返回的指针是否为 <code>NULL</code>，以确保分配操作成功。</p>
<h2 id="Linux-POSIX-calloc-详解"><a href="#Linux-POSIX-calloc-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; calloc() 详解"></a>Linux POSIX &lt;stdlib.h&gt; calloc() 详解</h2><p>在 Linux POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>calloc()</code> 函数是用于动态内存分配的重要函数之一，类似于 <code>malloc()</code>。不同之处在于，<code>calloc()</code> 不仅分配内存，还将分配的内存块初始化为零。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> num_elements, <span class="type">size_t</span> element_size)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>size_t num_elements</code>: 要分配的元素数量。</li>
<li><code>size_t element_size</code>: 每个元素的大小（以字节为单位）。</li>
</ul>
<h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>calloc()</code> 返回一个指向分配内存的指针。如果分配失败，则返回 <code>NULL</code>。</li>
</ul>
<h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>calloc()</code> 用于动态分配一块指定数量和大小的连续内存块，并将所有的位初始化为零。</li>
</ul>
<h3 id="使用示例：-1"><a href="#使用示例：-1" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个包含5个整数的内存块，并将其初始化为零</span></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">calloc</span>(size, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对分配的内存进行操作...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] = %d\n&quot;</span>, i, ptr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放分配的内存</span></span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>calloc()</code> 被用来分配一个包含5个整数的内存块，并将其初始化为零。然后，分配的内存被使用，并通过 <code>free()</code> 函数释放了已分配的内存。同样，需要检查返回的指针是否为 <code>NULL</code>，以确保分配操作成功。</p>
<h2 id="Linux-POSIX-realloc-详解"><a href="#Linux-POSIX-realloc-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; realloc() 详解"></a>Linux POSIX &lt;stdlib.h&gt; realloc() 详解</h2><p>在 Linux POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>realloc()</code> 函数是用于重新分配动态内存的重要函数。它允许程序修改先前分配的内存块的大小，可能扩大或缩小该内存块的大小。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-2"><a href="#参数：-2" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>void *ptr</code>: 指向先前分配内存的指针。</li>
<li><code>size_t size</code>: 新的内存块大小（以字节为单位）。</li>
</ul>
<h3 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>realloc()</code> 返回一个指向重新分配内存的指针。如果分配失败，则返回 <code>NULL</code>。如果 <code>ptr</code> 为 <code>NULL</code>，则 <code>realloc()</code> 的行为类似于 <code>malloc()</code>。</li>
</ul>
<h3 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>realloc()</code> 用于更改先前分配的内存块的大小。如果内存大小增加，可能会移动现有的数据到新的内存位置，并将新分配的空间初始化为未定义的值。</li>
</ul>
<h3 id="使用示例：-2"><a href="#使用示例：-2" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个包含5个整数的内存块</span></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对分配的内存进行操作...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            ptr[i] = i * <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] = %d\n&quot;</span>, i, ptr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新分配内存块大小为10个整数大小</span></span><br><span class="line">        <span class="type">int</span> new_size = <span class="number">10</span>;</span><br><span class="line">        ptr = (<span class="type">int</span> *)<span class="built_in">realloc</span>(ptr, new_size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;重新分配内存失败！\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;重新分配内存成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 继续操作重新分配的内存...</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = size; i &lt; new_size; ++i) &#123;</span><br><span class="line">                ptr[i] = i * <span class="number">10</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] = %d\n&quot;</span>, i, ptr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放重新分配的内存</span></span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，首先使用 <code>malloc()</code> 分配了一个包含5个整数的内存块。然后，使用 <code>realloc()</code> 函数重新分配内存块的大小为10个整数大小。需要注意的是，<code>realloc()</code> 可能会在必要时重新分配内存并将原始数据复制到新分配的位置。最后，通过 <code>free()</code> 函数释放了重新分配的内存。</p>
<h2 id="Linux-POSIX-free-详解"><a href="#Linux-POSIX-free-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; free() 详解"></a>Linux POSIX &lt;stdlib.h&gt; free() 详解</h2><p>在 Linux POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>free()</code> 函数是用于释放动态分配的内存块的关键函数。</p>
<h3 id="函数签名：-3"><a href="#函数签名：-3" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-3"><a href="#参数：-3" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>void *ptr</code>: 指向先前分配内存的指针。</li>
</ul>
<h3 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>free()</code> 函数没有返回值。</li>
</ul>
<h3 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>free()</code> 用于释放先前使用 <code>malloc()</code>、<code>calloc()</code> 或 <code>realloc()</code> 分配的动态内存。通过释放已分配的内存，将其返回给系统，使其可以在以后的操作中重新使用。</li>
</ul>
<h3 id="使用示例：-3"><a href="#使用示例：-3" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *ptr;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个包含5个整数的内存块</span></span><br><span class="line">    ptr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对分配的内存进行操作...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            ptr[i] = i * <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ptr[%d] = %d\n&quot;</span>, i, ptr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放分配的内存</span></span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存已释放。\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，首先使用 <code>malloc()</code> 分配了一个包含5个整数的内存块，然后使用 <code>free()</code> 函数释放了该内存块。释放内存后，应避免继续使用指向已释放内存的指针，因为这可能导致未定义的行为。因此，在释放内存后，通常将指针设置为 <code>NULL</code>，以避免意外使用。</p>
<h2 id="Linux-POSIX-atoi-详解"><a href="#Linux-POSIX-atoi-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; atoi() 详解"></a>Linux POSIX &lt;stdlib.h&gt; atoi() 详解</h2><p>在 Linux POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>atoi()</code> 函数用于将字符串转换为整数。</p>
<h3 id="函数签名：-4"><a href="#函数签名：-4" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-4"><a href="#参数：-4" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>const char *str</code>: 要转换为整数的字符串。</li>
</ul>
<h3 id="返回值：-4"><a href="#返回值：-4" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>atoi()</code> 返回转换后的整数值。如果输入字符串不是有效的整数表示形式，则返回 0。</li>
</ul>
<h3 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>atoi()</code> 函数将传入的字符串参数解析为整数。它会跳过字符串开始的空格字符，然后从第一个非空格字符开始，尝试解析尽可能多的连续字符作为整数。它会忽略非数字字符，直到遇到非数字字符或字符串结束。</li>
</ul>
<h3 id="使用示例：-4"><a href="#使用示例：-4" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">    <span class="type">int</span> result = atoi(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串转换为整数结果：%d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str2 = <span class="string">&quot;42abc&quot;</span>;</span><br><span class="line">    <span class="type">int</span> result2 = atoi(str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;非完整字符串转换为整数结果：%d\n&quot;</span>, result2);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str3 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">int</span> result3 = atoi(str3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;非数字字符串转换为整数结果：%d\n&quot;</span>, result3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>atoi()</code> 函数被用于将不同的字符串转换为整数。第一个示例中的字符串 “12345” 被成功转换为整数 12345。第二个示例中的字符串 “42abc” 以数字部分 “42” 被成功转换为整数 42。第三个示例中的字符串 “abc” 不是有效的整数表示形式，因此 <code>atoi()</code> 返回 0。需要注意的是，<code>atoi()</code> 对于不完整或无效的输入可能会返回 0，因此在使用时需要谨慎检查返回值。</p>
<h2 id="Linux-POSIX-atof-详解"><a href="#Linux-POSIX-atof-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; atof() 详解"></a>Linux POSIX &lt;stdlib.h&gt; atof() 详解</h2><p>在 Linux POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>atof()</code> 函数用于将字符串转换为浮点数。</p>
<h3 id="函数签名：-5"><a href="#函数签名：-5" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">atof</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-5"><a href="#参数：-5" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>const char *str</code>: 要转换为浮点数的字符串。</li>
</ul>
<h3 id="返回值：-5"><a href="#返回值：-5" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>atof()</code> 返回转换后的浮点数值。如果输入字符串不是有效的浮点数表示形式，则返回 0.0。</li>
</ul>
<h3 id="功能：-5"><a href="#功能：-5" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>atof()</code> 函数将传入的字符串参数解析为浮点数。它会跳过字符串开始的空格字符，然后从第一个非空格字符开始，尝试解析尽可能多的连续字符作为浮点数。它会忽略非数字字符，直到遇到非数字字符、小数点、指数标志（如 ‘e’ 或 ‘E’）或字符串结束。</li>
</ul>
<h3 id="使用示例：-5"><a href="#使用示例：-5" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;123.456&quot;</span>;</span><br><span class="line">    <span class="type">double</span> result = atof(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串转换为浮点数结果：%f\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str2 = <span class="string">&quot;3.14abc&quot;</span>;</span><br><span class="line">    <span class="type">double</span> result2 = atof(str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;非完整字符串转换为浮点数结果：%f\n&quot;</span>, result2);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str3 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">double</span> result3 = atof(str3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;非数字字符串转换为浮点数结果：%f\n&quot;</span>, result3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>atof()</code> 函数被用于将不同的字符串转换为浮点数。第一个示例中的字符串 “123.456” 被成功转换为浮点数 123.456。第二个示例中的字符串 “3.14abc” 以浮点数部分 “3.14” 被成功转换为浮点数 3.14。第三个示例中的字符串 “abc” 不是有效的浮点数表示形式，因此 <code>atof()</code> 返回 0.0。需要注意的是，<code>atof()</code> 对于不完整或无效的输入可能会返回 0.0，因此在使用时需要谨慎检查返回值。</p>
<h2 id="Linux-POSIX-itoa-详解"><a href="#Linux-POSIX-itoa-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; itoa() 详解"></a>Linux POSIX &lt;stdlib.h&gt; itoa() 详解</h2><p>在 POSIX 标准中，<code>itoa()</code> 函数实际上不是标准 C 函数，它不在 C 标准库 <code>&lt;stdlib.h&gt;</code> 中定义。<code>itoa()</code> 用于将整数转换为字符串。尽管在某些特定的编译器或系统中可能会提供 <code>itoa()</code> 函数，但它并不是 C 语言标准库的一部分，因此在不同的系统或编译器中，<code>itoa()</code> 的可用性和实现方式可能会有所不同。</p>
<p>通常情况下，如果没有 <code>itoa()</code> 函数，可以使用标准库函数 <code>sprintf()</code> 或 <code>snprintf()</code> 来实现整数到字符串的转换。这两个函数允许将格式化的数据写入字符串缓冲区中。</p>
<p>下面是使用 <code>snprintf()</code> 函数将整数转换为字符串的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LENGTH 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">12345</span>;</span><br><span class="line">    <span class="type">char</span> str[MAX_LENGTH];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(str, MAX_LENGTH, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;整数转换为字符串结果：%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>snprintf()</code> 函数将整数 <code>num</code> 转换为字符串，并将结果存储在 <code>str</code> 缓冲区中。使用 <code>&quot;%d&quot;</code> 格式化字符串指定要转换的整数类型。这种方法提供了一种可移植且不依赖于特定编译器或系统的整数到字符串转换方式。</p>
<h2 id="Linux-POSIX-rand-详解"><a href="#Linux-POSIX-rand-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; rand() 详解"></a>Linux POSIX &lt;stdlib.h&gt; rand() 详解</h2><p>在 POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>rand()</code> 函数用于生成伪随机整数。</p>
<h3 id="函数签名：-6"><a href="#函数签名：-6" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rand</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-6"><a href="#参数：-6" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>void</code>：<code>rand()</code> 函数没有参数。</li>
</ul>
<h3 id="返回值：-6"><a href="#返回值：-6" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>rand()</code> 返回一个伪随机整数值。范围通常是 0 到 <code>RAND_MAX</code> 之间（包括 0 和 <code>RAND_MAX</code>）。</li>
</ul>
<h3 id="功能：-6"><a href="#功能：-6" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>rand()</code> 函数生成伪随机整数。每次调用 <code>rand()</code>，它会返回一个在指定范围内的整数值。伪随机性意味着生成的数字序列是基于初始种子值的，因此在相同的种子值下，<code>rand()</code> 将生成相同的数字序列。</li>
</ul>
<h3 id="使用示例：-6"><a href="#使用示例：-6" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, randomNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用当前时间作为种子</span></span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;生成的随机数为：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成并打印 10 个随机数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        randomNum = rand();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, randomNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>srand()</code> 函数使用当前时间作为种子，以确保每次程序运行时生成的随机数序列是不同的。然后，使用 <code>rand()</code> 函数生成并打印了 10 个随机数。需要注意的是，如果不调用 <code>srand()</code> 来设置种子，每次程序运行时将会生成相同的随机数序列。因此，在许多情况下，通常在程序开始时使用不同的种子来初始化随机数生成器，以产生不同的随机数序列。</p>
<h2 id="Linux-POSIX-srand-详解"><a href="#Linux-POSIX-srand-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; srand() 详解"></a>Linux POSIX &lt;stdlib.h&gt; srand() 详解</h2><p>在 POSIX 标准的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>srand()</code> 函数用于设置 <code>rand()</code> 函数生成随机数所使用的种子值。</p>
<h3 id="函数签名：-7"><a href="#函数签名：-7" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-7"><a href="#参数：-7" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>unsigned int seed</code>：用作随机数生成器种子的整数值。</li>
</ul>
<h3 id="返回值：-7"><a href="#返回值：-7" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>srand()</code> 函数没有返回值。</li>
</ul>
<h3 id="功能：-7"><a href="#功能：-7" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>srand()</code> 函数设置 <code>rand()</code> 函数使用的种子值。这个种子值将影响 <code>rand()</code> 函数生成的随机数序列。如果使用相同的种子值调用 <code>srand()</code>，则后续对 <code>rand()</code> 的调用将生成相同的随机数序列。</li>
</ul>
<h3 id="使用示例：-7"><a href="#使用示例：-7" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, randomNum;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> seed = <span class="number">123</span>; <span class="comment">// 设置种子值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用指定种子值</span></span><br><span class="line">    srand(seed);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用种子值 %u 生成的随机数为：\n&quot;</span>, seed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成并打印 10 个随机数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        randomNum = rand();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, randomNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>srand()</code> 函数被用于设置随机数生成器的种子值为 <code>123</code>。然后，<code>rand()</code> 函数被调用多次以生成随机数序列。重要的是要注意，如果使用相同的种子值多次调用 <code>srand()</code>，后续对 <code>rand()</code> 的调用将生成相同的随机数序列。通常情况下，使用随机的种子值（比如当前时间）可以帮助确保每次程序运行时都生成不同的随机数序列。</p>
<h2 id="Linux-POSIX-getenv-详解"><a href="#Linux-POSIX-getenv-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; getenv() 详解"></a>Linux POSIX &lt;stdlib.h&gt; getenv() 详解</h2><p>在 POSIX 标准的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>getenv()</code> 函数用于获取指定环境变量的值。</p>
<h3 id="函数签名：-8"><a href="#函数签名：-8" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-8"><a href="#参数：-8" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>const char *name</code>：要获取其值的环境变量的名称字符串。</li>
</ul>
<h3 id="返回值：-8"><a href="#返回值：-8" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>getenv()</code> 函数返回一个指向环境变量值的字符串指针。如果未找到指定名称的环境变量，则返回 <code>NULL</code>。</li>
</ul>
<h3 id="功能：-8"><a href="#功能：-8" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>getenv()</code> 函数用于获取指定环境变量的值。环境变量是一种在程序执行时存储有关环境信息的方式，比如系统路径、用户信息等。</li>
</ul>
<h3 id="使用示例：-8"><a href="#使用示例：-8" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *path = getenv(<span class="string">&quot;PATH&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;PATH 环境变量的值是：%s\n&quot;</span>, path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到 PATH 环境变量\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>getenv()</code> 函数被用于获取名为 “PATH” 的环境变量的值。如果找到了名为 “PATH” 的环境变量，则打印其值。如果未找到指定的环境变量，则打印一条消息说明未找到该环境变量。需要注意的是，如果环境变量不存在或未定义，则 <code>getenv()</code> 返回 <code>NULL</code>。</p>
<h2 id="Linux-POSIX-system-详解"><a href="#Linux-POSIX-system-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; system() 详解"></a>Linux POSIX &lt;stdlib.h&gt; system() 详解</h2><p>在 POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>system()</code> 函数用于执行命令行中的命令。</p>
<h3 id="函数签名：-9"><a href="#函数签名：-9" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">system</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-9"><a href="#参数：-9" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>const char *command</code>：要执行的命令的字符串。</li>
</ul>
<h3 id="返回值：-9"><a href="#返回值：-9" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>system()</code> 函数返回命令执行的状态信息。返回值通常是命令退出状态的表示方式，通常情况下，0 表示命令成功执行，非零值表示出现了错误。</li>
</ul>
<h3 id="功能：-9"><a href="#功能：-9" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>system()</code> 函数用于在程序中执行命令。它将传入的命令字符串发送给系统命令解释器来执行。在执行完成后，会返回命令的退出状态信息。</li>
</ul>
<h3 id="使用示例：-9"><a href="#使用示例：-9" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 执行命令 ls，并检查返回状态</span></span><br><span class="line">    <span class="type">int</span> status = system(<span class="string">&quot;ls -l&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;命令执行成功！\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;命令执行失败或出现错误！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>system()</code> 函数被用于执行 <code>ls -l</code> 命令，并通过检查返回的状态信息来判断命令是否执行成功。需要注意的是，<code>system()</code> 函数执行命令后，会等待命令执行完成，并返回其退出状态信息。因此，如果执行的命令会花费很长时间，程序也会相应地等待。此外，<code>system()</code> 函数也可以用来执行其他的系统命令，但需要注意潜在的安全风险，尤其是当传入的命令字符串由用户输入或动态生成时。</p>
<h2 id="Linux-POSIX-exit-详解"><a href="#Linux-POSIX-exit-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; exit() 详解"></a>Linux POSIX &lt;stdlib.h&gt; exit() 详解</h2><p>在 POSIX 标准的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>exit()</code> 函数用于终止程序的执行，并返回一个指定的退出状态给操作系统。</p>
<h3 id="函数签名：-10"><a href="#函数签名：-10" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-10"><a href="#参数：-10" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>int status</code>：程序的退出状态码。通常情况下，0 表示成功退出，非零值表示出现了错误。</li>
</ul>
<h3 id="返回值：-10"><a href="#返回值：-10" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>exit()</code> 函数没有返回值。</li>
</ul>
<h3 id="功能：-10"><a href="#功能：-10" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>exit()</code> 函数用于正常终止程序的执行。当调用 <code>exit()</code> 时，它会立即终止当前正在运行的程序，清理所有的资源并返回指定的退出状态码给操作系统。</li>
</ul>
<h3 id="使用示例：-10"><a href="#使用示例：-10" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序执行中...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一些操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止程序的执行，并返回退出状态码 0（表示成功）</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>exit()</code> 函数被用于正常终止程序的执行。当程序到达 <code>exit(0)</code> 时，程序将立即终止，并将退出状态码 <code>0</code> 返回给操作系统。<code>exit()</code> 函数可以用于在程序的任何地方终止执行，不仅仅是在 <code>main()</code> 函数内。</p>
<h2 id="Linux-POSIX-abort-详解"><a href="#Linux-POSIX-abort-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; abort() 详解"></a>Linux POSIX &lt;stdlib.h&gt; abort() 详解</h2><p>在 POSIX 中的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>abort()</code> 函数用于使程序异常终止。</p>
<h3 id="函数签名：-11"><a href="#函数签名：-11" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-11"><a href="#参数：-11" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>void</code>：<code>abort()</code> 函数没有参数。</li>
</ul>
<h3 id="返回值：-11"><a href="#返回值：-11" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>abort()</code> 函数不会返回，它会导致程序异常终止。</li>
</ul>
<h3 id="功能：-11"><a href="#功能：-11" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>abort()</code> 函数用于引发程序的异常终止。调用 <code>abort()</code> 会立即终止程序的执行，并向操作系统发送一个异常终止信号。通常情况下，会生成一个 <code>SIGABRT</code> 信号，表示程序发生了严重错误，并且无法继续运行。</li>
</ul>
<h3 id="使用示例：-11"><a href="#使用示例：-11" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序执行中...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在某些条件下触发异常终止</span></span><br><span class="line">    <span class="type">int</span> condition = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发生错误，程序即将异常终止！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的代码不会被执行，因为在上面已经调用了 abort()</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这行代码不会被执行\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>abort()</code> 函数被用于条件满足时触发异常终止。如果条件满足（<code>condition</code> 为真），则会触发 <code>abort()</code> 调用，导致程序立即终止，并不会执行 <code>abort()</code> 之后的代码。<code>abort()</code> 函数通常用于标记程序发生了严重错误或遇到不可恢复的情况，需要立即停止程序的执行。</p>
<h2 id="Linux-POSIX-qsort-详解"><a href="#Linux-POSIX-qsort-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; qsort() 详解"></a>Linux POSIX &lt;stdlib.h&gt; qsort() 详解</h2><p>在 POSIX 标准的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>qsort()</code> 函数用于对数组进行快速排序。</p>
<h3 id="函数签名：-12"><a href="#函数签名：-12" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> nmemb, <span class="type">size_t</span> size, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-12"><a href="#参数：-12" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>void *base</code>：指向要排序的数组的指针。</li>
<li><code>size_t nmemb</code>：数组中元素的数量。</li>
<li><code>size_t size</code>：每个元素的大小（以字节为单位）。</li>
<li><code>int (*compar)(const void *, const void *)</code>：指向比较函数的指针，用于定义元素之间的比较规则。</li>
</ul>
<h3 id="返回值：-12"><a href="#返回值：-12" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>qsort()</code> 函数没有返回值。</li>
</ul>
<h3 id="功能：-12"><a href="#功能：-12" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>qsort()</code> 函数用于对数组进行快速排序。它根据提供的比较函数，按照升序排列数组元素。快速排序是一种高效的排序算法，具有较好的平均性能。</li>
</ul>
<h3 id="比较函数-compar："><a href="#比较函数-compar：" class="headerlink" title="比较函数 compar："></a>比较函数 <code>compar</code>：</h3><ul>
<li>比较函数 <code>compar</code> 接受两个指向要比较的元素的指针，返回一个整数值表示它们的关系：<ul>
<li>如果第一个元素应排在第二个元素之前，则返回负值；</li>
<li>如果第一个元素应排在第二个元素之后，则返回正值；</li>
<li>如果两个元素相等，则返回零。</li>
</ul>
</li>
</ul>
<h3 id="使用示例：-12"><a href="#使用示例：-12" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数，用于指定排序规则（升序）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">int</span> *)a - *(<span class="type">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前的数组：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数组进行快速排序</span></span><br><span class="line">    qsort(arr, size, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>qsort()</code> 函数被用于对整数数组 <code>arr</code> 进行升序排序。通过提供的比较函数 <code>compare</code>，指定了元素之间的比较规则。<code>qsort()</code> 函数将数组按升序排列后，打印排序前后的数组内容。</p>
<h2 id="Linux-POSIX-bsearch-详解"><a href="#Linux-POSIX-bsearch-详解" class="headerlink" title="Linux POSIX &lt;stdlib.h&gt; bsearch() 详解"></a>Linux POSIX &lt;stdlib.h&gt; bsearch() 详解</h2><p>在 POSIX 标准的 <code>&lt;stdlib.h&gt;</code> 头文件中，<code>bsearch()</code> 函数用于在已排序数组中执行二分查找。</p>
<h3 id="函数签名：-13"><a href="#函数签名：-13" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">bsearch</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">const</span> <span class="type">void</span> *base, <span class="type">size_t</span> nmemb, <span class="type">size_t</span> size, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-13"><a href="#参数：-13" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>const void *key</code>：要查找的元素的指针。</li>
<li><code>const void *base</code>：指向已排序数组的起始地址的指针。</li>
<li><code>size_t nmemb</code>：数组中元素的数量。</li>
<li><code>size_t size</code>：每个元素的大小（以字节为单位）。</li>
<li><code>int (*compar)(const void *, const void *)</code>：指向比较函数的指针，用于定义元素之间的比较规则。</li>
</ul>
<h3 id="返回值：-13"><a href="#返回值：-13" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>bsearch()</code> 函数返回一个指针，指向查找到的元素的位置。如果未找到匹配的元素，则返回 <code>NULL</code>。</li>
</ul>
<h3 id="功能：-13"><a href="#功能：-13" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>bsearch()</code> 函数用于在已排序的数组中执行二分查找。它搜索数组中是否存在与指定关键字匹配的元素。二分查找是一种高效的查找算法，但要求数组必须是已排序的。</li>
</ul>
<h3 id="比较函数-compar：-1"><a href="#比较函数-compar：-1" class="headerlink" title="比较函数 compar："></a>比较函数 <code>compar</code>：</h3><ul>
<li>比较函数 <code>compar</code> 与 <code>qsort()</code> 函数中的比较函数类似，接受两个指向要比较的元素的指针，返回一个整数值表示它们的关系。</li>
</ul>
<h3 id="使用示例：-13"><a href="#使用示例：-13" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较函数，用于指定比较规则</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (*(<span class="type">int</span> *)a - *(<span class="type">int</span> *)b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> key = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数组进行快速排序（必须是已排序的数组）</span></span><br><span class="line">    qsort(arr, size, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在已排序数组中执行二分查找</span></span><br><span class="line">    <span class="type">int</span> *result = (<span class="type">int</span> *)bsearch(&amp;key, arr, size, <span class="keyword">sizeof</span>(<span class="type">int</span>), compare);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 找到在数组中的位置：%ld\n&quot;</span>, key, result - arr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 未找到在数组中\n&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>bsearch()</code> 函数被用于在已排序数组 <code>arr</code> 中查找元素 <code>key</code>。首先，数组必须是已排序的，然后使用 <code>qsort()</code> 对其进行排序。然后调用 <code>bsearch()</code> 函数来寻找 <code>key</code>，并根据返回结果确定是否找到该元素。如果找到，<code>bsearch()</code> 返回指向匹配元素的指针，否则返回 <code>NULL</code>。</p>
<h2 id="C-putenv-函数-详解"><a href="#C-putenv-函数-详解" class="headerlink" title="C putenv() 函数 详解"></a>C putenv() 函数 详解</h2><p><code>putenv()</code> 函数用于设置环境变量。它是C标准库中的一部分，定义在 <code>&lt;stdlib.h&gt;</code> 头文件中。</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li><code>string</code>：一个以形式 <code>name=value</code> 表示的字符串，用于设置环境变量。这个字符串会被函数复制，因此你可以在调用后安全地释放它。</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul>
<li>如果设置环境变量成功，则返回0；否则返回一个非零值。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>putenv()</code> 在某些平台上可能不是线程安全的，因此在多线程环境中使用时需要小心。</li>
<li>在某些平台上，使用 <code>putenv()</code> 可能会导致内存泄漏，因为它只是修改了指向环境变量的指针，而不是为其分配新的内存空间。</li>
<li>在某些操作系统上，对环境变量的更改可能会影响整个程序的行为，因此使用 <code>putenv()</code> 需要谨慎。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面是一个简单的示例，演示了如何使用 <code>putenv()</code> 设置一个环境变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置环境变量</span></span><br><span class="line">    <span class="type">char</span> env_var[] = <span class="string">&quot;MY_ENV_VAR=Hello World&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (putenv(env_var) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to set environment variable\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取环境变量并输出</span></span><br><span class="line">    <span class="type">char</span>* value = getenv(<span class="string">&quot;MY_ENV_VAR&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Value of MY_ENV_VAR: %s\n&quot;</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;MY_ENV_VAR is not set\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们设置了一个名为 <code>MY_ENV_VAR</code> 的环境变量，其值为 <code>Hello World</code>。然后，我们获取并输出这个环境变量的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_9_time_h/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C/C_5_POSIX_%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/2024-05-22-C_5_9_time_h/" class="post-title-link" itemprop="url">C_5_9_time_h</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Linux POSIX &lt;time.h&gt;  详解</li>
</ul>
<h2 id="Linux-POSIX-详解"><a href="#Linux-POSIX-详解" class="headerlink" title="Linux POSIX &lt;time.h&gt;  详解"></a>Linux POSIX &lt;time.h&gt;  详解</h2><p><code>&lt;time.h&gt;</code> 是 C 标准库中的一个头文件，用于处理日期和时间相关的操作。它同时也是 POSIX 操作系统接口的一部分，提供了在 POSIX 兼容环境下处理时间的函数和类型。</p>
<p>以下是 <code>&lt;time.h&gt;</code> 中一些关键组成部分的详解：</p>
<h3 id="时间类型："><a href="#时间类型：" class="headerlink" title="时间类型："></a>时间类型：</h3><ol>
<li><p>**<code>time_t</code>**：表示自 1970 年 1 月 1 日 00:00:00 UTC（称为 Epoch）以来经过的秒数。它通常用于存储和操作时间值。</p>
</li>
<li><p>**<code>struct tm</code>**：表示一个日期和时间，以其各个组成部分表示（例如年、月、日、小时、分钟、秒等）。</p>
</li>
</ol>
<h3 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h3><ol>
<li><p>**<code>time()</code>**：从系统时钟获取当前时间，并以 <code>time_t</code> 值的形式返回。</p>
</li>
<li><p>**<code>gmtime()</code>**：将 <code>time_t</code> 值转换为包含 UTC 时间的 <code>struct tm</code> 结构。</p>
</li>
<li><p>**<code>localtime()</code>**：将 <code>time_t</code> 值转换为包含本地时间的 <code>struct tm</code> 结构，已经根据当前时区进行了调整。</p>
</li>
<li><p>**<code>mktime()</code>**：将 <code>struct tm</code> 时间表示转换为 <code>time_t</code> 值。</p>
</li>
<li><p>**<code>strftime()</code>**：根据格式字符串，将 <code>struct tm</code> 时间值格式化为指定的字符串表示形式。</p>
</li>
<li><p>**<code>difftime()</code>**：计算两个 <code>time_t</code> 值之间的差异，以秒为单位返回差值。</p>
</li>
</ol>
<h3 id="常量："><a href="#常量：" class="headerlink" title="常量："></a>常量：</h3><ol>
<li><p><strong>Epoch</strong>：定义为时间的起始点，通常被表示为 1970 年 1 月 1 日（00:00:00 UTC）。</p>
</li>
<li><p><strong>与日期&#x2F;时间计算相关的常量</strong>：比如 <code>SECONDS_PER_MINUTE</code>（每分钟秒数）、<code>SECONDS_PER_HOUR</code>（每小时秒数）、<code>SECONDS_PER_DAY</code>（每天秒数）等，用于时间计算。</p>
</li>
</ol>
<h3 id="时间操作："><a href="#时间操作：" class="headerlink" title="时间操作："></a>时间操作：</h3><p>通过 <code>&lt;time.h&gt;</code>，你可以进行各种时间相关的操作，比如：</p>
<ul>
<li>获取当前时间和日期。</li>
<li>在不同的时间表示之间进行转换（比如 <code>time_t</code> 和 <code>struct tm</code>）。</li>
<li>将时间值格式化为字符串。</li>
<li>对时间值进行算术运算。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> currentTime;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">localTime</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    currentTime = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前时间转换为本地时间</span></span><br><span class="line">    localTime = localtime(&amp;currentTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示本地时间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前本地时间和日期：%s&quot;</span>, asctime(localTime));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>&lt;time.h&gt;</code> 中的函数获取当前本地时间和日期，并将其打印到控制台。</p>
<p>请注意，虽然 <code>&lt;time.h&gt;</code> 提供了在 C 中进行基本日期和时间操作的功能，但是对于更高级的操作或在 C++ 中进行操作时，可能有更现代和功能更强大的库可用，比如 C++ 中的 <code>&lt;chrono&gt;</code>，或者其他库提供的更高级抽象。</p>
<h2 id="Linux-POSIX-time-详解"><a href="#Linux-POSIX-time-详解" class="headerlink" title="Linux POSIX &lt;time.h&gt; time()  详解"></a>Linux POSIX &lt;time.h&gt; time()  详解</h2><p><code>time()</code> 是 POSIX 操作系统中 <code>&lt;time.h&gt;</code> 头文件中所定义的一个函数，用于获取当前系统时间，并以 <code>time_t</code> 格式返回从 Epoch（1970 年 1 月 1 日 00:00:00 UTC）到当前时间经过的秒数。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *seconds)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：返回一个 <code>time_t</code> 类型的值，表示自 Epoch 起至当前时间经过的秒数。</li>
<li><strong>参数</strong>：<ul>
<li><code>seconds</code>（可选）：一个指向 <code>time_t</code> 类型变量的指针。如果不为 <code>NULL</code>，函数会把获取到的当前时间也存储在这个指针所指向的位置，以便于进一步使用。</li>
</ul>
</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> currentTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    currentTime = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前时间（自 Epoch 起的秒数）：%lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)currentTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释示例："><a href="#解释示例：" class="headerlink" title="解释示例："></a>解释示例：</h3><ol>
<li>引入 <code>&lt;stdio.h&gt;</code> 和 <code>&lt;time.h&gt;</code> 头文件。</li>
<li>声明一个 <code>time_t</code> 类型的变量 <code>currentTime</code>。</li>
<li>使用 <code>time(NULL)</code> 函数来获取当前时间，<code>NULL</code> 作为参数意味着函数只返回当前时间，不将其存储到其他地方。</li>
<li>使用 <code>printf()</code> 将获取的当前时间值打印出来。</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>time()</code> 函数返回的时间值通常是自 Epoch（1970 年 1 月 1 日 00:00:00 UTC）起至当前时间的秒数。这个值的精度因系统而异，一般是秒级别的精度。</li>
<li>如果 <code>seconds</code> 参数不为 <code>NULL</code>，则会将当前时间的值保存到这个参数所指向的位置，方便进一步处理。</li>
</ul>
<p><code>time()</code> 函数在 C 编程中常用于获取时间戳或者记录程序运行时间等任务。</p>
<h2 id="Linux-POSIX-gmtime-详解"><a href="#Linux-POSIX-gmtime-详解" class="headerlink" title="Linux POSIX &lt;time.h&gt; gmtime()  详解"></a>Linux POSIX &lt;time.h&gt; gmtime()  详解</h2><p><code>gmtime()</code> 是 POSIX 操作系统中 <code>&lt;time.h&gt;</code> 头文件中定义的一个函数，用于将 <code>time_t</code> 类型的时间值（从 Epoch 起的秒数）转换为一个 UTC（协调世界时）时间的结构体表示，即 <code>struct tm</code> 类型。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：返回一个指向 <code>struct tm</code> 结构体的指针，其中包含了由 <code>time_t</code> 值表示的 UTC 时间的各个分量。</li>
<li><strong>参数</strong>：<ul>
<li><code>timep</code>：一个指向 <code>time_t</code> 类型变量的指针，表示待转换的时间值。</li>
</ul>
</li>
</ul>
<h3 id="struct-tm-结构体定义："><a href="#struct-tm-结构体定义：" class="headerlink" title="struct tm 结构体定义："></a><code>struct tm</code> 结构体定义：</h3><p><code>struct tm</code> 结构体包含了表示时间的各个成员变量，例如年、月、日、小时、分钟、秒等，它的定义通常如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> tm_sec;   <span class="comment">// 秒，范围 0-59</span></span><br><span class="line">    <span class="type">int</span> tm_min;   <span class="comment">// 分，范围 0-59</span></span><br><span class="line">    <span class="type">int</span> tm_hour;  <span class="comment">// 小时，范围 0-23</span></span><br><span class="line">    <span class="type">int</span> tm_mday;  <span class="comment">// 一个月中的日期，范围 1-31</span></span><br><span class="line">    <span class="type">int</span> tm_mon;   <span class="comment">// 月份，从一月开始计数，范围 0-11</span></span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">// 自 1900 年起至今的年数</span></span><br><span class="line">    <span class="type">int</span> tm_wday;  <span class="comment">// 一周中的天数，范围 0-6 (0 表示周日)</span></span><br><span class="line">    <span class="type">int</span> tm_yday;  <span class="comment">// 一年中的天数，范围 0-365</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">// 夏令时标志（0 表示不使用夏令时，正值表示夏令时，负值表示信息不可用）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> currentTime;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">utcTime</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    currentTime = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前时间转换为 UTC 时间</span></span><br><span class="line">    utcTime = gmtime(&amp;currentTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示 UTC 时间的各个成员</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UTC 时间：%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>,</span><br><span class="line">        utcTime-&gt;tm_year + <span class="number">1900</span>, utcTime-&gt;tm_mon + <span class="number">1</span>, utcTime-&gt;tm_mday,</span><br><span class="line">        utcTime-&gt;tm_hour, utcTime-&gt;tm_min, utcTime-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释示例：-1"><a href="#解释示例：-1" class="headerlink" title="解释示例："></a>解释示例：</h3><ol>
<li>引入 <code>&lt;stdio.h&gt;</code> 和 <code>&lt;time.h&gt;</code> 头文件。</li>
<li>声明一个 <code>time_t</code> 类型的变量 <code>currentTime</code> 和一个指向 <code>struct tm</code> 的指针 <code>utcTime</code>。</li>
<li>使用 <code>time(NULL)</code> 函数获取当前时间。</li>
<li>使用 <code>gmtime(&amp;currentTime)</code> 函数将获取的时间转换为 UTC 时间，并将结果保存在 <code>utcTime</code> 指针指向的位置。</li>
<li>使用 <code>printf()</code> 打印 UTC 时间的各个成员变量，需要注意月份应加一、年份需要加上 1900。</li>
</ol>
<p><code>gmtime()</code> 函数将 <code>time_t</code> 类型的时间值转换为 UTC 时间的结构体表示，方便对时间进行更详细的分析和处理。</p>
<h2 id="Linux-POSIX-localtime-详解"><a href="#Linux-POSIX-localtime-详解" class="headerlink" title="Linux POSIX &lt;time.h&gt; localtime()  详解"></a>Linux POSIX &lt;time.h&gt; localtime()  详解</h2><p><code>localtime()</code> 是 POSIX 操作系统中 <code>&lt;time.h&gt;</code> 头文件中定义的一个函数，用于将 <code>time_t</code> 类型的时间值（从 Epoch 起的秒数）转换为一个本地时间的结构体表示，即 <code>struct tm</code> 类型。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：返回一个指向 <code>struct tm</code> 结构体的指针，其中包含了由 <code>time_t</code> 值表示的本地时间的各个分量。</li>
<li><strong>参数</strong>：<ul>
<li><code>timep</code>：一个指向 <code>time_t</code> 类型变量的指针，表示待转换的时间值。</li>
</ul>
</li>
</ul>
<h3 id="struct-tm-结构体定义：-1"><a href="#struct-tm-结构体定义：-1" class="headerlink" title="struct tm 结构体定义："></a><code>struct tm</code> 结构体定义：</h3><p><code>struct tm</code> 结构体包含了表示时间的各个成员变量，例如年、月、日、小时、分钟、秒等，它的定义通常如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> tm_sec;   <span class="comment">// 秒，范围 0-59</span></span><br><span class="line">    <span class="type">int</span> tm_min;   <span class="comment">// 分，范围 0-59</span></span><br><span class="line">    <span class="type">int</span> tm_hour;  <span class="comment">// 小时，范围 0-23</span></span><br><span class="line">    <span class="type">int</span> tm_mday;  <span class="comment">// 一个月中的日期，范围 1-31</span></span><br><span class="line">    <span class="type">int</span> tm_mon;   <span class="comment">// 月份，从一月开始计数，范围 0-11</span></span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">// 自 1900 年起至今的年数</span></span><br><span class="line">    <span class="type">int</span> tm_wday;  <span class="comment">// 一周中的天数，范围 0-6 (0 表示周日)</span></span><br><span class="line">    <span class="type">int</span> tm_yday;  <span class="comment">// 一年中的天数，范围 0-365</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">// 夏令时标志（0 表示不使用夏令时，正值表示夏令时，负值表示信息不可用）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> currentTime;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">localTime</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    currentTime = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前时间转换为本地时间</span></span><br><span class="line">    localTime = localtime(&amp;currentTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示本地时间的各个成员</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;本地时间：%d-%02d-%02d %02d:%02d:%02d\n&quot;</span>,</span><br><span class="line">        localTime-&gt;tm_year + <span class="number">1900</span>, localTime-&gt;tm_mon + <span class="number">1</span>, localTime-&gt;tm_mday,</span><br><span class="line">        localTime-&gt;tm_hour, localTime-&gt;tm_min, localTime-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释示例：-2"><a href="#解释示例：-2" class="headerlink" title="解释示例："></a>解释示例：</h3><ol>
<li>引入 <code>&lt;stdio.h&gt;</code> 和 <code>&lt;time.h&gt;</code> 头文件。</li>
<li>声明一个 <code>time_t</code> 类型的变量 <code>currentTime</code> 和一个指向 <code>struct tm</code> 的指针 <code>localTime</code>。</li>
<li>使用 <code>time(NULL)</code> 函数获取当前时间。</li>
<li>使用 <code>localtime(&amp;currentTime)</code> 函数将获取的时间转换为本地时间，并将结果保存在 <code>localTime</code> 指针指向的位置。</li>
<li>使用 <code>printf()</code> 打印本地时间的各个成员变量，需要注意月份应加一、年份需要加上 1900。</li>
</ol>
<p><code>localtime()</code> 函数将 <code>time_t</code> 类型的时间值转换为本地时间的结构体表示，这样就可以方便地对时间进行更详细的分析和处理，并以易读的形式输出。</p>
<h2 id="Linux-POSIX-mktime-详解"><a href="#Linux-POSIX-mktime-详解" class="headerlink" title="Linux POSIX &lt;time.h&gt; mktime()  详解"></a>Linux POSIX &lt;time.h&gt; mktime()  详解</h2><p><code>mktime()</code> 是 POSIX 操作系统中 <code>&lt;time.h&gt;</code> 头文件中定义的一个函数，用于将一个表示日期和时间的 <code>struct tm</code> 结构体转换为 <code>time_t</code> 类型的时间值（从 Epoch 起的秒数）。</p>
<h3 id="函数签名：-3"><a href="#函数签名：-3" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *timeptr)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：返回一个 <code>time_t</code> 类型的值，表示由 <code>struct tm</code> 结构体表示的时间值，即从 Epoch 起的秒数。</li>
<li><strong>参数</strong>：<ul>
<li><code>timeptr</code>：一个指向 <code>struct tm</code> 结构体的指针，表示待转换为 <code>time_t</code> 类型的时间值。</li>
</ul>
</li>
</ul>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">dateTime</span>;</span></span><br><span class="line">    <span class="type">time_t</span> timeValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充日期和时间信息到 struct tm 结构体</span></span><br><span class="line">    dateTime.tm_year = <span class="number">2023</span> - <span class="number">1900</span>; <span class="comment">// 年份从 1900 开始计数</span></span><br><span class="line">    dateTime.tm_mon = <span class="number">11</span> - <span class="number">1</span>;       <span class="comment">// 月份从 0 开始计数</span></span><br><span class="line">    dateTime.tm_mday = <span class="number">23</span>;          <span class="comment">// 日期</span></span><br><span class="line">    dateTime.tm_hour = <span class="number">10</span>;          <span class="comment">// 小时</span></span><br><span class="line">    dateTime.tm_min = <span class="number">30</span>;           <span class="comment">// 分钟</span></span><br><span class="line">    dateTime.tm_sec = <span class="number">0</span>;            <span class="comment">// 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 struct tm 结构体转换为 time_t 类型的时间值</span></span><br><span class="line">    timeValue = mktime(&amp;dateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示转换后的时间值（从 Epoch 起的秒数）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;转换后的时间值：%lld\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)timeValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释示例：-3"><a href="#解释示例：-3" class="headerlink" title="解释示例："></a>解释示例：</h3><ol>
<li>引入 <code>&lt;stdio.h&gt;</code> 和 <code>&lt;time.h&gt;</code> 头文件。</li>
<li>声明一个 <code>struct tm</code> 类型的变量 <code>dateTime</code> 和一个 <code>time_t</code> 类型的变量 <code>timeValue</code>。</li>
<li>填充 <code>struct tm</code> 结构体 <code>dateTime</code> 中的年、月、日、小时、分钟、秒等成员变量。</li>
<li>使用 <code>mktime(&amp;dateTime)</code> 函数将 <code>struct tm</code> 结构体转换为 <code>time_t</code> 类型的时间值，并将结果保存在 <code>timeValue</code> 变量中。</li>
<li>使用 <code>printf()</code> 打印转换后的时间值（从 Epoch 起的秒数）。</li>
</ol>
<p><code>mktime()</code> 函数将日期和时间信息从 <code>struct tm</code> 结构体转换为 <code>time_t</code> 类型的时间值，方便在不同的时间表示之间进行转换。</p>
<h2 id="Linux-POSIX-strftime-详解"><a href="#Linux-POSIX-strftime-详解" class="headerlink" title="Linux POSIX &lt;time.h&gt; strftime()  详解"></a>Linux POSIX &lt;time.h&gt; strftime()  详解</h2><p><code>strftime()</code> 是 POSIX 操作系统中 <code>&lt;time.h&gt;</code> 头文件中定义的一个函数，用于将 <code>struct tm</code> 结构体表示的时间值格式化为指定格式的字符串。</p>
<h3 id="函数签名：-4"><a href="#函数签名：-4" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *s, <span class="type">size_t</span> maxsize, <span class="type">const</span> <span class="type">char</span> *format, <span class="type">const</span> <span class="keyword">struct</span> tm *timeptr)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：返回生成的字符串的字符数（不包括空字符 <code>\0</code>），如果格式化失败或者输出的字符串超出了 <code>maxsize</code> 的限制，则返回 0。</li>
<li><strong>参数</strong>：<ul>
<li><code>s</code>：一个指向字符数组的指针，用于存储生成的格式化后的字符串。</li>
<li><code>maxsize</code>：字符数组 <code>s</code> 的最大长度，以防止溢出。</li>
<li><code>format</code>：一个表示输出格式的字符串。该格式字符串可以包含转换说明符以及普通字符。</li>
<li><code>timeptr</code>：一个指向 <code>struct tm</code> 结构体的指针，表示待格式化的时间值。</li>
</ul>
</li>
</ul>
<h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">dateTime</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充日期和时间信息到 struct tm 结构体</span></span><br><span class="line">    dateTime.tm_year = <span class="number">2023</span> - <span class="number">1900</span>; <span class="comment">// 年份从 1900 开始计数</span></span><br><span class="line">    dateTime.tm_mon = <span class="number">11</span> - <span class="number">1</span>;       <span class="comment">// 月份从 0 开始计数</span></span><br><span class="line">    dateTime.tm_mday = <span class="number">23</span>;          <span class="comment">// 日期</span></span><br><span class="line">    dateTime.tm_hour = <span class="number">10</span>;          <span class="comment">// 小时</span></span><br><span class="line">    dateTime.tm_min = <span class="number">30</span>;           <span class="comment">// 分钟</span></span><br><span class="line">    dateTime.tm_sec = <span class="number">0</span>;            <span class="comment">// 秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化 struct tm 结构体中的时间信息为字符串</span></span><br><span class="line">    strftime(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, &amp;dateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示格式化后的字符串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;格式化后的时间字符串：%s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释示例：-4"><a href="#解释示例：-4" class="headerlink" title="解释示例："></a>解释示例：</h3><ol>
<li>引入 <code>&lt;stdio.h&gt;</code> 和 <code>&lt;time.h&gt;</code> 头文件。</li>
<li>声明一个 <code>struct tm</code> 类型的变量 <code>dateTime</code> 和一个字符数组 <code>buffer</code>。</li>
<li>填充 <code>struct tm</code> 结构体 <code>dateTime</code> 中的年、月、日、小时、分钟、秒等成员变量。</li>
<li>使用 <code>strftime()</code> 函数将 <code>struct tm</code> 结构体中的时间信息格式化为字符串，按照给定的格式 <code>&quot;%Y-%m-%d %H:%M:%S&quot;</code>（表示年-月-日 时:分:秒）。</li>
<li>生成的格式化后的字符串保存在 <code>buffer</code> 数组中，并使用 <code>printf()</code> 打印出来。</li>
</ol>
<p><code>strftime()</code> 函数可以根据指定的格式将 <code>struct tm</code> 结构体表示的时间值格式化为字符串，非常方便用于生成各种不同格式的日期时间字符串。</p>
<h2 id="Linux-POSIX-difftime-详解"><a href="#Linux-POSIX-difftime-详解" class="headerlink" title="Linux POSIX &lt;time.h&gt; difftime()  详解"></a>Linux POSIX &lt;time.h&gt; difftime()  详解</h2><p><code>difftime()</code> 是 POSIX 操作系统中 <code>&lt;time.h&gt;</code> 头文件中定义的一个函数，用于计算两个 <code>time_t</code> 类型的时间值之间的差异，返回结果以秒为单位。</p>
<h3 id="函数签名：-5"><a href="#函数签名：-5" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">difftime</span><span class="params">(<span class="type">time_t</span> time1, <span class="type">time_t</span> time0)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：返回一个 <code>double</code> 类型的值，表示两个时间值之间的差异（以秒为单位）。</li>
<li><strong>参数</strong>：<ul>
<li><code>time1</code>：第一个 <code>time_t</code> 类型的时间值。</li>
<li><code>time0</code>：第二个 <code>time_t</code> 类型的时间值。</li>
</ul>
</li>
</ul>
<h3 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">time_t</span> currentTime;</span><br><span class="line">    <span class="type">time_t</span> startTime;</span><br><span class="line">    <span class="type">double</span> difference;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间和起始时间</span></span><br><span class="line">    currentTime = time(<span class="literal">NULL</span>);</span><br><span class="line">    startTime = <span class="number">1638732000</span>; <span class="comment">// 2021-12-06 12:00:00 的时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两个时间之间的差异</span></span><br><span class="line">    difference = difftime(currentTime, startTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示两个时间之间的差异（秒数）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;时间差：%f 秒\n&quot;</span>, difference);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释示例：-5"><a href="#解释示例：-5" class="headerlink" title="解释示例："></a>解释示例：</h3><ol>
<li>引入 <code>&lt;stdio.h&gt;</code> 和 <code>&lt;time.h&gt;</code> 头文件。</li>
<li>声明 <code>time_t</code> 类型的变量 <code>currentTime</code>、<code>startTime</code> 和 <code>double</code> 类型的变量 <code>difference</code>。</li>
<li>使用 <code>time(NULL)</code> 获取当前时间戳 <code>currentTime</code>，并将特定日期时间的时间戳（<code>2021-12-06 12:00:00</code>）存储在 <code>startTime</code> 变量中。</li>
<li>使用 <code>difftime()</code> 函数计算当前时间 <code>currentTime</code> 和特定起始时间 <code>startTime</code> 之间的差异。</li>
<li>将计算得到的时间差异（秒数）显示在控制台上。</li>
</ol>
<p><code>difftime()</code> 函数可用于计算两个 <code>time_t</code> 类型的时间值之间的差异，常用于测量时间间隔或计算程序执行时间等场景。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/19/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/21/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
