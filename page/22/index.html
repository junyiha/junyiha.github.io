<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/22/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/22/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_06_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-C++_06_3_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_06_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-C++_06_3_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">C++_06_3_编程技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++编程技巧</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/C++/C++_06_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-C++_06_3_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_0_readme/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_0_readme/" class="post-title-link" itemprop="url">C++_10_0_readme</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++标准库模块</li>
</ul>
<h2 id="文件列表"><a href="#文件列表" class="headerlink" title="文件列表"></a>文件列表</h2><ul>
<li><p>readme</p>
<ul>
<li>C++_10_00_readme</li>
</ul>
</li>
<li><p>random</p>
<ul>
<li>C++_10_01_random</li>
</ul>
</li>
<li><p>algorithm</p>
<ul>
<li>C++_10_02_algorithm</li>
</ul>
</li>
<li><p>vector</p>
<ul>
<li>C++_10_03_vector</li>
</ul>
</li>
<li><p>chrono</p>
<ul>
<li>C++_10_04_chrono</li>
</ul>
</li>
<li><p>string</p>
<ul>
<li>C++_10_05_string</li>
</ul>
</li>
<li><p>cctype</p>
<ul>
<li>C++_10_06_cctype</li>
</ul>
</li>
<li><p>array</p>
<ul>
<li>C++_10_07_array</li>
</ul>
</li>
<li><p>exception</p>
<ul>
<li>C++_10_08_exception</li>
</ul>
</li>
<li><p>memory</p>
<ul>
<li>C++_10_09_memory</li>
</ul>
</li>
<li><p>cstring</p>
<ul>
<li>C++_10_10_cstring</li>
</ul>
</li>
<li><p>version</p>
<ul>
<li>C++_10_11_version</li>
</ul>
</li>
<li><p>thread</p>
<ul>
<li>C++_10_12_thread</li>
</ul>
</li>
<li><p>mutex</p>
<ul>
<li>C++_10_13_mutex</li>
</ul>
</li>
<li><p>condition_variable</p>
<ul>
<li>C++_10_14_condition_variable</li>
</ul>
</li>
<li><p>atomic</p>
<ul>
<li>C++_10_15_atomic</li>
</ul>
</li>
<li><p>regex</p>
<ul>
<li>C++_10_16_regex</li>
</ul>
</li>
<li><p>fstream</p>
<ul>
<li>C++_10_17_fstream</li>
</ul>
</li>
<li><p>cmath</p>
<ul>
<li>C++_10_18_cmath</li>
</ul>
</li>
<li><p>functional</p>
<ul>
<li>C++_10_19_functional</li>
</ul>
</li>
<li><p>initializer_list</p>
<ul>
<li>C++_10_20_initializer_list</li>
</ul>
</li>
<li><p>utility</p>
<ul>
<li>C++_10_21_utility</li>
</ul>
</li>
<li><p>tuple</p>
<ul>
<li>C++_10_22_tuple</li>
</ul>
</li>
<li><p>cstdint</p>
<ul>
<li>C++_10_23_cstdint</li>
</ul>
</li>
<li><p>list</p>
<ul>
<li>C++_10_24_list</li>
</ul>
</li>
<li><p>forward_list</p>
<ul>
<li>C++_10_25_forward_list</li>
</ul>
</li>
<li><p>deque</p>
<ul>
<li>C++_10_26_deque</li>
</ul>
</li>
<li><p>span</p>
<ul>
<li>C++_10_27_span</li>
</ul>
</li>
<li><p>queue</p>
<ul>
<li>C++_10_28_queue</li>
</ul>
</li>
<li><p>stack</p>
<ul>
<li>C++_10_29_stack</li>
</ul>
</li>
<li><p>set</p>
<ul>
<li>C++_10_30_set</li>
</ul>
</li>
<li><p>map</p>
<ul>
<li>C++_10_31_map</li>
</ul>
</li>
<li><p>iomanip</p>
<ul>
<li>C++_10_32_iomanip</li>
</ul>
</li>
<li><p>sstream</p>
<ul>
<li>C++_10_33_sstream</li>
</ul>
</li>
<li><p>future</p>
<ul>
<li>C++_10_34_future</li>
</ul>
</li>
<li><p>bitset</p>
<ul>
<li>C++_10_35_bitset</li>
</ul>
</li>
<li><p>ratio</p>
<ul>
<li>C++_10_36_ratio</li>
</ul>
</li>
<li><p>iterator</p>
<ul>
<li>C++_10_37_iterator</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_07_%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/2024-05-22-C++_07_%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_07_%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/2024-05-22-C++_07_%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">C++_07_常用算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>常见算法</li>
</ul>
<h2 id="Modbus通信协议-CRC16校验码详解"><a href="#Modbus通信协议-CRC16校验码详解" class="headerlink" title="Modbus通信协议 CRC16校验码详解"></a>Modbus通信协议 CRC16校验码详解</h2><p>Modbus通信协议是一种用于在不同设备之间进行通信的协议，常用于工业自动化和控制系统。其中，CRC16校验码是用来验证通信数据的完整性的一部分。</p>
<p>CRC（Cyclic Redundancy Check）是一种错误检测码，通过对数据进行多项式除法运算，生成一个校验码，用于检测数据传输过程中的错误。CRC16是一种使用16位位宽的CRC校验码。</p>
<p>Modbus协议在通信中使用CRC16校验码来确保数据的准确传输。具体而言，CRC16校验码的计算方式是对要发送或接收的数据按照一定规则进行计算，然后将计算得到的校验码附加到数据中，接收方在接收数据后也会进行相同的校验计算，并比较计算得到的校验码是否与接收到的校验码相符，以判断数据是否完整、正确。</p>
<p>以下是CRC16校验码计算的主要步骤：</p>
<ol>
<li>初始化CRC寄存器为0xFFFF。</li>
<li>针对每个字节（8位）的数据，从最高位开始，依次进行以下操作：<ul>
<li>将CRC寄存器的最低位与当前数据位异或（XOR）操作。</li>
<li>对CRC寄存器进行右移一位。</li>
<li>如果异或操作的结果为1，则将CRC寄存器与预定义的多项式（通常是0xA001）进行异或操作。</li>
</ul>
</li>
<li>继续处理下一个字节的数据，重复步骤2，直到所有数据字节都被处理。</li>
<li>最终CRC寄存器中的值即为CRC16校验码。</li>
</ol>
<p>在接收方，接收到数据后，同样使用相同的计算方式进行CRC16校验计算，然后将计算得到的校验码与接收到的校验码比较。如果相符，则说明数据传输没有错误，否则可能存在错误。</p>
<p>需要注意的是，CRC校验并不能纠正错误，而只能检测错误。如果CRC校验不通过，通常需要进行数据重传等处理来保证数据的正确传输。</p>
<p>上述解释是CRC16校验码的基本原理，实际使用中可能会涉及一些细节和配置参数，取决于通信协议的具体要求。不同的Modbus协议变种可能会有稍微不同的CRC16计算方法，因此在实际应用中，需要参考相关的协议文档或标准来进行实现。</p>
<h2 id="C-modbus-crc16-校验码-示例"><a href="#C-modbus-crc16-校验码-示例" class="headerlink" title="C modbus crc16 校验码 示例"></a>C modbus crc16 校验码 示例</h2><p>Modbus通信协议中常使用CRC16校验码来验证数据的完整性。以下是一个示例，展示如何计算Modbus CRC16校验码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算CRC16校验码</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">calculate_crc16</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *data, <span class="type">size_t</span> length)</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> crc = <span class="number">0xFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        crc ^= data[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (crc &amp; <span class="number">0x0001</span>) &#123;</span><br><span class="line">                crc &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                crc ^= <span class="number">0xA001</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                crc &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> crc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">uint8_t</span> data[] = &#123;<span class="number">0x01</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>&#125;; <span class="comment">// 示例数据</span></span><br><span class="line">    <span class="type">size_t</span> data_length = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> crc = calculate_crc16(data, data_length);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CRC16: 0x%04X\n&quot;</span>, crc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>calculate_crc16</code> 函数接受一个字节数组和其长度作为参数，并计算其CRC16校验码。<code>main</code> 函数演示了如何调用该函数来计算示例数据的CRC16校验码。</p>
<p>需要注意的是，CRC16校验码的计算是Modbus通信协议中的一部分，不同的实现可能会有细微的差异。上述示例展示了一个常见的CRC16计算方法，但在实际应用中，你需要根据通信协议的规范和要求来进行计算。</p>
<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><p>在C++中，可以使用标准库提供的范围查找算法来在容器中查找特定元素或满足特定条件的元素。以下是一些常用的范围查找算法：</p>
<ol>
<li><code>std::find()</code>：在指定范围内查找指定值的第一个匹配项。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="comment">// 找到了元素</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有找到元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>std::find_if()</code>：在指定范围内查找满足特定条件的第一个元素。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEven</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), isEven);</span><br><span class="line">    <span class="keyword">if</span> (it != numbers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="comment">// 找到满足条件的元素</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有找到满足条件的元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>std::binary_search()</code>：在已排序的范围内执行二分查找，判断指定值是否存在。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> exists = std::<span class="built_in">binary_search</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (exists) &#123;</span><br><span class="line">        <span class="comment">// 值存在</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 值不存在</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些是一些常见的范围查找算法示例，您可以根据具体的需求选择适合的算法来执行查找操作。请注意，在使用这些算法之前，确保容器已经按照所需的顺序进行了排序（如果需要）。</p>
<h2 id="射线法，判断点在多边形内"><a href="#射线法，判断点在多边形内" class="headerlink" title="射线法，判断点在多边形内"></a>射线法，判断点在多边形内</h2><ul>
<li><p>思路</p>
<ul>
<li>该算法的思路很简单，就是从目标点出发引一条射线，看这条射线和多边形所有边的交点数目。</li>
<li>如果有奇数个交点，则说明在内部，如果有偶数个交点，则说明在外部。</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li>已知点point(x,y)和多边形Polygon的点有序集合（x1,y1;x2,y2;….xn,yn;）</li>
<li>以point为起点，以无穷远为终点作平行于X轴的射线line(x,y; -∞,y)；循环取得多边形的每一条边side(xi,yi;xi+1,yi+1)：<ul>
<li>判断point(x,y)是否在side上，如果是，则返回true。</li>
<li>判断line与side是否有交点，如果有则count++。</li>
</ul>
</li>
<li>判断交点的总数count，如果为奇数则返回true，偶数则返回false。</li>
</ul>
</li>
</ul>
<h2 id="判断矩形框是否在多边形区域内"><a href="#判断矩形框是否在多边形区域内" class="headerlink" title="判断矩形框是否在多边形区域内"></a>判断矩形框是否在多边形区域内</h2><p>要判断一个矩形框是否在多边形区域内，可以使用点与多边形边界的位置关系进行判断。下面是一个简单的示例，展示了如何判断一个矩形框是否在多边形区域内部：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断点是否在多边形内部</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isInsidePolygon</span><span class="params">(<span class="type">const</span> Point&amp; point, <span class="type">const</span> std::vector&lt;Point&gt;&amp; polygon)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = polygon.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">bool</span> inside = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; n; j = i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((polygon[i].y &gt; point.y) != (polygon[j].y &gt; point.y)) &amp;&amp;</span><br><span class="line">            (point.x &lt; (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) &#123;</span><br><span class="line">            inside = !inside;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inside;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断矩形框是否在多边形区域内部</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isRectangleInsidePolygon</span><span class="params">(<span class="type">const</span> std::vector&lt;Point&gt;&amp; rectangle, <span class="type">const</span> std::vector&lt;Point&gt;&amp; polygon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Point&amp; point : rectangle) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isInsidePolygon</span>(point, polygon)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;Point&gt; polygon = &#123;</span><br><span class="line">        &#123;<span class="number">0.0</span>, <span class="number">0.0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5.0</span>, <span class="number">0.0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5.0</span>, <span class="number">5.0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0.0</span>, <span class="number">5.0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Point&gt; rectangle = &#123;</span><br><span class="line">        &#123;<span class="number">1.0</span>, <span class="number">1.0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4.0</span>, <span class="number">1.0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4.0</span>, <span class="number">4.0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1.0</span>, <span class="number">4.0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isRectangleInsidePolygon</span>(rectangle, polygon)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;矩形框在多边形区域内&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;矩形框不在多边形区域内&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用了射线法的思想来判断点是否在多边形内部，然后将该方法应用到矩形框的每个顶点。函数 <code>isInsidePolygon</code> 判断点是否在多边形内部，函数 <code>isRectangleInsidePolygon</code> 判断矩形框的每个顶点是否都在多边形区域内。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_11_version/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_11_version/" class="post-title-link" itemprop="url">C++_10_11_version</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <version>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <version>标准库</h2><p><code>&lt;version&gt;</code> 是 C++17 引入的头文件，它允许开发者检查编译器是否支持特定版本的 C++ 标准库，并提供了编译器和库的版本信息。</p>
<p>通常情况下，可以使用 <code>&lt;version&gt;</code> 头文件来检查 C++ 标准库的支持情况和版本信息。例如，可以通过检查宏来获取编译器和库的版本信息，或者进行预处理以检查特定的 C++ 特性是否可用。</p>
<p>以下是一个简单的示例，演示了如何使用 <code>&lt;version&gt;</code> 头文件获取编译器和库的版本信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;version&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cpp_lib_string_view <span class="comment">// 检查是否支持 string_view</span></span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Compiler supports string_view!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Compiler does not support string_view.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;C++ standard library version: &quot;</span> &lt;&lt; __cplusplus &lt;&lt; std::endl; <span class="comment">// 输出 C++ 标准库版本</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Compiler version: &quot;</span> &lt;&lt; __clang_major__ &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; __clang_minor__ &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; __clang_patchlevel__ &lt;&lt; std::endl; <span class="comment">// 输出编译器版本</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>&lt;version&gt;</code> 头文件被包含，然后使用预处理指令 <code>#ifdef</code> 来检查编译器是否支持 <code>string_view</code> 这一 C++17 特性。然后使用一些预定义的宏（例如 <code>__cplusplus</code>、<code>__clang_major__</code>、<code>__clang_minor__</code> 等）来输出 C++ 标准库和编译器的版本信息。</p>
<p>这种方法可以帮助开发者根据编译器和库的版本信息选择性地使用特定的 C++ 特性，并确保代码在不同的环境下能够正常工作。</p>
<h2 id="C-标准库-常用的宏和函数"><a href="#C-标准库-常用的宏和函数" class="headerlink" title="C++ 标准库 常用的宏和函数"></a>C++ <version>标准库 常用的宏和函数</h2><p><code>&lt;version&gt;</code> 头文件主要用于检查编译器对 C++ 标准库的支持情况，并提供了一些宏来表示不同的 C++ 特性。常用的一些宏和函数如下：</p>
<h3 id="宏："><a href="#宏：" class="headerlink" title="宏："></a>宏：</h3><ol>
<li><p><code>__cplusplus</code>：表示编译器支持的 C++ 标准版本。对应的值如下：</p>
<ul>
<li>C++98：值为 <code>199711L</code></li>
<li>C++11：值为 <code>201103L</code></li>
<li>C++14：值为 <code>201402L</code></li>
<li>C++17：值为 <code>201703L</code></li>
<li>C++20：值为 <code>202002L</code></li>
<li>C++23：预计将在未来版本中定义相应的值。</li>
</ul>
</li>
<li><p><code>__has_include(header)</code>：检查编译器是否支持包含某个头文件。例如：<code>__has_include(&lt;string_view&gt;)</code> 可用于检查编译器是否支持 <code>&lt;string_view&gt;</code>。</p>
</li>
<li><p>一些特定的特性检测宏，例如：</p>
<ul>
<li><code>__cpp_lib_string_view</code>：检查编译器是否支持 <code>std::string_view</code>。</li>
<li><code>__cpp_lib_optional</code>：检查编译器是否支持 <code>std::optional</code>。</li>
<li><code>__cpp_lib_variant</code>：检查编译器是否支持 <code>std::variant</code>。</li>
</ul>
</li>
</ol>
<h3 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h3><p><code>&lt;version&gt;</code> 头文件本身并没有定义函数，它主要提供了一些宏来检查特定的特性是否被编译器支持。基于这些宏的检查，开发者可以编写代码以选择性地使用特定版本的 C++ 特性或标准库组件。</p>
<p>例如，可以使用类似于 <code>#ifdef __cpp_lib_string_view</code> 的条件语句来检查编译器是否支持 <code>std::string_view</code>，从而在代码中选择性地使用这个特性。</p>
<p>使用 <code>&lt;version&gt;</code> 头文件和其中定义的宏，可以更加方便地编写跨平台和兼容不同编译器版本的 C++ 代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_12_thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_12_thread/" class="post-title-link" itemprop="url">C++_10_12_thread</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <thread>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <thread>标准库</h2><p><code>&lt;thread&gt;</code> 是 C++ 标准库中提供的头文件，用于支持多线程编程。它包含了许多与线程相关的类、函数和工具，使得开发者能够创建、管理和控制线程。</p>
<p>以下是 <code>&lt;thread&gt;</code> 标准库中常用的一些类和函数：</p>
<h3 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h3><ol>
<li><p><strong>std::thread</strong>：表示一个线程对象。通过实例化 <code>std::thread</code> 类，可以创建一个新的线程来执行指定的函数或可调用对象。</p>
</li>
<li><p><strong>std::mutex</strong>：互斥量类，用于在多线程环境中保护共享资源，防止多个线程同时访问。</p>
</li>
<li><p><strong>std::condition_variable</strong>：条件变量类，用于在多线程间进行通信和同步，允许线程等待特定的条件。</p>
</li>
<li><p><strong>std::atomic</strong>：提供了原子操作，用于在多线程环境下执行原子操作，避免竞态条件。</p>
</li>
</ol>
<h3 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h3><ol>
<li><p>**std::this_thread::sleep_for()**：让当前线程休眠指定的时间段。</p>
</li>
<li><p>**std::this_thread::get_id()**：获取当前线程的唯一标识符。</p>
</li>
<li><p>**std::thread::join()**：等待线程结束，阻塞当前线程直到该线程完成执行。</p>
</li>
<li><p>**std::thread::detach()**：分离线程，允许线程在后台运行，不需要等待其完成。</p>
</li>
<li><p><strong>std::mutex::lock()</strong> 和 **std::mutex::unlock()**：分别用于互斥量的锁定和解锁。</p>
</li>
</ol>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread</span><span class="params">(threadFunction)</span></span>; <span class="comment">// 创建新线程</span></span><br><span class="line"></span><br><span class="line">    myThread.<span class="built_in">join</span>(); <span class="comment">// 等待线程执行完毕</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了如何使用 <code>&lt;thread&gt;</code> 标准库创建新的线程，并在主线程中等待新线程的执行结束。<code>std::thread</code> 类被用来创建一个执行 <code>threadFunction</code> 函数的新线程。然后，<code>join()</code> 函数被用来等待新线程执行完成，使得主线程可以在新线程执行完成后继续执行。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <thread>标准库 常用的类和函数</h2><p><code>&lt;thread&gt;</code> 标准库提供了许多用于多线程编程的类和函数。以下是其中一些常用的类和函数：</p>
<h3 id="类：-1"><a href="#类：-1" class="headerlink" title="类："></a>类：</h3><ol>
<li><p><strong>std::thread</strong>：表示一个线程对象。通过 <code>std::thread</code> 类，可以创建一个新的线程来执行指定的函数或可调用对象。</p>
</li>
<li><p><strong>std::mutex</strong>：互斥量类，用于在多线程环境中保护共享资源，防止多个线程同时访问。</p>
</li>
<li><p><strong>std::condition_variable</strong>：条件变量类，用于在多线程间进行通信和同步，允许线程等待特定的条件。</p>
</li>
<li><p><strong>std::atomic</strong>：提供了原子操作，用于在多线程环境下执行原子操作，避免竞态条件。</p>
</li>
<li><p><strong>std::thread::id</strong>：表示线程的唯一标识符。</p>
</li>
</ol>
<h3 id="函数：-1"><a href="#函数：-1" class="headerlink" title="函数："></a>函数：</h3><ol>
<li><p>**std::thread::join()**：等待线程结束，阻塞当前线程直到该线程完成执行。</p>
</li>
<li><p>**std::thread::detach()**：分离线程，允许线程在后台运行，不需要等待其完成。</p>
</li>
<li><p>**std::this_thread::sleep_for()**：让当前线程休眠指定的时间段。</p>
</li>
<li><p>**std::this_thread::get_id()**：获取当前线程的唯一标识符。</p>
</li>
<li><p><strong>std::mutex::lock()</strong> 和 **std::mutex::unlock()**：分别用于互斥量的锁定和解锁。</p>
</li>
<li><p><strong>std::condition_variable::wait()</strong> 和 **std::condition_variable::notify_one()**：用于条件变量的等待和唤醒操作。</p>
</li>
</ol>
<h3 id="示例用法：-1"><a href="#示例用法：-1" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lck, [] &#123; <span class="keyword">return</span> ready; &#125;); <span class="comment">// 等待条件变量为 true</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread is processing...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// Perform work here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(workerThread)</span></span>; <span class="comment">// 创建新线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做一些其他工作...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待一段时间后，设置条件变量为 true</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 唤醒等待的线程</span></span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 等待线程执行完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>&lt;thread&gt;</code> 标准库中的类和函数进行线程的创建、同步和通信。主线程设置条件变量为 <code>true</code> 并唤醒等待的工作线程，从而使得工作线程可以执行相应的任务。</p>
<h2 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h2><p><code>std::thread</code> 是 C++ 标准库 <code>&lt;thread&gt;</code> 中定义的类，用于表示一个线程对象。通过 <code>std::thread</code> 类，可以创建新的线程来执行指定的函数或可调用对象。</p>
<h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><p><code>std::thread</code> 对象的构造函数可以接受函数、可调用对象（函数对象、Lambda 表达式等）作为参数，并在新的线程中执行。构造函数的基本形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">myThread</span><span class="params">(myFunction)</span></span>; <span class="comment">// 通过函数创建新线程</span></span><br><span class="line"><span class="function">std::thread <span class="title">myThread2</span><span class="params">([] &#123; <span class="comment">/* Lambda 表达式 */</span> &#125;)</span></span>; <span class="comment">// 通过 Lambda 表达式创建新线程</span></span><br></pre></td></tr></table></figure>

<h3 id="成员函数和操作："><a href="#成员函数和操作：" class="headerlink" title="成员函数和操作："></a>成员函数和操作：</h3><ol>
<li><p>**join()**：等待线程结束，阻塞当前线程直到该线程完成执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myThread.<span class="built_in">join</span>(); <span class="comment">// 等待 myThread 执行完毕</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**detach()**：分离线程，允许线程在后台运行，不需要等待其完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myThread.<span class="built_in">detach</span>(); <span class="comment">// 分离 myThread</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**get_id()**：获取线程的唯一标识符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::thread::id threadId = myThread.<span class="built_in">get_id</span>(); <span class="comment">// 获取 myThread 的线程标识符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**joinable()**：检查线程是否可连接，即是否可以调用 <code>join()</code> 或 <code>detach()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (myThread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">    <span class="comment">// 可以调用 join() 或 detach()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="示例用法：-2"><a href="#示例用法：-2" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread function, x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread</span><span class="params">(threadFunction, value)</span></span>; <span class="comment">// 创建新线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (myThread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">        myThread.<span class="built_in">join</span>(); <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>std::thread</code> 类被用来创建一个执行 <code>threadFunction</code> 函数的新线程。主线程使用 <code>join()</code> 函数等待新线程的执行结束。在创建线程时，可以传递函数名或可调用对象，并且可以携带参数供线程函数使用。</p>
<h2 id="std-thread-join"><a href="#std-thread-join" class="headerlink" title="std::thread::join()"></a>std::thread::join()</h2><p><code>std::thread::join()</code> 是 <code>std::thread</code> 类的成员函数，用于等待线程的结束。调用 <code>join()</code> 函数会使当前线程阻塞，直到对应的 <code>std::thread</code> 对象所代表的线程执行完毕。</p>
<h3 id="用法示例："><a href="#用法示例：" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 执行一些任务...</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>)); <span class="comment">// 模拟线程执行耗时操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread completed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread</span><span class="params">(threadFunction)</span></span>; <span class="comment">// 创建新线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (myThread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">        myThread.<span class="built_in">join</span>(); <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main thread: Thread joined.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main thread: Thread cannot be joined.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::thread::join()</code> 被用来等待 <code>myThread</code> 所代表的线程执行完毕。<code>join()</code> 函数使得主线程进入阻塞状态，直到 <code>myThread</code> 线程执行完毕，然后继续执行主线程的后续代码。</p>
<h2 id="std-thread-detach"><a href="#std-thread-detach" class="headerlink" title="std::thread::detach()"></a>std::thread::detach()</h2><p><code>std::thread::detach()</code> 是 <code>std::thread</code> 类的成员函数，用于将 <code>std::thread</code> 对象所代表的线程与 <code>std::thread</code> 对象分离。一旦调用了 <code>detach()</code>，<code>std::thread</code> 对象将不再与实际线程相关联，且不再具有对线程的控制能力。</p>
<h3 id="用法示例：-1"><a href="#用法示例：-1" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 执行一些任务...</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>)); <span class="comment">// 模拟线程执行耗时操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread completed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread</span><span class="params">(threadFunction)</span></span>; <span class="comment">// 创建新线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (myThread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">        myThread.<span class="built_in">detach</span>(); <span class="comment">// 分离线程</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main thread: Thread detached.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main thread: Thread cannot be detached.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里主线程不会等待新线程执行完毕，直接退出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::thread::detach()</code> 被用来分离 <code>myThread</code> 所代表的线程。调用了 <code>detach()</code> 后，<code>myThread</code> 不再与线程相关联，即使 <code>myThread</code> 所代表的线程仍在执行，主线程也不会等待该线程完成。调用 <code>detach()</code> 后，<code>myThread</code> 对象将不再具有对线程的控制能力，也不再需要调用 <code>join()</code>。</p>
<h2 id="std-thread-get-id"><a href="#std-thread-get-id" class="headerlink" title="std::thread::get_id()"></a>std::thread::get_id()</h2><p><code>std::thread::get_id()</code> 是 <code>std::thread</code> 类的成员函数，用于获取表示特定线程的唯一标识符。</p>
<h3 id="用法示例：-2"><a href="#用法示例：-2" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取线程的唯一标识符</span></span><br><span class="line">    std::thread::id threadId = std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; threadId &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread</span><span class="params">(threadFunction)</span></span>; <span class="comment">// 创建新线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (myThread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">        myThread.<span class="built_in">join</span>(); <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::thread::get_id()</code> 被用来获取表示线程的唯一标识符。<code>std::thread::id</code> 是一个表示线程标识符的类型，可以通过 <code>get_id()</code> 函数获取当前线程的标识符，然后将其打印输出。</p>
<p>请注意，线程的标识符类型是 <code>std::thread::id</code>，它可以通过 <code>get_id()</code> 函数来获取。这个标识符是在每个线程创建时由操作系统生成的，用于唯一标识一个线程。</p>
<h2 id="std-thread-joinable"><a href="#std-thread-joinable" class="headerlink" title="std::thread::joinable()"></a>std::thread::joinable()</h2><p><code>std::thread::joinable()</code> 是 <code>std::thread</code> 类的成员函数，用于检查 <code>std::thread</code> 对象是否与实际的线程相关联，即该线程是否可连接（joinable）。</p>
<h3 id="用法示例：-3"><a href="#用法示例：-3" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread is running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 执行一些任务...</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>)); <span class="comment">// 模拟线程执行耗时操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread completed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">myThread</span><span class="params">(threadFunction)</span></span>; <span class="comment">// 创建新线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (myThread.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread is joinable.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        myThread.<span class="built_in">join</span>(); <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread is not joinable.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::thread::joinable()</code> 被用来检查 <code>myThread</code> 对象是否与实际线程相关联。如果线程可以连接（即可等待其完成），则调用 <code>join()</code> 函数等待线程执行完毕。否则，输出提示线程不可连接。调用 <code>joinable()</code> 函数可以避免在不可连接的线程上调用 <code>join()</code> 或 <code>detach()</code> 导致的未定义行为。</p>
<h2 id="std-this-thread"><a href="#std-this-thread" class="headerlink" title="std::this_thread"></a>std::this_thread</h2><p><code>std::this_thread</code> 是 C++ 标准库中 <code>&lt;thread&gt;</code> 头文件中定义的命名空间，提供了一些与当前线程相关的功能和信息。</p>
<h3 id="主要成员函数："><a href="#主要成员函数：" class="headerlink" title="主要成员函数："></a>主要成员函数：</h3><ol>
<li><p>**std::this_thread::get_id()**：获取当前线程的唯一标识符，返回类型为 <code>std::thread::id</code>。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::thread::id threadId = std::this_thread::<span class="built_in">get_id</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>**std::this_thread::sleep_for()**：让当前线程休眠指定的时间段。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 休眠 2 秒</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**std::this_thread::yield()**：提示线程调度器当前线程愿意让出 CPU 时间片给其他线程。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 提示线程调度器让出 CPU 时间片</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="示例用法：-3"><a href="#示例用法：-3" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread::id threadId = std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; threadId &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread completed sleep.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">myThread</span><span class="params">(threadFunction)</span></span>; <span class="comment">// 创建新线程</span></span><br><span class="line"></span><br><span class="line">    myThread.<span class="built_in">join</span>(); <span class="comment">// 等待线程执行完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::this_thread</code> 被用来获取当前线程的标识符，并在主线程和另一个线程中进行输出。同时，<code>sleep_for()</code> 函数被用来让当前线程休眠一段时间。</p>
<h2 id="std-this-thread命名空间下常用的类和函数"><a href="#std-this-thread命名空间下常用的类和函数" class="headerlink" title="std::this_thread命名空间下常用的类和函数"></a>std::this_thread命名空间下常用的类和函数</h2><p>在 <code>std::this_thread</code> 命名空间下，主要包含用于管理和操作当前线程的一些常用类和函数。以下是其中一些常用的类和函数：</p>
<h3 id="类：-2"><a href="#类：-2" class="headerlink" title="类："></a>类：</h3><ol>
<li><p><strong>std::this_thread::id</strong>：表示线程的唯一标识符类型，用于标识当前线程的标识符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::thread::id threadId = std::this_thread::<span class="built_in">get_id</span>(); <span class="comment">// 获取当前线程的标识符</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="函数：-2"><a href="#函数：-2" class="headerlink" title="函数："></a>函数：</h3><ol>
<li><p>**std::this_thread::get_id()**：获取当前线程的唯一标识符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::thread::id threadId = std::this_thread::<span class="built_in">get_id</span>(); <span class="comment">// 获取当前线程的标识符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**std::this_thread::sleep_for()**：让当前线程休眠指定的时间段。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>)); <span class="comment">// 休眠 500 毫秒</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**std::this_thread::sleep_until()**：让当前线程休眠直到指定的时间点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::chrono::time_point&lt;std::chrono::system_clock&gt; timeout = std::chrono::system_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>);</span><br><span class="line">std::this_thread::<span class="built_in">sleep_until</span>(timeout); <span class="comment">// 休眠直到 timeout 时间点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**std::this_thread::yield()**：提示线程调度器当前线程愿意让出 CPU 时间片给其他线程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 提示线程调度器让出 CPU 时间片</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些函数和类型提供了对当前线程的一些基本操作，比如获取线程标识符、线程休眠等，有助于对当前线程进行控制和管理。</p>
<h2 id="std-this-thread-id"><a href="#std-this-thread-id" class="headerlink" title="std::this_thread::id"></a>std::this_thread::id</h2><p><code>std::this_thread::id</code> 是一个类型，用于表示线程的唯一标识符。这个类型代表了当前线程的标识符，并且可以用于区分不同的线程。</p>
<h3 id="主要操作："><a href="#主要操作：" class="headerlink" title="主要操作："></a>主要操作：</h3><ol>
<li><p>**std::this_thread::get_id()**：获取当前线程的唯一标识符。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::thread::id threadId = std::this_thread::<span class="built_in">get_id</span>(); <span class="comment">// 获取当前线程的标识符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>比较操作</strong>：<code>std::this_thread::id</code> 类型的对象支持比较操作符，可以用来检查两个线程标识符是否相等。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::thread::id threadId1 = std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">std::thread::id threadId2 = std::this_thread::<span class="built_in">get_id</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (threadId1 == threadId2) &#123;</span><br><span class="line">    <span class="comment">// 这两个线程标识符相等</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 这两个线程标识符不相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>std::this_thread::id</code> 类型的对象被用于表示线程的唯一标识符，可以用来区分不同的线程。通常，它被用于获取当前线程的标识符并进行比较，以便进行线程相关的操作和判断。</p>
<h2 id="std-this-thread-get-id"><a href="#std-this-thread-get-id" class="headerlink" title="std::this_thread::get_id()"></a>std::this_thread::get_id()</h2><p><code>std::this_thread::get_id()</code> 是 <code>std::this_thread</code> 命名空间中的函数，用于获取当前线程的唯一标识符（ID）。返回值类型是 <code>std::thread::id</code>，这个类型的对象用于唯一标识线程。</p>
<h3 id="用法示例：-4"><a href="#用法示例：-4" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread::id thisThreadId = std::this_thread::<span class="built_in">get_id</span>(); <span class="comment">// 获取当前线程的标识符</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current thread ID: &quot;</span> &lt;&lt; thisThreadId &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数被用来获取当前线程的标识符，返回的 <code>std::thread::id</code> 对象可以表示当前线程的唯一标识符。通常用于在多线程环境中识别和区分不同的线程。</p>
<h2 id="std-this-thread-sleep-for"><a href="#std-this-thread-sleep-for" class="headerlink" title="std::this_thread::sleep_for()"></a>std::this_thread::sleep_for()</h2><p><code>std::this_thread::sleep_for()</code> 是 <code>std::this_thread</code> 命名空间中的函数，用于让当前线程休眠一段指定的时间。</p>
<h3 id="用法示例：-5"><a href="#用法示例：-5" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Start sleeping...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 休眠 2 秒钟</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Wake up after sleeping for 2 seconds.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数被用来让当前线程暂停执行一段时间。在示例中，<code>std::this_thread::sleep_for()</code> 使得程序执行暂停了 2 秒钟，然后继续往下执行。</p>
<p>该函数的参数是 <code>std::chrono::duration</code> 类型的实例，可接受各种时间单位（如秒、毫秒、微秒等），用于指定线程暂停的时间长度。</p>
<h2 id="std-this-thread-sleep-until"><a href="#std-this-thread-sleep-until" class="headerlink" title="std::this_thread::sleep_until()"></a>std::this_thread::sleep_until()</h2><p><code>std::this_thread::sleep_until()</code> 是 <code>std::this_thread</code> 命名空间中的函数，用于让当前线程休眠直到指定的时间点。</p>
<h3 id="用法示例：-6"><a href="#用法示例：-6" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Start sleeping...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置一个时间点为当前时间加上 5 秒钟</span></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock&gt; wakeupTime = std::chrono::system_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让当前线程休眠直到指定的时间点</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_until</span>(wakeupTime);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Woke up after 5 seconds.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::this_thread::sleep_until()</code> 函数使得当前线程休眠直到指定的时间点。通过 <code>std::chrono::time_point</code> 设置了一个时间点为当前时间加上 5 秒钟，并将其作为参数传递给 <code>sleep_until()</code> 函数，使得线程休眠直到这个时间点。</p>
<p>这个函数的参数是 <code>std::chrono::time_point</code> 类型的对象，表示线程应该休眠的时间点。</p>
<h2 id="std-this-thread-yield"><a href="#std-this-thread-yield" class="headerlink" title="std::this_thread::yield()"></a>std::this_thread::yield()</h2><p><code>std::this_thread::yield()</code> 是 <code>std::this_thread</code> 命名空间中的函数，用于提示线程调度器当前线程愿意让出 CPU 时间片，以便给其他线程执行的机会。</p>
<h3 id="用法示例：-7"><a href="#用法示例：-7" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Task running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 提示线程调度器让出 CPU 时间片</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">task</span><span class="params">(taskFunction)</span></span>; <span class="comment">// 创建新线程执行任务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main thread running...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 提示线程调度器让出 CPU 时间片</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task.<span class="built_in">join</span>(); <span class="comment">// 等待任务线程执行完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::this_thread::yield()</code> 被用来提示线程调度器让出 CPU 时间片。主线程和任务线程分别交替执行，每次循环调用 <code>yield()</code> 后，当前线程会主动让出 CPU 时间片，给其他线程执行的机会。注意，<code>yield()</code> 函数只是一个提示，调度器是否立即采纳取决于操作系统的具体实现。</p>
<h2 id="C-std-thread-hardware-concurrency-函数"><a href="#C-std-thread-hardware-concurrency-函数" class="headerlink" title="C++ std::thread::hardware_concurrency() 函数"></a>C++ std::thread::hardware_concurrency() 函数</h2><p><code>std::thread::hardware_concurrency()</code> 是 C++ 标准库中的一个函数，用于获取当前系统支持的并发线程数量。这个函数返回一个整数，表示当前系统可用的并发线程数量，通常对应于硬件支持的线程数或处理器核心数。</p>
<p>以下是对 <code>std::thread::hardware_concurrency()</code> 函数的详细解释：</p>
<ol>
<li><p><strong>功能</strong>：</p>
<ul>
<li>获取当前系统支持的并发线程数量。</li>
</ul>
</li>
<li><p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> std::thread::<span class="built_in">hardware_concurrency</span>() <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>参数</strong>：</p>
<ul>
<li>无参数。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>一个 <code>unsigned int</code> 类型的整数，表示当前系统支持的并发线程数量。</li>
<li>如果无法确定当前系统支持的并发线程数量，或者该信息不可用，则返回值为0。</li>
</ul>
</li>
<li><p><strong>异常</strong>：</p>
<ul>
<li>该函数不抛出任何异常。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cores = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of cores: &quot;</span> &lt;&lt; cores &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>说明</strong>：</p>
<ul>
<li>这个函数可以帮助程序员确定在当前系统上进行并行操作时的最佳线程数量。</li>
<li>返回值为0时，表示无法确定当前系统支持的并发线程数量，程序可能需要使用默认值或者其他启发式方法来确定线程数量。</li>
<li>返回值并不总是精确的，有时会受到系统配置、资源限制或者其他因素的影响。因此，在实际应用中，可能需要结合其他信息和策略来确定最佳的并发线程数量。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>std::thread::hardware_concurrency()</code> 函数是一个便捷的工具，可以帮助程序员在编写多线程程序时确定当前系统支持的并发线程数量，从而更好地利用系统资源。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_13_mutex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_13_mutex/" class="post-title-link" itemprop="url">C++_10_13_mutex</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <mutex>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <mutex>标准库</h2><p><code>&lt;mutex&gt;</code> 是 C++ 标准库提供的头文件，其中定义了一些用于多线程编程的基本互斥量和锁（mutexes和locks）。</p>
<h3 id="主要类和功能："><a href="#主要类和功能：" class="headerlink" title="主要类和功能："></a>主要类和功能：</h3><ol>
<li><p>**<code>std::mutex</code>**：</p>
<ul>
<li>互斥量，提供了基本的互斥访问，用于保护共享资源。</li>
<li>可以使用 <code>lock()</code> 和 <code>unlock()</code> 方法来手动锁定和解锁。</li>
<li>通常与 <code>std::lock_guard</code> 或 <code>std::unique_lock</code> 结合使用，实现自动的锁定和解锁。</li>
</ul>
</li>
<li><p>**<code>std::lock_guard</code>**：</p>
<ul>
<li>提供了一种简单的方式来管理互斥量的锁定和解锁。</li>
<li>在构造时锁定互斥量，在作用域结束时自动解锁。</li>
</ul>
</li>
<li><p>**<code>std::unique_lock</code>**：</p>
<ul>
<li>类似于 <code>std::lock_guard</code>，提供对互斥量的锁定和解锁操作。</li>
<li>拥有更多的灵活性，可以手动控制锁的范围，也可以手动解锁并重新锁定。</li>
</ul>
</li>
<li><p>**<code>std::recursive_mutex</code>**：</p>
<ul>
<li>递归互斥量，允许同一线程多次对其进行加锁，避免死锁。</li>
</ul>
</li>
<li><p>**<code>std::timed_mutex</code>**：</p>
<ul>
<li>有超时功能的互斥量，在尝试锁定超时后会返回失败。</li>
</ul>
</li>
<li><p>**<code>std::recursive_timed_mutex</code>**：</p>
<ul>
<li>有超时功能的递归互斥量。</li>
</ul>
</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_shared_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    ++shared_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment_shared_data)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment_shared_data)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>std::mutex</code> 用于保护共享资源 <code>shared_data</code>。<code>std::lock_guard</code> 用于在作用域内锁定互斥量，确保对 <code>shared_data</code> 的增加操作是线程安全的。通过使用互斥量，可以确保多个线程不会同时访问共享资源，避免了竞态条件（race condition）的发生。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <mutex>标准库 详解</h2><p><code>&lt;mutex&gt;</code> 是 C++ 标准库中的头文件，提供了用于多线程编程的互斥量（mutex）和锁（lock）的基本支持。</p>
<h3 id="主要类和功能：-1"><a href="#主要类和功能：-1" class="headerlink" title="主要类和功能："></a>主要类和功能：</h3><ol>
<li><p>**<code>std::mutex</code>**：</p>
<ul>
<li>互斥量类，用于保护共享资源，防止多个线程同时访问。</li>
<li>成员函数有 <code>lock()</code>（锁定互斥量）、<code>try_lock()</code>（尝试锁定互斥量，避免阻塞）、<code>unlock()</code>（解锁互斥量）等。</li>
</ul>
</li>
<li><p>**<code>std::lock_guard</code>**：</p>
<ul>
<li>提供自动管理互斥量的锁定和解锁。</li>
<li>在构造时锁定互斥量，在作用域结束时自动解锁。</li>
</ul>
</li>
<li><p>**<code>std::unique_lock</code>**：</p>
<ul>
<li>与 <code>std::lock_guard</code> 类似，提供对互斥量的锁定和解锁。</li>
<li>拥有更多的灵活性，允许手动控制锁的范围，也可以手动解锁和重新锁定。</li>
</ul>
</li>
<li><p>**<code>std::recursive_mutex</code>**：</p>
<ul>
<li>递归互斥量，允许同一线程多次对其进行加锁，避免死锁。</li>
</ul>
</li>
<li><p>**<code>std::timed_mutex</code>**：</p>
<ul>
<li>有超时功能的互斥量，在尝试锁定超时后会返回失败。</li>
</ul>
</li>
<li><p>**<code>std::recursive_timed_mutex</code>**：</p>
<ul>
<li>有超时功能的递归互斥量。</li>
</ul>
</li>
</ol>
<h3 id="锁类型选择："><a href="#锁类型选择：" class="headerlink" title="锁类型选择："></a>锁类型选择：</h3><ul>
<li><code>std::lock_guard</code> 适用于简单的互斥量锁定，作用域结束时自动释放锁。</li>
<li><code>std::unique_lock</code> 更灵活，允许手动控制锁的生命周期和多次锁定和解锁。</li>
<li><code>std::timed_mutex</code> 和 <code>std::recursive_timed_mutex</code> 适用于需要超时特性的情况。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_shared_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    ++shared_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment_shared_data)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment_shared_data)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>std::mutex</code> 用于保护共享资源 <code>shared_data</code>。<code>std::lock_guard</code> 用于在作用域内锁定互斥量，确保对 <code>shared_data</code> 的增加操作是线程安全的。通过使用互斥量，可以确保多个线程不会同时访问共享资源，避免了竞态条件（race condition）的发生。</p>
<h2 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h2><ul>
<li><code>std::mutex</code> 是 C++ 标准库 <code>&lt;mutex&gt;</code> 中定义的类，用于提供互斥量功能，确保在多线程环境中对共享资源的安全访问。</li>
</ul>
<h3 id="std-mutex-详解"><a href="#std-mutex-详解" class="headerlink" title="std::mutex 详解"></a>std::mutex 详解</h3><ul>
<li><p>构造函数: </p>
<ul>
<li>std::mutex不允许拷贝构造，也不允许move拷贝，最初产生的mutex对象是处于unlocked状态的</li>
</ul>
</li>
<li><p>lock()</p>
<ul>
<li>调用线程将锁住该互斥量。</li>
<li>线程调用该函数会发生下面三种情况<ul>
<li>如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用unlock之前，该线程一直用于该锁</li>
<li>如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住</li>
<li>如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)</li>
</ul>
</li>
</ul>
</li>
<li><p>unlock()</p>
<ul>
<li>解锁，释放对互斥量的所有权</li>
</ul>
</li>
<li><p>try_lock()</p>
<ul>
<li>尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。</li>
<li>线程调用该函数也会出现下面三种情况<ul>
<li>如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用unlock释放互斥量</li>
<li>如果当前互斥量被其他线程锁住，则当前调用线程返回false，而且并不会被阻塞</li>
<li>如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="主要操作和函数："><a href="#主要操作和函数：" class="headerlink" title="主要操作和函数："></a>主要操作和函数：</h3><ol>
<li><p>**lock() 和 unlock()**：<code>std::mutex</code> 提供了 <code>lock()</code> 和 <code>unlock()</code> 函数用于手动锁定和解锁互斥量。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line">mtx.<span class="built_in">lock</span>(); <span class="comment">// 锁定互斥量</span></span><br><span class="line"><span class="comment">// 对共享资源进行操作</span></span><br><span class="line">mtx.<span class="built_in">unlock</span>(); <span class="comment">// 解锁互斥量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::lock_guard</strong>：<code>std::lock_guard</code> 是一个 RAII（资源获取即初始化）类，用于自动管理 <code>std::mutex</code> 的锁定和解锁。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 在作用域中自动锁定互斥量</span></span><br><span class="line">    <span class="comment">// 对共享资源进行操作</span></span><br><span class="line">&#125; <span class="comment">// 在作用域结束时自动解锁互斥量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**try_lock()**：尝试锁定互斥量，如果不能立即获得锁，<code>try_lock()</code> 函数会立即返回，而不会阻塞线程。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mtx.<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">    <span class="comment">// 成功获得锁，对共享资源进行操作</span></span><br><span class="line">    mtx.<span class="built_in">unlock</span>(); <span class="comment">// 解锁互斥量</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 未能立即获得锁，执行其他操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>递归互斥量</strong>：<code>std::recursive_mutex</code> 类是 <code>std::mutex</code> 的变种，允许同一线程多次对互斥量进行加锁操作，适用于特定场景。</p>
</li>
</ol>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>(); <span class="comment">// 锁定互斥量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is executing...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>(); <span class="comment">// 解锁互斥量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadFunction, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(threadFunction, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::mutex</code> 被用来保护对共享资源（在这里是标准输出流 <code>std::cout</code>）的访问。线程函数通过调用 <code>mtx.lock()</code> 和 <code>mtx.unlock()</code> 来手动锁定和解锁互斥量，确保每个线程在访问共享资源时的独占性。</p>
<h2 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h2><p><code>std::lock_guard</code> 是 C++ 标准库中的一个模板类，用于管理互斥量的锁定和解锁操作。它提供了一种简单的方式，在作用域内锁定互斥量，并在作用域结束时自动释放锁。</p>
<h3 id="std-lock-guard-详解"><a href="#std-lock-guard-详解" class="headerlink" title="std::lock_guard 详解"></a>std::lock_guard 详解</h3><ul>
<li><p>std::lock_guard 是C++11中定义的模板类。定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Mutex</span>&gt; <span class="keyword">class</span> <span class="title class_">lock_guard</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>std::lock_guard 对象通常用于管理某个锁对象，因此与Mute RAII相关，方便线程对互斥量上锁，即在某个 std::lock_guard对象的生命周期内，它所管理的锁对象会一直保持上锁状态；而std::lock_guard的生命周期结束之后，它所管理的锁对象会被解锁(类似 std::shared_ptr等智能指针管理动态分配的内存资源)</p>
</li>
<li><p>模板参数Mutex代表互斥量类型，例如std::mutex类型，它应该是一个基本的BasicLockable类型。</p>
</li>
<li><p>标准库中定义几种基本的BasicLockable类型，分别是</p>
<ul>
<li>std::mutex</li>
<li>std::recursive_mutex</li>
<li>std::timed_mutex</li>
<li>std::recursive_timed_mutex</li>
<li>std::unique_lock</li>
</ul>
</li>
<li><p>在lock_guard对象构造时，传入的Mutex对象(即它所管理的Mutex对象)会被当前线程锁住。在lock_guard对象被析构时，它所管理的Mutex对象会自动解锁，由于不需要程序员手动调用lock和unlock对Mutex进行上所和解锁操作，因此这也是最简单安全的上所和解锁方式，尤其是在程序抛出异常后先前已被上锁的Mutex对象可以正确进行解锁操作，极大的简化了程序员编写与Mutex相关的异常处理代码</p>
</li>
<li><p>值的注意的是，lock_guard对象并不负责管理Mutex对象的生命周期，lock_guard对象只是简化了Mutex对象的上锁和解锁操作，方便线程对互斥量上锁，即在某个lock_guard对象的生命周期内，它所管理的锁对象会一直保持上锁状态；而lock_guard的声明周期结束之后，它所管理的锁对象会被解锁。</p>
</li>
<li><p>std::lock_guard构造函数如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">locking</span>(<span class="number">1</span>) <span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">(mutex_type&amp; m)</span></span>;</span><br><span class="line"><span class="built_in">adopting</span>(<span class="number">2</span>) <span class="built_in">lock_guard</span>(mutex_type&amp; m, <span class="type">adopt_lock_t</span> tag);</span><br><span class="line">copy [deleted](<span class="number">3</span>) <span class="built_in">lock_guard</span>(<span class="type">const</span> lock_guard&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>locking初始化</p>
<ul>
<li>lock_guard对象管理Mutex对象m，并在构造函数对m进行上锁(调用m.lock())</li>
</ul>
</li>
<li><p>adopting初始化</p>
<ul>
<li>lock_guard对象管理Mutex对象m，与locking初始化(1)不同的是，Mutex对象m已被当前线程锁住</li>
</ul>
</li>
<li><p>拷贝构造</p>
<ul>
<li>lock_guard对象的拷贝构造和移动构造(move construction)均被禁用，因此lock_guard对象不可被拷贝构造和移动构造</li>
</ul>
</li>
</ul>
<h3 id="主要特性和用法："><a href="#主要特性和用法：" class="headerlink" title="主要特性和用法："></a>主要特性和用法：</h3><ol>
<li><strong>自动锁定和解锁</strong>：<code>std::lock_guard</code> 在构造时锁定互斥量，在作用域结束时自动释放锁。</li>
<li><strong>简化代码</strong>：使用 <code>std::lock_guard</code> 可以避免手动调用 <code>mutex</code> 的 <code>lock()</code> 和 <code>unlock()</code> 方法。</li>
<li><strong>RAII（资源获取即初始化）</strong>：充分利用了 RAII 的机制，确保在异常或作用域提前退出时，锁都能正确释放，防止死锁和资源泄漏。</li>
</ol>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><p>以下是一个简单的示例，展示了 <code>std::lock_guard</code> 的使用方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_shared_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 在此处锁定互斥量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对共享资源进行操作</span></span><br><span class="line">    ++shared_data;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared data incremented by 1.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 lock 对象超出作用域时，自动解锁互斥量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment_shared_data)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment_shared_data)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final shared data value: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>std::lock_guard</code> 类型的对象 <code>lock</code> 在构造时锁定了互斥量 <code>mtx</code>，在作用域结束时，<code>lock</code> 对象超出作用域范围，自动调用析构函数，从而自动解锁了 <code>mtx</code> 互斥量。这确保了 <code>shared_data</code> 的增加操作是在互斥访问下进行的，避免了多线程环境下的竞态条件。</p>
<h2 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock"></a>std::unique_lock</h2><p><code>std::unique_lock</code> 是 C++ 标准库中提供的一个模板类，用于管理互斥量（<code>std::mutex</code>）的锁定和解锁操作。它提供了更灵活的锁管理机制，相比于 <code>std::lock_guard</code>，<code>std::unique_lock</code> 提供了更多的功能。</p>
<h3 id="std-unique-lock-详解"><a href="#std-unique-lock-详解" class="headerlink" title="std::unique_lock 详解"></a>std::unique_lock 详解</h3><ul>
<li><p>unique_lock 对象以独占所有权的方式管理mutex对象的上锁和解锁操作，所谓独占所有权，就是没有其他的unique_lock对象同时拥有某个mutex对象的所有权</p>
</li>
<li><p>在构造(或移动赋值)时，unique_lock对象需要传递一个Mutex对象作为它的参数，新创建的unique_lock对象负责传入的Mutex对象的上锁和解锁操作。</p>
</li>
</ul>
<h3 id="主要特性和用法：-1"><a href="#主要特性和用法：-1" class="headerlink" title="主要特性和用法："></a>主要特性和用法：</h3><ol>
<li><strong>灵活性</strong>：<code>std::unique_lock</code> 对象的锁定和解锁不仅限于作用域的进入和退出，可以手动控制锁的范围。</li>
<li><strong>构造和析构</strong>：<code>std::unique_lock</code> 对象在构造时锁定互斥量，在析构时自动解锁。</li>
<li><strong>锁定和解锁</strong>：可通过 <code>lock()</code> 和 <code>unlock()</code> 方法手动锁定和解锁互斥量。</li>
<li><strong>所有权转移</strong>：支持将 <code>std::unique_lock</code> 对象的所有权转移给另一个对象，提供了移动语义。</li>
</ol>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><p>以下是一个简单示例，演示了 <code>std::unique_lock</code> 的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 在此处锁定互斥量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做一些工作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Doing some work within a critical section.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 lock 超出作用域时自动解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(someFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行其他操作</span></span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::unique_lock</code> 对象 <code>lock</code> 在构造时锁定了互斥量 <code>mtx</code>，当 <code>lock</code> 超出作用域时，会自动解锁互斥量。这种机制保证了在 <code>std::unique_lock</code> 对象生命周期内，互斥量的锁定状态始终得到正确管理。</p>
<p><code>std::unique_lock</code> 的另一个优点是，可以手动控制锁的范围，例如使用 <code>lock()</code> 和 <code>unlock()</code> 方法，允许在需要时手动进行锁定和解锁操作，提供更多灵活性。</p>
<p>此外，<code>std::unique_lock</code> 也支持将其所有权转移给另一个 <code>std::unique_lock</code> 对象，这种特性可用于实现更复杂的锁管理场景，比如资源的安全移交。</p>
<h2 id="std-recursive-mutex"><a href="#std-recursive-mutex" class="headerlink" title="std::recursive_mutex"></a>std::recursive_mutex</h2><p><code>std::recursive_mutex</code> 是 C++ 标准库中提供的一个互斥量类，它与 <code>std::mutex</code> 类似，但允许同一个线程对互斥量多次进行锁定。这种特性允许同一线程在已经锁定的情况下再次对其进行锁定，避免了死锁的可能性。<br><code>std::recursive_mutex</code> 释放互斥量时需要调用与该锁层次深度相同次数的unlock()，可以理解为lock()次数和unlock()次数相同，除此之外，std::recursive_mutex的特性和std::mutex大致相同</p>
<h3 id="主要特点和用法："><a href="#主要特点和用法：" class="headerlink" title="主要特点和用法："></a>主要特点和用法：</h3><ol>
<li><strong>递归锁定</strong>：<code>std::recursive_mutex</code> 允许同一个线程对它进行多次锁定。</li>
<li><strong>避免死锁</strong>：递归锁可以使得同一个线程在持有锁的情况下再次对其进行锁定，避免了由于同一线程多次锁定导致的死锁。</li>
<li><strong>使用方法</strong>：与 <code>std::mutex</code> 类似，使用 <code>lock()</code> 和 <code>unlock()</code> 方法进行锁定和解锁。</li>
</ol>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><p>以下是一个简单的示例，演示了 <code>std::recursive_mutex</code> 的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::recursive_mutex r_mtx;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_shared_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lock</span><span class="params">(r_mtx)</span></span>;</span><br><span class="line">    ++shared_data;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared data incremented by 1.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursive_function</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lock</span><span class="params">(r_mtx)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">recursive_function</span>(count - <span class="number">1</span>); <span class="comment">// 递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment_shared_data)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(recursive_function, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final shared data value: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>std::recursive_mutex</code> 类型的对象 <code>r_mtx</code> 被用于保护共享资源 <code>shared_data</code>。在函数 <code>recursive_function()</code> 中，<code>r_mtx</code> 被同一线程多次锁定，并通过递归调用自身来展示 <code>std::recursive_mutex</code> 的递归特性。通过递归锁定，同一线程可以多次对 <code>r_mtx</code> 进行加锁，避免了死锁的可能性。</p>
<h2 id="std-timed-mutex"><a href="#std-timed-mutex" class="headerlink" title="std::timed_mutex"></a>std::timed_mutex</h2><p><code>std::timed_mutex</code> 是 C++ 标准库提供的一个互斥量类，它是 <code>std::mutex</code> 的变种，提供了超时功能。<code>std::timed_mutex</code> 允许线程尝试锁定互斥量，但在一段时间内无法成功锁定时，可以设置超时机制，以避免无限期等待。</p>
<h3 id="std-timed-mutex-详解"><a href="#std-timed-mutex-详解" class="headerlink" title="std::timed_mutex 详解"></a>std::timed_mutex 详解</h3><ul>
<li><p>try_lock_for 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住(与std::mutex的try_lock()不同，try_lock如果被调用时没有获得锁则直接返回false)，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时(即在指定时间内还是没有获得锁)，则返回false</p>
</li>
<li><p>try_lock_until 函数接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时(即在指定时间还是没有获得锁)，则返回false</p>
</li>
</ul>
<h3 id="主要特点和用法：-1"><a href="#主要特点和用法：-1" class="headerlink" title="主要特点和用法："></a>主要特点和用法：</h3><ol>
<li><strong>超时锁定</strong>：<code>std::timed_mutex</code> 允许线程尝试锁定互斥量，并在超时后返回结果，避免线程无限期等待。</li>
<li>**<code>try_lock_for()</code> 和 <code>try_lock_until()</code>**：提供了超时版本的 <code>try_lock()</code>，允许线程在一段时间内尝试锁定互斥量。</li>
<li>**<code>lock()</code> 和 <code>unlock()</code>**：与 <code>std::mutex</code> 类似，用于手动锁定和解锁互斥量。</li>
<li><strong>超时策略</strong>：可以使用 <code>std::chrono</code> 中的时间点或时间段，设置超时时间。</li>
</ol>
<h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><p>以下是一个简单的示例，演示了 <code>std::timed_mutex</code> 的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::timed_mutex t_mtx;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">try_lock_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t_mtx.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>))) &#123;</span><br><span class="line">        <span class="comment">// 成功锁定互斥量</span></span><br><span class="line">        ++shared_data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shared data incremented by 1.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        t_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未能在指定时间内锁定互斥量</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Could not acquire lock within specified time.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(try_lock_function)</span></span>;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final shared data value: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>std::timed_mutex</code> 类型的对象 <code>t_mtx</code> 用于保护共享资源 <code>shared_data</code>。<code>try_lock_function()</code> 函数尝试在100毫秒内锁定 <code>t_mtx</code>，如果在超时时间内成功获得了锁，则增加 <code>shared_data</code> 的值，否则在未获得锁时输出一条提示信息。这样可以避免线程无限期等待互斥量的锁定，提高程序的鲁棒性。</p>
<h2 id="std-recursive-timed-mutex"><a href="#std-recursive-timed-mutex" class="headerlink" title="std::recursive_timed_mutex"></a>std::recursive_timed_mutex</h2><p><code>std::recursive_timed_mutex</code> 是 C++ 标准库提供的一个互斥量类，结合了 <code>std::recursive_mutex</code> 和 <code>std::timed_mutex</code> 的特性，允许同一个线程多次对其进行锁定，并提供了超时功能。</p>
<h3 id="主要特点和用法：-2"><a href="#主要特点和用法：-2" class="headerlink" title="主要特点和用法："></a>主要特点和用法：</h3><ol>
<li><strong>递归和超时</strong>：<code>std::recursive_timed_mutex</code> 允许同一个线程对互斥量多次进行锁定，并在一定时间内尝试锁定互斥量，提供了递归性和超时性。</li>
<li>**<code>try_lock_for()</code> 和 <code>try_lock_until()</code>**：提供了超时版本的 <code>try_lock()</code>，允许线程在一段时间内尝试锁定互斥量。</li>
<li>**<code>lock()</code> 和 <code>unlock()</code>**：与 <code>std::recursive_mutex</code> 类似，用于手动锁定和解锁互斥量。</li>
</ol>
<h3 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h3><p>以下是一个简单的示例，演示了 <code>std::recursive_timed_mutex</code> 的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::recursive_timed_mutex rt_mtx;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursive_lock_function</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::recursive_timed_mutex&gt; <span class="title">lock</span><span class="params">(rt_mtx, std::defer_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lock.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>))) &#123;</span><br><span class="line">            <span class="comment">// 成功锁定互斥量</span></span><br><span class="line">            ++shared_data;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Shared data incremented by 1.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 未能在指定时间内锁定互斥量</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Could not acquire lock within specified time.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">recursive_lock_function</span>(count - <span class="number">1</span>); <span class="comment">// 递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">recursive_lock_function</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final shared data value: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>std::recursive_timed_mutex</code> 类型的对象 <code>rt_mtx</code> 用于保护共享资源 <code>shared_data</code>。<code>recursive_lock_function()</code> 函数尝试在100毫秒内锁定 <code>rt_mtx</code>，如果在超时时间内成功获得了锁，则增加 <code>shared_data</code> 的值，并在解锁后进行递归调用。这样，线程可以多次锁定同一个 <code>std::recursive_timed_mutex</code> 对象，并提供了超时机制。</p>
<h2 id="C-std-call-once函数-详解"><a href="#C-std-call-once函数-详解" class="headerlink" title="C++ std::call_once函数 详解"></a>C++ std::call_once函数 详解</h2><p><code>std::call_once</code> 是 C++11 标准库 <code>&lt;mutex&gt;</code> 头文件中的一个函数，用于保证某个函数在多线程环境下只被调用一次。它通常与 <code>std::once_flag</code> 结合使用。</p>
<p>这个函数的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Callable, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">( std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>flag</code> 是一个 <code>std::once_flag</code> 对象，用于标识某个函数是否已经被调用过。</li>
<li><code>f</code> 是一个可调用对象，可以是函数指针、函数对象或者是 lambda 表达式。</li>
<li><code>args</code> 是 <code>f</code> 执行时所需的参数。</li>
</ul>
<p><code>std::call_once</code> 的工作原理是，它会检查 <code>std::once_flag</code> 对象是否已经被设置过。如果没有，它会调用传递给它的可调用对象 <code>f</code>，并将 <code>std::once_flag</code> 对象设置为已调用状态。这样，即使在多线程环境下，也只会有一个线程调用 <code>f</code>。</p>
<p>一般来说，<code>std::call_once</code> 用于在多线程环境下执行初始化工作或者执行某个需要确保只执行一次的操作。例如，可以用它来确保在多线程环境下只创建一个全局对象。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::once_flag flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize_shared_resource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initializing shared resource\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 在这里执行初始化工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(flag, initialize_shared_resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t3</span><span class="params">(thread_function)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t4</span><span class="params">(thread_function)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">4.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>initialize_shared_resource</code> 函数会被多个线程调用，但是由于 <code>std::call_once</code> 的作用，它只会被调用一次。</p>
<h2 id="C-std-once-flag-详解"><a href="#C-std-once-flag-详解" class="headerlink" title="C++ std::once_flag 详解"></a>C++ std::once_flag 详解</h2><p><code>std::once_flag</code> 是 C++11 标准库 <code>&lt;mutex&gt;</code> 头文件中定义的一个标准库类，用于在多线程环境中确保某个函数或某段代码只被执行一次。</p>
<p><code>std::once_flag</code> 的作用是作为 <code>std::call_once</code> 函数的参数，用于标记某个函数是否已经被调用过。它通常在多线程环境中与 <code>std::call_once</code> 函数结合使用。</p>
<p>这个类的定义相对简单，它通常只是一个轻量级的标志，标识某个函数是否已经被调用过。</p>
<p>以下是 <code>std::once_flag</code> 的简单示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::once_flag flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize_shared_resource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initializing shared resource\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 在这里执行初始化工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(flag, initialize_shared_resource); <span class="comment">// 仅会执行一次</span></span><br><span class="line">    std::<span class="built_in">call_once</span>(flag, []()&#123; std::cout &lt;&lt; <span class="string">&quot;This won&#x27;t run\n&quot;</span>; &#125;); <span class="comment">// 由于flag已被设置，这里的lambda表达式不会执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>initialize_shared_resource</code> 函数仅被执行一次，即使在多个线程中调用了 <code>std::call_once</code>。这是因为 <code>std::once_flag</code> 确保了其中的初始化代码仅被执行一次。</p>
<p>总的来说，<code>std::once_flag</code> 提供了一种在多线程环境中安全地执行某个函数或代码段的机制，确保它们只被执行一次。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_10_cstring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_10_cstring/" class="post-title-link" itemprop="url">C++_10_10_cstring</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <cstring>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <cstring>标准库</h2><p><code>&lt;cstring&gt;</code> 是 C++ 标准库中的头文件，它提供了一系列对 C 风格字符串（以 null 结尾的字符数组）进行操作的函数和工具。</p>
<p>以下是 <code>&lt;cstring&gt;</code> 头文件中常见的函数及其功能：</p>
<ol>
<li><p><strong>字符串操作函数</strong>：</p>
<ul>
<li><code>strcpy()</code>：将一个字符串复制到另一个字符串中。</li>
<li><code>strncpy()</code>：将指定长度的字符串复制到另一个字符串中。</li>
<li><code>strcat()</code>：将一个字符串连接到另一个字符串的末尾。</li>
<li><code>strncat()</code>：将指定长度的字符串连接到另一个字符串的末尾。</li>
<li><code>strlen()</code>：返回字符串的长度。</li>
<li><code>strcmp()</code>：比较两个字符串。</li>
<li><code>strncmp()</code>：比较两个字符串的指定长度部分。</li>
<li><code>strchr()</code>：在字符串中查找指定字符的第一个出现位置。</li>
<li><code>strrchr()</code>：在字符串中查找指定字符的最后一个出现位置。</li>
<li><code>strstr()</code>：在字符串中查找子串的第一个出现位置。</li>
<li><code>strtok()</code>：将字符串分割成标记（token）。</li>
<li><code>strpbrk()</code>：在字符串中查找任意字符集中的任意字符第一次出现的位置。</li>
</ul>
</li>
<li><p><strong>字符串内存操作函数</strong>：</p>
<ul>
<li><code>memset()</code>：将内存块设置为指定的值。</li>
<li><code>memcpy()</code>：将一个内存区块的内容拷贝到另一个内存区块。</li>
<li><code>memmove()</code>：将内存区块的内容移动到另一个内存区块。</li>
<li><code>memcmp()</code>：比较两个内存区块。</li>
</ul>
</li>
</ol>
<p>这些函数提供了对字符串进行复制、连接、比较、搜索以及内存块操作等一系列常用操作的功能。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>以下是一个简单的示例，展示了 <code>&lt;cstring&gt;</code> 头文件中的一些函数的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝字符串</span></span><br><span class="line">    <span class="type">char</span> dest[<span class="number">20</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(dest, str1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Copied string: &quot;</span> &lt;&lt; dest &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接字符串</span></span><br><span class="line">    std::<span class="built_in">strcat</span>(dest, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    std::<span class="built_in">strcat</span>(dest, str2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Concatenated string: &quot;</span> &lt;&lt; dest &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较字符串</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">strcmp</span>(str1, str2) != <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Strings are different.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找子串</span></span><br><span class="line">    <span class="type">char</span>* sub_str = std::<span class="built_in">strstr</span>(dest, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sub_str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Found substring: &quot;</span> &lt;&lt; sub_str &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="std-strcpy"><a href="#std-strcpy" class="headerlink" title="std::strcpy()"></a>std::strcpy()</h2><p><code>std::strcpy()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于将一个字符串（以 null 结尾的字符数组）复制到另一个字符串中。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>dest</code>：指向目标字符数组的指针，接收源字符串的内容。要确保目标字符数组足够大，能够容纳源字符串的内容。</li>
<li><code>src</code>：指向源字符串的指针，要被复制到目标字符数组中的内容。</li>
</ul>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回一个指向目标字符数组 <code>dest</code> 的指针，即源字符串被复制后的字符串起始地址。</li>
</ul>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><p><code>strcpy()</code> 函数将源字符串 <code>src</code> 的内容（包括结束符 <code>\0</code>）复制到目标字符数组 <code>dest</code> 中，直到遇到源字符串的结束符 <code>\0</code>。如果 <code>dest</code> 字符数组不够大，可能会导致缓冲区溢出，因此使用时需要确保目标字符数组足够大以容纳源字符串的内容。</p>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> source[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">strcpy</span>(destination, source);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Source string: &quot;</span> &lt;&lt; source &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destination string: &quot;</span> &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strcpy()</code> 函数被用来将 <code>source</code> 字符串的内容复制到 <code>destination</code> 字符数组中。复制后，<code>destination</code> 中存储了与 <code>source</code> 相同的字符串。</p>
<p>在此示例中，使用了一系列 <code>&lt;cstring&gt;</code> 中的函数来进行字符串的复制、拼接、比较和查找操作。<code>strcpy()</code> 用于复制字符串，<code>strcat()</code> 用于连接字符串，<code>strcmp()</code> 用于比较字符串，<code>strstr()</code> 用于在字符串中查找子串。</p>
<h2 id="std-strncpy"><a href="#std-strncpy" class="headerlink" title="std::strncpy()"></a>std::strncpy()</h2><p><code>std::strncpy()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于将一个字符串的指定长度复制到另一个字符串中。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strncpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>dest</code>：指向目标字符数组的指针，接收源字符串的内容。要确保目标字符数组足够大，能够容纳指定长度的源字符串内容。</li>
<li><code>src</code>：指向源字符串的指针，要被复制到目标字符数组中的内容。</li>
<li><code>count</code>：要复制的字符数，包括结束符 <code>\0</code>。如果 <code>count</code> 大于源字符串的长度，将在目标字符串中填充额外的 <code>\0</code> 以填满指定的长度。</li>
</ul>
<h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回一个指向目标字符数组 <code>dest</code> 的指针，即源字符串的一部分被复制到了目标字符数组中。</li>
</ul>
<h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h3><p><code>strncpy()</code> 函数将源字符串 <code>src</code> 的指定长度（包括结束符 <code>\0</code>）复制到目标字符数组 <code>dest</code> 中。如果源字符串的长度小于 <code>count</code>，则剩余的部分将用 <code>\0</code> 填充，以确保目标字符数组的长度为 <code>count</code>。</p>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> source[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">strncpy</span>(destination, source, <span class="number">5</span>); <span class="comment">// 复制 source 中的前5个字符到 destination</span></span><br><span class="line"></span><br><span class="line">    destination[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 手动添加 null 结尾字符，确保字符串正确结束</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Source string: &quot;</span> &lt;&lt; source &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destination string: &quot;</span> &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strncpy()</code> 函数被用来将 <code>source</code> 字符串的前5个字符复制到 <code>destination</code> 字符数组中。最后一个字符被设置为 <code>\0</code>，以确保字符串正确结束。</p>
<h2 id="std-strcat"><a href="#std-strcat" class="headerlink" title="std::strcat()"></a>std::strcat()</h2><p><code>std::strcat()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于将一个字符串连接到另一个字符串的末尾。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-2"><a href="#参数：-2" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>dest</code>：指向目标字符数组的指针，包含源字符串，并将要连接的字符串追加到此字符串的末尾。要确保目标字符数组足够大，能够容纳源字符串和要连接的字符串。</li>
<li><code>src</code>：指向源字符串的指针，要被连接到目标字符串的末尾。</li>
</ul>
<h3 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回一个指向目标字符数组 <code>dest</code> 的指针，即连接后的字符串起始地址。</li>
</ul>
<h3 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h3><p><code>strcat()</code> 函数将源字符串 <code>src</code> 的内容（不包括结束符 <code>\0</code>）连接到目标字符数组 <code>dest</code> 的末尾，并添加 <code>\0</code> 作为连接后字符串的结束符。</p>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">20</span>] = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">strcat</span>(str1, str2);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Concatenated string: &quot;</span> &lt;&lt; str1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strcat()</code> 函数被用来将 <code>str2</code> 字符串连接到 <code>str1</code> 字符数组的末尾，得到一个新的字符串。最终输出的结果为连接后的字符串 <code>&quot;Hello, World!&quot;</code>。请注意，在使用 <code>strcat()</code> 连接字符串时，确保目标字符数组有足够的空间来容纳连接后的结果。</p>
<h2 id="std-strncat"><a href="#std-strncat" class="headerlink" title="std::strncat()"></a>std::strncat()</h2><p><code>std::strncat()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于将源字符串的指定长度连接到另一个字符串的末尾。</p>
<h3 id="函数签名：-3"><a href="#函数签名：-3" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strncat</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-3"><a href="#参数：-3" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>dest</code>：指向目标字符数组的指针，包含源字符串，并将要连接的部分字符串追加到此字符串的末尾。要确保目标字符数组足够大，能够容纳源字符串和要连接的部分字符串。</li>
<li><code>src</code>：指向源字符串的指针，要被连接到目标字符串的末尾。</li>
<li><code>count</code>：要连接的字符数，最多追加 <code>count</code> 个字符到目标字符数组中。</li>
</ul>
<h3 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回一个指向目标字符数组 <code>dest</code> 的指针，即连接后的字符串起始地址。</li>
</ul>
<h3 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a>功能：</h3><p><code>strncat()</code> 函数将源字符串 <code>src</code> 的指定长度（不包括结束符 <code>\0</code>）连接到目标字符数组 <code>dest</code> 的末尾，并添加 <code>\0</code> 作为连接后字符串的结束符。该函数将最多连接 <code>count</code> 个字符，但如果 <code>src</code> 中的字符串长度小于 <code>count</code>，则会连接完整的 <code>src</code> 字符串。</p>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">20</span>] = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">strncat</span>(str1, str2, <span class="number">3</span>); <span class="comment">// 仅连接 str2 的前3个字符</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Concatenated string: &quot;</span> &lt;&lt; str1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strncat()</code> 函数被用来将 <code>str2</code> 字符串的前3个字符连接到 <code>str1</code> 字符数组的末尾，得到一个新的字符串。最终输出的结果为连接后的字符串 <code>&quot;Hello, Wor&quot;</code>。请确保目标字符数组有足够的空间来容纳连接后的结果。</p>
<h2 id="std-strlen"><a href="#std-strlen" class="headerlink" title="std::strlen()"></a>std::strlen()</h2><p><code>std::strlen()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于计算以 null 结尾的 C 风格字符串的长度，即字符串中的字符数量，不包括结尾的 null 终止符 <code>\0</code>。</p>
<h3 id="函数签名：-4"><a href="#函数签名：-4" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-4"><a href="#参数：-4" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：指向以 null 结尾的 C 风格字符串的指针。</li>
</ul>
<h3 id="返回值：-4"><a href="#返回值：-4" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回字符串的长度，即字符串中的字符数量，不包括结尾的 null 终止符 <code>\0</code>。</li>
</ul>
<h3 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a>功能：</h3><p><code>strlen()</code> 函数会扫描参数 <code>str</code> 指向的字符串，直到遇到字符串结尾的 null 终止符 <code>\0</code>，然后返回字符串的实际长度，不包括结尾的 null 终止符。</p>
<h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> length = std::<span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Length of the string: &quot;</span> &lt;&lt; length &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strlen()</code> 函数被用来计算字符串 <code>&quot;Hello, World!&quot;</code> 的长度，即输出结果为字符串的字符数量（不包括结尾的 null 终止符），最终输出结果为字符串的长度为 <code>13</code>。</p>
<h2 id="std-strcmp"><a href="#std-strcmp" class="headerlink" title="std::strcmp()"></a>std::strcmp()</h2><p><code>std::strcmp()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于比较两个字符串。</p>
<h3 id="函数签名：-5"><a href="#函数签名：-5" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-5"><a href="#参数：-5" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str1</code>：指向第一个要比较的以 null 结尾的 C 风格字符串的指针。</li>
<li><code>str2</code>：指向第二个要比较的以 null 结尾的 C 风格字符串的指针。</li>
</ul>
<h3 id="返回值：-5"><a href="#返回值：-5" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果两个字符串相同，则返回 <code>0</code>；如果第一个不同于第二个，返回其 ASCII 值差；如果第一个小于第二个，则返回一个负值；如果第一个大于第二个，则返回一个正值。</li>
</ul>
<h3 id="功能：-5"><a href="#功能：-5" class="headerlink" title="功能："></a>功能：</h3><p><code>strcmp()</code> 函数对比两个字符串 <code>str1</code> 和 <code>str2</code>，并按照字典顺序进行比较。它逐个比较两个字符串对应位置的字符，直到发现不同的字符或者遇到其中一个字符串的结束符 <code>\0</code>。</p>
<h3 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = std::<span class="built_in">strcmp</span>(str1, str2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Strings are equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String 1 is less than String 2.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;String 1 is greater than String 2.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strcmp()</code> 函数被用来比较两个字符串 <code>&quot;Hello&quot;</code> 和 <code>&quot;World&quot;</code>。由于 <code>&quot;Hello&quot;</code> 在字典中排在 <code>&quot;World&quot;</code> 之前，所以输出结果为 <code>&quot;String 1 is less than String 2.&quot;</code>。</p>
<h2 id="std-strncmp"><a href="#std-strncmp" class="headerlink" title="std::strncmp()"></a>std::strncmp()</h2><p><code>std::strncmp()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于比较两个字符串的指定长度部分。</p>
<h3 id="函数签名：-6"><a href="#函数签名：-6" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str1, <span class="type">const</span> <span class="type">char</span>* str2, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-6"><a href="#参数：-6" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str1</code>：指向第一个要比较的以 null 结尾的 C 风格字符串的指针。</li>
<li><code>str2</code>：指向第二个要比较的以 null 结尾的 C 风格字符串的指针。</li>
<li><code>count</code>：要比较的字符数，即指定要比较的字符串部分的长度。</li>
</ul>
<h3 id="返回值：-6"><a href="#返回值：-6" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果两个字符串相同，则返回 <code>0</code>；如果第一个不同于第二个，返回其 ASCII 值差；如果第一个小于第二个，则返回一个负值；如果第一个大于第二个，则返回一个正值。</li>
</ul>
<h3 id="功能：-6"><a href="#功能：-6" class="headerlink" title="功能："></a>功能：</h3><p><code>strncmp()</code> 函数与 <code>strcmp()</code> 类似，但是 <code>strncmp()</code> 比较的字符数是通过参数 <code>count</code> 指定的。它逐个比较两个字符串相应位置的字符，直到达到指定的字符数 <code>count</code>、发现不同的字符或者遇到其中一个字符串的结束符 <code>\0</code>。</p>
<h3 id="示例：-7"><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str2 = <span class="string">&quot;Help&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = std::<span class="built_in">strncmp</span>(str1, str2, <span class="number">3</span>); <span class="comment">// 比较前3个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First 3 characters of strings are equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First 3 characters of String 1 are less than String 2.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First 3 characters of String 1 are greater than String 2.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strncmp()</code> 函数被用来比较两个字符串的前3个字符。因为在比较范围内，<code>&#39;l&#39;</code>（来自 <code>&quot;Hello&quot;</code>）在字典顺序上大于 <code>&#39;p&#39;</code>（来自 <code>&quot;Help&quot;</code>），所以输出结果为 <code>&quot;First 3 characters of String 1 are greater than String 2.&quot;</code>。</p>
<h2 id="std-strchr"><a href="#std-strchr" class="headerlink" title="std::strchr()"></a>std::strchr()</h2><p><code>std::strchr()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于在字符串中查找指定字符的第一次出现位置。</p>
<h3 id="函数签名：-7"><a href="#函数签名：-7" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">int</span> character)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-7"><a href="#参数：-7" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：指向要搜索的以 null 结尾的 C 风格字符串的指针。</li>
<li><code>character</code>：要在字符串中查找的字符，作为整数值传递。通常使用字符的 ASCII 值作为参数传递。</li>
</ul>
<h3 id="返回值：-7"><a href="#返回值：-7" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果找到指定的字符，则返回一个指向该字符首次出现的位置的指针；如果未找到，则返回 <code>nullptr</code>。</li>
</ul>
<h3 id="功能：-7"><a href="#功能：-7" class="headerlink" title="功能："></a>功能：</h3><p><code>strchr()</code> 函数在给定字符串 <code>str</code> 中搜索指定的字符 <code>character</code>，并返回第一次出现的位置（指针）。它从给定字符串的开头开始搜索，直到找到指定的字符或者遇到字符串结束符 <code>\0</code>。</p>
<h3 id="示例：-8"><a href="#示例：-8" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* position = std::<span class="built_in">strchr</span>(str, ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;First occurrence of &#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; at position: &quot;</span> &lt;&lt; position - str &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strchr()</code> 函数被用来查找字符串 <code>&quot;Hello, World!&quot;</code> 中字符 <code>&#39;o&#39;</code> 的第一次出现位置。因为 <code>&#39;o&#39;</code> 第一次出现在索引为 4 的位置（字符串索引从 0 开始），所以输出结果为 <code>&quot;First occurrence of &#39;o&#39; at position: 4&quot;</code>。</p>
<h2 id="std-strrchr"><a href="#std-strrchr" class="headerlink" title="std::strrchr()"></a>std::strrchr()</h2><p><code>std::strrchr()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于在字符串中查找指定字符的最后一次出现位置。</p>
<h3 id="函数签名：-8"><a href="#函数签名：-8" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">int</span> character)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-8"><a href="#参数：-8" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：指向要搜索的以 null 结尾的 C 风格字符串的指针。</li>
<li><code>character</code>：要在字符串中查找的字符，作为整数值传递。通常使用字符的 ASCII 值作为参数传递。</li>
</ul>
<h3 id="返回值：-8"><a href="#返回值：-8" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果找到指定的字符，则返回一个指向该字符最后一次出现的位置的指针；如果未找到，则返回 <code>nullptr</code>。</li>
</ul>
<h3 id="功能：-8"><a href="#功能：-8" class="headerlink" title="功能："></a>功能：</h3><p><code>strrchr()</code> 函数在给定字符串 <code>str</code> 中从后向前搜索指定的字符 <code>character</code>，并返回最后一次出现的位置（指针）。它从字符串的结尾向开头搜索，直到找到指定的字符或者遇到字符串起始位置。</p>
<h3 id="示例：-9"><a href="#示例：-9" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* position = std::<span class="built_in">strrchr</span>(str, ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Last occurrence of &#x27;&quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;&#x27; at position: &quot;</span> &lt;&lt; position - str &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strrchr()</code> 函数被用来查找字符串 <code>&quot;Hello, World!&quot;</code> 中字符 <code>&#39;o&#39;</code> 的最后一次出现位置。因为 <code>&#39;o&#39;</code> 最后一次出现在索引为 8 的位置（字符串索引从 0 开始），所以输出结果为 <code>&quot;Last occurrence of &#39;o&#39; at position: 8&quot;</code>。</p>
<h2 id="std-strstr"><a href="#std-strstr" class="headerlink" title="std::strstr()"></a>std::strstr()</h2><p><code>std::strstr()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于在字符串中查找子串的第一次出现位置。</p>
<h3 id="函数签名：-9"><a href="#函数签名：-9" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>* substr)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-9"><a href="#参数：-9" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：指向要搜索的以 null 结尾的 C 风格字符串的指针。</li>
<li><code>substr</code>：指向要查找的以 null 结尾的 C 风格子串的指针。</li>
</ul>
<h3 id="返回值：-9"><a href="#返回值：-9" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果找到子串，则返回一个指向字符串 <code>str</code> 中子串 <code>substr</code> 第一次出现的位置的指针；如果未找到，则返回 <code>nullptr</code>。</li>
</ul>
<h3 id="功能：-9"><a href="#功能：-9" class="headerlink" title="功能："></a>功能：</h3><p><code>strstr()</code> 函数在给定字符串 <code>str</code> 中搜索子串 <code>substr</code>，并返回子串第一次出现的位置（指针）。如果找到了子串，则返回子串第一次出现的位置的指针；如果未找到，则返回 <code>nullptr</code>。</p>
<h3 id="示例：-10"><a href="#示例：-10" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* substr = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* position = std::<span class="built_in">strstr</span>(str, substr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Substring found at position: &quot;</span> &lt;&lt; position - str &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Substring not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strstr()</code> 函数被用来查找字符串 <code>&quot;Hello, World!&quot;</code> 中子串 <code>&quot;World&quot;</code> 的第一次出现位置。由于 <code>&quot;World&quot;</code> 子串第一次出现在索引为 7 的位置（字符串索引从 0 开始），所以输出结果为 <code>&quot;Substring found at position: 7&quot;</code>。</p>
<h2 id="std-strtok"><a href="#std-strtok" class="headerlink" title="std::strtok()"></a>std::strtok()</h2><p><code>std::strtok()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于将字符串分割成标记（token）。</p>
<h3 id="函数签名：-10"><a href="#函数签名：-10" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strtok</span><span class="params">(<span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>* delimiters)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-10"><a href="#参数：-10" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要分割的字符串。第一次调用时，传入要分割的字符串；在后续调用时，传入 <code>nullptr</code>。如果 <code>str</code> 不是 <code>nullptr</code>，则函数会修改这个字符串，将找到的分隔标记替换为 null 终止符 <code>\0</code>。</li>
<li><code>delimiters</code>：作为分隔标记的字符集合，表示分割字符串的分隔符。</li>
</ul>
<h3 id="返回值：-10"><a href="#返回值：-10" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果找到标记，则返回标记的指针；如果字符串结束或者没有找到标记，则返回 <code>nullptr</code>。</li>
</ul>
<h3 id="功能：-10"><a href="#功能：-10" class="headerlink" title="功能："></a>功能：</h3><p><code>strtok()</code> 函数用于将字符串 <code>str</code> 根据指定的分隔符 <code>delimiters</code> 进行分割，返回每个分割出来的标记。第一次调用时，<code>str</code> 指向要分割的字符串，后续调用时传入 <code>nullptr</code> 继续分割。每次调用会返回找到的下一个标记，直到字符串结束或者没有找到更多标记。</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>strtok()</code> 函数是非线程安全的，因为它使用了静态变量来存储上次分割的位置。在多线程环境中，可以使用 <code>strtok_r()</code>（POSIX 函数）或者其他替代方案。</li>
</ul>
<h3 id="示例：-11"><a href="#示例：-11" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello, World! This is a test.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* token = std::<span class="built_in">strtok</span>(str, <span class="string">&quot; ,.!&quot;</span>); <span class="comment">// 分割字符集为空格、逗号和句号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Token: &quot;</span> &lt;&lt; token &lt;&lt; std::endl;</span><br><span class="line">        token = std::<span class="built_in">strtok</span>(<span class="literal">nullptr</span>, <span class="string">&quot; ,.!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strtok()</code> 函数用于将字符串 <code>&quot;Hello, World! This is a test.&quot;</code> 按照空格、逗号和句号作为分隔符进行分割。通过循环调用 <code>strtok()</code>，分别获取分割出来的标记，并输出每个标记。</p>
<h2 id="std-strpbrk"><a href="#std-strpbrk" class="headerlink" title="std::strpbrk()"></a>std::strpbrk()</h2><p><code>std::strpbrk()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于在字符串中查找任意字符集中的任意字符第一次出现的位置。</p>
<h3 id="函数签名：-11"><a href="#函数签名：-11" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strpbrk</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> <span class="type">char</span>* charset)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-11"><a href="#参数：-11" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要搜索的以 null 结尾的 C 风格字符串的指针。</li>
<li><code>charset</code>：作为搜索字符集合的字符串，包含了要在 <code>str</code> 中查找的字符。</li>
</ul>
<h3 id="返回值：-11"><a href="#返回值：-11" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果找到任意字符集中的任意字符，则返回第一个匹配的字符的指针；如果未找到，则返回 <code>nullptr</code>。</li>
</ul>
<h3 id="功能：-11"><a href="#功能：-11" class="headerlink" title="功能："></a>功能：</h3><p><code>strpbrk()</code> 函数在给定字符串 <code>str</code> 中搜索 <code>charset</code> 中的任意字符，返回第一次出现的位置（指针）。它会从字符串的开头开始搜索，直到找到任意字符集中的字符或者遇到字符串结束符 <code>\0</code>。</p>
<h3 id="示例：-12"><a href="#示例：-12" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* charset = <span class="string">&quot;od!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* position = std::<span class="built_in">strpbrk</span>(str, charset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character found at position: &quot;</span> &lt;&lt; position - str &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>strpbrk()</code> 函数被用来查找字符串 <code>&quot;Hello, World!&quot;</code> 中字符集 <code>&quot;od!&quot;</code> 中的任意字符第一次出现的位置。由于其中字符 <code>&#39;o&#39;</code> 第一次出现在索引为 4 的位置（字符串索引从 0 开始），所以输出结果为 <code>&quot;Character found at position: 4&quot;</code>。</p>
<h2 id="std-memcpy"><a href="#std-memcpy" class="headerlink" title="std::memcpy"></a>std::memcpy</h2><p><code>std::memcpy</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中定义的函数，用于在内存块之间复制一定数量的字节。</p>
<p>其基本原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memcpy</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, std::<span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dest</code>：目标内存块的起始地址，数据将被复制到这个地址。</li>
<li><code>src</code>：源内存块的起始地址，数据将从这个地址复制到目标内存块。</li>
<li><code>count</code>：要复制的字节数。</li>
</ul>
<p><code>std::memcpy</code> 主要用于进行内存的原始字节级别的拷贝操作。它是一种直接的、快速的内存拷贝方式，通常用于复制大块的内存数据。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> source[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> destination[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">memcpy</span>(destination, source, std::<span class="built_in">strlen</span>(source) + <span class="number">1</span>); <span class="comment">// 复制 source 到 destination</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Copied string: &quot;</span> &lt;&lt; destination &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::memcpy</code> 用于将源字符串 <code>source</code> 复制到目标字符串 <code>destination</code>，包括字符串结尾的 null 终止符。要确保目标内存块足够大以容纳源内存块的数据。</p>
<h2 id="std-memset"><a href="#std-memset" class="headerlink" title="std::memset()"></a>std::memset()</h2><p><code>std::memset()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中定义的函数，用于设置指定内存区域的内容为指定的值。</p>
<p>其基本原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memset</span><span class="params">(<span class="type">void</span>* dest, <span class="type">int</span> value, std::<span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dest</code>：要设置值的内存区域的起始地址。</li>
<li><code>value</code>：要设置的值，通常是一个整数（<code>int</code> 类型），会被转换为无符号字符进行设置。</li>
<li><code>count</code>：要设置的字节数。</li>
</ul>
<p><code>std::memset()</code> 将 <code>value</code> 的值复制到 <code>dest</code> 指向的内存区域的前 <code>count</code> 个字节。通常情况下，它用于初始化内存块为特定的值，比如初始化数组、清除缓冲区等。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">memset</span>(buffer, <span class="string">&#x27;A&#x27;</span>, <span class="built_in">sizeof</span>(buffer)); <span class="comment">// 将 buffer 内存区域的内容设置为字符 &#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Buffer after memset: &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::memset()</code> 将字符 <code>&#39;A&#39;</code> 设置到 <code>buffer</code> 内存区域的每个字节中。要注意，<code>std::memset()</code> 是按字节进行操作，并不会处理字符数组或字符串的结尾 null 终止符。</p>
<h2 id="std-memmove"><a href="#std-memmove" class="headerlink" title="std::memmove()"></a>std::memmove()</h2><p><code>std::memmove()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于在内存块之间移动一定数量的字节，即使这两个内存块有重叠。</p>
<h3 id="函数签名：-12"><a href="#函数签名：-12" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memmove</span><span class="params">(<span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-12"><a href="#参数：-12" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>dest</code>：指向目标内存区域的指针，表示要移动数据的目标位置。</li>
<li><code>src</code>：指向源内存区域的指针，表示要从哪里复制数据。</li>
<li><code>count</code>：要移动的字节数。</li>
</ul>
<h3 id="返回值：-12"><a href="#返回值：-12" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回指向目标内存区域的指针。</li>
</ul>
<h3 id="功能：-12"><a href="#功能：-12" class="headerlink" title="功能："></a>功能：</h3><p><code>memmove()</code> 函数用于从源地址 <code>src</code> 复制 <code>count</code> 个字节的数据到目标地址 <code>dest</code>。这个函数可以处理源地址和目标地址的内存重叠情况，保证在复制数据时不会出错。</p>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>memmove()</code> 函数比 <code>memcpy()</code> 更安全，因为它可以正确处理内存区域的重叠。对于无重叠的内存区域，<code>memcpy()</code> 和 <code>memmove()</code> 的功能基本相同。</li>
</ul>
<h3 id="示例：-13"><a href="#示例：-13" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before memmove: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动字符串中的一部分数据，模拟向左移动6个字符</span></span><br><span class="line">    std::<span class="built_in">memmove</span>(str + <span class="number">5</span>, str + <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After memmove: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>memmove()</code> 函数被用来将字符串中的一部分数据向左移动了 6 个字符。原始字符串为 <code>&quot;Hello, World!&quot;</code>，经过 <code>memmove()</code> 处理后变为 <code>&quot;HelloWorld, World!&quot;</code>。</p>
<h2 id="std-memcmp"><a href="#std-memcmp" class="headerlink" title="std::memcmp()"></a>std::memcmp()</h2><p><code>std::memcmp()</code> 是 C++ 标准库 <code>&lt;cstring&gt;</code> 头文件中的函数，用于比较两个内存块的内容。</p>
<h3 id="函数签名：-13"><a href="#函数签名：-13" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* ptr1, <span class="type">const</span> <span class="type">void</span>* ptr2, <span class="type">size_t</span> num)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-13"><a href="#参数：-13" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>ptr1</code>：指向要比较的第一个内存块的指针。</li>
<li><code>ptr2</code>：指向要比较的第二个内存块的指针。</li>
<li><code>num</code>：要比较的字节数。</li>
</ul>
<h3 id="返回值：-13"><a href="#返回值：-13" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果两个内存块的内容相等，则返回 <code>0</code>。</li>
<li>如果第一个内存块的内容小于第二个内存块的内容，则返回负值。</li>
<li>如果第一个内存块的内容大于第二个内存块的内容，则返回正值。</li>
</ul>
<h3 id="功能：-13"><a href="#功能：-13" class="headerlink" title="功能："></a>功能：</h3><p><code>memcmp()</code> 函数用于按字节比较两个内存块的内容。它逐字节比较两个内存块的内容，直到比较完指定的字节数 <code>num</code> 或者发现第一个不相等的字节。返回比较结果。</p>
<h3 id="示例：-14"><a href="#示例：-14" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str3 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result1 = std::<span class="built_in">memcmp</span>(str1, str2, <span class="number">5</span>); <span class="comment">// 比较 str1 和 str2 的前5个字符</span></span><br><span class="line">    <span class="type">int</span> result2 = std::<span class="built_in">memcmp</span>(str1, str3, <span class="number">5</span>); <span class="comment">// 比较 str1 和 str3 的前5个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result1 == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 and str2 are equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 and str2 are not equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result2 == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 and str3 are equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 and str3 are not equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>memcmp()</code> 函数被用来比较字符串 <code>&quot;Hello&quot;</code> 和 <code>&quot;Hello&quot;</code> 以及 <code>&quot;Hello&quot;</code> 和 <code>&quot;World&quot;</code> 的前5个字符。由于前两个字符串相等，所以 <code>result1</code> 为 <code>0</code>，输出结果为 <code>&quot;str1 and str2 are equal.&quot;</code>；而第二个比较中，因为字符串不相等，所以 <code>result2</code> 不为 <code>0</code>，输出结果为 <code>&quot;str1 and str3 are not equal.&quot;</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_15_atomic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_15_atomic/" class="post-title-link" itemprop="url">C++_10_15_atomic</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <atomic>标准库</li>
</ul>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <atomic>标准库 详解</h2><p><code>&lt;atomic&gt;</code> 是 C++ 标准库中提供的用于原子操作的头文件，它提供了一组工具和类型，用于在多线程环境中执行原子操作。原子操作是指在执行过程中不会被中断的操作，它们能够确保多个线程同时访问共享数据时不会发生竞态条件（race condition）。</p>
<p>以下是 <code>&lt;atomic&gt;</code> 头文件中最常用的类和函数：</p>
<h3 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h3><ul>
<li><strong>std::atomic&lt;T&gt;</strong>: 这是模板类，提供了对类型 T 的原子访问。可以使用不同的基本数据类型（如整数、指针等）来实例化它。</li>
</ul>
<h3 id="原子操作函数"><a href="#原子操作函数" class="headerlink" title="原子操作函数"></a>原子操作函数</h3><ul>
<li><code>store()</code>: 将值存储到原子对象中。</li>
<li><code>load()</code>: 从原子对象中加载值。</li>
<li><code>exchange()</code>: 将新值存储到原子对象中，并返回先前的值。</li>
<li><code>compare_exchange_weak()</code> 和 <code>compare_exchange_strong()</code>: 比较原子对象的值与预期值，如果相等则修改。<code>compare_exchange_weak()</code> 可能会在比较失败时返回 <code>false</code>，而 <code>compare_exchange_strong()</code> 则保证了强一致性。</li>
<li><code>fetch_add()</code>, <code>fetch_sub()</code>, <code>fetch_and()</code>, <code>fetch_or()</code>, <code>fetch_xor()</code>: 执行原子的加法、减法、与操作、或操作和异或操作，并返回操作之前的值。</li>
</ul>
<h3 id="其他重要函数和特性"><a href="#其他重要函数和特性" class="headerlink" title="其他重要函数和特性"></a>其他重要函数和特性</h3><ul>
<li><code>is_lock_free()</code>: 检查给定类型的原子操作是否是无锁的，即是否可以在特定平台上以原子方式执行。</li>
<li>Memory Order（内存顺序）：这些是在原子操作中指定的参数，用于控制原子操作的顺序和可见性。<ul>
<li><code>memory_order_relaxed</code>: 最轻量级的内存顺序，没有顺序约束。</li>
<li><code>memory_order_acquire</code>, <code>memory_order_release</code>: 分别用于读操作和写操作的同步。</li>
<li><code>memory_order_consume</code>: 用于依赖关系。</li>
<li><code>memory_order_seq_cst</code>: 最严格的内存顺序，提供全序保证。</li>
</ul>
</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        atomic_counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(increment_counter)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread2</span><span class="params">(increment_counter)</span></span>;</span><br><span class="line"></span><br><span class="line">    thread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    thread<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; atomic_counter.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个简单的示例，展示了如何使用 <code>&lt;atomic&gt;</code> 来确保在多线程环境中对共享变量进行原子操作。在这个例子中，两个线程分别调用 <code>increment_counter()</code> 函数来增加 <code>atomic_counter</code> 的值，最终输出其最终的值。</p>
<p>请注意，在使用原子操作时要小心避免出现数据竞争和不正确的同步问题。原子操作能够提供基本的线程安全保证，但仍需谨慎设计代码以避免更复杂的并发问题。</p>
<h2 id="C-标准库-常用类和函数"><a href="#C-标准库-常用类和函数" class="headerlink" title="C++ 标准库 常用类和函数"></a>C++ <atomic>标准库 常用类和函数</h2><p>在 C++ 标准库中的 <code>&lt;atomic&gt;</code> 头文件中，常用的类和函数如下：</p>
<h3 id="常用类："><a href="#常用类：" class="headerlink" title="常用类："></a>常用类：</h3><ol>
<li>**std::atomic&lt;T&gt;**：表示一个原子类型，用于执行对类型 <code>T</code> 的原子操作。<ul>
<li><code>store(val, order)</code>: 将值 <code>val</code> 存储到原子对象中，使用指定的内存顺序 <code>order</code>。</li>
<li><code>load(order)</code>: 从原子对象中加载值，使用指定的内存顺序 <code>order</code>。</li>
<li><code>exchange(val, order)</code>: 将新值 <code>val</code> 存储到原子对象中，并返回先前的值，使用指定的内存顺序 <code>order</code>。</li>
<li><code>compare_exchange_weak(expected, val, order_success, order_failure)</code>: 如果原子对象的值等于 <code>expected</code>，则将其设置为 <code>val</code>，并返回 <code>true</code>；否则，将 <code>expected</code> 更新为原子对象的当前值，并返回 <code>false</code>。该操作使用 <code>order_success</code> 和 <code>order_failure</code> 指定的内存顺序。</li>
<li><code>fetch_add(val, order)</code>, <code>fetch_sub(val, order)</code>, <code>fetch_and(val, order)</code>, <code>fetch_or(val, order)</code>, <code>fetch_xor(val, order)</code>: 执行原子的加法、减法、与操作、或操作和异或操作，并返回操作之前的值，使用指定的内存顺序 <code>order</code>。</li>
</ul>
</li>
</ol>
<h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><ol>
<li>**std::atomic_thread_fence(order)**：在当前线程执行内存屏障（memory fence），强制按照指定的内存顺序 <code>order</code> 来排序内存访问操作。</li>
<li>**std::atomic_signal_fence(order)**：在当前线程执行信号屏障（signal fence），强制按照指定的内存顺序 <code>order</code> 来排序内存访问操作，但不影响线程间的同步。</li>
<li>**std::atomic_is_lock_free(&amp;obj)**：检查给定的原子对象 <code>obj</code> 是否是无锁的，返回 <code>true</code> 表示原子类型在特定平台上支持无锁操作。</li>
</ol>
<h3 id="内存顺序（Memory-Order）："><a href="#内存顺序（Memory-Order）：" class="headerlink" title="内存顺序（Memory Order）："></a>内存顺序（Memory Order）：</h3><ul>
<li><code>std::memory_order_relaxed</code>：最轻量级的内存顺序，没有顺序约束。</li>
<li><code>std::memory_order_acquire</code>：用于读取操作，确保在这个操作之后的读取操作都不会被重新排序到这个操作之前。</li>
<li><code>std::memory_order_release</code>：用于写入操作，确保在这个操作之前的写入操作都不会被重新排序到这个操作之后。</li>
<li><code>std::memory_order_acq_rel</code>：同时包括 <code>acquire</code> 和 <code>release</code> 的特性。</li>
<li><code>std::memory_order_seq_cst</code>：最严格的内存顺序，提供全序保证。</li>
</ul>
<p>这些类和函数提供了一套原子操作的工具，使得在多线程环境中对共享数据进行操作时更加安全和可靠。在使用时，需要注意内存顺序和操作的原子性，以确保正确的并发行为。</p>
<h2 id="std-atomic"><a href="#std-atomic" class="headerlink" title="std::atomic"></a>std::atomic</h2><p><code>std::atomic</code> 是 C++ 标准库 <code>&lt;atomic&gt;</code> 中定义的模板类，用于执行原子操作，提供了多线程环境下对共享变量的安全访问。<code>std::atomic</code> 类型的变量可以保证其操作的原子性，即对它们的操作不会被中断。</p>
<h3 id="主要特性和操作："><a href="#主要特性和操作：" class="headerlink" title="主要特性和操作："></a>主要特性和操作：</h3><ol>
<li><p><strong>原子操作</strong>：<code>std::atomic</code> 类型的变量支持多种原子操作，包括读取、写入和各种算术和逻辑操作。这些操作保证在多线程环境中的原子性，不会被其他线程的操作中断。</p>
</li>
<li><p><strong>内存顺序（Memory Order）</strong>：原子操作可以指定内存顺序，即操作在多线程间的执行顺序，包括 <code>memory_order_relaxed</code>、<code>memory_order_acquire</code>、<code>memory_order_release</code> 等。</p>
</li>
<li><p><strong>支持的操作</strong>：<code>std::atomic</code> 类型支持各种操作，如加载（load）、存储（store）、交换（exchange）、比较交换（compare_exchange_strong&#x2F;compare_exchange_weak）等。</p>
</li>
</ol>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">incrementCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed); <span class="comment">// 原子性地增加计数器值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(incrementCounter)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(incrementCounter)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl; <span class="comment">// 输出计数器的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::atomic&lt;int&gt;</code> 类型的 <code>counter</code> 变量用于在两个线程中增加一个计数器的值。<code>fetch_add()</code> 函数用于原子性地增加计数器的值，保证了多线程环境下的安全访问。最终输出的 <code>counter</code> 值应该是 <code>20000</code>，因为两个线程各自增加了 <code>10000</code> 次。</p>
<h2 id="std-atomic-store"><a href="#std-atomic-store" class="headerlink" title="std::atomic::store()"></a>std::atomic::store()</h2><p><code>std::atomic::store()</code> 是 <code>std::atomic</code> 类中的一个成员函数，用于将指定的值存储到原子对象中。这个函数是用于原子性地将新值存储到 <code>std::atomic</code> 对象中的方法之一。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span><span class="params">( T value, std::memory_order order = std::memory_order_seq_cst )</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>value</code> 是要存储到原子对象中的新值。</li>
<li><code>order</code> 是可选的参数，表示存储操作所使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>，即最严格的顺序，提供全序保证。</li>
</ul>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    atomic_value.<span class="built_in">store</span>(<span class="number">42</span>); <span class="comment">// 将值 42 存储到 atomic_value 中，默认使用 std::memory_order_seq_cst</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value stored: &quot;</span> &lt;&lt; atomic_value.<span class="built_in">load</span>() &lt;&lt; std::endl; <span class="comment">// 输出存储后的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>store()</code> 将值 42 存储到 <code>atomic_value</code> 中，并通过 <code>load()</code> 方法加载并打印存储后的值。这些操作都是原子的，保证在多线程环境中的线程安全性。</p>
<h2 id="std-atomic-load"><a href="#std-atomic-load" class="headerlink" title="std::atomic::load()"></a>std::atomic::load()</h2><p><code>std::atomic::load()</code> 是 <code>std::atomic</code> 类的成员函数，用于从原子对象中加载值并返回该值。它是用于原子地获取 <code>std::atomic</code> 对象的值的方法之一。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">load</span><span class="params">(std::memory_order order = std::memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>order</code> 是可选的参数，表示加载操作所使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>，即最严格的顺序，提供全序保证。</li>
</ul>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> loaded_value = atomic_value.<span class="built_in">load</span>(); <span class="comment">// 从 atomic_value 中加载值，默认使用 std::memory_order_seq_cst</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value loaded: &quot;</span> &lt;&lt; loaded_value &lt;&lt; std::endl; <span class="comment">// 输出加载的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>load()</code> 方法从 <code>atomic_value</code> 中加载其当前的值，并将其赋给 <code>loaded_value</code> 变量。这个操作是原子的，确保在多线程环境中的线程安全性。</p>
<h2 id="std-atomic-exchange"><a href="#std-atomic-exchange" class="headerlink" title="std::atomic::exchange()"></a>std::atomic::exchange()</h2><p><code>std::atomic::exchange()</code> 是 <code>std::atomic</code> 类的成员函数，用于将新值存储到原子对象中，并返回先前的值。这个函数允许原子地交换原子对象的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">exchange</span><span class="params">(T desired, std::memory_order order = std::memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>desired</code> 是要存储到原子对象中的新值。</li>
<li><code>order</code> 是可选的参数，表示交换操作所使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>，即最严格的顺序，提供全序保证。</li>
</ul>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> old_value = atomic_value.<span class="built_in">exchange</span>(<span class="number">100</span>); <span class="comment">// 将值 100 存储到 atomic_value 中，并返回先前的值，默认使用 std::memory_order_seq_cst</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Old value exchanged: &quot;</span> &lt;&lt; old_value &lt;&lt; std::endl; <span class="comment">// 输出交换前的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current value: &quot;</span> &lt;&lt; atomic_value.<span class="built_in">load</span>() &lt;&lt; std::endl; <span class="comment">// 输出当前值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>exchange()</code> 方法将值 100 存储到 <code>atomic_value</code> 中，并将先前的值（42）返回并存储在 <code>old_value</code> 中。这个操作是原子的，确保在多线程环境中的线程安全性。</p>
<h2 id="std-atomic-compare-exchange-weak"><a href="#std-atomic-compare-exchange-weak" class="headerlink" title="std::atomic::compare_exchange_weak()"></a>std::atomic::compare_exchange_weak()</h2><p><code>std::atomic::compare_exchange_weak()</code> 是 <code>std::atomic</code> 类的成员函数，用于原子地比较原子对象的值与预期值，如果相等，则修改为新值。它是一种 CAS（比较并交换）操作的弱保证版本，可能在比较失败时返回 <code>false</code>，但不会引发重试。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_weak</span><span class="params">(T&amp; expected, T desired,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::memory_order success = std::memory_order_seq_cst,</span></span></span><br><span class="line"><span class="params"><span class="function">                           std::memory_order failure = std::memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>expected</code> 是期望的值，如果原子对象的值与 <code>expected</code> 相等，则修改为 <code>desired</code>。</li>
<li><code>desired</code> 是要存储到原子对象中的新值。</li>
<li><code>success</code> 是可选参数，表示成功时使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>。</li>
<li><code>failure</code> 是可选参数，表示比较失败时使用的内存顺序，默认值也是 <code>std::memory_order_seq_cst</code>。</li>
</ul>
<p>该函数将比较预期值（<code>expected</code>）和原子对象的当前值，如果相等，则将原子对象的值设置为 <code>desired</code>，并返回 <code>true</code>；否则，将 <code>expected</code> 更新为原子对象的当前值，并返回 <code>false</code>。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> expected = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> desired = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> success = atomic_value.<span class="built_in">compare_exchange_weak</span>(expected, desired); <span class="comment">// 比较预期值与原子对象的值，若相等则修改为新值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value exchanged successfully!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value not exchanged. Expected: &quot;</span> &lt;&lt; expected &lt;&lt; <span class="string">&quot;, Actual: &quot;</span> &lt;&lt; atomic_value.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>compare_exchange_weak()</code> 将比较 <code>atomic_value</code> 和 <code>expected</code>，若相等，则将其修改为 <code>desired</code>。成功时返回 <code>true</code>，并输出成功的消息，否则返回 <code>false</code>，并输出原子对象的当前值和预期值。</p>
<h2 id="std-atomic-fetch-add"><a href="#std-atomic-fetch-add" class="headerlink" title="std::atomic::fetch_add()"></a>std::atomic::fetch_add()</h2><p><code>std::atomic::fetch_add()</code> 是 <code>std::atomic</code> 类的成员函数，用于执行原子的加法操作，并返回操作之前的值。它是一种原子操作，用于对原子对象的值进行增加操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">fetch_add</span><span class="params">(T arg, std::memory_order order = std::memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>arg</code> 是要增加到原子对象中的值。</li>
<li><code>order</code> 是可选参数，表示操作所使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>，即最严格的顺序，提供全序保证。</li>
</ul>
<p>该函数将原子对象的值增加 <code>arg</code>，并返回增加前的值。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> previous_value = atomic_value.<span class="built_in">fetch_add</span>(<span class="number">5</span>); <span class="comment">// 将值 5 加到 atomic_value 中，并返回增加前的值，默认使用 std::memory_order_seq_cst</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Previous value: &quot;</span> &lt;&lt; previous_value &lt;&lt; std::endl; <span class="comment">// 输出增加前的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current value: &quot;</span> &lt;&lt; atomic_value.<span class="built_in">load</span>() &lt;&lt; std::endl; <span class="comment">// 输出当前值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>fetch_add()</code> 方法将值 5 加到 <code>atomic_value</code> 中，并返回增加前的值。这个操作是原子的，确保在多线程环境中的线程安全性。</p>
<h2 id="std-atomic-fetch-sub"><a href="#std-atomic-fetch-sub" class="headerlink" title="std::atomic::fetch_sub()"></a>std::atomic::fetch_sub()</h2><p><code>std::atomic::fetch_sub()</code> 是 <code>std::atomic</code> 类的成员函数，用于执行原子的减法操作，并返回操作之前的值。它是一种原子操作，用于对原子对象的值进行减少操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">fetch_sub</span><span class="params">(T arg, std::memory_order order = std::memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>arg</code> 是要减少的值，会从原子对象中减去这个值。</li>
<li><code>order</code> 是可选参数，表示操作所使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>，即最严格的顺序，提供全序保证。</li>
</ul>
<p>该函数将原子对象的值减少 <code>arg</code>，并返回减少前的值。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> previous_value = atomic_value.<span class="built_in">fetch_sub</span>(<span class="number">7</span>); <span class="comment">// 从 atomic_value 中减去值 7，并返回减少前的值，默认使用 std::memory_order_seq_cst</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Previous value: &quot;</span> &lt;&lt; previous_value &lt;&lt; std::endl; <span class="comment">// 输出减少前的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current value: &quot;</span> &lt;&lt; atomic_value.<span class="built_in">load</span>() &lt;&lt; std::endl; <span class="comment">// 输出当前值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>fetch_sub()</code> 方法将值 7 从 <code>atomic_value</code> 中减去，并返回减少前的值。这个操作是原子的，确保在多线程环境中的线程安全性。</p>
<h2 id="std-atomic-fetch-add-1"><a href="#std-atomic-fetch-add-1" class="headerlink" title="std::atomic::fetch_add()"></a>std::atomic::fetch_add()</h2><p><code>std::atomic::fetch_and()</code> 是 <code>std::atomic</code> 类的成员函数，用于执行原子的按位与（AND）操作，并返回操作之前的值。它是一种原子操作，用于对原子对象的值进行按位与操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">fetch_and</span><span class="params">(T arg, std::memory_order order = std::memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>arg</code> 是用于按位与运算的操作数，会与原子对象的值进行按位与操作。</li>
<li><code>order</code> 是可选参数，表示操作所使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>，即最严格的顺序，提供全序保证。</li>
</ul>
<p>该函数将原子对象的值与 <code>arg</code> 进行按位与运算，并返回按位与运算前的原子对象的值。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">0b1100</span>)</span></span>; <span class="comment">// 值为 12 (二进制 1100)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> previous_value = atomic_value.<span class="built_in">fetch_and</span>(<span class="number">0b1010</span>); <span class="comment">// 对 atomic_value 进行按位与操作，并返回按位与前的值，默认使用 std::memory_order_seq_cst</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Previous value: &quot;</span> &lt;&lt; previous_value &lt;&lt; std::endl; <span class="comment">// 输出按位与前的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current value: &quot;</span> &lt;&lt; atomic_value.<span class="built_in">load</span>() &lt;&lt; std::endl; <span class="comment">// 输出当前值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>fetch_and()</code> 方法将 <code>atomic_value</code> 的值与 0b1010 进行按位与操作，并返回按位与操作前的值。这个操作是原子的，确保在多线程环境中的线程安全性。</p>
<h2 id="std-atomic-fetch-or"><a href="#std-atomic-fetch-or" class="headerlink" title="std::atomic::fetch_or()"></a>std::atomic::fetch_or()</h2><p><code>std::atomic::fetch_or()</code> 是 <code>std::atomic</code> 类的成员函数，用于执行原子的按位或（OR）操作，并返回操作之前的值。它是一种原子操作，用于对原子对象的值进行按位或操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">fetch_or</span><span class="params">(T arg, std::memory_order order = std::memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>arg</code> 是用于按位或运算的操作数，会与原子对象的值进行按位或操作。</li>
<li><code>order</code> 是可选参数，表示操作所使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>，即最严格的顺序，提供全序保证。</li>
</ul>
<p>该函数将原子对象的值与 <code>arg</code> 进行按位或运算，并返回按位或运算前的原子对象的值。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">0b1100</span>)</span></span>; <span class="comment">// 值为 12 (二进制 1100)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> previous_value = atomic_value.<span class="built_in">fetch_or</span>(<span class="number">0b1010</span>); <span class="comment">// 对 atomic_value 进行按位或操作，并返回按位或前的值，默认使用 std::memory_order_seq_cst</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Previous value: &quot;</span> &lt;&lt; previous_value &lt;&lt; std::endl; <span class="comment">// 输出按位或前的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current value: &quot;</span> &lt;&lt; atomic_value.<span class="built_in">load</span>() &lt;&lt; std::endl; <span class="comment">// 输出当前值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>fetch_or()</code> 方法将 <code>atomic_value</code> 的值与 0b1010 进行按位或操作，并返回按位或操作前的值。这个操作是原子的，确保在多线程环境中的线程安全性。</p>
<h2 id="std-atomic-fetch-xor"><a href="#std-atomic-fetch-xor" class="headerlink" title="std::atomic::fetch_xor()"></a>std::atomic::fetch_xor()</h2><p><code>std::atomic::fetch_xor()</code> 是 <code>std::atomic</code> 类的成员函数，用于执行原子的按位异或（XOR）操作，并返回操作之前的值。它是一种原子操作，用于对原子对象的值进行按位异或操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">fetch_xor</span><span class="params">(T arg, std::memory_order order = std::memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>arg</code> 是用于按位异或运算的操作数，会与原子对象的值进行按位异或操作。</li>
<li><code>order</code> 是可选参数，表示操作所使用的内存顺序，默认值是 <code>std::memory_order_seq_cst</code>，即最严格的顺序，提供全序保证。</li>
</ul>
<p>该函数将原子对象的值与 <code>arg</code> 进行按位异或运算，并返回按位异或运算前的原子对象的值。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">0b1100</span>)</span></span>; <span class="comment">// 值为 12 (二进制 1100)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> previous_value = atomic_value.<span class="built_in">fetch_xor</span>(<span class="number">0b1010</span>); <span class="comment">// 对 atomic_value 进行按位异或操作，并返回按位异或前的值，默认使用 std::memory_order_seq_cst</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Previous value: &quot;</span> &lt;&lt; previous_value &lt;&lt; std::endl; <span class="comment">// 输出按位异或前的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current value: &quot;</span> &lt;&lt; atomic_value.<span class="built_in">load</span>() &lt;&lt; std::endl; <span class="comment">// 输出当前值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>fetch_xor()</code> 方法将 <code>atomic_value</code> 的值与 0b1010 进行按位异或操作，并返回按位异或操作前的值。这个操作是原子的，确保在多线程环境中的线程安全性。</p>
<h2 id="std-atomic-is-lock-free"><a href="#std-atomic-is-lock-free" class="headerlink" title="std::atomic::is_lock_free()"></a>std::atomic::is_lock_free()</h2><p><code>std::atomic::is_lock_free()</code> 是 <code>std::atomic</code> 类的成员函数，用于检查特定类型的原子操作是否是无锁（lock-free）的。这个函数返回一个布尔值，表示给定类型的原子操作是否可以在特定平台上以无锁方式执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">is_lock_free</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数是一个静态成员函数，可以在实例化 <code>std::atomic</code> 类之前使用。它在编译时确定，用于检查给定类型的原子操作是否可以在当前平台上以无锁方式执行。如果返回 <code>true</code>，表示该类型的原子操作在该平台上是无锁的；如果返回 <code>false</code>，则表示不是无锁的。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Atomic int is lock-free: &quot;</span> &lt;&lt; std::atomic&lt;<span class="type">int</span>&gt;::<span class="built_in">is_lock_free</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Atomic double is lock-free: &quot;</span> &lt;&lt; std::atomic&lt;<span class="type">double</span>&gt;::<span class="built_in">is_lock_free</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，<code>is_lock_free()</code> 分别检查 <code>std::atomic&lt;int&gt;</code> 和 <code>std::atomic&lt;double&gt;</code> 是否是无锁的，并输出结果。这个函数对于确定特定类型的原子操作在给定平台上是否无锁非常有用。</p>
<h2 id="std-atomic-memory-order-relaxed"><a href="#std-atomic-memory-order-relaxed" class="headerlink" title="std::atomic::memory_order_relaxed()"></a>std::atomic::memory_order_relaxed()</h2><p>在C++中，<code>std::atomic</code> 的成员函数 <code>memory_order_relaxed</code> 是一个静态成员函数，它用于提供一个标志位（枚举类型）<code>std::memory_order_relaxed</code>，用于指示最轻松的内存顺序，它表示不对原子操作的顺序做出任何约束。</p>
<p><code>std::memory_order_relaxed</code> 并不是 <code>std::atomic</code> 类的函数，而是用于指定原子操作内存顺序的枚举类型。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">atomic_value</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    atomic_value.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed); <span class="comment">// 使用 relaxed 内存顺序进行存储操作</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> loaded_value = atomic_value.<span class="built_in">load</span>(std::memory_order_relaxed); <span class="comment">// 使用 relaxed 内存顺序进行加载操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value stored and loaded with relaxed order: &quot;</span> &lt;&lt; loaded_value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::memory_order_relaxed</code> 被用作 <code>store()</code> 和 <code>load()</code> 方法的参数，指定了这些原子操作的内存顺序是最轻松的，没有特定的顺序约束。</p>
<h2 id="std-memory-order-acquire"><a href="#std-memory-order-acquire" class="headerlink" title="std::memory_order_acquire"></a>std::memory_order_acquire</h2><p><code>std::memory_order_acquire</code> 是 C++ 标准库 <code>&lt;atomic&gt;</code> 头文件中定义的枚举常量之一，用于指定原子操作中的内存顺序，特别是用于读取操作的同步方式。</p>
<p>这个枚举类型属于 <code>std::memory_order</code> 枚举类，表示一种内存顺序，用于指定在某个原子操作中读取的同步方式。具体地说，<code>std::memory_order_acquire</code> 用于确保在当前读取操作之后，后续的读取操作不会被重排序到前面。</p>
<p>在实际编程中，可以将 <code>std::memory_order_acquire</code> 作为参数传递给原子操作的函数，例如 <code>load()</code> 函数，以指定该操作的内存顺序。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">shared_data</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_data.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed);</span><br><span class="line">    ready.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!ready.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 等待写者完成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value read: &quot;</span> &lt;&lt; shared_data.<span class="built_in">load</span>(std::memory_order_relaxed) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">writer_thread</span><span class="params">(writer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">reader_thread</span><span class="params">(reader)</span></span>;</span><br><span class="line"></span><br><span class="line">    writer_thread.<span class="built_in">join</span>();</span><br><span class="line">    reader_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::memory_order_acquire</code> 被用作 <code>load()</code> 和 <code>store()</code> 方法的参数，确保在读取 <code>shared_data</code> 和设置 <code>ready</code> 的值时使用了正确的内存顺序，以确保线程间的同步。</p>
<h2 id="std-memory-order-release"><a href="#std-memory-order-release" class="headerlink" title="std::memory_order_release"></a>std::memory_order_release</h2><p><code>std::memory_order_release</code> 是 C++ 标准库 <code>&lt;atomic&gt;</code> 头文件中定义的枚举常量之一，用于指定原子操作中的内存顺序，特别是用于写入操作的同步方式。</p>
<p>这个枚举类型属于 <code>std::memory_order</code> 枚举类，表示一种内存顺序，用于指定在某个原子操作中写入的同步方式。具体地说，<code>std::memory_order_release</code> 用于确保在当前写入操作之前，前面的写入操作不会被重排序到后面。</p>
<p>在实际编程中，可以将 <code>std::memory_order_release</code> 作为参数传递给原子操作的函数，例如 <code>store()</code> 函数，以指定该操作的内存顺序。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">shared_data</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_data.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_relaxed);</span><br><span class="line">    ready.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!ready.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 等待写者完成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value read: &quot;</span> &lt;&lt; shared_data.<span class="built_in">load</span>(std::memory_order_relaxed) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">writer_thread</span><span class="params">(writer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">reader_thread</span><span class="params">(reader)</span></span>;</span><br><span class="line"></span><br><span class="line">    writer_thread.<span class="built_in">join</span>();</span><br><span class="line">    reader_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::memory_order_release</code> 被用作 <code>store()</code> 和 <code>load()</code> 方法的参数，确保在写入 <code>shared_data</code> 和读取 <code>ready</code> 的值时使用了正确的内存顺序，以确保线程间的同步。</p>
<h2 id="std-memory-order-seq-cst"><a href="#std-memory-order-seq-cst" class="headerlink" title="std::memory_order_seq_cst"></a>std::memory_order_seq_cst</h2><p><code>std::memory_order_seq_cst</code> 是 C++ 标准库 <code>&lt;atomic&gt;</code> 头文件中定义的枚举常量之一，用于指定原子操作中的内存顺序。</p>
<p>这个枚举类型属于 <code>std::memory_order</code> 枚举类，表示顺序一致性内存顺序。具体地说，<code>std::memory_order_seq_cst</code> 表示全序（Total Ordering）保证，即对于所有线程来说，原子操作的执行顺序与其在代码中的顺序一致。</p>
<p>在实际编程中，<code>std::memory_order_seq_cst</code> 通常是默认的内存顺序，并被用作原子操作的函数参数，例如 <code>load()</code>、<code>store()</code>、<code>exchange()</code> 等，以指定原子操作的内存顺序。</p>
<p>示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">shared_data</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_data.<span class="built_in">store</span>(<span class="number">42</span>, std::memory_order_seq_cst); <span class="comment">// 使用 std::memory_order_seq_cst 内存顺序进行存储操作</span></span><br><span class="line">    ready.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_seq_cst); <span class="comment">// 使用 std::memory_order_seq_cst 内存顺序进行存储操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!ready.<span class="built_in">load</span>(std::memory_order_seq_cst)) &#123; <span class="comment">// 使用 std::memory_order_seq_cst 内存顺序进行加载操作</span></span><br><span class="line">        std::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 等待写者完成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value read: &quot;</span> &lt;&lt; shared_data.<span class="built_in">load</span>(std::memory_order_seq_cst) &lt;&lt; std::endl; <span class="comment">// 使用 std::memory_order_seq_cst 内存顺序进行加载操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">writer_thread</span><span class="params">(writer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">reader_thread</span><span class="params">(reader)</span></span>;</span><br><span class="line"></span><br><span class="line">    writer_thread.<span class="built_in">join</span>();</span><br><span class="line">    reader_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::memory_order_seq_cst</code> 被用作 <code>load()</code>、<code>store()</code> 方法的参数，确保在读取 <code>shared_data</code> 和设置 <code>ready</code> 的值时使用了顺序一致性的内存顺序，以确保线程间的同步。</p>
<h2 id="C-std-atomic-compare-exchange-strong-函数-详解"><a href="#C-std-atomic-compare-exchange-strong-函数-详解" class="headerlink" title="C++ std::atomic::compare_exchange_strong() 函数 详解"></a>C++ std::atomic::compare_exchange_strong() 函数 详解</h2><p><code>std::atomic::compare_exchange_strong()</code> 是 C++ 标准库中 <code>std::atomic</code> 类提供的一个成员函数，用于原子比较和交换操作。它允许在多线程环境中安全地执行原子操作，确保在没有其他线程干扰的情况下执行比较和交换。</p>
<p>以下是该函数的详细解释：</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_strong</span><span class="params">(T&amp; expected, T desired, memory_order order = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><p><code>expected</code>：传入一个引用，表示当前的期望值。如果当前的值等于期望值，比较和交换操作将成功，并将 <code>desired</code> 的值写入 <code>std::atomic</code> 对象；否则，<code>expected</code> 保持不变。</p>
</li>
<li><p><code>desired</code>：传入一个新值，如果当前的值等于 <code>expected</code>，则用 <code>desired</code> 替换当前值。</p>
</li>
<li><p><code>order</code>：传入一个可选参数，表示内存顺序（memory order）的类型，默认是 <code>memory_order_seq_cst</code>。内存顺序用于控制不同线程之间的操作顺序，可以选择不同的内存顺序来权衡性能和一致性。</p>
</li>
</ul>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><p>如果比较和交换成功（当前值等于期望值），则返回 <code>true</code>，并将 <code>desired</code> 的值写入 <code>std::atomic</code> 对象。</p>
</li>
<li><p>如果比较和交换失败（当前值不等于期望值），则返回 <code>false</code>，并将 <code>expected</code> 的值更新为当前的实际值。</p>
</li>
</ul>
<h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">data</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> expected = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> desired = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">compare_exchange_strong</span>(expected, desired)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exchange successful. New value: &quot;</span> &lt;&lt; data.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exchange failed. Current value: &quot;</span> &lt;&lt; data.<span class="built_in">load</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果 <code>data</code> 的当前值等于 <code>expected</code>（初始值为0），则将 <code>desired</code>（值为1）写入 <code>data</code>，并输出成功的消息。否则，输出失败的消息。</p>
<p>请注意，<code>compare_exchange_strong()</code> 函数是一个原子操作，因此可以在多线程环境中安全使用，确保在没有竞态条件的情况下执行比较和交换。</p>
<h2 id="C-std-atomic-compare-exchange-strong-函数对enum-class类型怎么处理"><a href="#C-std-atomic-compare-exchange-strong-函数对enum-class类型怎么处理" class="headerlink" title="C++ std::atomic::compare_exchange_strong() 函数对enum class类型怎么处理"></a>C++ std::atomic::compare_exchange_strong() 函数对enum class类型怎么处理</h2><p><code>std::atomic::compare_exchange_strong()</code> 函数对于 <code>enum class</code> 类型的处理与其他类型类似。这个函数用于原子地比较并交换值，确保在多线程环境中执行这个操作是安全的。</p>
<p>以下是 <code>compare_exchange_strong()</code> 函数的一般形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare_exchange_strong</span><span class="params">(T&amp; expected, T desired, memory_order order = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>T</code> 是 <code>std::atomic</code> 包装的类型。对于 <code>enum class</code> 类型，你可以使用该函数进行原子比较和交换。</p>
<p>假设你有一个 <code>enum class</code> 类型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">MyEnum</span> &#123; Value1, Value2, Value3 &#125;;</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>std::atomic</code> 包装这个类型，并使用 <code>compare_exchange_strong()</code> 函数进行原子比较和交换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::atomic&lt;MyEnum&gt; <span class="title">atomicEnum</span><span class="params">(MyEnum::Value1)</span></span>;</span><br><span class="line"></span><br><span class="line">    MyEnum expected = MyEnum::Value1;</span><br><span class="line">    MyEnum desired = MyEnum::Value2;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> success = atomicEnum.<span class="built_in">compare_exchange_strong</span>(expected, desired);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exchange successful. New value: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(desired) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Exchange failed. Current value: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(atomicEnum.<span class="built_in">load</span>()) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>compare_exchange_strong()</code> 函数将 <code>atomicEnum</code> 的当前值与 <code>expected</code> 进行比较。如果它们相等，将 <code>desired</code> 值写入 <code>atomicEnum</code> 中，并返回 <code>true</code> 表示交换成功。否则，返回 <code>false</code> 表示交换失败，并将 <code>expected</code> 更新为当前的实际值。</p>
<p>需要注意的是，由于 <code>enum class</code> 类型的底层类型是整数，所以在打印时需要使用 <code>static_cast&lt;int&gt;</code> 进行强制转换。</p>
<p>总体来说，<code>compare_exchange_strong()</code> 函数对 <code>enum class</code> 类型的处理方式与其他类型相似，提供了一种在多线程环境中执行原子比较和交换的安全手段。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_16_regex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_16_regex/" class="post-title-link" itemprop="url">C++_10_16_regex</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <regex>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <regex>标准库</h2><p><code>&lt;regex&gt;</code> 是 C++11 标准库中提供的头文件，用于处理正则表达式。它提供了一系列类和函数，使得在 C++ 程序中可以进行正则表达式的匹配、搜索和替换等操作。</p>
<h3 id="主要类和函数："><a href="#主要类和函数：" class="headerlink" title="主要类和函数："></a>主要类和函数：</h3><ol>
<li><p><strong>std::regex</strong>：表示一个正则表达式对象。</p>
</li>
<li><p>**std::regex_match()**：用于检查整个字符串是否与正则表达式匹配。</p>
</li>
<li><p>**std::regex_search()**：在给定字符串中搜索正则表达式的匹配项。</p>
</li>
<li><p>**std::regex_replace()**：使用正则表达式进行替换操作。</p>
</li>
<li><p><strong>std::smatch</strong> 和 <strong>std::cmatch</strong>：表示正则表达式匹配结果的容器，分别用于 <code>std::string</code> 和 <code>const char*</code> 类型的字符串。</p>
</li>
<li><p><strong>std::regex_iterator</strong>：用于在字符串中迭代查找匹配的正则表达式。</p>
</li>
</ol>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;fox&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查整个字符串是否与正则表达式匹配</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match not found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用正则表达式进行替换操作</span></span><br><span class="line">    std::string replacedText = std::<span class="built_in">regex_replace</span>(text, pattern, <span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Replaced text: &quot;</span> &lt;&lt; replacedText &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>&lt;regex&gt;</code> 头文件中的函数和类被用于查找匹配的字符串并进行替换。<code>std::regex_search()</code> 用于检查是否存在匹配项，而 <code>std::regex_replace()</code> 则用于替换匹配的部分。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <regex>标准库 详解</h2><p>C++ 标准库中的 <code>&lt;regex&gt;</code> 头文件提供了对正则表达式的支持，允许进行字符串的匹配、搜索和替换等操作。在 C++11 标准中引入了正则表达式库，它提供了一系列类和函数用于处理正则表达式。</p>
<h3 id="主要类和函数：-1"><a href="#主要类和函数：-1" class="headerlink" title="主要类和函数："></a>主要类和函数：</h3><ol>
<li><p><strong>std::regex</strong>：表示一个正则表达式对象。可以创建一个 <code>std::regex</code> 对象，用于表示要匹配的正则表达式模式。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;your_pattern_here&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**std::regex_match()**：用于检查整个字符串是否与正则表达式模式匹配。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;your_text_here&quot;</span>;</span><br><span class="line"><span class="type">bool</span> isMatch = std::<span class="built_in">regex_match</span>(text, pattern);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**std::regex_search()**：在给定的字符串中搜索正则表达式模式的匹配项。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;your_text_here&quot;</span>;</span><br><span class="line"><span class="type">bool</span> isMatch = std::<span class="built_in">regex_search</span>(text, pattern);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**std::regex_replace()**：使用正则表达式模式进行替换操作。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;your_text_here&quot;</span>;</span><br><span class="line">std::string replacedText = std::<span class="built_in">regex_replace</span>(text, pattern, <span class="string">&quot;replacement_text&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::smatch</strong> 和 <strong>std::cmatch</strong>：表示正则表达式匹配结果的容器，分别用于 <code>std::string</code> 和 <code>const char*</code> 类型的字符串。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;your_text_here&quot;</span>;</span><br><span class="line">std::smatch match;</span><br><span class="line">std::<span class="built_in">regex_match</span>(text, match, pattern);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::regex_iterator</strong>：用于在字符串中迭代查找正则表达式模式的匹配项。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;your_text_here&quot;</span>;</span><br><span class="line"><span class="function">std::regex_iterator&lt;std::string::iterator&gt; <span class="title">it</span><span class="params">(text.begin(), text.end(), pattern)</span></span>;</span><br><span class="line">std::regex_iterator&lt;std::string::iterator&gt; end;</span><br><span class="line"><span class="keyword">for</span> (; it != end; ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Match found: &quot;</span> &lt;&lt; it-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些函数和类提供了对正则表达式的基本支持，可以在 C++ 程序中执行各种与正则表达式相关的操作，包括匹配、搜索和替换等。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <regex>标准库 常用的类和函数</h2><p>C++ 标准库 <code>&lt;regex&gt;</code> 中包含了一些常用的类和函数，用于处理正则表达式。以下是其中一些主要的类和函数：</p>
<h3 id="主要类："><a href="#主要类：" class="headerlink" title="主要类："></a>主要类：</h3><ol>
<li><p><strong>std::regex</strong>：表示一个正则表达式对象。</p>
</li>
<li><p><strong>std::smatch</strong> 和 <strong>std::cmatch</strong>：表示正则表达式匹配结果的容器，分别用于 <code>std::string</code> 和 <code>const char*</code> 类型的字符串。</p>
</li>
<li><p><strong>std::regex_iterator</strong>：用于在字符串中迭代查找正则表达式的匹配项。</p>
</li>
</ol>
<h3 id="主要函数："><a href="#主要函数：" class="headerlink" title="主要函数："></a>主要函数：</h3><ol>
<li><p>**std::regex_match()**：用于检查整个字符串是否与正则表达式匹配。</p>
</li>
<li><p>**std::regex_search()**：在给定字符串中搜索正则表达式的匹配项。</p>
</li>
<li><p>**std::regex_replace()**：使用正则表达式进行替换操作。</p>
</li>
<li><p><strong>std::regex_constants</strong>：提供了一些常量，用于设置正则表达式的标志和选项。</p>
</li>
</ol>
<p>这些类和函数允许在 C++ 中对字符串执行正则表达式的匹配、搜索、替换等操作，为处理文本提供了强大的工具。</p>
<h2 id="std-regex"><a href="#std-regex" class="headerlink" title="std::regex"></a>std::regex</h2><p><code>std::regex</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的类，用于表示一个正则表达式对象。它允许在 C++ 程序中创建和使用正则表达式模式，并用于字符串的匹配、搜索和替换等操作。</p>
<h3 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h3><ol>
<li><p><strong>构造和使用正则表达式对象</strong>：<code>std::regex</code> 可以使用正则表达式字符串构造对象，表示要匹配的模式。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;your_pattern_here&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>匹配检查</strong>：<code>std::regex_match()</code> 函数用于检查整个字符串是否与正则表达式模式匹配。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;your_text_here&quot;</span>;</span><br><span class="line"><span class="type">bool</span> isMatch = std::<span class="built_in">regex_match</span>(text, pattern);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>搜索匹配项</strong>：<code>std::regex_search()</code> 函数在给定的字符串中搜索正则表达式模式的匹配项。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;your_text_here&quot;</span>;</span><br><span class="line"><span class="type">bool</span> isMatch = std::<span class="built_in">regex_search</span>(text, pattern);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>替换操作</strong>：<code>std::regex_replace()</code> 函数使用正则表达式模式进行替换操作。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string text = <span class="string">&quot;your_text_here&quot;</span>;</span><br><span class="line">std::string replacedText = std::<span class="built_in">regex_replace</span>(text, pattern, <span class="string">&quot;replacement_text&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>std::regex</code> 类提供了对正则表达式模式的支持，并允许在 C++ 中对字符串进行基于模式的匹配、搜索和替换等操作。</p>
<h2 id="std-smatch"><a href="#std-smatch" class="headerlink" title="std::smatch"></a>std::smatch</h2><p><code>std::smatch</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的类，用于存储正则表达式的匹配结果。它是一个模板类，用于存储 <code>std::string</code> 类型的匹配结果。</p>
<h3 id="主要特点和用法："><a href="#主要特点和用法：" class="headerlink" title="主要特点和用法："></a>主要特点和用法：</h3><ol>
<li><p><strong>存储匹配结果</strong>：<code>std::smatch</code> 类型的对象可以存储正则表达式匹配到的结果，以便进一步处理。</p>
</li>
<li><p><strong>作为 std::regex_match() 和 std::regex_search() 的参数</strong>：通常作为 <code>std::regex_match()</code> 和 <code>std::regex_search()</code> 函数的额外参数，用于存储匹配的结果。</p>
</li>
<li><p><strong>访问匹配子字符串</strong>：通过索引或迭代器等方式可以访问匹配到的子字符串。</p>
</li>
</ol>
<h3 id="示例用法：-1"><a href="#示例用法：-1" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;\\b\\w&#123;4&#125;\\b&quot;</span>)</span></span>; <span class="comment">// 匹配长度为4的单词</span></span><br><span class="line"></span><br><span class="line">    std::smatch match;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, match, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历匹配到的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = match.<span class="built_in">begin</span>(); it != match.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Matched substring: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::smatch</code> 类型的对象 <code>match</code> 用于存储正则表达式模式匹配到的结果。通过 <code>std::regex_search()</code> 函数将匹配结果存储在 <code>match</code> 对象中，并可以通过迭代器或索引访问匹配到的子字符串。</p>
<h2 id="std-cmatch"><a href="#std-cmatch" class="headerlink" title="std::cmatch"></a>std::cmatch</h2><p><code>std::cmatch</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的类，用于存储正则表达式的匹配结果。不同于 <code>std::smatch</code>，<code>std::cmatch</code> 专门用于存储匹配 C 风格字符串（<code>const char*</code> 类型）的结果。</p>
<h3 id="主要特点和用法：-1"><a href="#主要特点和用法：-1" class="headerlink" title="主要特点和用法："></a>主要特点和用法：</h3><ol>
<li><p><strong>存储匹配结果</strong>：<code>std::cmatch</code> 类型的对象可以存储正则表达式匹配到的 C 风格字符串（<code>const char*</code> 类型）的结果。</p>
</li>
<li><p><strong>作为 std::regex_match() 和 std::regex_search() 的参数</strong>：通常作为 <code>std::regex_match()</code> 和 <code>std::regex_search()</code> 函数的额外参数，用于存储匹配的结果。</p>
</li>
<li><p><strong>访问匹配子字符串</strong>：通过索引或迭代器等方式可以访问匹配到的子字符串。</p>
</li>
</ol>
<h3 id="示例用法：-2"><a href="#示例用法：-2" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* text = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;\\b\\w&#123;4&#125;\\b&quot;</span>)</span></span>; <span class="comment">// 匹配长度为4的单词</span></span><br><span class="line"></span><br><span class="line">    std::cmatch match;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, match, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历匹配到的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = match.<span class="built_in">begin</span>(); it != match.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Matched substring: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::cmatch</code> 类型的对象 <code>match</code> 用于存储正则表达式模式匹配到的 C 风格字符串的结果。通过 <code>std::regex_search()</code> 函数将匹配结果存储在 <code>match</code> 对象中，并可以通过迭代器或索引访问匹配到的子字符串。</p>
<h2 id="std-regex-iterator"><a href="#std-regex-iterator" class="headerlink" title="std::regex_iterator"></a>std::regex_iterator</h2><p><code>std::regex_iterator</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的类，用于在字符串中迭代查找正则表达式的匹配项。</p>
<h3 id="主要特点和用法：-2"><a href="#主要特点和用法：-2" class="headerlink" title="主要特点和用法："></a>主要特点和用法：</h3><ol>
<li><p><strong>在字符串中迭代查找匹配项</strong>：<code>std::regex_iterator</code> 可以在给定的字符串中按顺序迭代查找正则表达式的所有匹配项。</p>
</li>
<li><p><strong>作为 std::sregex_iterator 和 std::cregex_iterator 的实例</strong>：<code>std::regex_iterator</code> 实际上是 <code>std::sregex_iterator</code>（用于 <code>std::string</code>）和 <code>std::cregex_iterator</code>（用于 <code>const char*</code>）的实例。</p>
</li>
<li><p><strong>迭代器遍历匹配结果</strong>：通过迭代器可以逐个访问匹配的子字符串。</p>
</li>
</ol>
<h3 id="示例用法：-3"><a href="#示例用法：-3" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;\\b\\w&#123;4&#125;\\b&quot;</span>)</span></span>; <span class="comment">// 匹配长度为4的单词</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::sregex_iterator <span class="title">it</span><span class="params">(text.begin(), text.end(), pattern)</span></span>; <span class="comment">// 用于 std::string 的迭代器</span></span><br><span class="line">    std::sregex_iterator end; <span class="comment">// 结束迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; it != end; ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Matched substring: &quot;</span> &lt;&lt; it-&gt;<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::sregex_iterator</code> 被用来在给定的 <code>std::string</code> 中迭代查找正则表达式模式的匹配项。<code>std::sregex_iterator</code> 构造函数的参数是要进行匹配的字符串的迭代器范围和正则表达式模式，然后通过迭代器逐个访问匹配的子字符串。</p>
<h2 id="std-regex-match"><a href="#std-regex-match" class="headerlink" title="std::regex_match()"></a>std::regex_match()</h2><p><code>std::regex_match()</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的函数，用于检查整个字符串是否与给定的正则表达式模式匹配。</p>
<h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;quick&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isMatch = std::<span class="built_in">regex_match</span>(text, pattern);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isMatch) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Text matches the pattern!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>std::regex_match()</code> 函数接受两个参数：待匹配的字符串和正则表达式模式。</li>
<li>如果整个字符串完全匹配正则表达式模式，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li>此函数会尝试将整个输入字符串与模式进行匹配。如果整个字符串与模式匹配成功，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<p>需要注意的是，<code>std::regex_match()</code> 会尝试对整个输入字符串进行匹配，如果要在字符串中查找匹配的子序列，可以使用 <code>std::regex_search()</code>。</p>
<h2 id="std-regex-search"><a href="#std-regex-search" class="headerlink" title="std::regex_search()"></a>std::regex_search()</h2><p><code>std::regex_search()</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的函数，用于在给定的字符串中搜索正则表达式的匹配项。</p>
<h3 id="用法：-1"><a href="#用法：-1" class="headerlink" title="用法："></a>用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;\\b\\w&#123;5&#125;\\b&quot;</span>)</span></span>; <span class="comment">// 匹配长度为5的单词</span></span><br><span class="line"></span><br><span class="line">    std::smatch match; <span class="comment">// 用于存储匹配结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, match, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历匹配到的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; m : match) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Matched substring: &quot;</span> &lt;&lt; m &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>std::regex_search()</code> 函数接受三个参数：待搜索的字符串、存储匹配结果的容器（例如 <code>std::smatch</code>）和正则表达式模式。</li>
<li>它在给定的字符串中搜索匹配正则表达式模式的第一个子序列。</li>
<li>如果找到了匹配项，则返回 <code>true</code>，并将匹配结果存储在提供的容器中，否则返回 <code>false</code>。</li>
</ul>
<p>该函数会在字符串中搜索第一个匹配项并将其存储在给定的容器中，方便进一步处理匹配到的子序列。如果需要查找所有匹配项，可以使用 <code>std::regex_iterator</code> 进行迭代搜索。</p>
<h2 id="std-regex-replace"><a href="#std-regex-replace" class="headerlink" title="std::regex_replace()"></a>std::regex_replace()</h2><p><code>std::regex_replace()</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的函数，用于使用正则表达式模式对字符串进行替换操作。</p>
<h3 id="用法：-2"><a href="#用法：-2" class="headerlink" title="用法："></a>用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;\\b\\w&#123;4&#125;\\b&quot;</span>)</span></span>; <span class="comment">// 匹配长度为4的单词</span></span><br><span class="line"></span><br><span class="line">    std::string replacedText = std::<span class="built_in">regex_replace</span>(text, pattern, <span class="string">&quot;REPLACEMENT&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original text: &quot;</span> &lt;&lt; text &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Replaced text: &quot;</span> &lt;&lt; replacedText &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>std::regex_replace()</code> 函数接受三个参数：待替换的字符串、正则表达式模式和替换的文本。</li>
<li>它会搜索字符串中与正则表达式模式匹配的部分，并用指定的文本进行替换。</li>
<li>替换后的新字符串被返回，原始字符串不会被修改。</li>
</ul>
<p>在示例中，<code>\\b\\w&#123;4&#125;\\b</code> 匹配长度为 4 的单词，然后将匹配到的单词替换为字符串 <code>&quot;REPLACEMENT&quot;</code>。注意，这里使用了双反斜杠来转义正则表达式中的特殊字符。</p>
<h2 id="std-regex-constants"><a href="#std-regex-constants" class="headerlink" title="std::regex_constants"></a>std::regex_constants</h2><p><code>std::regex_constants</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中定义的命名空间，提供了一些常量，用于设置正则表达式的标志和选项。</p>
<h3 id="主要的常量："><a href="#主要的常量：" class="headerlink" title="主要的常量："></a>主要的常量：</h3><ol>
<li><strong>std::regex_constants::icase</strong>：忽略大小写进行匹配。</li>
<li><strong>std::regex_constants::nosubs</strong>：不保存子匹配结果。</li>
<li><strong>std::regex_constants::optimize</strong>：优化正则表达式，提高匹配性能。</li>
<li><strong>std::regex_constants::collate</strong>：使用与语言相关的排序规则进行匹配。</li>
</ol>
<h3 id="用法示例："><a href="#用法示例：" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;quick&quot;</span>, std::regex_constants::icase)</span></span>; <span class="comment">// 使用忽略大小写进行匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，通过指定 <code>std::regex_constants::icase</code> 标志，创建的正则表达式模式将忽略大小写进行匹配。使用这些常量可以在创建正则表达式对象时设定不同的匹配选项，以满足特定的匹配需求。</p>
<h2 id="std-regex-constants-icase"><a href="#std-regex-constants-icase" class="headerlink" title="std::regex_constants::icase"></a>std::regex_constants::icase</h2><p><code>std::regex_constants::icase</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的一个常量，用于在创建正则表达式对象时设置忽略大小写的匹配模式。</p>
<p>当使用 <code>std::regex_constants::icase</code> 常量作为 <code>std::regex</code> 构造函数的第二个参数时，表示创建的正则表达式对象将以不区分大小写的方式进行匹配。</p>
<h3 id="用法示例：-1"><a href="#用法示例：-1" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The Quick Brown Fox&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;quick&quot;</span>, std::regex_constants::icase)</span></span>; <span class="comment">// 使用忽略大小写进行匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，正则表达式模式 <code>&quot;quick&quot;</code> 在文本中找不到精确的匹配项，但由于使用了 <code>std::regex_constants::icase</code>，它会忽略大小写进行查找，因此可以找到文本中的部分匹配项。</p>
<h2 id="std-regex-constants-nosubs"><a href="#std-regex-constants-nosubs" class="headerlink" title="std::regex_constants::nosubs"></a>std::regex_constants::nosubs</h2><p><code>std::regex_constants::nosubs</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的一个常量，用于在创建正则表达式对象时设置，表示不保存子匹配结果。</p>
<p>当使用 <code>std::regex_constants::nosubs</code> 常量作为 <code>std::regex</code> 构造函数的第二个参数时，表示创建的正则表达式对象将不保存子匹配的结果。</p>
<h3 id="用法示例：-2"><a href="#用法示例：-2" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The Quick Brown Fox&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;(\\w+)\\s(\\w+)&quot;</span>, std::regex_constants::nosubs)</span></span>; <span class="comment">// 不保存子匹配结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，正则表达式模式 <code>&quot;(\\w+)\\s(\\w+)&quot;</code> 匹配两个单词之间的空格，并使用 <code>std::regex_constants::nosubs</code> 标志创建了正则表达式对象。由于使用了 <code>nosubs</code>，正则表达式对象将不保存子匹配的结果，因此在搜索时只返回是否有整个模式的匹配，而不会保存子表达式的匹配结果。</p>
<h2 id="std-regex-constants-optimize"><a href="#std-regex-constants-optimize" class="headerlink" title="std::regex_constants::optimize"></a>std::regex_constants::optimize</h2><p><code>std::regex_constants::optimize</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的一个常量，用于在创建正则表达式对象时设置，表示优化正则表达式以提高匹配性能。</p>
<p>当使用 <code>std::regex_constants::optimize</code> 常量作为 <code>std::regex</code> 构造函数的第二个参数时，表示创建的正则表达式对象将进行优化，以提高匹配性能。</p>
<h3 id="用法示例：-3"><a href="#用法示例：-3" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The Quick Brown Fox&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;[a-z]+&quot;</span>, std::regex_constants::optimize)</span></span>; <span class="comment">// 优化正则表达式以提高匹配性能</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，正则表达式模式 <code>&quot;[a-z]+&quot;</code> 用于匹配小写字母序列。通过使用 <code>std::regex_constants::optimize</code> 常量作为参数创建正则表达式对象，正则表达式将进行优化，提高匹配性能，特别是对于复杂的模式可以提升匹配速度。</p>
<h2 id="std-regex-constants-collate"><a href="#std-regex-constants-collate" class="headerlink" title="std::regex_constants::collate"></a>std::regex_constants::collate</h2><p><code>std::regex_constants::collate</code> 是 C++ 标准库 <code>&lt;regex&gt;</code> 中的一个常量，用于在创建正则表达式对象时设置，表示使用与语言相关的排序规则进行匹配。</p>
<p>当使用 <code>std::regex_constants::collate</code> 常量作为 <code>std::regex</code> 构造函数的第二个参数时，表示创建的正则表达式对象将使用与语言相关的排序规则进行匹配。</p>
<h3 id="用法示例：-4"><a href="#用法示例：-4" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string text = <span class="string">&quot;The Quick Brown Fox&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;quick&quot;</span>, std::regex_constants::icase | std::regex_constants::collate)</span></span>; <span class="comment">// 使用忽略大小写和与语言相关的排序规则进行匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(text, pattern)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No match found!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，正则表达式模式 <code>&quot;quick&quot;</code> 使用了 <code>std::regex_constants::icase</code> 进行忽略大小写匹配，并且使用了 <code>std::regex_constants::collate</code>，表示使用与语言相关的排序规则进行匹配。这允许正则表达式引擎根据当前环境的语言规则对字符进行排序和匹配。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_14_condition_variable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_14_condition_variable/" class="post-title-link" itemprop="url">C++_10_14_condition_variable</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <condition_variable>标准库</li>
</ul>
<h2 id="condition-variable-介绍"><a href="#condition-variable-介绍" class="headerlink" title="condition_variable 介绍"></a>condition_variable 介绍</h2><ul>
<li><p>在C++11中，我们可以使用条件变量(condition_variable)实现多个线程间的同步操作；当条件不满足时，相关线程被一直阻塞，直到某种条件出现，这些线程才会被唤醒。</p>
</li>
<li><p>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：</p>
<ul>
<li>一个线程因等待 条件变量的条件成立 而挂起</li>
<li>另一个线程使 条件成立， 给出信号，从而唤醒被等待的线程。</li>
</ul>
</li>
<li><p>为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起；通常情况下这个锁是std::mutex并且管理这个锁只能是 std::unique_lock<a href="std::mutex">std::mutex</a> RAII模板类</p>
</li>
<li><p>上面提到的两个步骤，分别是使用以下两个方法实现的：</p>
<ul>
<li>等待条件成立使用的是 condition_variable 类成员wait, wait_for 或 wait_util</li>
<li>给出信号使用的是 condition_variable 类成员 notify_one 或者 notify_all 函数</li>
</ul>
</li>
</ul>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ul>
<li><p>在条件变量中只能使用 std::unique_lock<a href="std::mutex">std::mutex</a> 说明</p>
</li>
<li><p>unique_lock 和 lock_guard 都是管理锁的辅助工具，都是RAII风格；它们是在定义时获得锁，在析构时释放锁。</p>
</li>
<li><p>他们的主要区别在于 unique_lock 锁机制更加灵活。</p>
</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <condition_variable>标准库</h2><p><code>&lt;condition_variable&gt;</code> 是 C++ 标准库中的头文件，提供了多线程编程中用于线程同步的条件变量。条件变量用于线程之间的同步和通信，允许一个线程在某个特定条件下等待或被唤醒，以进行进一步的处理。</p>
<p>条件变量通常与互斥量（mutex）结合使用，以便线程可以安全地等待某个条件并在条件满足时被通知。</p>
<p>下面是一个简单的示例，演示了如何使用 <code>&lt;condition_variable&gt;</code> 进行线程间的同步：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟一些工作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker: Data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main: Starting worker thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> ready; &#125;); <span class="comment">// 等待条件满足</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main: Worker signaled data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 等待工作线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，主线程等待工作线程完成一些任务并准备好数据。它通过条件变量 <code>cv</code> 和互斥量 <code>mtx</code> 来实现同步和通信。主线程在互斥量的保护下等待条件满足，而工作线程在完成工作后发送信号通知主线程条件已满足。</p>
<p><code>std::condition_variable</code> 允许线程在等待条件变为真时暂时阻塞，并在条件被满足时唤醒线程。它常与 <code>std::mutex</code> 和 <code>std::unique_lock</code> 一起使用，以确保线程安全并避免死锁。</p>
<p>条件变量是在多线程编程中实现线程同步的重要工具，它允许线程在特定条件下等待或被唤醒，并且能够准确地控制线程的执行流程。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <condition_variable>标准库 详解</h2><p><code>&lt;condition_variable&gt;</code> 是 C++ 标准库中提供的用于多线程编程的头文件之一，它包含了 <code>std::condition_variable</code> 类的定义，用于线程间的同步和通信。</p>
<h3 id="主要成员函数和功能："><a href="#主要成员函数和功能：" class="headerlink" title="主要成员函数和功能："></a>主要成员函数和功能：</h3><ol>
<li><p><code>wait()</code>：让线程等待直到满足某个特定条件。</p>
<ul>
<li>通过参数接受一个 <code>std::unique_lock</code> 对象和一个谓词（可以是 lambda 表达式），并在谓词返回 <code>true</code> 时解除阻塞，或者在收到通知时解除阻塞。</li>
<li>在等待时会释放锁，并在被唤醒后再次获取锁，允许其他线程修改被保护的数据。</li>
</ul>
</li>
<li><p><code>notify_one()</code>：唤醒等待在条件变量上的一个线程。</p>
<ul>
<li>如果有多个线程在等待，只会唤醒其中一个线程（不保证唤醒的是哪个线程）。</li>
</ul>
</li>
<li><p><code>notify_all()</code>：唤醒等待在条件变量上的所有线程。</p>
<ul>
<li>唤醒所有等待的线程，允许它们竞争锁并继续执行。</li>
</ul>
</li>
<li><p><code>std::condition_variable</code> 是与互斥量（<code>std::mutex</code>）一起使用的，通过配合 <code>std::unique_lock</code> 对象，使线程能够在等待某个条件变为真时暂时阻塞自己，等待其他线程通知并且在条件满足时继续执行。</p>
</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>下面是一个简单的示例，演示了条件变量的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        data_ready = <span class="literal">true</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker: Data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main: Starting worker thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> data_ready; &#125;); <span class="comment">// 等待条件满足</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main: Worker signaled data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 等待工作线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，工作线程会等待一段时间模拟处理数据的操作，然后通知等待中的主线程。主线程在条件变量 <code>cv</code> 上等待，直到工作线程通知数据已准备就绪才会继续执行。</p>
<p>这个示例展示了如何使用 <code>std::condition_variable</code> 实现线程间的同步和通信，允许一个线程等待某个条件满足并在条件被满足时被通知。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <condition_variable>标准库 常用的类和函数</h2><p>在C++中，<code>&lt;condition_variable&gt;</code> 标准库提供了 <code>std::condition_variable</code> 类，以及与之配合使用的一些常用函数和类型。</p>
<h3 id="主要类和类型："><a href="#主要类和类型：" class="headerlink" title="主要类和类型："></a>主要类和类型：</h3><ol>
<li><p><strong>std::condition_variable</strong>：</p>
<ul>
<li>用于线程间的同步和通信。</li>
<li>允许一个或多个线程等待某个条件满足，并在满足条件时被通知。</li>
<li>主要成员函数有 <code>wait()</code>、<code>notify_one()</code>、<code>notify_all()</code>。</li>
<li>配合 <code>std::mutex</code> 和 <code>std::unique_lock</code> 一起使用，允许线程在等待条件满足时暂时阻塞自己。</li>
</ul>
</li>
<li><p><strong>std::mutex</strong>：</p>
<ul>
<li>互斥量，用于保护共享资源，防止多个线程同时访问。</li>
<li><code>std::unique_lock</code> 通常与 <code>std::mutex</code> 一起使用，用于在多线程环境中提供对共享资源的独占访问。</li>
</ul>
</li>
<li><p><strong>std::unique_lock</strong>：</p>
<ul>
<li>提供对互斥量的锁定和解锁操作。</li>
<li>可以通过构造函数进行锁定并在作用域结束时自动解锁。</li>
</ul>
</li>
</ol>
<h3 id="常用函数和成员方法："><a href="#常用函数和成员方法：" class="headerlink" title="常用函数和成员方法："></a>常用函数和成员方法：</h3><ol>
<li><p>**<code>wait(lock, pred)</code>**：</p>
<ul>
<li><code>std::condition_variable</code> 的成员函数。</li>
<li>让线程等待，直到某个特定条件满足或者收到通知。</li>
<li>参数 <code>lock</code> 是一个 <code>std::unique_lock</code> 对象（通常与互斥量一起使用），<code>pred</code> 是一个可调用对象，用于判断等待条件是否满足。</li>
</ul>
</li>
<li><p>**<code>notify_one()</code>**：</p>
<ul>
<li><code>std::condition_variable</code> 的成员函数。</li>
<li>唤醒一个等待在条件变量上的线程。</li>
</ul>
</li>
<li><p>**<code>notify_all()</code>**：</p>
<ul>
<li><code>std::condition_variable</code> 的成员函数。</li>
<li>唤醒所有等待在条件变量上的线程。</li>
</ul>
</li>
</ol>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        data_ready = <span class="literal">true</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker: Data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main: Starting worker thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> data_ready; &#125;); <span class="comment">// 等待条件满足</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main: Worker signaled data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 等待工作线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::condition_variable</code> 如何与互斥量 <code>std::mutex</code> 结合使用，使得一个线程可以等待另一个线程满足某个条件后通知它。</p>
<h2 id="std-condition-variable"><a href="#std-condition-variable" class="headerlink" title="std::condition_variable"></a>std::condition_variable</h2><p><code>std::condition_variable</code> 是 C++ 标准库 <code>&lt;condition_variable&gt;</code> 中定义的类，用于线程间的条件变量通信和同步。</p>
<p>它通常与 <code>std::mutex</code> 结合使用，实现线程的等待和唤醒操作，以在多线程环境中进行同步和通信。</p>
<h3 id="主要操作和函数："><a href="#主要操作和函数：" class="headerlink" title="主要操作和函数："></a>主要操作和函数：</h3><ol>
<li><p>**wait()**：线程等待条件变量满足。在等待时，线程会释放与互斥量关联的锁，直到另一个线程通过 <code>notify_one()</code> 或 <code>notify_all()</code> 唤醒它。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">cv.<span class="built_in">wait</span>(lck); <span class="comment">// 等待条件变量满足</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**notify_one() 和 notify_all()**：用于唤醒一个或所有等待条件变量的线程。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line">cv.<span class="built_in">notify_one</span>(); <span class="comment">// 唤醒一个等待条件变量的线程</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">cv.<span class="built_in">notify_all</span>(); <span class="comment">// 唤醒所有等待条件变量的线程</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lck, [] &#123; <span class="keyword">return</span> ready; &#125;); <span class="comment">// 等待条件变量为 true</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread is processing...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 执行工作...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(workerThread)</span></span>; <span class="comment">// 创建新线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做一些其他工作...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待一段时间后，设置条件变量为 true</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 唤醒等待的线程</span></span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 等待线程执行完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::condition_variable</code> 被用于在工作线程等待一个条件变量为 <code>true</code> 的信号，主线程在一定条件下唤醒工作线程。工作线程在等待期间会释放锁，只有当条件满足时才会被唤醒继续执行。主线程通过 <code>notify_one()</code> 唤醒等待的工作线程。</p>
<h2 id="std-condition-variable-wait"><a href="#std-condition-variable-wait" class="headerlink" title="std::condition_variable::wait()"></a>std::condition_variable::wait()</h2><p><code>std::condition_variable::wait()</code> 是 <code>std::condition_variable</code> 类的成员函数之一，用于让线程在条件变量上等待。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>lock</code>：一个 <code>std::unique_lock&lt;std::mutex&gt;</code> 对象的引用，用于保护等待期间可能修改的共享数据。</li>
<li><code>pred</code>：一个谓词（函数或函数对象），用于检查条件是否满足。如果谓词返回 <code>false</code>，<code>wait()</code> 函数将阻塞当前线程，并在收到通知或条件变为 <code>true</code> 时解除阻塞。</li>
</ul>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ul>
<li>当前线程在调用 <code>wait()</code> 时会释放 <code>lock</code> 引用的互斥量，并进入阻塞状态，直到另一个线程调用 <code>notify_one()</code> 或 <code>notify_all()</code> 通知或条件满足，将当前线程从阻塞状态唤醒。</li>
<li>在线程被唤醒后，<code>wait()</code> 函数会重新获取 <code>lock</code> 引用的互斥量，并检查条件谓词。如果条件谓词返回 <code>true</code> 或被通知唤醒，<code>wait()</code> 函数返回，线程继续执行。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        data_ready = <span class="literal">true</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker: Data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main: Starting worker thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> data_ready; &#125;); <span class="comment">// 等待条件满足</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main: Worker signaled data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 等待工作线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>cv.wait(lock, pred)</code> 函数在等待期间会释放 <code>lock</code> 引用的互斥量，然后阻塞当前线程。当工作线程完成数据准备后，它会调用 <code>cv.notify_one()</code> 发送通知，唤醒主线程。主线程被唤醒后，重新获取互斥量，并检查 <code>data_ready</code> 变量，继续执行。</p>
<h2 id="td-condition-variable-notify-one"><a href="#td-condition-variable-notify-one" class="headerlink" title="td::condition_variable::notify_one()"></a>td::condition_variable::notify_one()</h2><p><code>std::condition_variable::notify_one()</code> 是 <code>std::condition_variable</code> 类的成员函数之一，用于唤醒等待在条件变量上的一个线程。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>notify_one()</code> 用于通知等待在条件变量上的一个线程，唤醒其中一个被阻塞的线程。</li>
<li>如果有多个线程在条件变量上等待，只有其中一个线程会被唤醒。哪个线程会被唤醒是不确定的，取决于操作系统的调度和实现。</li>
</ul>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        data_ready = <span class="literal">true</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker: Data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main: Starting worker thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> data_ready; &#125;); <span class="comment">// 等待条件满足</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main: Worker signaled data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 等待工作线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>cv.notify_one()</code> 在工作线程中被调用，它唤醒了一个等待在条件变量 <code>cv</code> 上的主线程，使其从 <code>cv.wait()</code> 阻塞状态解除，并继续执行。需要注意的是，如果有多个线程在条件变量上等待，<code>notify_one()</code> 只会唤醒其中一个线程。</p>
<h2 id="std-condition-variable-notify-all"><a href="#std-condition-variable-notify-all" class="headerlink" title="std::condition_variable::notify_all()"></a>std::condition_variable::notify_all()</h2><p><code>std::condition_variable::notify_all()</code> 是 <code>std::condition_variable</code> 类的成员函数之一，用于唤醒等待在条件变量上的所有线程。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>notify_all()</code> 用于通知等待在条件变量上的所有线程，唤醒所有被阻塞的线程。</li>
<li>调用 <code>notify_all()</code> 会使所有等待在条件变量上的线程都从等待状态解除，并尝试重新获取锁以继续执行。</li>
</ul>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        data_ready = <span class="literal">true</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker: Data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv.<span class="built_in">notify_all</span>(); <span class="comment">// 通知所有等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main: Starting worker thread...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">std::thread <span class="title">worker</span><span class="params">(worker_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> data_ready; &#125;); <span class="comment">// 等待条件满足</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Main: Worker signaled data is ready.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker.<span class="built_in">join</span>(); <span class="comment">// 等待工作线程结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，<code>cv.notify_all()</code> 在工作线程中被调用，它唤醒了所有等待在条件变量 <code>cv</code> 上的主线程。所有等待的线程都会从 <code>cv.wait()</code> 阻塞状态解除，并尝试重新获取锁以继续执行。<code>notify_all()</code> 会唤醒所有线程，让它们竞争锁资源并继续执行。</p>
<h2 id="C-std-condition-variable-any-类-详解"><a href="#C-std-condition-variable-any-类-详解" class="headerlink" title="C++  std::condition_variable_any 类 详解"></a>C++ <condition_variable> std::condition_variable_any 类 详解</h2><p><code>std::condition_variable_any</code> 是 C++11 标准库中的一个同步原语，属于 <code>&lt;condition_variable&gt;</code> 头文件。它与 <code>std::condition_variable</code> 类似，但有所不同，主要在于它不要求条件变量与特定的锁类型（如 <code>std::mutex</code> 或 <code>std::unique_lock&lt;std::mutex&gt;</code>）绑定，因此更加灵活。</p>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p><code>std::condition_variable_any</code> 是一个条件变量，允许多个线程基于某个共享状态进行等待或通知。与 <code>std::condition_variable</code> 不同的是，它的等待操作不依赖于特定的互斥锁类型。它可以与任何类型的锁配合使用，只要该锁能够提供对共享数据的互斥访问。</p>
<h3 id="2-std-condition-variable-any-和-std-condition-variable-的区别"><a href="#2-std-condition-variable-any-和-std-condition-variable-的区别" class="headerlink" title="2. std::condition_variable_any 和 std::condition_variable 的区别"></a>2. <code>std::condition_variable_any</code> 和 <code>std::condition_variable</code> 的区别</h3><ul>
<li><code>std::condition_variable</code> 只能与 <code>std::unique_lock&lt;std::mutex&gt;</code> 这种特定的锁类型配合使用。</li>
<li><code>std::condition_variable_any</code> 可以与任何类型的锁（只要提供互斥性）一起使用，包括 <code>std::mutex</code>、<code>std::shared_mutex</code>、<code>std::timed_mutex</code> 等。</li>
</ul>
<p>这使得 <code>std::condition_variable_any</code> 更加通用，但也要求用户更小心地管理锁的类型和行为。</p>
<h3 id="3-核心成员函数"><a href="#3-核心成员函数" class="headerlink" title="3. 核心成员函数"></a>3. 核心成员函数</h3><ul>
<li><p><strong><code>wait(std::unique_lock&lt;Lock&gt;&amp; lock)</code></strong><br>使当前线程在条件变量上等待，直到被通知并且 <code>lock</code> 被重新获得。<code>lock</code> 必须是一个 <code>std::unique_lock</code>，并且它的锁类型可以是任何提供互斥的类型。</p>
</li>
<li><p><strong><code>wait_for(std::unique_lock&lt;Lock&gt;&amp; lock, std::chrono::duration&lt;Rep, Period&gt; const&amp; rel_time)</code></strong><br>与 <code>wait</code> 类似，但是它会在给定的时间段内超时。如果在超时之前没有被通知，线程会自动继续执行。</p>
</li>
<li><p><strong><code>wait_until(std::unique_lock&lt;Lock&gt;&amp; lock, std::chrono::time_point&lt;Clock, Duration&gt; const&amp; abs_time)</code></strong><br>等待直到某个特定的时间点，或者直到通知为止。</p>
</li>
<li><p><strong><code>notify_one()</code></strong><br>通知一个等待中的线程。如果有多个线程在等待条件变量，只有一个会被唤醒。</p>
</li>
<li><p><strong><code>notify_all()</code></strong><br>通知所有等待中的线程。</p>
</li>
</ul>
<h3 id="4-使用示例"><a href="#4-使用示例" class="headerlink" title="4. 使用示例"></a>4. 使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable_any cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_id</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lck);  <span class="comment">// Wait until ready is true</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    cv.<span class="built_in">notify_all</span>();  <span class="comment">// Notify all waiting threads</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread threads[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Launch threads</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(print_id, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Preparing to launch threads...\n&quot;</span>;</span><br><span class="line">    <span class="built_in">go</span>();  <span class="comment">// Notify all threads to proceed</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) &#123;</span><br><span class="line">        th.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-std-condition-variable-any-的使用场景"><a href="#5-std-condition-variable-any-的使用场景" class="headerlink" title="5. std::condition_variable_any 的使用场景"></a>5. <code>std::condition_variable_any</code> 的使用场景</h3><p><code>std::condition_variable_any</code> 更适用于那些需要灵活选择锁类型的场景。比如，你可能使用 <code>std::shared_mutex</code> 来允许多个线程共享读访问，但仍然需要在某些时刻进行写访问控制。在这种情况下，<code>std::condition_variable_any</code> 会比 <code>std::condition_variable</code> 更适用。</p>
<h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h3><ul>
<li><strong>性能考量</strong>：<code>std::condition_variable_any</code> 在某些情况下可能会有更多的性能开销，因为它需要在底层提供更多的灵活性来支持不同类型的锁。</li>
<li><strong>锁的类型匹配</strong>：在使用时，你需要确保传入的锁类型能够正确地支持 <code>wait</code>、<code>wait_for</code> 和 <code>wait_until</code> 等操作。</li>
</ul>
<p>总结来说，<code>std::condition_variable_any</code> 提供了比 <code>std::condition_variable</code> 更强的灵活性，但也要求开发者更细致地考虑锁的类型和同步的复杂性。如果你只需要与 <code>std::mutex</code> 配合使用，通常使用 <code>std::condition_variable</code> 会更加简单和高效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">C++_05_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ 相关的理论基础知识</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_18_cmath/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_18_cmath/" class="post-title-link" itemprop="url">C++_10_18_cmath</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <cmath>标准库</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_18_cmath/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_1_random/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_1_random/" class="post-title-link" itemprop="url">C++_10_1_random</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ random标准库笔记</li>
</ul>
<h2 id="C-random标准库是什么"><a href="#C-random标准库是什么" class="headerlink" title="C++ random标准库是什么"></a>C++ random标准库是什么</h2><p>C++ 标准库中的 <code>&lt;random&gt;</code> 头文件提供了用于生成随机数的工具和类。这个库提供了众多的随机数生成器和分布器，以支持高质量的随机数生成操作。使用 <code>&lt;random&gt;</code> 头文件可以生成各种类型的随机数，包括整数、浮点数以及其他分布的随机数。</p>
<p>以下是一些 <code>&lt;random&gt;</code> 头文件中常用的类和功能：</p>
<ol>
<li><p><strong>随机数引擎（Random Number Engines）</strong>：随机数引擎是一种生成随机数的算法。C++ 提供了几种不同的随机数引擎，例如 <code>std::default_random_engine</code>、<code>std::mt19937</code>（Mersenne Twister 引擎）等。</p>
</li>
<li><p><strong>分布器（Random Number Distributions）</strong>：分布器用于将随机数引擎生成的随机数映射到指定的分布上，如均匀分布、正态分布等。常见的分布器有 <code>std::uniform_int_distribution</code>（生成整数均匀分布）、<code>std::uniform_real_distribution</code>（生成浮点数均匀分布）等。</p>
</li>
<li><p><strong>随机设备（Random Devices）</strong>：<code>std::random_device</code> 是一个用于获取真随机数的设备，但其随机性取决于平台和实现。</p>
</li>
</ol>
<p>使用 <code>&lt;random&gt;</code> 头文件，可以轻松地生成随机数，并根据需要控制其分布特性。例如，以下是一个简单的示例，展示了如何使用随机数引擎和分布器生成随机整数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建随机数引擎和分布器</span></span><br><span class="line">    std::random_device rd; <span class="comment">// 随机设备</span></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>; <span class="comment">// Mersenne Twister 引擎</span></span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">1</span>, <span class="number">100</span>); <span class="comment">// 生成1到100之间的均匀分布的随机整数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成随机数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">dis</span>(gen);</span><br><span class="line">        std::cout &lt;&lt; random_number &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上示例使用 Mersenne Twister 引擎和均匀整数分布器生成了10个1到100之间的随机整数。</p>
<p><code>&lt;random&gt;</code> 标准库提供了灵活和强大的工具，可用于各种需要随机性的应用程序，例如模拟、密码学、游戏开发等。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <random>标准库 详解</h2><p><code>&lt;random&gt;</code> 是 C++ 标准库中用于生成随机数的头文件。它提供了一组类和函数，用于生成高质量的随机数，并支持不同的随机数引擎和分布。</p>
<p>下面是 <code>&lt;random&gt;</code> 头文件中一些重要的类和函数：</p>
<ol>
<li><p><strong>随机数引擎（Random Number Engines）</strong>：随机数引擎是一个产生随机数序列的算法。C++ 提供了多种随机数引擎，例如 <code>std::default_random_engine</code>、<code>std::mt19937</code>（Mersenne Twister 引擎）、<code>std::minstd_rand</code>（线性同余法引擎）等。你可以根据需要选择不同的引擎。</p>
</li>
<li><p><strong>随机数分布器（Random Number Distributions）</strong>：随机数分布器用于将随机数引擎生成的随机数映射到指定的分布上。常用的分布器包括 <code>std::uniform_int_distribution</code>（生成整数均匀分布）、<code>std::uniform_real_distribution</code>（生成浮点数均匀分布）、<code>std::normal_distribution</code>（生成正态分布）、<code>std::poisson_distribution</code>（生成泊松分布）等。</p>
</li>
<li><p><strong>随机设备（Random Devices）</strong>：<code>std::random_device</code> 是一个用于获取真随机数的设备。它可能会提供硬件随机数或者伪随机数，具体取决于实现和平台。可以用它来初始化随机数引擎，提供更好的随机性。</p>
</li>
</ol>
<p>下面是一个简单示例，演示了如何使用 <code>&lt;random&gt;</code> 头文件生成随机数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建随机设备和引擎</span></span><br><span class="line">    std::random_device rd;</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>; <span class="comment">// 使用 Mersenne Twister 引擎</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建均匀分布器并生成随机整数</span></span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">1</span>, <span class="number">100</span>); <span class="comment">// 生成1到100之间的均匀分布的随机整数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成随机数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">dis</span>(gen);</span><br><span class="line">        std::cout &lt;&lt; random_number &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例使用 Mersenne Twister 引擎和均匀整数分布器生成了10个1到100之间的随机整数。</p>
<p><code>&lt;random&gt;</code> 头文件提供了灵活且高效的随机数生成工具，可以满足各种应用程序对随机性的需求。当你需要生成随机数时，可以根据自己的需求选择合适的引擎和分布器。</p>
<h2 id="C-std-random-device-是什么"><a href="#C-std-random-device-是什么" class="headerlink" title="C++ std::random_device 是什么"></a>C++ std::random_device 是什么</h2><p><code>std::random_device</code> 是 C++ 标准库提供的类，用于获取真随机数。它被设计为一个可用于产生高质量随机数种子的设备，可以提供来自硬件和操作系统的真随机数，也可以提供伪随机数。</p>
<p><code>std::random_device</code> 可以用作随机数引擎的种子（如 Mersenne Twister 引擎 <code>std::mt19937</code>）的初始化器，以提供更好的随机性。</p>
<p>然而，需要注意的是，<code>std::random_device</code> 并不是在所有平台和实现上都能提供真正的硬件随机数。在某些系统上，它可能会退化成伪随机数生成器，或者可能由于系统限制而无法提供高质量的随机数。</p>
<p>通常，<code>std::random_device</code> 是作为初始化随机数引擎的种子使用，而不是直接生成随机数序列。下面是一个简单的示例，演示了如何使用 <code>std::random_device</code> 初始化 Mersenne Twister 引擎：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建随机设备</span></span><br><span class="line">    std::random_device rd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用随机设备来初始化 Mersenne Twister 引擎</span></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建均匀分布器并生成随机整数</span></span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">1</span>, <span class="number">100</span>); <span class="comment">// 生成1到100之间的均匀分布的随机整数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成随机数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">dis</span>(gen);</span><br><span class="line">        std::cout &lt;&lt; random_number &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>std::random_device</code> 用于初始化了 Mersenne Twister 引擎 <code>std::mt19937</code>，然后使用该引擎生成了10个1到100之间的随机整数。</p>
<h2 id="C-std-random-device详解"><a href="#C-std-random-device详解" class="headerlink" title="C++ std::random_device详解"></a>C++ std::random_device详解</h2><p><code>std::random_device</code> 是 C++ 标准库提供的类，用于获取随机数的设备。它旨在提供高质量的随机数种子，可用作随机数引擎的初始化器，以生成更好质量的随机数序列。</p>
<p>以下是关于 <code>std::random_device</code> 的详细说明：</p>
<ol>
<li><p><strong>随机性</strong>：</p>
<ul>
<li><code>std::random_device</code> 通常被设计为提供真随机数，但实现的随机性取决于底层操作系统和硬件设备的支持。</li>
<li>在大多数情况下，<code>std::random_device</code> 会尝试获取来自硬件设备或操作系统的真随机数。但有些平台可能会将其实现为伪随机数生成器，特别是当没有真正的硬件随机数可用时，或者由于平台限制而无法提供真随机性。</li>
</ul>
</li>
<li><p><strong>用途</strong>：</p>
<ul>
<li>最常见的用途是作为随机数引擎的种子。它可以提供一个高质量的种子，用于初始化伪随机数生成器（如 Mersenne Twister 引擎 <code>std::mt19937</code>）。</li>
<li>在生成密码学安全的随机数时，<code>std::random_device</code> 通常用作种子。</li>
</ul>
</li>
<li><p><strong>生成随机数序列</strong>：</p>
<ul>
<li><code>std::random_device</code> 并不直接生成随机数序列，而是产生用于初始化随机数引擎的种子。</li>
<li>一般地，通过使用 <code>std::random_device</code> 初始化随机数引擎，然后再使用引擎生成随机数序列。</li>
</ul>
</li>
<li><p><strong>初始化引擎</strong>：</p>
<ul>
<li>初始化引擎时，通常将 <code>std::random_device</code> 作为种子参数传递给引擎构造函数或作为引擎对象的参数。</li>
<li>例如：<code>std::mt19937 gen(rd());</code>，其中 <code>rd</code> 是 <code>std::random_device</code> 的一个实例。</li>
</ul>
</li>
<li><p><strong>实现依赖性</strong>：</p>
<ul>
<li><code>std::random_device</code> 在不同的平台和编译器实现中可能表现不同，有些平台可能无法提供真随机数，或者提供的随机性不足。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>std::random_device</code> 是用于获取随机数种子的一种机制。在大多数情况下，它能够提供高质量的随机数种子，以供初始化伪随机数生成器。但在某些特定情况下，可能会受到平台限制或实现差异的影响。</p>
<h2 id="std-default-random-engine"><a href="#std-default-random-engine" class="headerlink" title="std::default_random_engine"></a>std::default_random_engine</h2><p><code>std::default_random_engine</code> 是 C++ 标准库中的一个类模板，用于生成伪随机数的引擎部分，位于 <code>&lt;random&gt;</code> 头文件中。它是 C++ 提供的一个伪随机数生成器（Pseudo-Random Number Generator，PRNG），能够生成一系列的随机数。</p>
<p>这个引擎的实现可能因不同的 C++ 标准库而异，但通常实现了某种伪随机数算法来生成随机数。在程序中使用 <code>std::default_random_engine</code> 可以生成随机数序列，通常需要与其他组件（例如分布器）结合使用来生成特定分布的随机数。</p>
<p>以下是一个简单的示例，演示了如何使用 <code>std::default_random_engine</code> 生成随机数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建默认随机数引擎</span></span><br><span class="line">    std::default_random_engine generator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成整数分布为[1, 6]的随机数</span></span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">1</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;随机数：&quot;</span> &lt;&lt; random_number &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>使用 <code>std::default_random_engine</code> 创建了一个默认的随机数引擎。</li>
<li>使用 <code>std::uniform_int_distribution</code> 定义了一个整数分布，范围为 <code>[1, 6]</code>。</li>
<li>在循环中，<code>distribution(generator)</code> 使用 <code>generator</code> 引擎生成了指定范围内的随机数。</li>
</ul>
<p>需要注意的是，<code>std::default_random_engine</code> 可能会因实现的不同而有不同的特性和性能，对于一些需要高质量随机数的场景，可能需要选择更加复杂的随机数引擎或者特定算法来满足需求。</p>
<h2 id="std-mt19937"><a href="#std-mt19937" class="headerlink" title="std::mt19937"></a>std::mt19937</h2><p><code>std::mt19937</code> 是 C++ 标准库 <code>&lt;random&gt;</code> 头文件中定义的 Mersenne Twister 随机数引擎的一个特定实例。Mersenne Twister 是一种流行的伪随机数生成器 (PRNG) 算法，提供了高质量、高周期性的随机数序列。</p>
<p><code>std::mt19937</code> 使用 32 位整数作为状态空间，并且具有一个非常大的周期，通常为 2^19937-1。这种引擎在大多数情况下提供了良好的随机性和性能。</p>
<p>以下是一个使用 <code>std::mt19937</code> 的简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Mersenne Twister 引擎实例</span></span><br><span class="line">    std::mt19937 generator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义整数分布为[1, 100]范围内的随机数</span></span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">1</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;随机数：&quot;</span> &lt;&lt; random_number &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>使用 <code>std::mt19937</code> 创建了一个 Mersenne Twister 引擎实例。</li>
<li>使用 <code>std::uniform_int_distribution</code> 定义了一个整数分布，范围为 <code>[1, 100]</code>。</li>
<li>在循环中，<code>distribution(generator)</code> 使用 <code>generator</code> 引擎生成了指定范围内的随机数。</li>
</ul>
<p><code>std::mt19937</code> 是一个常用的随机数引擎，通常能够满足大多数随机数生成的需求。然而，在一些特殊场景下，可能需要根据特定需求选择其他的随机数引擎或者更复杂的生成算法。</p>
<h2 id="std-uniform-int-distribution"><a href="#std-uniform-int-distribution" class="headerlink" title="std::uniform_int_distribution"></a>std::uniform_int_distribution</h2><p><code>std::uniform_int_distribution</code> 是 C++ 标准库 <code>&lt;random&gt;</code> 头文件中定义的类模板，用于产生指定范围内均匀分布的整数随机数。</p>
<p>该类模板允许您定义一个离散的整数分布，指定了随机数的范围。在生成随机数时，会根据指定的范围，以均匀分布的方式生成整数。</p>
<p>以下是一个使用 <code>std::uniform_int_distribution</code> 的简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Mersenne Twister 引擎实例</span></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">generator</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义整数分布为[1, 100]范围内的随机数</span></span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">1</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;随机数：&quot;</span> &lt;&lt; random_number &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>使用 <code>std::mt19937</code> 创建了一个 Mersenne Twister 引擎实例，并使用 <code>std::random_device</code> 作为种子。</li>
<li>使用 <code>std::uniform_int_distribution</code> 定义了一个整数分布，范围为 <code>[1, 100]</code>。</li>
<li>在循环中，<code>distribution(generator)</code> 使用 <code>generator</code> 引擎生成了指定范围内的随机数。</li>
</ul>
<p><code>std::uniform_int_distribution</code> 是一个用于生成指定范围内均匀分布的整数随机数的实用工具，可以方便地生成各种整数范围内的随机数。</p>
<h2 id="std-uniform-real-distribution"><a href="#std-uniform-real-distribution" class="headerlink" title="std::uniform_real_distribution"></a>std::uniform_real_distribution</h2><p><code>std::uniform_real_distribution</code> 是 C++ 标准库 <code>&lt;random&gt;</code> 头文件中定义的类模板，用于产生指定范围内均匀分布的实数（浮点数）随机数。</p>
<p>该类模板允许您定义一个连续的均匀分布，指定了随机数的范围。在生成随机数时，会根据指定的范围，以均匀分布的方式生成浮点数。</p>
<p>以下是一个使用 <code>std::uniform_real_distribution</code> 的简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Mersenne Twister 引擎实例</span></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">generator</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义实数分布为[0.0, 1.0)范围内的随机数</span></span><br><span class="line">    <span class="function">std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">double</span> random_number = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;随机数：&quot;</span> &lt;&lt; random_number &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>使用 <code>std::mt19937</code> 创建了一个 Mersenne Twister 引擎实例，并使用 <code>std::random_device</code> 作为种子。</li>
<li>使用 <code>std::uniform_real_distribution</code> 定义了一个实数分布，范围为 <code>[0.0, 1.0)</code>。</li>
<li>在循环中，<code>distribution(generator)</code> 使用 <code>generator</code> 引擎生成了指定范围内的随机数。</li>
</ul>
<p><code>std::uniform_real_distribution</code> 是一个用于生成指定范围内均匀分布的实数随机数的实用工具，可以方便地生成各种浮点数范围内的随机数。</p>
<h2 id="std-normal-distribution"><a href="#std-normal-distribution" class="headerlink" title="std::normal_distribution"></a>std::normal_distribution</h2><p><code>std::normal_distribution</code> 是 C++ 标准库 <code>&lt;random&gt;</code> 头文件中定义的类模板，用于产生指定均值和标准差的正态分布（高斯分布）的随机数。</p>
<p>正态分布是一种连续的概率分布，通常称为高斯分布，其形状呈钟形曲线，以均值为中心，并由标准差确定其宽度。<code>std::normal_distribution</code> 允许您生成服从正态分布的随机数。</p>
<p>以下是一个使用 <code>std::normal_distribution</code> 的简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Mersenne Twister 引擎实例</span></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">generator</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义正态分布，均值为 0，标准差为 1 的随机数</span></span><br><span class="line">    <span class="function">std::normal_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">double</span> random_number = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;随机数：&quot;</span> &lt;&lt; random_number &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>使用 <code>std::mt19937</code> 创建了一个 Mersenne Twister 引擎实例，并使用 <code>std::random_device</code> 作为种子。</li>
<li>使用 <code>std::normal_distribution</code> 定义了一个正态分布，均值为 <code>0.0</code>，标准差为 <code>1.0</code>。</li>
<li>在循环中，<code>distribution(generator)</code> 使用 <code>generator</code> 引擎生成了符合指定正态分布的随机数。</li>
</ul>
<p><code>std::normal_distribution</code> 是一个用于生成指定均值和标准差的正态分布随机数的实用工具，可以方便地生成服从正态分布的随机数。</p>
<h2 id="std-poisson-distribution"><a href="#std-poisson-distribution" class="headerlink" title="std::poisson_distribution"></a>std::poisson_distribution</h2><p><code>std::poisson_distribution</code> 是 C++ 标准库 <code>&lt;random&gt;</code> 头文件中定义的类模板，用于生成服从泊松分布的随机整数。</p>
<p>泊松分布是一种描述在一定时间或空间范围内，事件发生次数的概率分布。它适用于描述在固定时间或空间区间内，事件发生的次数，如单位时间内接收到的电话数、一段时间内发生的交通事故次数等等。</p>
<p>以下是一个使用 <code>std::poisson_distribution</code> 的简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 Mersenne Twister 引擎实例</span></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">generator</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义泊松分布，lambda 值为 2.0</span></span><br><span class="line">    <span class="function">std::poisson_distribution&lt;<span class="type">int</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">2.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;随机数：&quot;</span> &lt;&lt; random_number &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>使用 <code>std::mt19937</code> 创建了一个 Mersenne Twister 引擎实例，并使用 <code>std::random_device</code> 作为种子。</li>
<li>使用 <code>std::poisson_distribution</code> 定义了一个泊松分布，lambda 值为 <code>2.0</code>。</li>
<li>在循环中，<code>distribution(generator)</code> 使用 <code>generator</code> 引擎生成了服从指定泊松分布的随机整数。</li>
</ul>
<p><code>std::poisson_distribution</code> 是一个用于生成服从泊松分布的随机整数的实用工具，可以方便地生成符合泊松分布的随机数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_17_fstream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_17_fstream/" class="post-title-link" itemprop="url">C++_10_17_fstream</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <fstream>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <fstream>标准库</h2><p>在 C++ 中，<code>&lt;fstream&gt;</code> 是标准库中用于文件输入和输出的头文件。它提供了用于操作文件的类和函数，允许你以输入和输出的方式处理文件数据。</p>
<p>这个头文件定义了三个主要的类：</p>
<ol>
<li><code>std::ifstream</code>: 用于从文件中读取数据（输入文件流）。</li>
<li><code>std::ofstream</code>: 用于向文件写入数据（输出文件流）。</li>
<li><code>std::fstream</code>: 用于读写文件（输入输出文件流）。</li>
</ol>
<p>这些类都继承自 <code>std::istream</code>（用于输入）或 <code>std::ostream</code>（用于输出），因此它们具有类似于 <code>std::cin</code> 和 <code>std::cout</code> 的功能。</p>
<p>以下是一个简单的示例，展示了如何使用 <code>&lt;fstream&gt;</code> 头文件中的 <code>std::ifstream</code> 和 <code>std::ofstream</code> 类来读取和写入文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">outputFile</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>; <span class="comment">// 创建一个输出文件流对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        outputFile &lt;&lt; <span class="string">&quot;Writing this to a file.\n&quot;</span>;</span><br><span class="line">        outputFile.<span class="built_in">close</span>(); <span class="comment">// 关闭文件流</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to open file for writing!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::ifstream <span class="title">inputFile</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>; <span class="comment">// 创建一个输入文件流对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::string line;</span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">getline</span>(inputFile, line)) &#123; <span class="comment">// 逐行读取文件内容</span></span><br><span class="line">            std::cout &lt;&lt; line &lt;&lt; std::endl; <span class="comment">// 输出到控制台</span></span><br><span class="line">        &#125;</span><br><span class="line">        inputFile.<span class="built_in">close</span>(); <span class="comment">// 关闭文件流</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unable to open file for reading!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，首先使用 <code>std::ofstream</code> 打开一个文件输出流，并向文件 “output.txt” 写入一行数据。接着使用 <code>std::ifstream</code> 打开相同的文件作为输入流，并使用 <code>std::getline</code> 逐行读取文件内容，并输出到控制台。</p>
<p>这些文件流类提供了许多其他的功能，比如定位到文件特定位置、判断文件是否打开、错误处理等，可以根据需要在程序中使用。</p>
<h2 id="C-标准库-常用类和函数"><a href="#C-标准库-常用类和函数" class="headerlink" title="C++ 标准库 常用类和函数"></a>C++ <fstream>标准库 常用类和函数</h2><p>在 C++ 的 <code>&lt;fstream&gt;</code> 标准库中，常用的类和函数用于文件的输入和输出操作。以下是一些常用的类和函数：</p>
<h3 id="常用类："><a href="#常用类：" class="headerlink" title="常用类："></a>常用类：</h3><ol>
<li><p>**<code>std::ifstream</code>**：</p>
<ul>
<li>用于从文件中读取数据的输入文件流类。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ifstream <span class="title">inputFile</span><span class="params">(<span class="string">&quot;filename.txt&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>std::ofstream</code>**：</p>
<ul>
<li>用于向文件写入数据的输出文件流类。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ofstream <span class="title">outputFile</span><span class="params">(<span class="string">&quot;filename.txt&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>std::fstream</code>**：</p>
<ul>
<li>用于同时进行文件读写操作的输入输出文件流类。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::fstream <span class="title">file</span><span class="params">(<span class="string">&quot;filename.txt&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><ol>
<li><p>**<code>open()</code>**：</p>
<ul>
<li>打开文件，可以指定文件名和打开模式。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::ifstream inputFile;</span><br><span class="line">inputFile.<span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>close()</code>**：</p>
<ul>
<li>关闭文件。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputFile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>is_open()</code>**：</p>
<ul>
<li>检查文件是否打开。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    <span class="comment">// 文件已打开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>operator&lt;&lt;</code> 和 <code>operator&gt;&gt;</code>**：</p>
<ul>
<li>用于向文件写入数据和从文件读取数据。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outputFile &lt;&lt; <span class="string">&quot;Writing to file\n&quot;</span>;</span><br><span class="line">inputFile &gt;&gt; data;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>getline()</code>**：</p>
<ul>
<li>从文件中逐行读取数据。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string line;</span><br><span class="line"><span class="keyword">while</span> (std::<span class="built_in">getline</span>(inputFile, line)) &#123;</span><br><span class="line">    <span class="comment">// 处理每一行数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**<code>tellg()</code> 和 <code>seekg()</code>**（对于 <code>std::fstream</code>）：</p>
<ul>
<li><code>tellg()</code> 返回当前文件指针的位置。</li>
<li><code>seekg()</code> 设置文件指针到指定位置。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputFile.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::beg); <span class="comment">// 将文件指针移至文件开头</span></span><br><span class="line">std::streampos position = inputFile.<span class="built_in">tellg</span>(); <span class="comment">// 获取当前文件指针位置</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>这些是 <code>&lt;fstream&gt;</code> 头文件中最常用的类和函数。它们提供了强大的功能，允许你对文件进行读写操作，并且具有一些用于定位、判断文件状态、格式化输入输出等额外的功能。</p>
<h2 id="std-ifstream"><a href="#std-ifstream" class="headerlink" title="std::ifstream"></a>std::ifstream</h2><p><code>std::ifstream</code> 是 C++ 标准库中的类，用于从文件中读取数据。它是 <code>std::istream</code> 的派生类，提供了用于从文件读取数据的功能。</p>
<h3 id="创建-std-ifstream-对象："><a href="#创建-std-ifstream-对象：" class="headerlink" title="创建 std::ifstream 对象："></a>创建 <code>std::ifstream</code> 对象：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">inputFile</span><span class="params">(<span class="string">&quot;filename.txt&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (inputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 文件已成功打开</span></span><br><span class="line">        <span class="comment">// 可以使用 inputFile 对象进行读取操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 文件打开失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    inputFile.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要方法和功能："><a href="#主要方法和功能：" class="headerlink" title="主要方法和功能："></a>主要方法和功能：</h3><ol>
<li><p>**<code>open()</code>**：用于打开文件，可以指定文件名和打开模式。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::ifstream inputFile;</span><br><span class="line">inputFile.<span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>is_open()</code>**：检查文件是否成功打开。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    <span class="comment">// 文件已打开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>close()</code>**：关闭文件。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputFile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>operator&gt;&gt;</code>**：从文件中读取数据。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> data;</span><br><span class="line">inputFile &gt;&gt; data;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>getline()</code>**：从文件中逐行读取数据。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string line;</span><br><span class="line"><span class="keyword">while</span> (std::<span class="built_in">getline</span>(inputFile, line)) &#123;</span><br><span class="line">    <span class="comment">// 处理每一行数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>tellg()</code> 和 <code>seekg()</code>**：用于获取和设置文件指针位置（对于 <code>std::ifstream</code> ）。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputFile.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::beg); <span class="comment">// 将文件指针移至文件开头</span></span><br><span class="line">std::streampos position = inputFile.<span class="built_in">tellg</span>(); <span class="comment">// 获取当前文件指针位置</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>std::ifstream</code> 允许你打开一个文件以供读取数据，并提供了许多方法来从文件中读取数据，包括按字节、按行等不同方式，使得文件读取操作非常灵活。</p>
<h2 id="std-ofstream"><a href="#std-ofstream" class="headerlink" title="std::ofstream"></a>std::ofstream</h2><p><code>std::ofstream</code> 是 C++ 标准库中的类，用于向文件中写入数据。它是 <code>std::ostream</code> 的派生类，提供了向文件写入数据的功能。</p>
<h3 id="创建-std-ofstream-对象："><a href="#创建-std-ofstream-对象：" class="headerlink" title="创建 std::ofstream 对象："></a>创建 <code>std::ofstream</code> 对象：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">outputFile</span><span class="params">(<span class="string">&quot;filename.txt&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (outputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 文件已成功打开</span></span><br><span class="line">        <span class="comment">// 可以使用 outputFile 对象进行写入操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 文件打开失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    outputFile.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要方法和功能：-1"><a href="#主要方法和功能：-1" class="headerlink" title="主要方法和功能："></a>主要方法和功能：</h3><ol>
<li><p>**<code>open()</code>**：用于打开文件，可以指定文件名和打开模式。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::ofstream outputFile;</span><br><span class="line">outputFile.<span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>is_open()</code>**：检查文件是否成功打开。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (outputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    <span class="comment">// 文件已打开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>close()</code>**：关闭文件。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputFile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>operator&lt;&lt;</code>**：向文件中写入数据。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputFile &lt;&lt; <span class="string">&quot;Writing this to the file.\n&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>std::ofstream</code> 允许你打开一个文件以供写入数据，并提供了 <code>operator&lt;&lt;</code> 等方法来向文件中写入数据。你可以使用这些方法将数据以文本或二进制形式写入文件中，完成各种文件写入操作。</p>
<h2 id="std-fstream"><a href="#std-fstream" class="headerlink" title="std::fstream"></a>std::fstream</h2><p><code>std::fstream</code> 是 C++ 标准库中的类，用于对文件进行读写操作。它是 <code>std::iostream</code> 的派生类，同时具有读取和写入文件的能力。</p>
<h3 id="创建-std-fstream-对象："><a href="#创建-std-fstream-对象：" class="headerlink" title="创建 std::fstream 对象："></a>创建 <code>std::fstream</code> 对象：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::fstream <span class="title">file</span><span class="params">(<span class="string">&quot;filename.txt&quot;</span>, std::ios::in | std::ios::out)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 文件已成功打开</span></span><br><span class="line">        <span class="comment">// 可以使用 file 对象进行读写操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 文件打开失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    file.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要方法和功能：-2"><a href="#主要方法和功能：-2" class="headerlink" title="主要方法和功能："></a>主要方法和功能：</h3><ol>
<li><p>**<code>open()</code>**：用于打开文件，可以指定文件名和打开模式。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::fstream file;</span><br><span class="line">file.<span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, std::ios::in | std::ios::out);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>std::ios::in</code>：以读取模式打开文件。</li>
<li><code>std::ios::out</code>：以写入模式打开文件。</li>
<li><code>std::ios::app</code>：在文件末尾追加数据。</li>
</ul>
</li>
<li><p>**<code>is_open()</code>**：检查文件是否成功打开。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    <span class="comment">// 文件已打开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>close()</code>**：关闭文件。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>operator&lt;&lt;</code> 和 <code>operator&gt;&gt;</code>**：用于向文件写入数据和从文件读取数据。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file &lt;&lt; <span class="string">&quot;Writing to file\n&quot;</span>;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">file &gt;&gt; data;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>seekg()</code> 和 <code>tellg()</code></strong> 和 **<code>seekp()</code> 和 <code>tellp()</code>**：用于获取和设置文件指针位置。</p>
<ul>
<li><p>对于输入位置（<code>get</code>）：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::beg); <span class="comment">// 将文件指针移至文件开头</span></span><br><span class="line">std::streampos position = file.<span class="built_in">tellg</span>(); <span class="comment">// 获取当前文件指针位置</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于输出位置（<code>put</code>）：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file.<span class="built_in">seekp</span>(<span class="number">0</span>, std::ios::beg); <span class="comment">// 将文件指针移至文件开头</span></span><br><span class="line">std::streampos position = file.<span class="built_in">tellp</span>(); <span class="comment">// 获取当前文件指针位置</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><code>std::fstream</code> 可以用于同时进行文件读取和写入操作，提供了一些类似 <code>std::ifstream</code> 和 <code>std::ofstream</code> 的方法和功能，可以更灵活地对文件进行操作。</p>
<h2 id="std-fstream-open"><a href="#std-fstream-open" class="headerlink" title="std::fstream::open()"></a>std::fstream::open()</h2><p><code>std::fstream::open()</code> 是 C++ 标准库 <code>&lt;fstream&gt;</code> 头文件中 <code>std::fstream</code> 类的成员函数之一。它用于打开文件并将其与 <code>std::fstream</code> 对象关联，从而允许对文件进行读取或写入操作。</p>
<p>这是 <code>std::fstream::open()</code> 的基本语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::fstream fileStream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个文件进行输入/输出操作</span></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, std::ios::in | std::ios::out);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 文件成功打开，执行操作</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成操作后关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未能打开文件，处理错误</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>open()</code> 中使用的参数解释：</p>
<ul>
<li><code>&quot;filename.txt&quot;</code> 是要打开的文件名。</li>
<li><code>std::ios::in</code> 指定文件将用于输入操作。</li>
<li><code>std::ios::out</code> 指定文件将用于输出操作。</li>
<li><code>std::ios::in | std::ios::out</code> 是一个示例，使用按位 OR 运算符结合这些标志，允许在文件上进行输入和输出操作。根据所需的文件访问模式，可以使用其他标志（例如 <code>std::ios::app</code>、<code>std::ios::binary</code> 等）。</li>
</ul>
<p>在执行任何读取或写入操作之前，请确保使用 <code>is_open()</code> 检查文件是否成功打开。另外，在对文件执行操作后，最好使用 <code>close()</code> 成员函数关闭文件，以释放与文件关联的资源。</p>
<p>此外，应实现错误处理来处理无法打开文件的情况，例如文件不存在或程序没有足够的权限访问文件等情况。</p>
<h2 id="std-ios"><a href="#std-ios" class="headerlink" title="std::ios"></a>std::ios</h2><p><code>std::ios</code> 是 C++ 标准库中定义的一个位掩码枚举类型，用于指定流的状态和控制流的行为。它提供了一系列常量，用于在文件流或内存流中指定不同的行为和状态。</p>
<p>这些常量通常与流类（比如 <code>std::ifstream</code>、<code>std::ofstream</code>、<code>std::fstream</code> 等）的成员函数一起使用，例如 <code>open()</code>、<code>close()</code> 等。</p>
<p>以下是一些 <code>std::ios</code> 类型的常量：</p>
<ul>
<li><code>std::ios::in</code>：用于输入操作，允许从流中读取数据。</li>
<li><code>std::ios::out</code>：用于输出操作，允许向流中写入数据。</li>
<li><code>std::ios::binary</code>：指定以二进制模式打开文件，用于处理二进制数据。</li>
<li><code>std::ios::ate</code>：在打开文件时将文件指针移到文件末尾。</li>
<li><code>std::ios::app</code>：在打开文件时将文件指针移到文件末尾，并在写入时将数据追加到文件末尾。</li>
<li><code>std::ios::trunc</code>：如果文件已经存在，打开时将文件截断为零长度。</li>
</ul>
<p>这些常量可以通过按位 OR 运算符结合使用，以同时指定多个流状态。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ofstream fileStream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件进行输出操作，并在文件末尾追加数据</span></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, std::ios::out | std::ios::app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 文件成功打开，执行操作</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成操作后关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未能打开文件，处理错误</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>std::ios::out | std::ios::app</code> 将打开文件以允许输出操作，并在文件末尾追加数据。</p>
<p><code>std::ios</code> 类型提供了灵活的控制和配置流的能力，可以根据需要组合使用这些常量，以满足特定的文件读写需求。</p>
<h2 id="std-fstream-close"><a href="#std-fstream-close" class="headerlink" title="std::fstream::close()"></a>std::fstream::close()</h2><p><code>std::fstream::close()</code> 是 C++ 标准库中 <code>std::fstream</code> 类的成员函数之一。它用于关闭先前由 <code>std::fstream::open()</code> 打开的文件。</p>
<p>在对文件执行读取或写入操作后，通常应使用 <code>std::fstream::close()</code> 函数来关闭文件，以释放与该文件关联的资源并确保对文件所做的更改被保存。关闭文件可以防止数据丢失或文件损坏，并允许其他程序或进程访问该文件。</p>
<p>以下是 <code>std::fstream::close()</code> 的使用示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::fstream fileStream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件进行读取/写入操作</span></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, std::ios::in | std::ios::out);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 文件成功打开，执行读取/写入操作</span></span><br><span class="line">        fileStream &lt;&lt; <span class="string">&quot;Hello, File!&quot;</span>; <span class="comment">// 写入数据到文件</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File closed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未能打开文件，处理错误</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to open the file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::fstream::close()</code> 在操作文件后调用，以关闭先前打开的文件。在关闭文件之前，任何对文件的操作都应该完成，以确保数据正确地写入文件。当文件不再需要时，最好及时关闭文件。</p>
<p>关闭文件的操作是一个良好的编程实践，有助于避免资源泄漏并确保文件的正确处理。</p>
<h2 id="std-fstream-is-open"><a href="#std-fstream-is-open" class="headerlink" title="std::fstream::is_open()"></a>std::fstream::is_open()</h2><p><code>std::fstream::is_open()</code> 是 <code>std::fstream</code> 类的成员函数之一，用于检查与 <code>std::fstream</code> 对象关联的文件是否成功打开。该函数返回一个 <code>bool</code> 类型的值，指示文件是否已打开。</p>
<p>以下是 <code>std::fstream::is_open()</code> 的基本用法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::fstream fileStream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试打开文件进行读取/写入操作</span></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;filename.txt&quot;</span>, std::ios::in | std::ios::out);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 文件成功打开，执行读取/写入操作</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File is open.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未能打开文件，处理错误</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to open the file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::fstream::is_open()</code> 用于检查文件是否成功打开。如果文件成功打开，则输出 <code>&quot;File is open.&quot;</code>，否则输出 <code>&quot;Failed to open the file.&quot;</code>。这可以帮助您在执行读取或写入操作之前检查文件是否已正确打开，以避免在无法访问文件的情况下执行文件操作。</p>
<p>使用 <code>std::fstream::is_open()</code> 是一种良好的实践，可用于确保文件已正确打开并准备接受读取或写入操作。</p>
<h2 id="std-fstream-operator"><a href="#std-fstream-operator" class="headerlink" title="std::fstream::operator&lt;&lt;"></a>std::fstream::operator&lt;&lt;</h2><p><code>std::fstream::operator&lt;&lt;</code> 是用于向文件流 (<code>std::fstream</code>) 写入数据的操作符重载。它允许像使用 <code>&lt;&lt;</code> 操作符一样向文件中写入数据，类似于向 <code>std::cout</code> 输出流中写入数据一样。</p>
<p>这个操作符重载通常与文件流对象一起使用，允许将各种类型的数据写入到已打开的文件中。</p>
<p>以下是一个简单的示例，演示了如何使用 <code>std::fstream::operator&lt;&lt;</code> 将数据写入文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ofstream fileStream; <span class="comment">// 使用 ofstream，但也可以使用 fstream</span></span><br><span class="line"></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>); <span class="comment">// 打开文件进行写入操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">        <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">        std::string message = <span class="string">&quot;Hello, File!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向文件写入数据</span></span><br><span class="line">        fileStream &lt;&lt; <span class="string">&quot;An integer: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line">        fileStream &lt;&lt; <span class="string">&quot;A double: &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">        fileStream &lt;&lt; <span class="string">&quot;A message: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data written to file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to open the file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>fileStream &lt;&lt; &quot;An integer: &quot; &lt;&lt; number &lt;&lt; std::endl;</code> 将整数、浮点数和字符串写入了文件中。<code>&lt;&lt;</code> 操作符被用于串联不同类型的数据，并将它们写入到打开的文件流中。<code>std::endl</code> 用于在文件中插入换行符。</p>
<p>请注意，在使用 <code>std::fstream::operator&lt;&lt;</code> 之前，确保文件已经成功打开，并且操作完毕后，记得关闭文件流以释放资源。</p>
<h2 id="std-fstream-operator-1"><a href="#std-fstream-operator-1" class="headerlink" title="std::fstream::operator&gt;&gt;"></a>std::fstream::operator&gt;&gt;</h2><p><code>std::fstream::operator&gt;&gt;</code> 是 C++ 标准库中 <code>std::fstream</code> 类的成员函数之一，用于文件流的输入操作。它允许从文件流中读取数据，类似于从标准输入流 <code>std::cin</code> 中读取数据。</p>
<p>这个操作符重载通常用于从已打开的文件中读取数据，并根据不同的数据类型进行提取。它可以和 <code>std::ifstream</code> 或 <code>std::fstream</code> 对象一起使用，允许从文件中读取各种类型的数据。</p>
<p>以下是一个示例，演示了如何使用 <code>std::fstream::operator&gt;&gt;</code> 从文件中读取数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ifstream fileStream; <span class="comment">// 使用 ifstream 进行输入操作</span></span><br><span class="line"></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;input.txt&quot;</span>); <span class="comment">// 打开文件进行读取</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> number;</span><br><span class="line">        <span class="type">double</span> pi;</span><br><span class="line">        std::string message;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从文件中读取数据</span></span><br><span class="line">        fileStream &gt;&gt; number &gt;&gt; pi &gt;&gt; message;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示从文件中读取的数据</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Number: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Pi: &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Message: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取完成后关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无法打开文件。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>operator&gt;&gt;</code> 用于从文件流 (<code>fileStream</code>) 中提取整数、浮点数和字符串，并将它们存储到相应的变量中（<code>number</code>、<code>pi</code>、<code>message</code>）。然后，它将从文件中提取的数据显示在控制台上。</p>
<p>请确保在尝试从文件中读取数据之前，文件已经成功打开，并在读取完成后关闭文件流，释放相关资源。</p>
<h2 id="std-fstream-getline"><a href="#std-fstream-getline" class="headerlink" title="std::fstream::getline()"></a>std::fstream::getline()</h2><p><code>std::fstream::getline()</code> 是 <code>std::fstream</code> 类的成员函数之一，用于从文件中逐行读取数据并将其存储到字符串中。</p>
<p>这个函数通常与 <code>std::ifstream</code> 或 <code>std::fstream</code> 对象一起使用，用于从文件中读取文本数据，并将每行数据存储到字符串中。</p>
<p>以下是一个示例，演示了如何使用 <code>std::fstream::getline()</code> 从文件中逐行读取数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ifstream fileStream; <span class="comment">// 使用 ifstream 进行输入操作</span></span><br><span class="line"></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;input.txt&quot;</span>); <span class="comment">// 打开文件进行读取</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::string line;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐行读取文件中的数据</span></span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">getline</span>(fileStream, line)) &#123;</span><br><span class="line">            <span class="comment">// 处理每行读取的数据</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Line read: &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取完成后关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无法打开文件。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::fstream::getline()</code> 用于从文件流 (<code>fileStream</code>) 中逐行读取数据，并将每行数据存储在名为 <code>line</code> 的字符串中。然后，每次读取一行后，它将该行数据显示在控制台上。</p>
<p>这是一个非常常用的方法，特别是当需要按行读取文本文件中的内容时。每次调用 <code>getline()</code> 函数时，它会读取文件的下一行，并将其存储到字符串中，直到文件结束或发生读取错误为止。</p>
<p>请确保文件已成功打开，并在读取完成后关闭文件流，以便释放相关资源。</p>
<h2 id="std-fstream-tellg"><a href="#std-fstream-tellg" class="headerlink" title="std::fstream::tellg()"></a>std::fstream::tellg()</h2><p><code>std::fstream::tellg()</code> 是 <code>std::fstream</code> 类的成员函数之一，用于返回当前文件读取位置的位置指针（stream position pointer）。</p>
<p>在 C++ 中，文件流有一个位置指针，用于标识当前读取或写入操作在文件中的位置。<code>tellg()</code> 用于获取当前位置指针的位置（以字节为单位），它返回一个 <code>std::streampos</code> 类型的值，表示文件流中当前的位置。</p>
<p>以下是一个示例，演示了如何使用 <code>std::fstream::tellg()</code> 来获取当前文件读取位置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ifstream fileStream; <span class="comment">// 使用 ifstream 进行输入操作</span></span><br><span class="line"></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;input.txt&quot;</span>, std::ios::ate); <span class="comment">// 打开文件并将文件指针移到文件末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 获取当前文件指针位置</span></span><br><span class="line">        std::streampos position = fileStream.<span class="built_in">tellg</span>();</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Current position in the file: &quot;</span> &lt;&lt; position &lt;&lt; <span class="string">&quot; bytes.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无法打开文件。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::fstream::tellg()</code> 被调用以获取当前文件读取位置。<code>std::ios::ate</code> 标志用于在打开文件时将文件指针移到文件末尾。获取位置指针后，它以字节为单位输出当前的文件指针位置。</p>
<p>请注意，在使用 <code>tellg()</code> 之前，通常会使用适当的打开模式打开文件，以便能够获取有效的位置。这个函数通常与其他文件定位和操作函数一起使用，用于了解当前的文件读取位置。</p>
<h2 id="std-fstream-seekg"><a href="#std-fstream-seekg" class="headerlink" title="std::fstream::seekg()"></a>std::fstream::seekg()</h2><p><code>std::fstream::seekg()</code> 是 <code>std::fstream</code> 类的成员函数之一，用于在文件流中定位读取位置。这个函数用于设置文件读取位置指针（stream position pointer）的位置，允许在文件中移动到特定的位置进行读取操作。</p>
<p>它有多种重载形式，允许您以不同的方式定位文件流的读取位置。一般情况下，它使用相对于某个位置的偏移量来移动文件读取位置指针。</p>
<p>以下是一个示例，演示了如何使用 <code>std::fstream::seekg()</code> 在文件中定位读取位置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ifstream fileStream; <span class="comment">// 使用 ifstream 进行输入操作</span></span><br><span class="line"></span><br><span class="line">    fileStream.<span class="built_in">open</span>(<span class="string">&quot;input.txt&quot;</span>); <span class="comment">// 打开文件进行读取</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileStream.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 移动文件读取位置指针到文件的第 10 个字节处（偏移量为 10）</span></span><br><span class="line">        fileStream.<span class="built_in">seekg</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取并显示从当前位置开始的文件内容</span></span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="keyword">while</span> (fileStream.<span class="built_in">get</span>(ch)) &#123;</span><br><span class="line">            std::cout &lt;&lt; ch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        fileStream.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无法打开文件。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::fstream::seekg(10)</code> 将文件读取位置指针移动到文件的第 10 个字节处。然后使用 <code>fileStream.get(ch)</code> 从当前位置开始读取文件内容，并将其显示在控制台上。</p>
<p><code>seekg()</code> 函数的参数可以是一个偏移量（例如 <code>seekg(10)</code>），也可以使用其他形式的重载函数，例如 <code>seekg(10, std::ios::beg)</code> 来指定相对于文件开头的偏移量，或者 <code>seekg(-10, std::ios::end)</code> 来指定相对于文件末尾的偏移量。</p>
<p>这个函数对于需要定位并从文件中的特定位置开始读取数据的情况非常有用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_20_initializer_list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_20_initializer_list/" class="post-title-link" itemprop="url">C++_10_20_initializer_list</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <initializer_list>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <initializer_list>标准库</h2><p><code>&lt;initializer_list&gt;</code> 是 C++11 引入的头文件，用于支持初始化列表（Initializer List）功能。它提供了一个模板类 <code>std::initializer_list</code>，用于表示一个初始化列表，允许在容器和其他类型中以类似数组的形式初始化对象。</p>
<h3 id="std-initializer-list-概述"><a href="#std-initializer-list-概述" class="headerlink" title="std::initializer_list 概述"></a>std::initializer_list 概述</h3><ul>
<li><code>std::initializer_list</code> 是一个模板类，定义在 <code>&lt;initializer_list&gt;</code> 头文件中。</li>
<li>它提供了一种轻便的语法，允许用花括号 <code>&#123;&#125;</code> 列表初始化特定类型的对象。</li>
<li>这个类是一个轻量级的封装器，可以在构造函数或函数参数中方便地传递初始化列表。</li>
</ul>
<h3 id="基本用法示例："><a href="#基本用法示例：" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : list) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::initializer_list&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 initializer_list 初始化对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initialized list: &quot;</span>;</span><br><span class="line">    <span class="built_in">printList</span>(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要特点和用途："><a href="#主要特点和用途：" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li>允许以列表初始化的方式传递多个值给函数或容器。</li>
<li>用于简化容器、类或函数的构造函数，使得初始化更为方便。</li>
<li>可用于自定义函数或类的构造函数，以便更轻松地处理多个参数的初始化。</li>
</ul>
<p><code>std::initializer_list</code> 的出现使得初始化更加简洁和灵活，它适用于许多场景，例如容器初始化、函数参数传递等，使得代码更具可读性和易用性。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <initializer_list>标准库 详解</h2><p><code>&lt;initializer_list&gt;</code> 是 C++11 引入的标准库头文件，其中定义了 <code>std::initializer_list</code> 类模板。它提供了初始化列表（initializer list）功能，允许以列表的形式初始化多个值，用于在构造函数或函数参数中传递多个值。</p>
<h3 id="std-initializer-list-概述："><a href="#std-initializer-list-概述：" class="headerlink" title="std::initializer_list 概述："></a><code>std::initializer_list</code> 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;initializer_list&gt;</code></li>
<li><strong>类模板：</strong> <code>std::initializer_list&lt;T&gt;</code></li>
</ul>
<h3 id="主要特点和用途：-1"><a href="#主要特点和用途：-1" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ol>
<li><p><strong>初始化列表的表示：</strong></p>
<ul>
<li><code>std::initializer_list</code> 是一个轻量级容器，用于保存多个同类型元素的列表。</li>
<li>使用花括号 <code>&#123;&#125;</code> 包围元素来构造初始化列表。</li>
</ul>
</li>
<li><p><strong>在函数参数中使用：</strong></p>
<ul>
<li>可以作为函数的参数，允许以初始化列表的形式传递多个值给函数。</li>
<li>通过此特性可以轻松传递多个参数给函数，方便进行函数调用。</li>
</ul>
</li>
<li><p><strong>类和容器中的应用：</strong></p>
<ul>
<li>类的构造函数可以接受 <code>std::initializer_list</code> 作为参数，允许通过初始化列表对类的成员进行初始化。</li>
<li>STL 容器如 <code>std::vector</code>、<code>std::array</code>、<code>std::map</code> 等也可以使用初始化列表来初始化元素。</li>
</ul>
</li>
<li><p><strong>用于范围迭代：</strong></p>
<ul>
<li>提供了 begin() 和 end() 方法，允许通过迭代器访问初始化列表的元素。</li>
</ul>
</li>
</ol>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数接受 initializer_list 作为参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : list) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化列表示例</span></span><br><span class="line">    std::initializer_list&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 initializer_list 初始化对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initialized list: &quot;</span>;</span><br><span class="line">    <span class="built_in">printList</span>(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::initializer_list</code> 在 C++ 中提供了一种便捷的方式来处理初始化列表，使得在构造函数或函数参数中传递多个值变得更加方便和直观。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <initializer_list>标准库 常用的类和函数</h2><p>在 <code>&lt;initializer_list&gt;</code> 头文件中主要定义了 <code>std::initializer_list</code> 类模板，该模板提供了一些常用的函数和方法来操作初始化列表。下面是 <code>std::initializer_list</code> 常用的类和方法：</p>
<h3 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h3><ul>
<li><strong><code>std::initializer_list&lt;T&gt;</code>：</strong> 这是一个类模板，表示一个初始化列表，其中 <code>T</code> 是元素的类型。</li>
</ul>
<h3 id="主要方法和功能："><a href="#主要方法和功能：" class="headerlink" title="主要方法和功能："></a>主要方法和功能：</h3><ul>
<li><p><strong>构造函数：</strong></p>
<ul>
<li><code>initializer_list</code> 的构造函数没有公开的构造函数。它是一个轻量级的容器类，由编译器隐式创建和管理。</li>
</ul>
</li>
<li><p><strong>成员函数：</strong></p>
<ul>
<li><strong><code>size()</code>：</strong> 返回初始化列表中元素的数量。</li>
<li><strong><code>begin()</code>：</strong> 返回指向初始化列表第一个元素的指针或迭代器。</li>
<li><strong><code>end()</code>：</strong> 返回指向初始化列表末尾（最后一个元素之后）的指针或迭代器。</li>
</ul>
</li>
</ul>
<h3 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> std::initializer_list&lt;<span class="type">int</span>&gt;&amp; list)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of list: &quot;</span> &lt;&lt; list.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::initializer_list&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 size() 方法获取初始化列表的大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of numbers: &quot;</span> &lt;&lt; numbers.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 begin() 和 end() 方法进行迭代</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements of numbers: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数并传递初始化列表</span></span><br><span class="line">    <span class="built_in">printList</span>(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>std::initializer_list</code> 的 <code>size()</code>、<code>begin()</code> 和 <code>end()</code> 成员函数来访问和操作初始化列表的元素。</p>
<h2 id="std-initializer-list"><a href="#std-initializer-list" class="headerlink" title="std::initializer_list"></a>std::initializer_list</h2><p><code>std::initializer_list</code> 是 C++ 标准库提供的模板类，位于 <code>&lt;initializer_list&gt;</code> 头文件中。它用于表示初始化列表，允许以列表的形式初始化多个值，通常用于构造函数或函数参数中传递多个值。</p>
<h3 id="std-initializer-list-概述：-1"><a href="#std-initializer-list-概述：-1" class="headerlink" title="std::initializer_list 概述："></a>std::initializer_list 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;initializer_list&gt;</code></li>
<li><strong>类模板：</strong> <code>std::initializer_list&lt;T&gt;</code></li>
</ul>
<h3 id="主要特点和用途：-2"><a href="#主要特点和用途：-2" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ol>
<li><p><strong>初始化列表的表示：</strong></p>
<ul>
<li><code>std::initializer_list</code> 是一个轻量级容器，用于保存多个同类型元素的列表。</li>
<li>使用花括号 <code>&#123;&#125;</code> 包围元素来构造初始化列表。</li>
</ul>
</li>
<li><p><strong>在函数参数中使用：</strong></p>
<ul>
<li>可以作为函数的参数，允许以初始化列表的形式传递多个值给函数。</li>
<li>通过此特性可以轻松传递多个参数给函数，方便进行函数调用。</li>
</ul>
</li>
<li><p><strong>类和容器中的应用：</strong></p>
<ul>
<li>类的构造函数可以接受 <code>std::initializer_list</code> 作为参数，允许通过初始化列表对类的成员进行初始化。</li>
<li>STL 容器如 <code>std::vector</code>、<code>std::array</code>、<code>std::map</code> 等也可以使用初始化列表来初始化元素。</li>
</ul>
</li>
<li><p><strong>用于范围迭代：</strong></p>
<ul>
<li>提供了 <code>begin()</code> 和 <code>end()</code> 方法，允许通过迭代器访问初始化列表的元素。</li>
</ul>
</li>
</ol>
<h3 id="示例代码：-2"><a href="#示例代码：-2" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : list) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化列表示例</span></span><br><span class="line">    std::initializer_list&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 initializer_list 初始化对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initialized list: &quot;</span>;</span><br><span class="line">    <span class="built_in">printList</span>(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::initializer_list</code> 在 C++ 中提供了一种便捷的方式来处理初始化列表，使得在构造函数或函数参数中传递多个值变得更加方便和直观。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_19_functional/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_19_functional/" class="post-title-link" itemprop="url">C++_10_19_functional</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <functional>标准库</li>
</ul>
<h2 id="C-std-mem-fn-函数-详解"><a href="#C-std-mem-fn-函数-详解" class="headerlink" title="C++ std::mem_fn() 函数 详解"></a>C++ std::mem_fn() 函数 详解</h2><p><code>std::mem_fn</code> 是 C++ 标准库 <code>&lt;functional&gt;</code> 头文件中的一个函数模板，用于生成可调用对象，绑定到成员函数或成员变量的指针。它主要用于函数式编程风格或与标准库算法配合使用。</p>
<hr>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p><code>std::mem_fn</code> 接受一个成员函数指针或成员变量指针，生成一个可调用对象。生成的对象可以通过：</p>
<ol>
<li>绑定对象实例调用成员函数。</li>
<li>操作对象的成员变量。</li>
</ol>
<hr>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">mem_fn</span><span class="params">( T T::* pm )</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>T</strong>：成员函数或成员变量所属的类。</li>
<li><strong>pm</strong>：成员函数指针或成员变量指针。</li>
</ul>
<hr>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回一个可调用对象，该对象可以通过不同的方式调用成员函数或访问成员变量。</p>
<hr>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><code>std::mem_fn</code> 的主要用途是将成员函数或成员变量指针适配为标准库算法（如 <code>std::for_each</code>）的需求，避免手动处理复杂的调用。</p>
<hr>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="1-绑定成员函数"><a href="#1-绑定成员函数" class="headerlink" title="1. 绑定成员函数"></a>1. 绑定成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;MyClass&gt; <span class="title">objects</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::mem_fn 绑定成员函数</span></span><br><span class="line">    std::for_each(objects.<span class="built_in">begin</span>(), objects.<span class="built_in">end</span>(), std::<span class="built_in">mem_fn</span>(&amp;MyClass::print));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello from MyClass!</span><br><span class="line">Hello from MyClass!</span><br><span class="line">Hello from MyClass!</span><br></pre></td></tr></table></figure>

<h3 id="2-绑定成员变量"><a href="#2-绑定成员变量" class="headerlink" title="2. 绑定成员变量"></a>2. 绑定成员变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;MyClass&gt; objects = &#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::mem_fn 访问成员变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; obj : objects) &#123;</span><br><span class="line">        std::cout &lt;&lt; std::<span class="built_in">mem_fn</span>(&amp;MyClass::value)(obj) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="3-与-std-bind-一起使用"><a href="#3-与-std-bind-一起使用" class="headerlink" title="3. 与 std::bind 一起使用"></a>3. 与 <code>std::bind</code> 一起使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind 和 std::mem_fn</span></span><br><span class="line">    <span class="keyword">auto</span> boundFunc = std::<span class="built_in">bind</span>(std::<span class="built_in">mem_fn</span>(&amp;MyClass::greet), obj, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">boundFunc</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    <span class="built_in">boundFunc</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, Alice!</span><br><span class="line">Hello, Bob!</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><strong>对象类型</strong>：<code>std::mem_fn</code> 返回的可调用对象支持各种调用方式，包括：<ul>
<li>对象实例 (<code>obj.*pm</code> 或 <code>obj-&gt;*pm</code>)。</li>
<li>智能指针（如 <code>std::shared_ptr</code> 和 <code>std::unique_ptr</code>）。</li>
</ul>
</li>
<li><strong>线程安全</strong>：<code>std::mem_fn</code> 本身是线程安全的，但如果调用的成员函数或成员变量是非线程安全的，需要用户自行管理线程同步。</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>std::mem_fn</code> 是一个方便的工具，可以简化成员函数或成员变量指针的调用和与算法的集成，尤其是在函数式编程中与其他标准库工具（如 <code>std::bind</code> 或 <code>std::function</code>）配合使用时非常有用。</p>
<h2 id="引用包装器-std-ref"><a href="#引用包装器-std-ref" class="headerlink" title="引用包装器 std::ref"></a>引用包装器 std::ref</h2><ul>
<li><p>我们经常需要处理各种各样的对象和函数调用，其中一个常见的问题是如何高效地传递对象。如果不注意，很容易引入不必要的拷贝开销和性能损失</p>
</li>
<li><p>什么是std::ref</p>
<ul>
<li>std::ref是 C++11 标准库中的一个函数模板，用于生成一个引用包装器。引用包装器本质上是对一个对象的引用进行封装，使得在某些场景下能够更加方便的传递和使用引用。</li>
<li>例如，在标准库的算法和多线程库中，经常需要传递引用，而std::ref可以帮助我们简化这一过程。</li>
</ul>
</li>
</ul>
<h3 id="为什么需要引用包装器"><a href="#为什么需要引用包装器" class="headerlink" title="为什么需要引用包装器"></a>为什么需要引用包装器</h3><ul>
<li>在C++中，函数传参时有几种常见方式，每种方式都有其使用的场景和特点<ul>
<li>按值传递： 会创建参数对象的副本，可能带来额外的性能开销</li>
<li>按指针传递：需要显式的处理指针，可能导致代码复杂性增加</li>
<li>按引用传递：无需创建副本，性能较高，但是在某些场景下使用起来不够方便</li>
</ul>
</li>
<li>在需要保持对象的引用关系，但是又不想显示地使用指针或者引用时，引用包装器 std::ref 就派上用场了</li>
</ul>
<h3 id="如何使用std-ref"><a href="#如何使用std-ref" class="headerlink" title="如何使用std::ref"></a>如何使用std::ref</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// 引入std::ref</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">    ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; f = std::<span class="built_in">bind</span>(increment, std::<span class="built_in">ref</span>(x));</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x after increment: &quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 输出：x after increment: 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">call_increment</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个例子中，std::bind用于绑定函数increment和参数x，而std::ref确保传递的是x的引用，而不是副本。</li>
</ul>
<h3 id="std-ref在多线程中的应用"><a href="#std-ref在多线程中的应用" class="headerlink" title="std::ref在多线程中的应用"></a>std::ref在多线程中的应用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_counter</span><span class="params">(<span class="type">int</span>&amp; counter, <span class="type">int</span> num_iterations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_iterations; ++i) &#123;</span><br><span class="line">        ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num_threads = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> num_iterations = <span class="number">1000</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(add_to_counter, std::<span class="built_in">ref</span>(counter), num_iterations);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl; <span class="comment">// 输出：Final counter value: 10000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个例子中，我们创建了10个线程，每个线程对同一个counter变量进行了1000次累加<br>操作。通过使用std::ref，我们确保每个线程操作的是同一个counter引用，而不是副本。</li>
</ul>
<h3 id="std-ref-与-std-cref"><a href="#std-ref-与-std-cref" class="headerlink" title="std::ref 与 std::cref"></a>std::ref 与 std::cref</h3><ul>
<li>除了 std::ref，C++标准库还提供了 std::cref，用于生成常量引用的包装器。</li>
<li>std::cref的使用方式与std::ref类似，不同之处在于它生成的是const引用，确保被引用的对象在使用过程中不会被修改。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_value</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; n)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; f = std::<span class="built_in">bind</span>(print_value, std::<span class="built_in">cref</span>(x));</span><br><span class="line">    <span class="built_in">f</span>(); <span class="comment">// 输出：Value: 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在这个例子中，std::cref确保传递的是x的常量引用，print_value函数无法修改x的值。</li>
</ul>
<h3 id="std-ref的内部实现"><a href="#std-ref的内部实现" class="headerlink" title="std::ref的内部实现"></a>std::ref的内部实现</h3><ul>
<li>虽然我们平时使用std::ref时只需要调用它的接口，但了解其内部实现有助于我们更深入地理解它的工作原理。std::ref的内部实现实际上非常简单，它定义了一个模板类reference_wrapper，用于封装引用。下面是一个简化的实现版本：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">reference_wrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">reference_wrapper</span><span class="params">(T&amp; ref)</span> : ref_(std::addressof(ref)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> T&amp;() <span class="type">const</span> &#123; <span class="keyword">return</span> *ref_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T&amp; <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *ref_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ref_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">reference_wrapper&lt;T&gt; <span class="title">ref</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reference_wrapper</span>&lt;T&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以看出，reference_wrapper通过保存一个指向引用对象的指针，实现了对引用的包装。</li>
<li>std::ref函数只是创建了一个reference_wrapper对象并且返回。</li>
</ul>
<h3 id="std-ref-小结"><a href="#std-ref-小结" class="headerlink" title="std::ref 小结"></a>std::ref 小结</h3><ul>
<li>std::ref 作为C++标准库中的一个小工具，虽然看似简单，但是在实际编程中却能够解决很多复杂的问题。</li>
<li>它不仅能够简化函数参数传递，还能在多线程编程中确保引用的正确传递，从而提升代码的性能和可读性。</li>
</ul>
<h2 id="什么是-std-function"><a href="#什么是-std-function" class="headerlink" title="什么是 std::function"></a>什么是 std::function</h2><ul>
<li><p>std::function 是C++11引入的一个函数包装器类型。它的主要作用是，将任何可调用实体(比如函数，lambda表达式，函数指针或者函数对象)都包装成一个统一的对象，从而可以统一的保存，传递和调用这些可调用实体。</p>
</li>
<li><p>简单的说，std::function就是一个可以容纳各种可调用实体的容器。我们可以将它看作是一个通用的函数指针，但是它比普通的函数指针更加灵活和强大。</p>
</li>
<li><p>std::function 提供了一种非常灵活和通用的方式来处理可调用实体，包括普通函数，lambda表达式以及函数对象。</p>
</li>
<li><p>它的主要优点包括</p>
<ul>
<li>统一的函数调用接口，简化了代码</li>
<li>可以存储在容器中，增强了代码的可扩展性</li>
<li>可以与std::bind()结合使用，实现参数绑定等高级功能</li>
</ul>
</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <functional>标准库</h2><p><code>&lt;functional&gt;</code> 标准库是 C++ 中的一个头文件，提供了函数对象（Function Object）的支持，包括了一些预定义的函数对象和函数适配器。它使得函数能够像对象一样被传递、存储、返回以及调用。</p>
<p>这个库中的重要组件包括：</p>
<h3 id="1-函数对象（Function-Objects）"><a href="#1-函数对象（Function-Objects）" class="headerlink" title="1. 函数对象（Function Objects）"></a>1. 函数对象（Function Objects）</h3><p>函数对象是可以像函数一样被调用的对象。在 <code>&lt;functional&gt;</code> 中有一些内置的函数对象，如：</p>
<ul>
<li><code>std::function</code>：用于封装可调用的目标，可以是函数指针、函数、成员函数、Lambda 表达式等，是一种通用的函数封装器。</li>
<li><code>std::bind</code>：用于创建函数对象，可绑定函数或者成员函数到指定的参数上。</li>
<li><code>std::placeholders</code>：用于占位符，在使用 <code>std::bind</code> 绑定函数时，指定部分参数留待后续提供。</li>
</ul>
<h3 id="2-函数适配器（Function-Adapters）"><a href="#2-函数适配器（Function-Adapters）" class="headerlink" title="2. 函数适配器（Function Adapters）"></a>2. 函数适配器（Function Adapters）</h3><p>函数适配器是用来修改函数行为的对象。常见的函数适配器有：</p>
<ul>
<li><code>std::bind</code>：上述已提到，可用于部分参数绑定和函数重组。</li>
<li><code>std::placeholders</code>：占位符，用于 <code>std::bind</code> 中占位某些参数的位置。</li>
<li><code>std::function</code>：用于封装可调用对象，提供了一种统一的处理方式。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function object example</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AddFunctor</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Using std::function with a lambda function</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; addFunction = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using std::bind to bind the first argument to 10</span></span><br><span class="line">    <span class="keyword">auto</span> addTen = std::<span class="built_in">bind</span>(addFunction, <span class="number">10</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using a function object</span></span><br><span class="line">    AddFunctor addObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using the function object</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of addObj: &quot;</span> &lt;&lt; <span class="built_in">addObj</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using std::function with std::bind</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of addFunction: &quot;</span> &lt;&lt; <span class="built_in">addFunction</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using std::bind function to add 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of addTen: &quot;</span> &lt;&lt; <span class="built_in">addTen</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了如何使用 <code>&lt;functional&gt;</code> 标准库中的函数对象和函数适配器。<code>std::function</code> 和 <code>std::bind</code> 是这个库中常用的工具，它们提供了更灵活和通用的函数操作方式。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <functional>标准库 详解</h2><p><code>&lt;functional&gt;</code> 标准库是 C++ 中提供函数对象（Function Objects）和函数适配器（Function Adapters）的头文件。这个库提供了许多功能，能够让函数像对象一样进行操作、传递和存储，以及改变函数的行为。</p>
<p>下面是 <code>&lt;functional&gt;</code> 标准库中一些重要的组件：</p>
<h3 id="1-函数对象（Function-Objects）-1"><a href="#1-函数对象（Function-Objects）-1" class="headerlink" title="1. 函数对象（Function Objects）"></a>1. 函数对象（Function Objects）</h3><p>函数对象是具有函数调用功能的对象，它可以像函数一样被调用。在 <code>&lt;functional&gt;</code> 中提供了以下函数对象：</p>
<ul>
<li><p><code>std::function</code>：是一个通用的函数封装器，可以封装可调用的目标，例如函数指针、函数、成员函数、Lambda 表达式等。可以用来存储和调用各种类型的可调用对象。</p>
</li>
<li><p>函数对象类：程序员可以自定义函数对象类，它们是类或结构体，重载了函数调用运算符 <code>operator()</code>，使得对象可以像函数一样被调用。</p>
</li>
</ul>
<h3 id="2-函数适配器（Function-Adapters）-1"><a href="#2-函数适配器（Function-Adapters）-1" class="headerlink" title="2. 函数适配器（Function Adapters）"></a>2. 函数适配器（Function Adapters）</h3><p>函数适配器是用于修改函数行为或调整函数参数的对象。其中常见的函数适配器有：</p>
<ul>
<li><p><code>std::bind</code>：用于创建函数对象，可以部分绑定函数或成员函数的参数。可以改变函数的参数个数或者顺序。</p>
</li>
<li><p><code>std::placeholders</code>：在使用 <code>std::bind</code> 绑定函数时，用于指定占位符，代表未指定的参数位置。</p>
</li>
</ul>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象示例</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MultiplyFunctor</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::function 包装 Lambda 表达式</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; multiplyFunction = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind 部分绑定参数</span></span><br><span class="line">    <span class="keyword">auto</span> multiplyByTwo = std::<span class="built_in">bind</span>(multiplyFunction, std::placeholders::_1, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义函数对象</span></span><br><span class="line">    MultiplyFunctor multiplyObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义函数对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of multiplyObj: &quot;</span> &lt;&lt; <span class="built_in">multiplyObj</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::function 调用 Lambda 函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of multiplyFunction: &quot;</span> &lt;&lt; <span class="built_in">multiplyFunction</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定函数的参数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of multiplyByTwo: &quot;</span> &lt;&lt; <span class="built_in">multiplyByTwo</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了如何使用 <code>&lt;functional&gt;</code> 标准库中的函数对象和函数适配器。<code>std::function</code> 提供了一种通用的函数封装器，<code>std::bind</code> 则用于创建函数对象并部分绑定参数。函数对象可以是 Lambda 表达式、函数指针或自定义的函数对象类。</p>
<h2 id="C-标准库-常用类和函数"><a href="#C-标准库-常用类和函数" class="headerlink" title="C++ 标准库 常用类和函数"></a>C++ <functional>标准库 常用类和函数</h2><p><code>&lt;functional&gt;</code> 标准库提供了许多有用的类和函数，使得函数能够像对象一样进行操作、传递和存储。以下是 <code>&lt;functional&gt;</code> 常用的类和函数：</p>
<h3 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h3><h4 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a><code>std::function</code></h4><ul>
<li>用于封装各种可调用对象，如函数指针、函数、成员函数、Lambda 表达式等。</li>
<li>提供了一种通用的函数封装器，能够在运行时存储和调用各种类型的可调用对象。</li>
</ul>
<h4 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a><code>std::bind</code></h4><ul>
<li>用于创建函数对象，能够绑定函数或成员函数的参数。</li>
<li>允许指定参数的顺序、部分绑定参数或者重新组织参数，生成一个新的可调用对象。</li>
</ul>
<h4 id="std-placeholders"><a href="#std-placeholders" class="headerlink" title="std::placeholders"></a><code>std::placeholders</code></h4><ul>
<li>用于指定占位符，配合 <code>std::bind</code> 使用，指定未指定的参数位置。</li>
<li>提供了占位符 <code>_1</code>、<code>_2</code>、<code>_3</code> 等，用于表示绑定时未指定的参数位置。</li>
</ul>
<h3 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h3><h4 id="算术函数："><a href="#算术函数：" class="headerlink" title="算术函数："></a>算术函数：</h4><ul>
<li><code>std::plus</code>：加法函数对象。</li>
<li><code>std::minus</code>：减法函数对象。</li>
<li><code>std::multiplies</code>：乘法函数对象。</li>
<li><code>std::divides</code>：除法函数对象。</li>
<li><code>std::modulus</code>：取模函数对象。</li>
</ul>
<h4 id="逻辑函数："><a href="#逻辑函数：" class="headerlink" title="逻辑函数："></a>逻辑函数：</h4><ul>
<li><code>std::logical_and</code>：逻辑与函数对象。</li>
<li><code>std::logical_or</code>：逻辑或函数对象。</li>
<li><code>std::logical_not</code>：逻辑非函数对象。</li>
</ul>
<h4 id="其他函数："><a href="#其他函数：" class="headerlink" title="其他函数："></a>其他函数：</h4><ul>
<li><code>std::negate</code>：一元取反函数对象。</li>
<li><code>std::not1</code>：一元谓词取反函数对象。</li>
<li><code>std::not2</code>：二元谓词取反函数对象。</li>
</ul>
<h3 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象示例</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MultiplyFunctor</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::function 封装 Lambda 表达式</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; multiplyFunction = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定函数对象并部分绑定参数</span></span><br><span class="line">    <span class="keyword">auto</span> multiplyByTwo = std::<span class="built_in">bind</span>(multiplyFunction, std::placeholders::_1, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义函数对象</span></span><br><span class="line">    MultiplyFunctor multiplyObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用自定义函数对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of multiplyObj: &quot;</span> &lt;&lt; <span class="built_in">multiplyObj</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::function 调用 Lambda 函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of multiplyFunction: &quot;</span> &lt;&lt; <span class="built_in">multiplyFunction</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::bind 绑定函数对象的参数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of multiplyByTwo: &quot;</span> &lt;&lt; <span class="built_in">multiplyByTwo</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>&lt;functional&gt;</code> 标准库中的一些常用函数和类的用法。<code>std::function</code> 可用于封装不同类型的可调用对象，<code>std::bind</code> 可用于创建函数对象并部分绑定参数，而函数对象可以是 Lambda 表达式、函数指针或自定义的函数对象类。</p>
<h2 id="std-function-1"><a href="#std-function-1" class="headerlink" title="std::function"></a>std::function</h2><p><code>std::function</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的一个类模板，用于封装可调用对象（函数、函数指针、成员函数、Lambda 表达式等），并提供一种通用的函数封装器。</p>
<h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::function&lt;return_type(args...)&gt; func_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>return_type</code>：函数或可调用对象返回类型。</li>
<li><code>args...</code>：函数或可调用对象的参数类型列表。</li>
</ul>
<h3 id="特点和用途："><a href="#特点和用途：" class="headerlink" title="特点和用途："></a>特点和用途：</h3><ul>
<li><code>std::function</code> 能够封装各种类型的可调用对象，提供了一种统一的处理方式。</li>
<li>可以在运行时动态地指定要调用的函数或对象，从而实现动态多态性。</li>
<li>可用作函数参数、返回值或容器内的元素类型，能够实现灵活的函数传递和存储。</li>
</ul>
<h3 id="示例代码：-2"><a href="#示例代码：-2" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 封装普通函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = add;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装 Lambda 表达式</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; lambdaFunc = [](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用封装的普通函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of add function: &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用封装的 Lambda 表达式</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of lambda function: &quot;</span> &lt;&lt; <span class="built_in">lambdaFunc</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::function</code> 分别封装了一个普通函数和一个 Lambda 表达式，并能够像函数一样调用这些封装的对象。<code>std::function</code> 提供了一种通用的函数封装器，能够灵活地封装各种可调用对象，并统一地调用它们。</p>
<h2 id="std-bind-1"><a href="#std-bind-1" class="headerlink" title="std::bind"></a>std::bind</h2><p><code>std::bind</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的一个函数模板，用于创建函数对象并进行参数绑定。</p>
<h3 id="基本语法：-1"><a href="#基本语法：-1" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>(func_to_bind, args...);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>func_to_bind</code>：要绑定的函数、函数指针、成员函数指针或可调用对象。</li>
<li><code>args...</code>：要绑定的参数列表，可以包含占位符 <code>_1</code>, <code>_2</code>, <code>_3</code> 等，代表未指定的参数位置。</li>
</ul>
<h3 id="特点和用途：-1"><a href="#特点和用途：-1" class="headerlink" title="特点和用途："></a>特点和用途：</h3><ul>
<li><code>std::bind</code> 允许对函数或函数对象进行部分参数绑定、参数重排以及参数固定等操作，生成一个新的函数对象。</li>
<li>可以用来创建函数对象，将部分参数预先绑定，使得函数调用更加灵活。</li>
<li>创建了一个新的可调用对象，其参数列表为绑定参数后剩余的参数。</li>
</ul>
<h3 id="示例代码：-3"><a href="#示例代码：-3" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数示例</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定参数的 add 函数</span></span><br><span class="line">    <span class="keyword">auto</span> addFive = std::<span class="built_in">bind</span>(add, <span class="number">5</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用绑定参数的 add 函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of addFive function: &quot;</span> &lt;&lt; <span class="built_in">addFive</span>(<span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::bind</code> 绑定了一个参数为 5 的 <code>add</code> 函数，并将第二个参数作为占位符 <code>_1</code> 留待后续提供。之后创建了一个新的函数对象 <code>addFive</code>，用于调用绑定了部分参数的 <code>add</code> 函数。<code>std::bind</code> 允许对函数进行部分参数绑定，生成一个新的可调用对象。</p>
<h2 id="std-placeholders-1"><a href="#std-placeholders-1" class="headerlink" title="std::placeholders"></a>std::placeholders</h2><p><code>std::placeholders</code> 是 <code>&lt;functional&gt;</code> 头文件中的一个命名空间，其中定义了一系列占位符，用于在使用 <code>std::bind</code> 时指示参数的位置。</p>
<h3 id="常用的占位符："><a href="#常用的占位符：" class="headerlink" title="常用的占位符："></a>常用的占位符：</h3><ul>
<li><code>_1</code>、<code>_2</code>、<code>_3</code>… <code>_n</code>：表示函数调用时的第一个、第二个、第三个… 第n个参数位置。</li>
</ul>
<p>这些占位符用于 <code>std::bind</code> 中，协助进行参数绑定。在 <code>std::bind</code> 中，使用这些占位符可以指定哪些参数是预先绑定的，哪些参数需要在调用时提供。</p>
<h3 id="示例代码：-4"><a href="#示例代码：-4" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printThree</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定函数并重新排列参数顺序</span></span><br><span class="line">    <span class="keyword">auto</span> printFunction = std::<span class="built_in">bind</span>(printThree, std::placeholders::_3, std::placeholders::_1, std::placeholders::_2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用绑定函数</span></span><br><span class="line">    <span class="built_in">printFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::placeholders</code> 的占位符 <code>_1</code>、<code>_2</code>、<code>_3</code> 分别表示绑定的函数 <code>printThree</code> 的第三个、第一个和第二个参数的位置。<code>std::bind</code> 创建了一个新的函数对象 <code>printFunction</code>，并重新排列了参数顺序。在调用 <code>printFunction</code> 时，参数的顺序将被重新排列以匹配绑定的函数。</p>
<h2 id="std-plus"><a href="#std-plus" class="headerlink" title="std::plus"></a>std::plus</h2><p><code>std::plus</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行加法操作。它是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行加法操作。</p>
<h3 id="基本语法：-2"><a href="#基本语法：-2" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::plus&lt;T&gt; plus_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：加法操作的参数类型。</li>
</ul>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::plus</code> 对象可以像函数一样调用，用于执行加法操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>int</code>、<code>float</code>、<code>double</code> 等。</p>
<h3 id="示例代码：-5"><a href="#示例代码：-5" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::plus&lt;<span class="type">int</span>&gt; plusInt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">plusInt</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 执行加法操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of addition: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::plus</code> 实例化为 <code>std::plus&lt;int&gt;</code>，表示执行整数类型的加法操作。<code>plusInt</code> 对象被调用并传递两个参数，执行加法操作并返回结果。</p>
<h2 id="std-minus"><a href="#std-minus" class="headerlink" title="std::minus"></a>std::minus</h2><p><code>std::minus</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行减法操作。它也是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行减法操作。</p>
<h3 id="基本语法：-3"><a href="#基本语法：-3" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::minus&lt;T&gt; minus_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：减法操作的参数类型。</li>
</ul>
<h3 id="使用方法：-1"><a href="#使用方法：-1" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::minus</code> 对象可以像函数一样调用，用于执行减法操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>int</code>、<code>float</code>、<code>double</code> 等。</p>
<h3 id="示例代码：-6"><a href="#示例代码：-6" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::minus&lt;<span class="type">int</span>&gt; minusInt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">minusInt</span>(<span class="number">7</span>, <span class="number">4</span>); <span class="comment">// 执行减法操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of subtraction: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::minus</code> 实例化为 <code>std::minus&lt;int&gt;</code>，表示执行整数类型的减法操作。<code>minusInt</code> 对象被调用并传递两个参数，执行减法操作并返回结果。</p>
<h2 id="std-multiplies"><a href="#std-multiplies" class="headerlink" title="std::multiplies"></a>std::multiplies</h2><p><code>std::multiplies</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行乘法操作。它是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行乘法操作。</p>
<h3 id="基本语法：-4"><a href="#基本语法：-4" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::multiplies&lt;T&gt; multiplies_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：乘法操作的参数类型。</li>
</ul>
<h3 id="使用方法：-2"><a href="#使用方法：-2" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::multiplies</code> 对象可以像函数一样调用，用于执行乘法操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>int</code>、<code>float</code>、<code>double</code> 等。</p>
<h3 id="示例代码：-7"><a href="#示例代码：-7" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multiplies&lt;<span class="type">int</span>&gt; multipliesInt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">multipliesInt</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 执行乘法操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of multiplication: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::multiplies</code> 实例化为 <code>std::multiplies&lt;int&gt;</code>，表示执行整数类型的乘法操作。<code>multipliesInt</code> 对象被调用并传递两个参数，执行乘法操作并返回结果。</p>
<h2 id="std-divides"><a href="#std-divides" class="headerlink" title="std::divides"></a>std::divides</h2><p><code>std::divides</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行除法操作。它是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行除法操作。</p>
<h3 id="基本语法：-5"><a href="#基本语法：-5" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::divides&lt;T&gt; divides_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：除法操作的参数类型。</li>
</ul>
<h3 id="使用方法：-3"><a href="#使用方法：-3" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::divides</code> 对象可以像函数一样调用，用于执行除法操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>int</code>、<code>float</code>、<code>double</code> 等。</p>
<h3 id="示例代码：-8"><a href="#示例代码：-8" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::divides&lt;<span class="type">double</span>&gt; dividesDouble;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> result = <span class="built_in">dividesDouble</span>(<span class="number">10.0</span>, <span class="number">2.0</span>); <span class="comment">// 执行除法操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of division: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::divides</code> 实例化为 <code>std::divides&lt;double&gt;</code>，表示执行双精度浮点数类型的除法操作。<code>dividesDouble</code> 对象被调用并传递两个参数，执行除法操作并返回结果。</p>
<h2 id="std-modulus"><a href="#std-modulus" class="headerlink" title="std::modulus"></a>std::modulus</h2><p><code>std::modulus</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行取模（取余）操作。它是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行取模操作。</p>
<h3 id="基本语法：-6"><a href="#基本语法：-6" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::modulus&lt;T&gt; modulus_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：取模操作的参数类型。</li>
</ul>
<h3 id="使用方法：-4"><a href="#使用方法：-4" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::modulus</code> 对象可以像函数一样调用，用于执行取模操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>int</code>、<code>float</code>、<code>double</code> 等。</p>
<h3 id="示例代码：-9"><a href="#示例代码：-9" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::modulus&lt;<span class="type">int</span>&gt; modulusInt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">modulusInt</span>(<span class="number">10</span>, <span class="number">3</span>); <span class="comment">// 执行取模操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of modulus: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::modulus</code> 实例化为 <code>std::modulus&lt;int&gt;</code>，表示执行整数类型的取模操作。<code>modulusInt</code> 对象被调用并传递两个参数，执行取模操作并返回结果。</p>
<h2 id="std-logical-and"><a href="#std-logical-and" class="headerlink" title="std::logical_and"></a>std::logical_and</h2><p><code>std::logical_and</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行逻辑与操作。它是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行逻辑与操作。</p>
<h3 id="基本语法：-7"><a href="#基本语法：-7" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::logical_and&lt;T&gt; logical_and_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：逻辑与操作的参数类型。</li>
</ul>
<h3 id="使用方法：-5"><a href="#使用方法：-5" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::logical_and</code> 对象可以像函数一样调用，用于执行逻辑与操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>bool</code> 等。</p>
<h3 id="示例代码：-10"><a href="#示例代码：-10" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::logical_and&lt;<span class="type">bool</span>&gt; logicalAndBool;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> result = <span class="built_in">logicalAndBool</span>(<span class="literal">true</span>, <span class="literal">false</span>); <span class="comment">// 执行逻辑与操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of logical AND: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::logical_and</code> 实例化为 <code>std::logical_and&lt;bool&gt;</code>，表示执行布尔类型的逻辑与操作。<code>logicalAndBool</code> 对象被调用并传递两个参数，执行逻辑与操作并返回结果。</p>
<h2 id="std-logical-or"><a href="#std-logical-or" class="headerlink" title="std::logical_or"></a>std::logical_or</h2><p><code>std::logical_or</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行逻辑或操作。它是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行逻辑或操作。</p>
<h3 id="基本语法：-8"><a href="#基本语法：-8" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::logical_or&lt;T&gt; logical_or_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：逻辑或操作的参数类型。</li>
</ul>
<h3 id="使用方法：-6"><a href="#使用方法：-6" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::logical_or</code> 对象可以像函数一样调用，用于执行逻辑或操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>bool</code> 等。</p>
<h3 id="示例代码：-11"><a href="#示例代码：-11" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::logical_or&lt;<span class="type">bool</span>&gt; logicalOrBool;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> result = <span class="built_in">logicalOrBool</span>(<span class="literal">true</span>, <span class="literal">false</span>); <span class="comment">// 执行逻辑或操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of logical OR: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::logical_or</code> 实例化为 <code>std::logical_or&lt;bool&gt;</code>，表示执行布尔类型的逻辑或操作。<code>logicalOrBool</code> 对象被调用并传递两个参数，执行逻辑或操作并返回结果。</p>
<h2 id="std-logical-not"><a href="#std-logical-not" class="headerlink" title="std::logical_not"></a>std::logical_not</h2><p><code>std::logical_not</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行逻辑非（取反）操作。它是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行逻辑非操作。</p>
<h3 id="基本语法：-9"><a href="#基本语法：-9" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::logical_not&lt;T&gt; logical_not_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：逻辑非操作的参数类型。</li>
</ul>
<h3 id="使用方法：-7"><a href="#使用方法：-7" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::logical_not</code> 对象可以像函数一样调用，用于执行逻辑非操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>bool</code> 等。</p>
<h3 id="示例代码：-12"><a href="#示例代码：-12" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::logical_not&lt;<span class="type">bool</span>&gt; logicalNotBool;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> result = <span class="built_in">logicalNotBool</span>(<span class="literal">true</span>); <span class="comment">// 执行逻辑非操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of logical NOT: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::logical_not</code> 实例化为 <code>std::logical_not&lt;bool&gt;</code>，表示执行布尔类型的逻辑非操作。<code>logicalNotBool</code> 对象被调用并传递一个参数，执行逻辑非操作并返回结果。</p>
<h2 id="std-negate"><a href="#std-negate" class="headerlink" title="std::negate"></a>std::negate</h2><p><code>std::negate</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象，用于执行一元取反操作。它是一个函数对象类，重载了函数调用运算符 <code>operator()</code>，使其能够执行一元取反操作。</p>
<h3 id="基本语法：-10"><a href="#基本语法：-10" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::negate&lt;T&gt; negate_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code>：取反操作的参数类型。</li>
</ul>
<h3 id="使用方法：-8"><a href="#使用方法：-8" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::negate</code> 对象可以像函数一样调用，用于执行一元取反操作。它是一个模板类，可以根据需要指定不同的参数类型，比如 <code>int</code>、<code>float</code>、<code>double</code> 等。</p>
<h3 id="示例代码：-13"><a href="#示例代码：-13" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::negate&lt;<span class="type">int</span>&gt; negateInt;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">negateInt</span>(<span class="number">10</span>); <span class="comment">// 执行一元取反操作</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of unary negation: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::negate</code> 实例化为 <code>std::negate&lt;int&gt;</code>，表示执行整数类型的一元取反操作。<code>negateInt</code> 对象被调用并传递一个参数，执行一元取反操作并返回结果。</p>
<h2 id="std-not1"><a href="#std-not1" class="headerlink" title="std::not1"></a>std::not1</h2><p><code>std::not1</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象适配器，用于对一元谓词函数进行取反操作。它可用于构造一个函数对象，将传入的一元谓词函数对象的结果进行取反。</p>
<h3 id="基本语法：-11"><a href="#基本语法：-11" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::not1&lt;UnaryPredicate&gt; not1_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>UnaryPredicate</code>：一元谓词函数对象类型。</li>
</ul>
<h3 id="使用方法：-9"><a href="#使用方法：-9" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::not1</code> 可以用于对一元谓词函数对象进行取反操作。它接受一个一元谓词函数对象作为参数，并返回一个新的谓词函数对象，该对象对传入的谓词函数的返回值进行取反。</p>
<h3 id="示例代码：-14"><a href="#示例代码：-14" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greaterThanThree</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; pred = std::not1&lt;std::function&lt;<span class="built_in">bool</span>(<span class="type">int</span>)&gt;&gt;(greaterThanThree);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of not1: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; <span class="built_in">pred</span>(<span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">// Result will be false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::not1</code> 对 <code>greaterThanThree</code> 函数对象进行取反操作。<code>pred</code> 对象被调用并传递一个参数，返回结果为传入参数的一元谓词函数的取反结果。</p>
<h2 id="std-not2"><a href="#std-not2" class="headerlink" title="std::not2"></a>std::not2</h2><p><code>std::not2</code> 是 <code>&lt;functional&gt;</code> 头文件中提供的函数对象适配器，用于对二元谓词函数进行取反操作。它可用于构造一个函数对象，将传入的二元谓词函数对象的结果进行取反。</p>
<h3 id="基本语法：-12"><a href="#基本语法：-12" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::not2&lt;BinaryPredicate&gt; not2_object;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>BinaryPredicate</code>：二元谓词函数对象类型。</li>
</ul>
<h3 id="使用方法：-10"><a href="#使用方法：-10" class="headerlink" title="使用方法："></a>使用方法：</h3><p><code>std::not2</code> 可以用于对二元谓词函数对象进行取反操作。它接受一个二元谓词函数对象作为参数，并返回一个新的谓词函数对象，该对象对传入的谓词函数的返回值进行取反。</p>
<h3 id="示例代码：-15"><a href="#示例代码：-15" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lessThanOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;= y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; pred = std::not2&lt;std::function&lt;<span class="built_in">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt;(lessThanOrEqual);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of not2: &quot;</span> &lt;&lt; std::boolalpha &lt;&lt; <span class="built_in">pred</span>(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// Result will be false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::not2</code> 对 <code>lessThanOrEqual</code> 函数对象进行取反操作。<code>pred</code> 对象被调用并传递两个参数，返回结果为传入参数的二元谓词函数的取反结果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_21_utility/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_21_utility/" class="post-title-link" itemprop="url">C++_10_21_utility</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <utility>标准库</li>
</ul>
<h2 id="pair工具类"><a href="#pair工具类" class="headerlink" title="pair工具类"></a>pair工具类</h2><ul>
<li>pair在<utility>头文件中定义，并将两个可能属于不同类型的值组合起来。可以通过first和second公共数据成员访问这两个值</li>
<li>在C++17引入对CTAD的支持之前，可以使用std::make_pair()工具函数模板，从两个值构造一个pair</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <utility>标准库</h2><p><code>&lt;utility&gt;</code> 是 C++ 标准库中的头文件，它包含了一些实用工具和通用功能，提供了一些模板类和函数。这个头文件定义了一些基本的工具类和函数，以支持各种通用编程需求。</p>
<p>以下是 <code>&lt;utility&gt;</code> 头文件中一些常见的功能和类：</p>
<h3 id="1-std-pair"><a href="#1-std-pair" class="headerlink" title="1. std::pair"></a>1. <code>std::pair</code></h3><ul>
<li><code>std::pair</code> 是一个模板类，用于存储一对值，类似于键值对的概念。</li>
<li>通常用于函数返回多个值或存储两个相关的值。</li>
</ul>
<h3 id="2-std-make-pair"><a href="#2-std-make-pair" class="headerlink" title="2. std::make_pair"></a>2. <code>std::make_pair</code></h3><ul>
<li><code>std::make_pair</code> 是一个模板函数，用于创建一个 <code>std::pair</code> 对象。</li>
<li>接受两个参数，自动推导类型并返回一个 <code>std::pair</code> 对象。</li>
</ul>
<h3 id="3-std-move"><a href="#3-std-move" class="headerlink" title="3. std::move"></a>3. <code>std::move</code></h3><ul>
<li><code>std::move</code> 是一个函数模板，用于将对象转移到新位置，通常与移动语义一起使用。</li>
<li>将对象转换为右值引用，以便在赋值后对象的状态可以改变，而不是复制。</li>
</ul>
<h3 id="4-std-forward"><a href="#4-std-forward" class="headerlink" title="4. std::forward"></a>4. <code>std::forward</code></h3><ul>
<li><code>std::forward</code> 是一个函数模板，用于完美转发（perfect forwarding）。</li>
<li>用于在函数模板中保留参数的引用类型，使其继续保持右值或左值属性。</li>
</ul>
<h3 id="5-其他工具和函数"><a href="#5-其他工具和函数" class="headerlink" title="5. 其他工具和函数"></a>5. 其他工具和函数</h3><ul>
<li><code>&lt;utility&gt;</code> 还包含其他一些小的工具函数和模板，比如 <code>std::swap</code> 用于交换两个值，以及一些用于元组访问和元编程的功能。</li>
</ul>
<p>这些工具和类都是用于提供一些通用的功能，可以在许多不同的情况下使用，从简单的值对存储到高级的模板转发等。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <utility>标准库 详解</h2><p><code>&lt;utility&gt;</code> 是 C++ 标准库中的头文件，提供了一些通用工具、类模板和函数，用于各种编程场景中的通用操作和工具性功能。以下是 <code>&lt;utility&gt;</code> 中一些主要的功能和类的详细解释：</p>
<h3 id="1-std-pair-1"><a href="#1-std-pair-1" class="headerlink" title="1. std::pair"></a>1. <code>std::pair</code></h3><ul>
<li><code>std::pair</code> 是一个模板类，用于存储一对值，即将两个值组合成一个对象。</li>
<li>通常用于函数返回多个值或需要将两个相关联的值作为一个单元处理的情况。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;<span class="type">int</span>, std::string&gt; myPair = std::<span class="built_in">make_pair</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-std-make-pair-1"><a href="#2-std-make-pair-1" class="headerlink" title="2. std::make_pair"></a>2. <code>std::make_pair</code></h3><ul>
<li><code>std::make_pair</code> 是一个模板函数，用于创建 <code>std::pair</code> 对象。</li>
<li>它接受两个参数并自动推导类型，并返回一个对应类型的 <code>std::pair</code> 对象。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myPair = std::<span class="built_in">make_pair</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-std-move-1"><a href="#3-std-move-1" class="headerlink" title="3. std::move"></a>3. <code>std::move</code></h3><ul>
<li><code>std::move</code> 是一个函数模板，用于将一个左值转换为对应的右值引用。</li>
<li>通常用于支持移动语义，在移动语义中，资源的所有权可以从一个对象转移到另一个对象，而无需进行深层复制。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::string str2 = std::<span class="built_in">move</span>(str1); <span class="comment">// Move str1 to str2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-std-forward-1"><a href="#4-std-forward-1" class="headerlink" title="4. std::forward"></a>4. <code>std::forward</code></h3><ul>
<li><code>std::forward</code> 是一个模板函数，用于完美转发（perfect forwarding）。</li>
<li>通常在泛型编程中用于传递参数，并保持参数的原始左值或右值特性。</li>
<li>主要用于在泛型函数或模板中保留参数的原始引用类型。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">some_function</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-std-swap"><a href="#5-std-swap" class="headerlink" title="5. std::swap"></a>5. <code>std::swap</code></h3><ul>
<li><code>std::swap</code> 是一个函数模板，用于交换两个对象的值。</li>
<li>适用于大多数基本类型以及用户自定义类型的交换操作。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">std::<span class="built_in">swap</span>(a, b); <span class="comment">// Swap values of a and b</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>这些功能和类提供了通用的工具和操作，可用于各种不同的情况，从简单的值对组合到高级的模板转发。它们是 C++ 标准库提供的一些核心工具，为编写高效、通用的代码提供了便利。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <utility>标准库 常用的类和函数</h2><p><code>&lt;utility&gt;</code> 标准库提供了一些常用的类和函数，以下是其中一些主要的类和函数：</p>
<h3 id="1-std-pair-2"><a href="#1-std-pair-2" class="headerlink" title="1. std::pair"></a>1. <code>std::pair</code></h3><ul>
<li><code>std::pair</code> 是一个模板类，用于存储一对值（通常是不同类型的值），将两个值作为一个单元存储和访问。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;<span class="type">int</span>, std::string&gt; myPair = std::<span class="built_in">make_pair</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-std-make-pair-2"><a href="#2-std-make-pair-2" class="headerlink" title="2. std::make_pair"></a>2. <code>std::make_pair</code></h3><ul>
<li><code>std::make_pair</code> 是一个模板函数，用于创建 <code>std::pair</code> 对象，根据传递的参数类型自动推导 <code>std::pair</code> 对象的类型。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myPair = std::<span class="built_in">make_pair</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-std-move-2"><a href="#3-std-move-2" class="headerlink" title="3. std::move"></a>3. <code>std::move</code></h3><ul>
<li><code>std::move</code> 是一个函数模板，用于将左值转换为对应的右值引用，支持移动语义。</li>
<li>用于支持移动语义，提高资源的有效使用。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::string str2 = std::<span class="built_in">move</span>(str1); <span class="comment">// Move str1 to str2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-std-forward-2"><a href="#4-std-forward-2" class="headerlink" title="4. std::forward"></a>4. <code>std::forward</code></h3><ul>
<li><code>std::forward</code> 是一个模板函数，用于完美转发（perfect forwarding）。</li>
<li>在泛型编程中用于传递参数，并保持参数的原始左值或右值特性。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">some_function</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-std-swap-1"><a href="#5-std-swap-1" class="headerlink" title="5. std::swap"></a>5. <code>std::swap</code></h3><ul>
<li><code>std::swap</code> 是一个函数模板，用于交换两个对象的值。</li>
<li>适用于大多数基本类型以及用户自定义类型的交换操作。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">std::<span class="built_in">swap</span>(a, b); <span class="comment">// Swap values of a and b</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>这些类和函数是 <code>&lt;utility&gt;</code> 头文件中最常用的，提供了许多方便的工具和功能，用于各种不同的编程场景中。使用它们可以简化代码，提高效率，并且支持泛型编程范式。</p>
<h2 id="std-pair"><a href="#std-pair" class="headerlink" title="std::pair"></a>std::pair</h2><p><code>std::pair</code> 是 C++ 标准库中的模板类，用于存储一对值。这两个值可以是不同类型的，通过 <code>std::pair</code> 可以将它们组合成一个单元，方便地对这两个值进行操作和传递。</p>
<h3 id="特点和用途："><a href="#特点和用途：" class="headerlink" title="特点和用途："></a>特点和用途：</h3><ul>
<li><strong>存储一对值：</strong> <code>std::pair</code> 允许存储两个值，可以是不同的类型。</li>
<li><strong>多用于函数返回值：</strong> 常用于函数需要返回两个值时，可以将这两个值打包成一个 <code>std::pair</code> 返回。</li>
<li><strong>作为映射容器的值类型：</strong> 在某些情况下，用于作为键值对存储在映射容器（如 <code>std::map</code>）中。</li>
</ul>
<h3 id="基本用法示例："><a href="#基本用法示例：" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">int</span>, std::string&gt; <span class="title">myPair</span><span class="params">(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First value: &quot;</span> &lt;&lt; myPair.first &lt;&lt; std::endl;   <span class="comment">// 访问第一个值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Second value: &quot;</span> &lt;&lt; myPair.second &lt;&lt; std::endl; <span class="comment">// 访问第二个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要成员函数："><a href="#主要成员函数：" class="headerlink" title="主要成员函数："></a>主要成员函数：</h3><ul>
<li><strong><code>first</code> 和 <code>second</code>：</strong> 分别用于访问存储的第一个值和第二个值。</li>
<li><strong><code>make_pair</code>：</strong> 用于创建 <code>std::pair</code> 对象。</li>
<li><strong><code>operator==</code> 和 <code>operator!=</code>：</strong> 用于比较两个 <code>std::pair</code> 对象是否相等或不相等。</li>
</ul>
<p><code>std::pair</code> 提供了一种便捷的方式来存储和操作一对值，特别是在函数需要返回多个值时，可以将这些值捆绑成一个 <code>std::pair</code> 返回，提高了代码的可读性和简洁性。</p>
<h2 id="std-make-pair"><a href="#std-make-pair" class="headerlink" title="std::make_pair()"></a>std::make_pair()</h2><p><code>std::make_pair()</code> 是一个模板函数，用于创建 <code>std::pair</code> 对象。它接受两个参数，并根据这两个参数的类型自动推导出 <code>std::pair</code> 对象的类型，然后返回这个新创建的 <code>std::pair</code> 对象。</p>
<h3 id="主要特点和用途："><a href="#主要特点和用途：" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>自动类型推导：</strong> <code>std::make_pair()</code> 会根据传入的参数类型自动推导出返回的 <code>std::pair</code> 对象的类型。</li>
<li><strong>便捷性：</strong> 方便创建和初始化 <code>std::pair</code> 对象，尤其适用于函数返回值或作为容器中的元素。</li>
</ul>
<h3 id="基本用法示例：-1"><a href="#基本用法示例：-1" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> myPair = std::<span class="built_in">make_pair</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First value: &quot;</span> &lt;&lt; myPair.first &lt;&lt; std::endl;   <span class="comment">// 访问第一个值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Second value: &quot;</span> &lt;&lt; myPair.second &lt;&lt; std::endl; <span class="comment">// 访问第二个值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::make_pair()</code> 接受一个整数和一个字符串作为参数，然后自动推导并返回一个 <code>std::pair&lt;int, const char*&gt;</code> 对象，将整数和字符串组合成一个对。这种自动推导减少了在代码中显式指定类型的需要，提高了代码的简洁性和可读性。</p>
<p>使用 <code>std::make_pair()</code> 可以方便地创建 <code>std::pair</code> 对象，并减少了手动指定模板参数的工作。</p>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p><code>std::move</code> 是 C++ 标准库中的一个函数模板，用于将给定的左值强制转换为右值引用。它并不实际移动任何数据，而是允许程序员表达对某个值的“移动语义”。</p>
<h3 id="主要特点和用途：-1"><a href="#主要特点和用途：-1" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>支持移动语义：</strong> <code>std::move</code> 是 C++11 引入的一个重要工具，用于支持右值引用和移动语义。</li>
<li><strong>避免不必要的复制：</strong> 可以使用 <code>std::move</code> 将左值转换为右值引用，从而避免不必要的复制操作，在移动语义下可以更有效地管理资源。</li>
<li><strong>用于移动语义：</strong> 通常与移动构造函数和移动赋值运算符一起使用，支持对资源的高效转移，如避免资源的深层复制。</li>
</ul>
<h3 id="基本用法示例：-2"><a href="#基本用法示例：-2" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str2 = std::<span class="built_in">move</span>(str1); <span class="comment">// 转移 str1 的内容到 str2</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1 after move: &quot;</span> &lt;&lt; str1 &lt;&lt; std::endl; <span class="comment">// 注意：此处 str1 可能已经为空</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2 after move: &quot;</span> &lt;&lt; str2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::move</code> 将 <code>str1</code> 转换为右值引用，允许将 <code>str1</code> 的内容有效地移动到 <code>str2</code> 中。移动操作不会复制数据，而是“窃取”了 <code>str1</code> 的资源，因此在输出 <code>str1</code> 的内容时，它可能为空。</p>
<p><strong>注意：</strong> 使用 <code>std::move</code> 后，原来的左值变量（这里是 <code>str1</code>）可能不再包含有效的数据，因此需要谨慎使用移动语义，以避免悬空引用和使用无效数据。</p>
<h2 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h2><p><code>std::forward</code> 是一个模板函数，通常与模板和引用折叠相关，用于完美转发（perfect forwarding）。</p>
<h3 id="主要特点和用途：-2"><a href="#主要特点和用途：-2" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>完美转发：</strong> 在泛型编程中，<code>std::forward</code> 用于在函数模板中正确地保持传递参数的值类别（左值或右值）。</li>
<li><strong>保留参数类型：</strong> 将传递给函数的参数的值类别（左值或右值）转发到另一个函数，以保留参数的原始引用类型。</li>
<li><strong>配合模板参数推导：</strong> 通常与函数模板一起使用，避免参数传递过程中的值类别转换。</li>
</ul>
<h3 id="基本用法示例：-3"><a href="#基本用法示例：-3" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个函数模板，使用 std::forward 进行完美转发</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">some_function</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(value); <span class="comment">// 参数是左值</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">100</span>);   <span class="comment">// 参数是右值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::forward</code> 用于将 <code>wrapper</code> 函数模板中的参数 <code>arg</code> 以原始的引用类型传递给 <code>some_function</code>。这有助于避免参数传递过程中的多余的值类别转换，实现完美转发，保持参数的原始引用类型。</p>
<p><code>std::forward</code> 在实现泛型函数和模板函数时非常有用，可以正确地将参数的左值或右值特性转发给另一个函数，以实现参数值的有效传递。</p>
<h2 id="std-swap"><a href="#std-swap" class="headerlink" title="std::swap()"></a>std::swap()</h2><p><code>std::swap()</code> 是 C++ 标准库中的一个函数模板，用于交换两个对象的值。它可以用于大多数基本类型和用户自定义类型的对象交换操作。</p>
<h3 id="主要特点和用途：-3"><a href="#主要特点和用途：-3" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>交换值：</strong> <code>std::swap()</code> 允许交换两个对象的值，无论对象是基本类型还是自定义类型。</li>
<li><strong>泛型：</strong> 是一个泛型函数模板，适用于各种类型的对象交换。</li>
<li><strong>支持自定义类型：</strong> 对于自定义类型，需要实现该类型的 <code>swap()</code> 成员函数或者提供全局的 <code>swap()</code> 重载函数。</li>
</ul>
<h3 id="基本用法示例：-4"><a href="#基本用法示例：-4" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    std::<span class="built_in">swap</span>(a, b); <span class="comment">// 交换 a 和 b 的值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a after swap: &quot;</span> &lt;&lt; a &lt;&lt; std::endl; <span class="comment">// 输出已交换后的 a</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b after swap: &quot;</span> &lt;&lt; b &lt;&lt; std::endl; <span class="comment">// 输出已交换后的 b</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例中展示了 <code>std::swap()</code> 函数如何交换两个整数变量 <code>a</code> 和 <code>b</code> 的值。对于基本类型，<code>std::swap()</code> 能够直接进行交换操作，但对于自定义类型，需要提供相应的 <code>swap()</code> 函数实现。</p>
<p>对于自定义类型，通常应该提供一个 <code>swap()</code> 成员函数或全局的 <code>swap()</code> 重载函数，以实现该类型对象的交换操作，从而使 <code>std::swap()</code> 能够正确工作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如，自定义类型的 swap() 函数实现：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 自定义类型的 swap() 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(MyClass&amp; other)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(value, other.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="comment">// 自定义类型的 swap() 全局重载函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(MyClass&amp; first, MyClass&amp; second)</span> </span>&#123;</span><br><span class="line">        first.<span class="built_in">swap</span>(second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过提供适当的 <code>swap()</code> 函数，可以确保 <code>std::swap()</code> 在对自定义类型的对象进行交换时正常工作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_22_tuple/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_22_tuple/" class="post-title-link" itemprop="url">C++_10_22_tuple</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <tuple>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <tuple>标准库</h2><p><code>&lt;tuple&gt;</code> 是 C++ 标准库中的头文件，提供了 <code>std::tuple</code> 类模板和相关函数，用于创建和操作元组（Tuple）。</p>
<h3 id="std-tuple-概述："><a href="#std-tuple-概述：" class="headerlink" title="std::tuple 概述："></a>std::tuple 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;tuple&gt;</code></li>
<li><strong>类模板：</strong> <code>std::tuple</code></li>
</ul>
<h3 id="元组（Tuple）的特点："><a href="#元组（Tuple）的特点：" class="headerlink" title="元组（Tuple）的特点："></a>元组（Tuple）的特点：</h3><ul>
<li><strong>有序集合：</strong> 元组是一个固定大小的、有序的集合，可以包含多个不同类型的元素。</li>
<li><strong>类似于数组：</strong> 类似于数组，但元组中的元素可以是不同的类型，并且元素数量固定。</li>
<li><strong>元素访问：</strong> 元组中的元素可以通过索引或 <code>std::get</code> 函数进行访问。</li>
<li><strong>用于函数返回多个值：</strong> 常用于函数需要返回多个值时，可以将这些值组织成元组进行返回。</li>
</ul>
<h3 id="基本操作和示例："><a href="#基本操作和示例：" class="headerlink" title="基本操作和示例："></a>基本操作和示例：</h3><ul>
<li><p><strong>创建元组：</strong> 使用 <code>std::make_tuple</code> 或直接使用构造函数创建元组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> myTuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; <span class="title">myTuple</span><span class="params">(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>访问元组元素：</strong> 使用 <code>std::get</code> 函数或 <code>std::tie</code> 函数进行元素的访问或解包。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(myTuple); <span class="comment">// 访问第一个元素</span></span><br><span class="line">std::string str = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(myTuple); <span class="comment">// 访问第二个元素</span></span><br><span class="line"><span class="type">double</span> d = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(myTuple); <span class="comment">// 访问第三个元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解包元组：</strong> 使用 <code>std::tie</code> 将元组解包为多个变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">std::string y;</span><br><span class="line"><span class="type">double</span> z;</span><br><span class="line">std::<span class="built_in">tie</span>(x, y, z) = myTuple; <span class="comment">// 将元组解包为 x, y, z 三个变量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>元组大小：</strong> 使用 <code>std::tuple_size</code> 获取元组的大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> tupleSize = std::tuple_size&lt;<span class="keyword">decltype</span>(myTuple)&gt;::value;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>std::tuple</code> 提供了一种方便的方式来组织和操作多个不同类型的值，并且可以在函数返回多个值时使用。通过元组，可以在不使用结构体的情况下返回多个相关联的值，提高了代码的灵活性和可读性。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <tuple>标准库 详解</h2><p><code>&lt;tuple&gt;</code> 标准库提供了 <code>std::tuple</code> 类模板和一些相关的函数，用于创建、操作和处理元组（Tuple）。元组是一个固定大小、有序的集合，可以容纳不同类型的元素。</p>
<h3 id="std-tuple-概览："><a href="#std-tuple-概览：" class="headerlink" title="std::tuple 概览："></a>std::tuple 概览：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;tuple&gt;</code></li>
<li><strong>类模板：</strong> <code>std::tuple</code></li>
</ul>
<h3 id="主要特点和用途："><a href="#主要特点和用途：" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>组织多个值：</strong> 元组用于组织多个不同类型的值，并且长度是固定的。</li>
<li><strong>多种构造方式：</strong> 可以使用 <code>std::make_tuple</code>、直接使用构造函数等多种方式创建元组。</li>
<li><strong>元素访问：</strong> 可以使用 <code>std::get</code> 获取元组中的元素，也可以通过解包或结构绑定方式访问元素。</li>
<li><strong>函数返回多个值：</strong> 在需要返回多个相关联的值时，可以使用元组。</li>
</ul>
<h3 id="基本用法示例："><a href="#基本用法示例：" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建元组</span></span><br><span class="line">    <span class="keyword">auto</span> myTuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元组元素</span></span><br><span class="line">    <span class="type">int</span> value = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(myTuple); <span class="comment">// 访问第一个元素</span></span><br><span class="line">    std::string str = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(myTuple); <span class="comment">// 访问第二个元素</span></span><br><span class="line">    <span class="type">double</span> d = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(myTuple); <span class="comment">// 访问第三个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解包元组</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string y;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">    std::<span class="built_in">tie</span>(x, y, z) = myTuple; <span class="comment">// 解包元组为 x, y, z 三个变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元组大小</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> tupleSize = std::tuple_size&lt;<span class="keyword">decltype</span>(myTuple)&gt;::value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元组是一个强大的工具，允许将多个值组织在一起，而不需要使用自定义结构体。它能够帮助编写更灵活、更通用的代码，尤其是在需要返回多个相关值的情况下，提高了代码的可读性和简洁性。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <tuple>标准库 常用的类和函数</h2><p><code>&lt;tuple&gt;</code> 标准库中常用的类和函数包括 <code>std::tuple</code> 类模板以及一些与元组相关的操作函数。</p>
<h3 id="1-std-tuple-类模板"><a href="#1-std-tuple-类模板" class="headerlink" title="1. std::tuple 类模板"></a>1. std::tuple 类模板</h3><ul>
<li><code>std::tuple</code> 是一个类模板，用于表示一个固定大小的有序集合，可以存储不同类型的元素。</li>
<li>用于组织多个值，并以元组的形式进行传递和处理。</li>
</ul>
<h3 id="2-std-make-tuple"><a href="#2-std-make-tuple" class="headerlink" title="2. std::make_tuple"></a>2. std::make_tuple</h3><ul>
<li><code>std::make_tuple</code> 是一个模板函数，用于创建 <code>std::tuple</code> 对象。</li>
<li>接受一系列参数，并根据参数类型推导出相应的 <code>std::tuple</code> 对象。</li>
</ul>
<h3 id="3-std-get"><a href="#3-std-get" class="headerlink" title="3. std::get"></a>3. std::get</h3><ul>
<li><code>std::get</code> 是一个模板函数，用于访问元组中指定位置的元素。</li>
<li>可以通过索引来获取元组中的元素，以实现对元组内容的访问。</li>
</ul>
<h3 id="4-std-tie"><a href="#4-std-tie" class="headerlink" title="4. std::tie"></a>4. std::tie</h3><ul>
<li><code>std::tie</code> 是一个模板函数，用于解包元组并将元组的元素绑定到变量上。</li>
<li>可以将元组中的值解包为多个变量，并将这些变量绑定到元组的相应位置。</li>
</ul>
<h3 id="5-std-tuple-size"><a href="#5-std-tuple-size" class="headerlink" title="5. std::tuple_size"></a>5. std::tuple_size</h3><ul>
<li><code>std::tuple_size</code> 是一个模板类，用于获取元组的大小（元素数量）。</li>
<li>通过该类模板可以获取元组的大小，通常与模板参数一起使用。</li>
</ul>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建元组</span></span><br><span class="line">    <span class="keyword">auto</span> myTuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元组元素</span></span><br><span class="line">    <span class="type">int</span> value = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(myTuple); <span class="comment">// 访问第一个元素</span></span><br><span class="line">    std::string str = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(myTuple); <span class="comment">// 访问第二个元素</span></span><br><span class="line">    <span class="type">double</span> d = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(myTuple); <span class="comment">// 访问第三个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解包元组</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string y;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">    std::<span class="built_in">tie</span>(x, y, z) = myTuple; <span class="comment">// 解包元组为 x, y, z 三个变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元组大小</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> tupleSize = std::tuple_size&lt;<span class="keyword">decltype</span>(myTuple)&gt;::value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些类和函数是 <code>&lt;tuple&gt;</code> 头文件中最常用的，用于创建、访问和处理元组。它们提供了一种方便的方式来组织和操作多个不同类型的值，可以在不使用结构体的情况下返回多个相关联的值，提高了代码的灵活性和可读性。</p>
<h2 id="std-tuple"><a href="#std-tuple" class="headerlink" title="std::tuple"></a>std::tuple</h2><p><code>std::tuple</code> 是 C++ 标准库中的一个模板类，用于表示一个固定数量、固定顺序的元素集合，这些元素可以是不同类型的。<code>std::tuple</code> 类模板允许以元组的形式存储和操作多个值。</p>
<h3 id="主要特点和用途：-1"><a href="#主要特点和用途：-1" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>有序集合：</strong> <code>std::tuple</code> 以有序集合的形式存储一组值，值的数量和类型是固定的。</li>
<li><strong>不同类型元素：</strong> 允许存储不同类型的元素，支持任意数量的不同类型值的组合。</li>
<li><strong>多用途：</strong> 用于函数返回多个值，传递多个参数，或者用于在不使用结构体的情况下组织多个值。</li>
</ul>
<h3 id="基本操作和示例：-1"><a href="#基本操作和示例：-1" class="headerlink" title="基本操作和示例："></a>基本操作和示例：</h3><h4 id="创建元组："><a href="#创建元组：" class="headerlink" title="创建元组："></a>创建元组：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用std::make_tuple创建元组</span></span><br><span class="line"><span class="keyword">auto</span> myTuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line"><span class="comment">// 使用tuple的构造函数创建元组</span></span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; <span class="title">myTuple</span><span class="params">(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="访问元组元素："><a href="#访问元组元素：" class="headerlink" title="访问元组元素："></a>访问元组元素：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(myTuple); <span class="comment">// 访问第一个元素</span></span><br><span class="line">std::string str = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(myTuple); <span class="comment">// 访问第二个元素</span></span><br><span class="line"><span class="type">double</span> d = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(myTuple); <span class="comment">// 访问第三个元素</span></span><br></pre></td></tr></table></figure>

<h4 id="解包元组："><a href="#解包元组：" class="headerlink" title="解包元组："></a>解包元组：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">std::string y;</span><br><span class="line"><span class="type">double</span> z;</span><br><span class="line">std::<span class="built_in">tie</span>(x, y, z) = myTuple; <span class="comment">// 将元组解包为 x, y, z 三个变量</span></span><br></pre></td></tr></table></figure>

<h4 id="获取元组大小："><a href="#获取元组大小：" class="headerlink" title="获取元组大小："></a>获取元组大小：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> tupleSize = std::tuple_size&lt;<span class="keyword">decltype</span>(myTuple)&gt;::value; <span class="comment">// 获取元组大小</span></span><br></pre></td></tr></table></figure>

<p><code>std::tuple</code> 是一个灵活且功能强大的工具，特别适用于需要返回多个相关联的值的情况。它可以提高代码的可读性和灵活性，同时也减少了在函数参数和返回值方面的代码复杂度。</p>
<h2 id="std-make-tuple"><a href="#std-make-tuple" class="headerlink" title="std::make_tuple"></a>std::make_tuple</h2><p><code>std::make_tuple</code> 是一个模板函数，用于创建 <code>std::tuple</code> 对象。它允许您通过传递一系列参数来创建一个元组对象，并自动推导出元组的类型。</p>
<h3 id="主要特点和用途：-2"><a href="#主要特点和用途：-2" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>自动类型推导：</strong> <code>std::make_tuple</code> 根据传递的参数类型自动推导出返回的 <code>std::tuple</code> 对象的类型。</li>
<li><strong>便捷性：</strong> 方便地创建和初始化元组，尤其适用于函数返回值或作为容器中的元素。</li>
</ul>
<h3 id="基本用法示例：-1"><a href="#基本用法示例：-1" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> myTuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(myTuple); <span class="comment">// 获取第一个元素</span></span><br><span class="line">    std::string str = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(myTuple); <span class="comment">// 获取第二个元素</span></span><br><span class="line">    <span class="type">double</span> d = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(myTuple); <span class="comment">// 获取第三个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::make_tuple</code> 接受三个参数并自动推导出一个 <code>std::tuple&lt;int, const char*, double&gt;</code> 类型的元组对象。使用 <code>std::get</code> 可以方便地访问元组中的各个元素。</p>
<p><code>std::make_tuple</code> 的优势在于提供了一种更简洁和易读的方式来创建元组对象，无需显式指定模板参数类型，编译器会根据传入的参数类型自动推导出正确的元组类型。</p>
<h2 id="std-get"><a href="#std-get" class="headerlink" title="std::get"></a>std::get</h2><p><code>std::get</code> 是用于从 <code>std::tuple</code> 中获取特定位置的元素值的模板函数。它提供了一种访问元组中特定位置元素的方式，允许您根据索引访问元组的元素。</p>
<h3 id="主要特点和用途：-3"><a href="#主要特点和用途：-3" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>访问元组元素：</strong> <code>std::get</code> 用于检索元组中特定索引位置的元素。</li>
<li><strong>参数化访问：</strong> 该函数模板使用一个整数模板参数来指定要访问的元素位置。</li>
<li><strong>安全性检查：</strong> 通过编译时索引进行访问，因此可以在编译时捕获索引错误。</li>
</ul>
<h3 id="基本用法示例：-2"><a href="#基本用法示例：-2" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; <span class="title">myTuple</span><span class="params">(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(myTuple); <span class="comment">// 获取第一个元素</span></span><br><span class="line">    std::string str = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(myTuple); <span class="comment">// 获取第二个元素</span></span><br><span class="line">    <span class="type">double</span> d = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(myTuple); <span class="comment">// 获取第三个元素</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::get&lt;index&gt;(myTuple)</code> 用于检索元组 <code>myTuple</code> 中指定索引位置（使用 <code>index</code>）的元素。元组索引从0开始，<code>std::get&lt;0&gt;(myTuple)</code> 获取第一个元素，<code>std::get&lt;1&gt;(myTuple)</code> 获取第二个元素，以此类推。</p>
<p>使用 <code>std::get</code> 可以方便地访问元组中特定位置的元素，并在编译时进行索引错误的检查，确保访问的元素位置是有效的。</p>
<h2 id="std-tie"><a href="#std-tie" class="headerlink" title="std::tie"></a>std::tie</h2><p><code>std::tie</code> 是一个模板函数，用于将元组的元素解包（unpack）并将其绑定到指定的变量上。这种操作常用于从函数返回多个值或者进行多个变量的赋值操作。</p>
<h3 id="主要特点和用途：-4"><a href="#主要特点和用途：-4" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>解包元组：</strong> <code>std::tie</code> 允许将元组中的元素解包为多个变量。</li>
<li><strong>多变量绑定：</strong> 可以将元组的元素按顺序绑定到一系列变量上，无需一个个分别赋值。</li>
</ul>
<h3 id="基本用法示例：-3"><a href="#基本用法示例：-3" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; <span class="title">myTuple</span><span class="params">(<span class="number">42</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    std::string y;</span><br><span class="line">    <span class="type">double</span> z;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 std::tie 解包元组并绑定到变量</span></span><br><span class="line">    std::<span class="built_in">tie</span>(x, y, z) = myTuple;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;z: &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::tie</code> 将 <code>myTuple</code> 元组中的元素解包，并将其依次绑定到变量 <code>x</code>、<code>y</code> 和 <code>z</code> 上。这样就能够直接从元组中获取值并赋给变量，而无需手动调用 <code>std::get</code>。</p>
<p><code>std::tie</code> 对于函数返回多个值时特别有用，可以让您一次性获取多个值并将它们分别赋给变量，提高代码的可读性和简洁性。</p>
<h2 id="std-tuple-size"><a href="#std-tuple-size" class="headerlink" title="std::tuple_size"></a>std::tuple_size</h2><p><code>std::tuple_size</code> 是一个模板类，用于获取元组的大小（也就是元组中元素的数量）。它通常与 <code>std::tuple</code> 一起使用，以在编译时获取元组的大小信息。</p>
<h3 id="主要特点和用途：-5"><a href="#主要特点和用途：-5" class="headerlink" title="主要特点和用途："></a>主要特点和用途：</h3><ul>
<li><strong>获取元组大小：</strong> <code>std::tuple_size</code> 用于获取元组类型的大小（元素数量）。</li>
<li><strong>编译时确定：</strong> 该类模板返回一个 <code>constexpr</code> 值，可以在编译时计算出元组的大小。</li>
</ul>
<h3 id="基本用法示例：-4"><a href="#基本用法示例：-4" class="headerlink" title="基本用法示例："></a>基本用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::tuple&lt;<span class="type">int</span>, std::string, <span class="type">double</span>&gt; myTuple;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::tuple_size 获取元组的大小</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> tupleSize = std::tuple_size&lt;<span class="keyword">decltype</span>(myTuple)&gt;::value;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Tuple size: &quot;</span> &lt;&lt; tupleSize &lt;&lt; std::endl; <span class="comment">// 输出元组的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::tuple_size</code> 类模板被用来获取 <code>myTuple</code> 元组对象的大小。使用 <code>decltype</code> 获取 <code>myTuple</code> 的类型，并使用 <code>::value</code> 获取元组大小的 <code>constexpr</code> 值。</p>
<p><code>std::tuple_size</code> 可以让您在编译时获取元组的大小，这在某些情况下可以用来进行一些特定的编译时优化和检查。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_23_cstdint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_23_cstdint/" class="post-title-link" itemprop="url">C++_10_23_cstdint</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <cstdint>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <cstdint>标准库</h2><p><code>&lt;cstdint&gt;</code> 是 C++ 标准库中的头文件，提供了固定大小的整数类型。它定义了一系列的整数类型，确保这些类型在不同平台上有固定的大小，以增强代码的可移植性。</p>
<h3 id="主要内容："><a href="#主要内容：" class="headerlink" title="主要内容："></a>主要内容：</h3><ul>
<li><strong>整数类型：</strong> 提供了带有明确大小的整数类型，例如 <code>int8_t</code>、<code>uint8_t</code>、<code>int16_t</code>、<code>uint16_t</code> 等。</li>
<li><strong>最小值和最大值：</strong> 定义了每种固定大小整数类型的最小值和最大值。</li>
<li><strong>位宽有符号和无符号整数：</strong> 提供了有符号和无符号整数类型，其位宽是确定的。</li>
</ul>
<h3 id="常用类型："><a href="#常用类型：" class="headerlink" title="常用类型："></a>常用类型：</h3><p>以下是一些常用的整数类型，它们保证了固定的大小和有符号&#x2F;无符号特性：</p>
<ul>
<li><code>int8_t</code>, <code>uint8_t</code>: 8 位整数类型</li>
<li><code>int16_t</code>, <code>uint16_t</code>: 16 位整数类型</li>
<li><code>int32_t</code>, <code>uint32_t</code>: 32 位整数类型</li>
<li><code>int64_t</code>, <code>uint64_t</code>: 64 位整数类型</li>
</ul>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int8_t</span> myInt8 = <span class="number">127</span>;</span><br><span class="line">    <span class="type">uint16_t</span> myUInt16 = <span class="number">65535</span>;</span><br><span class="line">    <span class="type">int32_t</span> myInt32 = <span class="number">-2147483647</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int8_t value: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(myInt8) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;uint16_t value: &quot;</span> &lt;&lt; myUInt16 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int32_t value: &quot;</span> &lt;&lt; myInt32 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;cstdint&gt;</code> 头文件提供了确定大小和有符号&#x2F;无符号特性的整数类型，确保了整数类型在各种平台上的可移植性和一致性。这些类型通常用于需要确切大小和精确位宽的数据表示的场景。</p>
<h2 id="C-标准库-常用类型和函数"><a href="#C-标准库-常用类型和函数" class="headerlink" title="C++ 标准库 常用类型和函数"></a>C++ <cstdint>标准库 常用类型和函数</h2><p><code>&lt;cstdint&gt;</code> 标准库提供了一组固定大小的整数类型和与整数类型相关的函数，以增强代码的可移植性和可读性。</p>
<h3 id="常用类型：-1"><a href="#常用类型：-1" class="headerlink" title="常用类型："></a>常用类型：</h3><ol>
<li><p><strong>有符号整数类型：</strong></p>
<ul>
<li><code>int8_t</code>: 8 位带符号整数类型</li>
<li><code>int16_t</code>: 16 位带符号整数类型</li>
<li><code>int32_t</code>: 32 位带符号整数类型</li>
<li><code>int64_t</code>: 64 位带符号整数类型</li>
</ul>
</li>
<li><p><strong>无符号整数类型：</strong></p>
<ul>
<li><code>uint8_t</code>: 8 位无符号整数类型</li>
<li><code>uint16_t</code>: 16 位无符号整数类型</li>
<li><code>uint32_t</code>: 32 位无符号整数类型</li>
<li><code>uint64_t</code>: 64 位无符号整数类型</li>
</ul>
</li>
<li><p><strong>最小值和最大值常量：</strong></p>
<ul>
<li><code>INT8_MIN</code>, <code>INT8_MAX</code>: <code>int8_t</code> 的最小值和最大值</li>
<li><code>UINT8_MAX</code>: <code>uint8_t</code> 的最大值</li>
<li>以此类推，每种固定大小整数类型都有相应的最小值和最大值常量。</li>
</ul>
</li>
</ol>
<h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><ol>
<li><p><strong>宏定义：</strong></p>
<ul>
<li><code>INT8_C</code>, <code>UINT8_C</code>: 用于创建带符号和无符号整数常量，例如 <code>INT8_C(5)</code> 表示带符号 8 位整数的常量 5。</li>
</ul>
</li>
<li><p><strong>最小宽度宏定义：</strong></p>
<ul>
<li><code>INT_LEAST8_MIN</code>, <code>INT_LEAST8_MAX</code>: <code>int_least8_t</code> 的最小值和最大值</li>
<li><code>UINT_LEAST8_MAX</code>: <code>uint_least8_t</code> 的最大值</li>
<li>以此类推，最小宽度整数类型都有对应的最小值和最大值常量。</li>
</ul>
</li>
<li><p><strong>快速宽度宏定义：</strong></p>
<ul>
<li><code>INT_FAST8_MIN</code>, <code>INT_FAST8_MAX</code>: <code>int_fast8_t</code> 的最小值和最大值</li>
<li><code>UINT_FAST8_MAX</code>: <code>uint_fast8_t</code> 的最大值</li>
<li>同样适用于其他固定大小整数类型。</li>
</ul>
</li>
<li><p><strong>其他函数：</strong></p>
<ul>
<li><code>INTPTR_MIN</code>, <code>INTPTR_MAX</code>: <code>intptr_t</code> 的最小值和最大值</li>
<li><code>UINTPTR_MAX</code>: <code>uintptr_t</code> 的最大值</li>
<li><code>INTMAX_MIN</code>, <code>INTMAX_MAX</code>: <code>intmax_t</code> 的最小值和最大值</li>
<li><code>UINTMAX_MAX</code>: <code>uintmax_t</code> 的最大值</li>
</ul>
</li>
</ol>
<p>这些常用类型和函数提供了在特定位宽下确定大小和精确度的整数类型，同时还提供了这些类型的最小值和最大值常量以及用于创建整数常量的宏定义。这些工具通常用于需要确切大小和精确位宽的数据表示的场景。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_25_forward_list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_25_forward_list/" class="post-title-link" itemprop="url">C++_10_25_forward_list</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <forward_list>标准库</li>
</ul>
<h2 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h2><ul>
<li>与list类似，区别在于forward_list是单链表，而list是双链表，这意味着forward_list只支持前向迭代。</li>
<li>C++标准要求forward_list最小化其内存使用，这就是没有size()方法的原因，因为不提供它，就不需要存储列表的大小。</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <forward_list>标准库</h2><p><code>&lt;forward_list&gt;</code> 是 C++ 标准库中的头文件，定义了单向链表（singly linked list）的模板类 <code>std::forward_list</code>。与 <code>std::list</code> 不同，<code>std::forward_list</code> 是单向链表，每个元素只保留指向下一个元素的指针。</p>
<h3 id="std-forward-list-概述："><a href="#std-forward-list-概述：" class="headerlink" title="std::forward_list 概述："></a>std::forward_list 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;forward_list&gt;</code></li>
<li><strong>容器类型：</strong> <code>std::forward_list</code> 是标准库中的容器类型之一，实现了单向链表。</li>
<li><strong>特点：</strong><ul>
<li>每个元素只保留指向下一个元素的指针，只能从前往后遍历。</li>
<li>支持高效的插入和删除操作，但对于随机访问效率较低。</li>
<li>没有 <code>size()</code> 函数，需要手动计算元素数量。</li>
</ul>
</li>
</ul>
<h3 id="主要操作和用法："><a href="#主要操作和用法：" class="headerlink" title="主要操作和用法："></a>主要操作和用法：</h3><ul>
<li><strong>插入和删除操作：</strong><ul>
<li><code>push_front()</code>, <code>pop_front()</code>: 在链表头部插入或删除元素。</li>
<li><code>insert_after()</code>, <code>erase_after()</code>: 在指定位置后插入或删除元素。</li>
</ul>
</li>
<li><strong>迭代器操作：</strong><ul>
<li><code>before_begin()</code>, <code>begin()</code>, <code>end()</code>: 获取链表迭代器。</li>
</ul>
</li>
<li><strong>大小操作：</strong><ul>
<li><code>empty()</code>: 判断链表是否为空。</li>
</ul>
</li>
<li><strong>其他操作：</strong><ul>
<li><code>remove()</code>: 移除链表中所有与给定值相等的元素。</li>
<li><code>reverse()</code>: 反转链表</li>
</ul>
</li>
</ul>
<p>由于技术问题，可能导致消息不完整。让我知道您是否需要更多关于 <code>&lt;forward_list&gt;</code> 的信息或者其他方面的帮助。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <forward_list>标准库 详解</h2><p><code>&lt;forward_list&gt;</code> 是 C++ 标准库中的头文件，定义了单向链表的模板类 <code>std::forward_list</code>。与 <code>std::list</code> 不同，<code>std::forward_list</code> 是单向链表，每个元素只保留指向下一个元素的指针。</p>
<h3 id="std-forward-list-概述：-1"><a href="#std-forward-list-概述：-1" class="headerlink" title="std::forward_list 概述："></a>std::forward_list 概述：</h3><ul>
<li><strong>头文件：</strong> <code>&lt;forward_list&gt;</code></li>
<li><strong>容器类型：</strong> <code>std::forward_list</code> 是标准库中的容器类型之一，实现了单向链表。</li>
<li><strong>特点：</strong><ul>
<li>每个元素只保留指向下一个元素的指针，只能从前往后遍历。</li>
<li>支持高效的插入和删除操作，但对于随机访问效率较低。</li>
<li>没有 <code>size()</code> 函数，需要手动计算元素数量。</li>
</ul>
</li>
</ul>
<h3 id="主要操作和用法：-1"><a href="#主要操作和用法：-1" class="headerlink" title="主要操作和用法："></a>主要操作和用法：</h3><ul>
<li><strong>插入和删除操作：</strong><ul>
<li><code>push_front()</code>, <code>pop_front()</code>: 在链表头部插入或删除元素。</li>
<li><code>insert_after()</code>, <code>erase_after()</code>: 在指定位置后插入或删除元素。</li>
</ul>
</li>
<li><strong>迭代器操作：</strong><ul>
<li><code>before_begin()</code>, <code>begin()</code>, <code>end()</code>: 获取链表迭代器。</li>
</ul>
</li>
<li><strong>大小操作：</strong><ul>
<li><code>empty()</code>: 判断链表是否为空。</li>
</ul>
</li>
<li><strong>其他操作：</strong><ul>
<li><code>remove()</code>: 移除链表中所有与给定值相等的元素。</li>
<li><code>reverse()</code>: 反转链表。</li>
</ul>
</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; myList = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">push_front</span>(<span class="number">0</span>); <span class="comment">// 在链表头部插入元素</span></span><br><span class="line">    myList.<span class="built_in">pop_front</span>(); <span class="comment">// 删除链表头部的元素</span></span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">insert_after</span>(myList.<span class="built_in">begin</span>(), <span class="number">4</span>); <span class="comment">// 在第一个元素后插入元素</span></span><br><span class="line">    myList.<span class="built_in">erase_after</span>(myList.<span class="built_in">begin</span>()); <span class="comment">// 删除第一个元素后的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">remove</span>(<span class="number">2</span>); <span class="comment">// 移除所有值为 2 的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">reverse</span>(); <span class="comment">// 反转链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::forward_list</code> 提供了一系列方法来操作单向链表，这些方法包括在链表头尾插入或删除元素、访问元素、迭代器操作、大小操作、移除指定元素和反转链表。通过这些函数，可以方便地对链表进行操作和管理。</p>
<h2 id="std-forward-list-reverse"><a href="#std-forward-list-reverse" class="headerlink" title="std::forward_list::reverse()"></a>std::forward_list::reverse()</h2><p>在 C++ 中，<code>std::forward_list::reverse()</code> 是 <code>std::forward_list</code> 类提供的成员函数之一，用于颠倒（反转）单向链表中元素的顺序。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数作用："><a href="#函数作用：" class="headerlink" title="函数作用："></a>函数作用：</h3><ul>
<li><code>reverse()</code> 函数将单向链表中的元素顺序颠倒，即将链表元素的顺序反转。</li>
</ul>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>std::forward_list</code> 是单向链表，它只能从前往后遍历。因此，颠倒链表元素的唯一方法就是重新排列链表中元素的指针，以颠倒其顺序。</li>
<li>由于单向链表只能从前往后遍历，因此颠倒链表需要遍历整个链表，时间复杂度为 O(n)。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; myList = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original forward_list: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    myList.<span class="built_in">reverse</span>(); <span class="comment">// 反转单向链表中的元素顺序</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reversed forward_list: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>myList.reverse()</code> 将 <code>myList</code> 单向链表中的元素顺序颠倒。最终输出将展示原始链表和反转后的链表的元素顺序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/21/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/page/23/">23</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/23/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
