<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/11/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/05/notebook/Compiler/2024-08-05-ld_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/05/notebook/Compiler/2024-08-05-ld_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">ld_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-05 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-05T09:00:00+08:00">2024-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Compiler/" itemprop="url" rel="index"><span itemprop="name">Compiler</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ld链接器相关理论基础</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/08/05/notebook/Compiler/2024-08-05-ld_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/04/notebook/Tools/2024-08-04-%E6%B5%81%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/04/notebook/Tools/2024-08-04-%E6%B5%81%E5%AA%92%E4%BD%93%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">流媒体技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-04 11:00:00" itemprop="dateCreated datePublished" datetime="2024-08-04T11:00:00+08:00">2024-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>流媒体相关笔记</li>
</ul>
<h2 id="ZLMediaKit-关于流媒体的知识点"><a href="#ZLMediaKit-关于流媒体的知识点" class="headerlink" title="ZLMediaKit 关于流媒体的知识点"></a>ZLMediaKit 关于流媒体的知识点</h2><h3 id="流媒体简介"><a href="#流媒体简介" class="headerlink" title="流媒体简介"></a>流媒体简介</h3><ul>
<li>流媒体(streaming media)是指将一连串的媒体数据压缩后，经过网络分段发送数据，在网上即时传输影音以供观赏的一种技术与过程，此技术使得数据包得以像流水一样发送；如果不使用此技术，就必须在使用前下载整个媒体文件，这种对于实时性要求比较高的场景而言，显然是不现实的，所以流媒体技术为此孕育而生。</li>
<li>传统的视频监控，IPTV，以及这几年兴起的视频直播，网络授课都属于流媒体的范畴，从广义上来讲，视频通话，视频会议也属于流媒体。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/08/01/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-08-01-%E4%B8%B4%E6%97%B6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/01/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-08-01-%E4%B8%B4%E6%97%B6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">临时笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-01 09:00:00" itemprop="dateCreated datePublished" datetime="2024-08-01T09:00:00+08:00">2024-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Personal/" itemprop="url" rel="index"><span itemprop="name">Personal</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="MFC-WTL-ATL-STL联系与区别"><a href="#MFC-WTL-ATL-STL联系与区别" class="headerlink" title="MFC,WTL,ATL,STL联系与区别"></a>MFC,WTL,ATL,STL联系与区别</h2><ul>
<li>C++是一门语言，它与平台无关。只要能提供C++编译器(或者交叉编译器)的平台，就能使用C++变成。基本上常见的操作系统都有C++编译器或者交叉编译器。</li>
<li>VC++，不是语言，而是一个工具软件。他甚至不是编译器，而是一个开发环境(VC++的编译器实际上只是一个可执行文件cl.exe)，用这个环境能帮你用C++快速的开发出各种win32的程序。</li>
<li>C++具有语言标准，这个标准由ISO批准的。所谓标准就是任何C++编译器都应该遵守的，包括cl.exe。所以，学好标准的C++就能再任何平台上开发。但是各个编译器除了支持标准外，还在不与标准冲突的范围内进行了语法扩充，当然是为了能够更高效方便的开发程序。</li>
<li>只有语言能做的事情非常少，在操作系统上跑需要各种现有的程序的支持，这些支持通常以库的形式表现出来。例如C标准库，C++标准库。这两个是标准的。非标准的就像所说的MFC之类的。</li>
<li>下面比较这几个库</li>
</ul>
<h3 id="STL-标准模板库"><a href="#STL-标准模板库" class="headerlink" title="STL(标准模板库)"></a>STL(标准模板库)</h3><ul>
<li>STL的代码从广义上讲分为三类：algorithm(算法)，container(容器)和iterator(迭代器)</li>
</ul>
<h3 id="ATL-活动模板库"><a href="#ATL-活动模板库" class="headerlink" title="ATL(活动模板库)"></a>ATL(活动模板库)</h3><ul>
<li>ATL，ActiveX Template Library. 是一个产生C++&#x2F;COM代码的框架，就如同C语言是产生一个汇编代码的框架。ATL又不同于MFC，它完全面向COM组件，其技术路线也不同于MFC。</li>
<li>MFC使用的是C++中的继承，封装，嵌套等常规技术，而ATL使用了C++中模板，多继承等高级技术，甚至还用到了STL</li>
<li>COM component(COM组件)，是微软公司为了计算机工业的软件生产更加符合人类的行为方式开发的一种新的软件开发技术。在COM构架下，人们可以开发出各种各样的功能专一的组件，然后将他们按照需要组合起来，以便随时进行系统的升级和定制；可以在多个应用系统中重复利用同一个组件；可以方便的将应用系统扩展到网络环境下</li>
</ul>
<h3 id="WTL-Windows-Template-Library"><a href="#WTL-Windows-Template-Library" class="headerlink" title="WTL(Windows Template Library)"></a>WTL(Windows Template Library)</h3><ul>
<li>WTL，构架于ATL之上，采用C++模板技术来包装大部分窗口控制，并给出一个与MFC相似的应用框架。</li>
</ul>
<h3 id="MFC"><a href="#MFC" class="headerlink" title="MFC"></a>MFC</h3><ul>
<li>MFC，Microsoft Foundation Classes. 实际上是微软提供的，用于在C++环境下编写应用程序的一个框架和引擎。</li>
<li>VC++是Windows下开发人员使用的专业C++ SDK(SDK, Standard SoftWare Develop Kit,专业软件开发平台)，MFC就是挂在它之上的一个辅助软件开发包。</li>
<li><strong>注意C++与VC++的区别</strong>：<ul>
<li>C++是一种程序设计语言，是一种大家都承认的软件编制的通用规范</li>
<li>VC++只是一个编译器，或者说是一中编译器＋源程序编辑器的IDE</li>
</ul>
</li>
<li>MFC是Win API与C++的结合。API，即微软提供的Windows下应用程序的编程接口，是一种软件编程的规范，但不是一种程序开发语言本身，可以允许用户使用各种各样的第三方的编程语言对Windows下应用程序的开发，是这些被开发出来的应用程序能在Windows下运行，比如VB，VC++，Java，Delphi。</li>
<li>编程语言函数本质上全部源于API，因此用他们开发出来的应用程序都能工作在Windows的消息机制和绘图里，遵循Windows作为一个操作系统的内部实现，这其实也是一种必要。微软如果不提供API，这个世界上对Windows编程的工作就不会存在，微软的产品就会迅速从时尚变为垃圾。</li>
<li>上面说到MFC是微软对API函数的专用C++封装，这种结合一方面让用户使用微软的专业C++ SDK来进行Windows下应用程序的开发变得很容易，因为MFC是对API的封装，微软做了大量的工作，隐藏了好多程序开发人员在Windows下用C++ &amp; MFC编制软件时的大量细节，例如应用程序实现消息的处理，设备环境绘图，这种结合是以方便为目的的，必定要付出一定代价，因此就造成了MFC对类封装中的一定程度的冗余。</li>
<li>最后要明白MFC不只是一个功能单纯的界面开发系统，它提供的类绝大部分用来进行界面开发，关联一个窗口的侗族，但它提供的类中也有好多类不与一个窗口关联，即类的作用不是一个界面类，不实现一个窗口对象的控制，而是一些在Windows中实现内部处理的类，例如数据库的管理类等。学习中最应该花费时间的是消息和设备环境，对C++和MFC的学习中最难的部分是指针，C++面向对象程序设计的其他部分，例如数据类型，流程控制都不难。</li>
</ul>
<h2 id="C-类的成员变量是在堆区还是在栈区"><a href="#C-类的成员变量是在堆区还是在栈区" class="headerlink" title="C++类的成员变量是在堆区还是在栈区"></a>C++类的成员变量是在堆区还是在栈区</h2><h3 id="C-内存分配基础"><a href="#C-内存分配基础" class="headerlink" title="C++内存分配基础"></a>C++内存分配基础</h3><ul>
<li>在理解C++类的成员变量存储位置之前，我们先要了解C++中的几种主要内存区域<ul>
<li>栈区(Stack): 栈区内存由编译器自动分配和释放，存储函数的局部变量，参数等。栈区内存具有生命周期短，分配效率高的特点</li>
<li>堆区(Heap): 堆区内存由程序员手动分配和释放(使用new和delete)。堆区内存的生命周期由程序员控制，适合存储需要长时间存在的数据</li>
<li>静态存储区(Static Storage): 该区域存储静态数据成员和全局变量，内存分配在程序开始时进行，直到程序结束时才释放</li>
<li>代码区和常量区: 存储程序代码和常量数据</li>
</ul>
</li>
</ul>
<h3 id="类的成员变量存储位置"><a href="#类的成员变量存储位置" class="headerlink" title="类的成员变量存储位置"></a>类的成员变量存储位置</h3><ul>
<li>类的成员变量的存储位置取决于类的实例(对象)如何创建。主要有以下几种情况</li>
</ul>
<ol>
<li><p>栈上分配的对象</p>
<ul>
<li>当一个对象在栈上分配时，成员变量也存储在栈上</li>
</ul>
</li>
<li><p>堆上分配的对象</p>
<ul>
<li>当使用new关键字动态分配一个对象时，对象和其成员变量会存储在堆上。</li>
</ul>
</li>
<li><p>静态存储区的对象</p>
<ul>
<li>如果一个对象是全局变量或静态变量，那么它会被分配在静态存储区。</li>
<li>这些对象的内存在程序开始时分配，并且在程序运行期间一直存在，直到程序结束时才会释放。因此，静态对象和全局对象的成员变量存储在静态存储区中。</li>
</ul>
</li>
</ol>
<h2 id="C-BEGIN-DECLS-是什么"><a href="#C-BEGIN-DECLS-是什么" class="headerlink" title="C __BEGIN_DECLS 是什么"></a>C __BEGIN_DECLS 是什么</h2><p><code>__BEGIN_DECLS</code> 和 <code>__END_DECLS</code> 是在C语言和C++代码混合时使用的宏。它们用于确保 C 头文件在被 C++ 编译器编译时能够正确处理 C 函数原型。</p>
<p>当在 C++ 环境中包含 C 头文件时，需要用 <code>extern &quot;C&quot;</code> 来告诉 C++ 编译器这些声明是 C 语言的，以便正确处理名字修饰（name mangling）。<code>__BEGIN_DECLS</code> 和 <code>__END_DECLS</code> 宏正是为了简化这一过程而设计的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __BEGIN_DECLS extern <span class="string">&quot;C&quot;</span> &#123;</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __END_DECLS &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __BEGIN_DECLS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __END_DECLS</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这段代码的含义是：</p>
<ul>
<li>如果编译器是 C++ 编译器 (<code>__cplusplus</code> 被定义)，则 <code>__BEGIN_DECLS</code> 被定义为 <code>extern &quot;C&quot; &#123;</code>，<code>__END_DECLS</code> 被定义为 <code>&#125;</code>。</li>
<li>如果编译器是 C 编译器，则这两个宏都定义为空。</li>
</ul>
<p>使用这些宏可以这样写一个头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_HEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_HEADER_H</span></span><br><span class="line"></span><br><span class="line">__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_function</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">__END_DECLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MY_HEADER_H</span></span></span><br></pre></td></tr></table></figure>

<p>当这个头文件在 C++ 代码中被包含时，<code>my_function</code> 的声明会被包含在 <code>extern &quot;C&quot;</code> 块中，从而避免了 C++ 名字修饰问题。在 C 代码中，宏会被定义为空，所以对代码没有影响。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/30/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-07-30-C++%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/30/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-07-30-C++%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">C++共享内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-30 09:00:00" itemprop="dateCreated datePublished" datetime="2024-07-30T09:00:00+08:00">2024-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Personal/" itemprop="url" rel="index"><span itemprop="name">Personal</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Linux系统下进程键通讯方式之共享内存，相关笔记</li>
</ul>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><ul>
<li>共享内存(shared memory)指在多处理器的计算机系统中，可以被不同中央处理器访问的大容量内存。由于多个CPU需要快速访问存储器，这样就要对存储器进行缓存。由于其他处理器可能也要访问，任一缓存数据更新后，共享内存就需要立即更新，否则不同处理器可能用到不同的数据。</li>
<li>共享内存的类似方案有分布内存，分布共享内存，用以解决同类问题。</li>
<li>共享内存区是可用IPC形式中最快的。一旦这样的内存区映射到共享它的进程的地址空间，这些进程间数据的传递就不再涉及内核。然而往该共享内存区存放消息或从中取走消息的进程间通常需要某种形式的同步。我们在第三部分讨论了各种形式的同步：互斥锁，条件变量，读写锁，记录锁，信号量。</li>
<li>这里说的： 不再涉及内核的含义是: 进程不再通过执行任何进入内核的系统调用来彼此传递数据。显然，内核必须建立允许各个进程共享该内存区的内存映射关系，然后一直管理该内存区。</li>
</ul>
<h2 id="相关的方法"><a href="#相关的方法" class="headerlink" title="相关的方法"></a>相关的方法</h2><ul>
<li>&lt;sys&#x2F;mman.h&gt;头文件<ul>
<li>mmap()函数</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/23/notebook/Tools/2024-07-23-%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/23/notebook/Tools/2024-07-23-%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">视频教程笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-23 11:00:00" itemprop="dateCreated datePublished" datetime="2024-07-23T11:00:00+08:00">2024-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>录制视频教程，std::vector相关笔记</li>
</ul>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul>
<li><p>看一下笔记，按照笔记复习。</p>
</li>
<li><p>小结</p>
<ul>
<li>std::vector 动态数组，动态增长的原理 1.5(2)倍增长，增长的流程，大概说一下。</li>
<li>size() 和 capacity() 的区别，</li>
<li>push_back 和 emplace_back() 的区别</li>
<li>支持随机访问，常量时间复杂度，</li>
<li>插入，删除操作是跟数据大小有关。</li>
<li>下一个视频，复习一下 std::vector , std::list, std::deque, 主要是 std::vector 和 std::list的区别</li>
</ul>
</li>
</ul>
<h2 id="list-array-deque-vector"><a href="#list-array-deque-vector" class="headerlink" title="list, array, deque, vector"></a>list, array, deque, vector</h2><ul>
<li><p>list 相关的笔记</p>
</li>
<li><p>小结</p>
<ul>
<li>list 不能提供随机访问，也不能提供指针运算，只能通过 ++p 或 –p 来遍历list</li>
<li>充分利用插入和删除常量时间复杂度的特性，两个list的合并 merge() , 或者是一个 list 的splice()</li>
<li>array 固定大小，在栈上分配内存，vector则是访问自由存储区，相对来说，效率会更高一些，</li>
<li>缺点 swap() array是线性时间复杂度，vector是常量时间复杂度，</li>
<li>与C风格的数组比较，优点就是封装了一些常用的方法，例如size(), empty()</li>
<li>deque</li>
</ul>
</li>
<li><p>下一步</p>
<ul>
<li>关联式容器: map, set, pair,  multimap, multiset</li>
<li>无序式关联容器： unordered_map, unordered_set,</li>
<li>堆栈的一些概念，内存模型，类，虚函数表，this指针，成员函数的地址，怎么调用成员函数的。</li>
</ul>
</li>
</ul>
<h2 id="map-set"><a href="#map-set" class="headerlink" title="map, set"></a>map, set</h2><ul>
<li><p>容器，分为序列容器和关联容器</p>
<ul>
<li>序列容器: vector, array, list, deque</li>
<li>关联容器<ul>
<li>有序关联容器: map, set, multimap, multiset</li>
<li>无序关联容器: unordered_map, unordered_set, unordered_multimap, unordered_multiset</li>
</ul>
</li>
</ul>
</li>
<li><p>小结</p>
<ul>
<li>。。。</li>
</ul>
</li>
<li><p>下一步</p>
<ul>
<li>cuda， cudnn， tensorrt</li>
<li>深拷贝，<ul>
<li>memcpy,strcpy,strlen()<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li>排序<ul>
<li>std::sort() lambda() </li>
<li>algorithm<ul>
<li>std::sort</li>
<li>std::merge</li>
<li>std::find_if</li>
<li>std::for_each</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>cuda<ul>
<li>NVIDIA,</li>
<li>异构</li>
</ul>
</li>
<li>C++ 内存模型，堆栈一些概念</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/20/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-07-20-C++STL%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/20/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-07-20-C++STL%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">C++ STL教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-20 09:00:00" itemprop="dateCreated datePublished" datetime="2024-07-20T09:00:00+08:00">2024-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>C++ 标准模板库(Standard Template Library, STL)是一套功能强大的C++模板类和函数的集合，它提供了一系列通用的，可复用的算法和数据结构。</p>
</li>
<li><p>STL的设计基于泛型编程，这意味着使用模板可以编写出独立于任何特定数据类型的代码。</p>
</li>
<li><p>STL分为多个组件，包括容器(Containers)，迭代器(Iterators)，算法(Algorithms)，函数对象(Function Objects)和适配器(Adapters)等</p>
</li>
<li><p>使用STL的好处</p>
<ul>
<li>代码复用: STL提供了大量通用数据和算法，可以减少重复编写代码的工作</li>
<li>性能优化: STL中的算法和数据结构都经过了优化，以提供最佳的性能</li>
<li>泛型编程: 使用模板，STL支持泛型编程，使得算法和数据结构可以适用于任何数据类型</li>
<li>易于维护: STL的设计使得代码更加模板化，易于阅读和维护</li>
</ul>
</li>
<li><p>C++标准模板库的核心包括以下重要组件</p>
<ul>
<li>容器(Containers): 容器是STL中最基本的组件之一，提供了各种数据结构，包括向量(vector)，链表(list)，队列(queue)，栈(stack)，集合(set)，映射(map)等。这些容器具有不同的特性和用途，可以根据实际需求选择合适的容器</li>
<li>算法(Algorithms): STL提供了大量的算法，用于对容器中的元素进行各种操作，包括排序，搜索，复制，移动，变换等。这些算法在使用时不需要关心容器的具体类型，只需要指定要操作的范围即可。</li>
<li>迭代器(iterators): 迭代器用于遍历容器中的元素，允许以统一的方式访问容器中的元素，而不用关心容器的内部实现细节。STL提供了多种类型的迭代器，包括随机访问迭代器，双向迭代器，前向迭代器和输入输出迭代器等</li>
<li>函数对象(Function Objects): 函数对象是可以像函数一样调用的对象，可以用于算法中的各种操作。STL提供了多种函数对象，包括一元函数对象 ，二元函数对象，谓词等，可以满足不同的需求</li>
<li>适配器(Adapters): 适配器用于将一种容器或迭代器适配成另一种容器或迭代器，以满足特定的需求。STL提供了多种适配器，包括栈适配器(stack adapter)，队列适配器(queue adapter)和优先队列适配器(priority queue adapter)等。</li>
</ul>
</li>
<li><p>Containers are used to store the data</p>
</li>
<li><p>Algorithms are used to process the data</p>
</li>
<li><p>Functors are used to write custom algorithms</p>
</li>
<li><p>Iterators are used to navigate through the data</p>
</li>
<li><p>All of them are part of STL</p>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/07/20/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-07-20-C++STL%E6%95%99%E7%A8%8B/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/18/notebook/OpenCV/opencv_2_%E5%B8%B8%E7%94%A8%E7%B1%BB/2024-07-18_VideoWriter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/18/notebook/OpenCV/opencv_2_%E5%B8%B8%E7%94%A8%E7%B1%BB/2024-07-18_VideoWriter/" class="post-title-link" itemprop="url">VideoWrite</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-18 09:00:00" itemprop="dateCreated datePublished" datetime="2024-07-18T09:00:00+08:00">2024-07-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenCV/" itemprop="url" rel="index"><span itemprop="name">OpenCV</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>cv::VideoWrite类相关笔记</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/07/18/notebook/OpenCV/opencv_2_%E5%B8%B8%E7%94%A8%E7%B1%BB/2024-07-18_VideoWriter/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/17/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-07-17-linux_2_97_strace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/17/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-07-17-linux_2_97_strace/" class="post-title-link" itemprop="url">linux_2_96_strace</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-17 09:00:00" itemprop="dateCreated datePublished" datetime="2024-07-17T09:00:00+08:00">2024-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>strace命令相关笔记</li>
</ul>
<h2 id="linux-strace命令是什么"><a href="#linux-strace命令是什么" class="headerlink" title="linux strace命令是什么"></a>linux strace命令是什么</h2><p><code>strace</code> 是 Linux 下的一个用于诊断和调试程序的命令，它可以跟踪系统调用和接收的信号。<code>strace</code> 工具允许你查看一个进程执行期间所有的系统调用和它们的返回值，这对理解程序的行为和调试问题非常有帮助。</p>
<p>以下是 <code>strace</code> 的一些常见用法：</p>
<ol>
<li><p><strong>跟踪一个程序的系统调用</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -o output.txt program_name</span><br></pre></td></tr></table></figure>
<p>这会启动 <code>program_name</code> 并将所有的系统调用记录到 <code>output.txt</code> 文件中。</p>
</li>
<li><p><strong>跟踪一个已经在运行的进程</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -p pid</span><br></pre></td></tr></table></figure>
<p>其中 <code>pid</code> 是进程的 ID。这会附加到已经运行的进程并开始跟踪它的系统调用。</p>
</li>
<li><p><strong>只跟踪特定类型的系统调用</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -e trace=open,<span class="built_in">read</span>,write program_name</span><br></pre></td></tr></table></figure>
<p>这将只跟踪 <code>open</code>、<code>read</code> 和 <code>write</code> 系统调用。</p>
</li>
<li><p><strong>打印每个系统调用所花费的时间</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -T program_name</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>跟踪系统调用和信号</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -c program_name</span><br></pre></td></tr></table></figure>
<p>这会总结系统调用的次数、出错次数和执行时间。</p>
</li>
</ol>
<p>示例：使用 <code>strace</code> 跟踪 <code>ls</code> 命令的系统调用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>这个命令会在终端中打印出 <code>ls</code> 命令执行期间所有的系统调用和它们的返回值。</p>
<p><code>strace</code> 是一个非常强大的工具，特别是在调试程序、分析系统性能和排查系统问题时非常有用。</p>
<h2 id="linux-strace命令-详解"><a href="#linux-strace命令-详解" class="headerlink" title="linux strace命令 详解"></a>linux strace命令 详解</h2><p><code>strace</code> 是一个强大的 Linux 工具，用于诊断和调试程序。它能够跟踪系统调用（syscalls）和信号（signals），从而帮助用户了解程序的行为、查找问题根源、调试错误等。以下是 <code>strace</code> 的详细使用说明和示例。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="跟踪一个程序的系统调用"><a href="#跟踪一个程序的系统调用" class="headerlink" title="跟踪一个程序的系统调用"></a>跟踪一个程序的系统调用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace program_name</span><br></pre></td></tr></table></figure>

<p>这会启动 <code>program_name</code> 并在终端上显示其所有系统调用。</p>
<h4 id="将输出重定向到文件"><a href="#将输出重定向到文件" class="headerlink" title="将输出重定向到文件"></a>将输出重定向到文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -o output.txt program_name</span><br></pre></td></tr></table></figure>

<p>将系统调用输出记录到 <code>output.txt</code> 文件中。</p>
<h4 id="跟踪已经运行的进程"><a href="#跟踪已经运行的进程" class="headerlink" title="跟踪已经运行的进程"></a>跟踪已经运行的进程</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -p pid</span><br></pre></td></tr></table></figure>

<p>其中 <code>pid</code> 是进程的 ID。这会附加到已经运行的进程并开始跟踪它的系统调用。</p>
<h3 id="过滤系统调用"><a href="#过滤系统调用" class="headerlink" title="过滤系统调用"></a>过滤系统调用</h3><h4 id="只跟踪特定类型的系统调用"><a href="#只跟踪特定类型的系统调用" class="headerlink" title="只跟踪特定类型的系统调用"></a>只跟踪特定类型的系统调用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -e trace=open,<span class="built_in">read</span>,write program_name</span><br></pre></td></tr></table></figure>

<p>这将只跟踪 <code>open</code>、<code>read</code> 和 <code>write</code> 系统调用。</p>
<h4 id="跟踪所有文件相关的系统调用"><a href="#跟踪所有文件相关的系统调用" class="headerlink" title="跟踪所有文件相关的系统调用"></a>跟踪所有文件相关的系统调用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -e trace=file program_name</span><br></pre></td></tr></table></figure>

<p>这会跟踪所有与文件操作相关的系统调用，例如 <code>open</code>、<code>read</code>、<code>write</code> 等。</p>
<h4 id="跟踪所有网络相关的系统调用"><a href="#跟踪所有网络相关的系统调用" class="headerlink" title="跟踪所有网络相关的系统调用"></a>跟踪所有网络相关的系统调用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -e trace=network program_name</span><br></pre></td></tr></table></figure>

<p>这会跟踪所有与网络操作相关的系统调用，例如 <code>socket</code>、<code>connect</code>、<code>send</code>、<code>recv</code> 等。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><h4 id="打印每个系统调用所花费的时间"><a href="#打印每个系统调用所花费的时间" class="headerlink" title="打印每个系统调用所花费的时间"></a>打印每个系统调用所花费的时间</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -T program_name</span><br></pre></td></tr></table></figure>

<p>在输出中包含每个系统调用所花费的时间。</p>
<h4 id="打印时间戳"><a href="#打印时间戳" class="headerlink" title="打印时间戳"></a>打印时间戳</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -t program_name</span><br></pre></td></tr></table></figure>

<p>在每个系统调用前面加上时间戳。</p>
<h4 id="显示相对时间戳"><a href="#显示相对时间戳" class="headerlink" title="显示相对时间戳"></a>显示相对时间戳</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -r program_name</span><br></pre></td></tr></table></figure>

<p>在每个系统调用前面显示相对于前一个系统调用的时间间隔。</p>
<h3 id="统计信息"><a href="#统计信息" class="headerlink" title="统计信息"></a>统计信息</h3><h4 id="汇总系统调用的次数、出错次数和执行时间"><a href="#汇总系统调用的次数、出错次数和执行时间" class="headerlink" title="汇总系统调用的次数、出错次数和执行时间"></a>汇总系统调用的次数、出错次数和执行时间</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -c program_name</span><br></pre></td></tr></table></figure>

<p>程序执行完毕后，输出汇总统计信息。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="跟踪-ls-命令的系统调用"><a href="#跟踪-ls-命令的系统调用" class="headerlink" title="跟踪 ls 命令的系统调用"></a>跟踪 <code>ls</code> 命令的系统调用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;/bin/ls&quot;, [&quot;ls&quot;], 0x7ffccf5a8c38 /* 20 vars */) = 0</span><br><span class="line">brk(NULL)                               = 0x56325f1ff000</span><br><span class="line">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fbb6141f000</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="跟踪一个已经运行的进程"><a href="#跟踪一个已经运行的进程" class="headerlink" title="跟踪一个已经运行的进程"></a>跟踪一个已经运行的进程</h4><p>假设进程 ID 为 1234：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -p 1234</span><br></pre></td></tr></table></figure>

<h4 id="只跟踪-open-和-read-系统调用"><a href="#只跟踪-open-和-read-系统调用" class="headerlink" title="只跟踪 open 和 read 系统调用"></a>只跟踪 <code>open</code> 和 <code>read</code> 系统调用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -e trace=open,<span class="built_in">read</span> <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<h3 id="常见系统调用解释"><a href="#常见系统调用解释" class="headerlink" title="常见系统调用解释"></a>常见系统调用解释</h3><ul>
<li><code>execve</code>: 执行程序。</li>
<li><code>open</code>: 打开文件。</li>
<li><code>read</code>: 读取文件。</li>
<li><code>write</code>: 写入文件。</li>
<li><code>close</code>: 关闭文件描述符。</li>
<li><code>brk</code>: 调整数据段末尾位置，用于内存分配。</li>
<li><code>mmap</code>: 内存映射，用于文件或设备的内存访问。</li>
</ul>
<p><code>strace</code> 是一个非常强大的工具，特别是在调试程序、分析系统性能和排查系统问题时非常有用。它的输出可以帮助开发者理解程序的行为，找出问题的根源并进行优化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/16/notebook/Tools/2024-07-16-Zabbix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/16/notebook/Tools/2024-07-16-Zabbix/" class="post-title-link" itemprop="url">Zabbix</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-16 11:00:00" itemprop="dateCreated datePublished" datetime="2024-07-16T11:00:00+08:00">2024-07-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>zabbix工具相关笔记</li>
</ul>
<h2 id="Zabbix是什么"><a href="#Zabbix是什么" class="headerlink" title="Zabbix是什么"></a>Zabbix是什么</h2><p>Zabbix 是一个开源的企业级监控解决方案，旨在监控和跟踪 IT 基础设施的健康和性能。它提供了多种功能来帮助管理员监控网络、服务器、应用程序、云服务等。以下是 Zabbix 的一些主要特点：</p>
<ol>
<li><p><strong>全面的监控</strong>：Zabbix 能够监控各种类型的网络设备、服务器、虚拟机、云服务和应用程序。它支持多种协议，如 SNMP、IPMI、JMX、HTTP、SSH、Telnet 等。</p>
</li>
<li><p><strong>数据收集和分析</strong>：Zabbix 可以收集大量的性能和可用性数据，并对这些数据进行存储和分析。它提供了强大的数据可视化工具，如图表、仪表盘和报告。</p>
</li>
<li><p><strong>告警和通知</strong>：Zabbix 支持复杂的告警机制，可以根据预定义的条件触发告警，并通过多种渠道（如邮件、短信、Slack、Telegram 等）发送通知。</p>
</li>
<li><p><strong>自动化和自愈</strong>：Zabbix 提供了自动化功能，可以在检测到问题时自动执行预定义的操作，如重启服务或执行脚本，以实现自愈。</p>
</li>
<li><p><strong>高扩展性</strong>：Zabbix 设计为高扩展性，可以支持从小型环境到大型企业环境的监控需求。它支持分布式监控和代理模式，能够轻松扩展。</p>
</li>
<li><p><strong>开源和社区支持</strong>：Zabbix 是开源软件，拥有活跃的社区和广泛的用户基础。社区提供了大量的插件、模板和文档，帮助用户快速上手和扩展功能。</p>
</li>
</ol>
<p>Zabbix 的灵活性和强大的功能使其成为许多企业和组织选择的监控解决方案。无论是用于监控网络设备、服务器性能，还是应用程序健康，Zabbix 都能提供可靠的支持。</p>
<h2 id="zabbix-详解"><a href="#zabbix-详解" class="headerlink" title="zabbix 详解"></a>zabbix 详解</h2><h3 id="什么是-Zabbix？"><a href="#什么是-Zabbix？" class="headerlink" title="什么是 Zabbix？"></a>什么是 Zabbix？</h3><p>Zabbix 是一个开源的监控软件工具，旨在监控和跟踪 IT 基础设施、网络、服务器、虚拟机、应用程序和云服务的健康状况和性能。它提供了一整套功能，从数据收集、存储、分析到告警和自动化操作。由于其高扩展性和灵活性，Zabbix 可以满足从小型组织到大型企业的不同需求。</p>
<h3 id="主要功能和特点"><a href="#主要功能和特点" class="headerlink" title="主要功能和特点"></a>主要功能和特点</h3><h4 id="1-数据收集和监控"><a href="#1-数据收集和监控" class="headerlink" title="1. 数据收集和监控"></a>1. <strong>数据收集和监控</strong></h4><ul>
<li><strong>广泛的支持</strong>：支持多种协议和技术，如 SNMP、IPMI、JMX、HTTP、SSH、Telnet 等，可以监控各种设备和应用程序。</li>
<li><strong>主动监控</strong>：通过代理（Agent）和代理代理（Proxy）模式，支持分布式监控，能够在网络的不同部分进行监控。</li>
<li><strong>被动监控</strong>：支持从设备和应用程序中获取数据，适用于需要从设备中获取状态和性能信息的场景。</li>
</ul>
<h4 id="2-数据存储和处理"><a href="#2-数据存储和处理" class="headerlink" title="2. 数据存储和处理"></a>2. <strong>数据存储和处理</strong></h4><ul>
<li><strong>历史数据存储</strong>：Zabbix 可以存储大量的历史数据，支持长期的数据保留和分析。</li>
<li><strong>灵活的数据处理</strong>：通过自定义的触发器和阈值，能够对监控数据进行实时处理和分析。</li>
</ul>
<h4 id="3-告警和通知"><a href="#3-告警和通知" class="headerlink" title="3. 告警和通知"></a>3. <strong>告警和通知</strong></h4><ul>
<li><strong>复杂的告警机制</strong>：支持根据预定义的条件和阈值触发告警，告警可以基于多个条件进行组合和过滤。</li>
<li><strong>多渠道通知</strong>：支持通过邮件、短信、IM（如 Slack、Telegram 等）和脚本发送通知，确保管理员能够及时收到告警信息。</li>
<li><strong>告警升级</strong>：支持告警的升级和降级，确保重要问题能够及时得到关注和处理。</li>
</ul>
<h4 id="4-数据可视化"><a href="#4-数据可视化" class="headerlink" title="4. 数据可视化"></a>4. <strong>数据可视化</strong></h4><ul>
<li><strong>图表和仪表盘</strong>：提供强大的图表和仪表盘功能，能够直观地展示监控数据和趋势。</li>
<li><strong>报告和分析</strong>：支持生成各种报告，帮助管理员了解系统的健康状况和性能。</li>
</ul>
<h4 id="5-自动化和自愈"><a href="#5-自动化和自愈" class="headerlink" title="5. 自动化和自愈"></a>5. <strong>自动化和自愈</strong></h4><ul>
<li><strong>自动操作</strong>：支持在检测到问题时自动执行预定义的操作，如重启服务、执行脚本等。</li>
<li><strong>自愈功能</strong>：通过自动化操作实现系统的自愈，减少人为干预，提高系统的可靠性。</li>
</ul>
<h4 id="6-高扩展性"><a href="#6-高扩展性" class="headerlink" title="6. 高扩展性"></a>6. <strong>高扩展性</strong></h4><ul>
<li><strong>分布式监控</strong>：支持代理和代理代理模式，能够扩展到大规模的分布式环境中进行监控。</li>
<li><strong>高可用性</strong>：通过集群和冗余设计，确保监控系统的高可用性和可靠性。</li>
</ul>
<h4 id="7-开源和社区支持"><a href="#7-开源和社区支持" class="headerlink" title="7. 开源和社区支持"></a>7. <strong>开源和社区支持</strong></h4><ul>
<li><strong>开源许可</strong>：Zabbix 是开源软件，拥有 GPL 许可，用户可以自由使用、修改和分发。</li>
<li><strong>活跃的社区</strong>：拥有庞大且活跃的用户和开发者社区，提供丰富的插件、模板和文档资源，用户可以从社区中获取支持和帮助。</li>
</ul>
<h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><ul>
<li><strong>网络监控</strong>：监控路由器、交换机、防火墙等网络设备的性能和状态。</li>
<li><strong>服务器监控</strong>：监控物理服务器和虚拟机的 CPU、内存、磁盘等资源的使用情况。</li>
<li><strong>应用程序监控</strong>：监控数据库、Web 服务器、邮件服务器等应用程序的性能和健康状况。</li>
<li><strong>云服务监控</strong>：监控 AWS、Azure 等云服务的资源使用情况和性能。</li>
</ul>
<h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><h4 id="1-系统要求"><a href="#1-系统要求" class="headerlink" title="1. 系统要求"></a>1. <strong>系统要求</strong></h4><ul>
<li><strong>操作系统</strong>：支持多种操作系统，如 Linux、Windows 等。</li>
<li><strong>数据库</strong>：需要一个数据库来存储监控数据，支持 MySQL、PostgreSQL、Oracle 等。</li>
<li><strong>Web 服务器</strong>：需要一个 Web 服务器来运行 Zabbix 的前端界面，支持 Apache、Nginx 等。</li>
</ul>
<h4 id="2-安装步骤"><a href="#2-安装步骤" class="headerlink" title="2. 安装步骤"></a>2. <strong>安装步骤</strong></h4><ul>
<li><strong>数据库安装和配置</strong>：安装并配置所需的数据库。</li>
<li><strong>Zabbix 服务器安装</strong>：安装 Zabbix 服务器组件。</li>
<li><strong>Zabbix 前端安装</strong>：安装并配置 Web 服务器和 Zabbix 前端。</li>
<li><strong>Zabbix 代理安装</strong>：在需要监控的设备上安装 Zabbix 代理。</li>
</ul>
<h4 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. <strong>配置</strong></h4><ul>
<li><strong>添加主机和模板</strong>：在 Zabbix 前端界面中添加需要监控的主机，并应用相应的监控模板。</li>
<li><strong>设置触发器和告警</strong>：配置触发器和告警规则，定义告警条件和通知方式。</li>
<li><strong>创建图表和仪表盘</strong>：根据监控需求创建图表和仪表盘，直观展示监控数据。</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Zabbix 是一个功能强大且灵活的监控解决方案，适用于各种 IT 环境。从网络设备和服务器的监控，到应用程序和云服务的监控，Zabbix 都能提供可靠的支持。通过其全面的数据收集、分析、告警和自动化功能，Zabbix 帮助企业提高 IT 基础设施的可见性和可靠性，从而更好地保障业务的连续性和性能。</p>
<h2 id="zabbix-使用-示例"><a href="#zabbix-使用-示例" class="headerlink" title="zabbix 使用 示例"></a>zabbix 使用 示例</h2><p>以下是一个简单的 Zabbix 使用示例，展示如何安装、配置和使用 Zabbix 来监控一台服务器的基本性能指标。</p>
<h3 id="示例环境"><a href="#示例环境" class="headerlink" title="示例环境"></a>示例环境</h3><ul>
<li><strong>Zabbix Server</strong>：Ubuntu 20.04</li>
<li><strong>监控对象</strong>：一台运行 Ubuntu 20.04 的服务器</li>
</ul>
<h3 id="步骤-1：安装-Zabbix-Server"><a href="#步骤-1：安装-Zabbix-Server" class="headerlink" title="步骤 1：安装 Zabbix Server"></a>步骤 1：安装 Zabbix Server</h3><ol>
<li><p><strong>更新系统包</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt upgrade -y</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装 Zabbix 存储库</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.zabbix.com/zabbix/6.0/ubuntu/pool/main/z/zabbix-release/zabbix-release_6.0-2+ubuntu20.04_all.deb</span><br><span class="line"><span class="built_in">sudo</span> dpkg -i zabbix-release_6.0-2+ubuntu20.04_all.deb</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装 Zabbix Server、前端和数据库</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install zabbix-server-mysql zabbix-frontend-php zabbix-apache-conf zabbix-agent</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装并配置 MySQL 数据库</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install mysql-server</span><br><span class="line"><span class="built_in">sudo</span> mysql_secure_installation</span><br></pre></td></tr></table></figure>

<p>进入 MySQL 命令行，创建数据库和用户：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE zabbix <span class="keyword">CHARACTER SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;zabbix&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> zabbix.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;zabbix&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>导入初始架构和数据</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat /usr/share/doc/zabbix-server-mysql*/create.sql.gz | mysql -uzabbix -p zabbix</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置 Zabbix Server 连接到数据库</strong></p>
<p>编辑配置文件 <code>/etc/zabbix/zabbix_server.conf</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DBPassword=password</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动 Zabbix Server 和代理</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart zabbix-server zabbix-agent apache2</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> zabbix-server zabbix-agent apache2</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="步骤-2：安装和配置-Zabbix-Agent-在被监控服务器上"><a href="#步骤-2：安装和配置-Zabbix-Agent-在被监控服务器上" class="headerlink" title="步骤 2：安装和配置 Zabbix Agent 在被监控服务器上"></a>步骤 2：安装和配置 Zabbix Agent 在被监控服务器上</h3><ol>
<li><p><strong>在被监控服务器上安装 Zabbix Agent</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.zabbix.com/zabbix/6.0/ubuntu/pool/main/z/zabbix-release/zabbix-release_6.0-2+ubuntu20.04_all.deb</span><br><span class="line"><span class="built_in">sudo</span> dpkg -i zabbix-release_6.0-2+ubuntu20.04_all.deb</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install zabbix-agent</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置 Zabbix Agent</strong></p>
<p>编辑配置文件 <code>/etc/zabbix/zabbix_agentd.conf</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server=&lt;Zabbix Server IP&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动 Zabbix Agent</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart zabbix-agent</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> zabbix-agent</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="步骤-3：在-Zabbix-前端配置监控"><a href="#步骤-3：在-Zabbix-前端配置监控" class="headerlink" title="步骤 3：在 Zabbix 前端配置监控"></a>步骤 3：在 Zabbix 前端配置监控</h3><ol>
<li><p><strong>访问 Zabbix 前端</strong></p>
<p>在浏览器中访问 <code>http://&lt;Zabbix Server IP&gt;/zabbix</code>，按照提示完成初始设置。</p>
</li>
<li><p><strong>登录 Zabbix 前端</strong></p>
<p>使用默认用户名 <code>Admin</code> 和密码 <code>zabbix</code> 登录。</p>
</li>
<li><p><strong>添加主机</strong></p>
<ul>
<li>导航到 <code>Configuration</code> -&gt; <code>Hosts</code> -&gt; <code>Create host</code>。</li>
<li>填写主机名、组和 IP 地址。</li>
<li>在 <code>Templates</code> 标签中，选择 <code>Template OS Linux</code> 模板。</li>
</ul>
</li>
<li><p><strong>检查监控数据</strong></p>
<ul>
<li>导航到 <code>Monitoring</code> -&gt; <code>Latest data</code>。</li>
<li>选择刚刚添加的主机，查看收集到的监控数据。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上步骤，你已经成功安装并配置了 Zabbix 服务器和代理，并添加了一台被监控的服务器。你可以通过 Zabbix 前端界面查看监控数据，设置告警规则，以及创建图表和仪表盘来直观展示数据。</p>
<p>Zabbix 提供了强大的功能和灵活性，可以监控各种类型的 IT 资源和服务。根据实际需求，你可以进一步定制 Zabbix 的配置和功能，以满足特定的监控需求。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/13/notebook/Video/2024-07-13-%E6%B5%81%E5%AA%92%E4%BD%93%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/13/notebook/Video/2024-07-13-%E6%B5%81%E5%AA%92%E4%BD%93%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">流媒体基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-13 09:00:00" itemprop="dateCreated datePublished" datetime="2024-07-13T09:00:00+08:00">2024-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Video/" itemprop="url" rel="index"><span itemprop="name">Video</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>流媒体相关理论基础笔记</li>
</ul>
<h2 id="推流是什么"><a href="#推流是什么" class="headerlink" title="推流是什么"></a>推流是什么</h2><p>推流（Streaming）是指将音视频内容通过网络实时传输到远程服务器或客户端，使得用户可以在不下载完整文件的情况下进行实时播放。推流技术广泛应用于直播、视频会议、在线教育、远程监控等领域。</p>
<h3 id="推流的基本原理"><a href="#推流的基本原理" class="headerlink" title="推流的基本原理"></a>推流的基本原理</h3><ol>
<li><p><strong>采集</strong>：</p>
<ul>
<li>通过摄像头、麦克风或其他输入设备采集音视频数据。</li>
</ul>
</li>
<li><p><strong>编码</strong>：</p>
<ul>
<li>将采集到的音视频数据压缩编码，以减少数据量。常用的视频编码格式有 H.264、H.265，音频编码格式有 AAC、MP3 等。</li>
</ul>
</li>
<li><p><strong>封装</strong>：</p>
<ul>
<li>将编码后的音视频数据封装成适合传输的流媒体格式，如 FLV、HLS 等。</li>
</ul>
</li>
<li><p><strong>传输</strong>：</p>
<ul>
<li>将封装后的流媒体数据通过网络传输到流媒体服务器。常用的传输协议有 RTMP、HTTP、WebRTC 等。</li>
</ul>
</li>
<li><p><strong>分发和播放</strong>：</p>
<ul>
<li>流媒体服务器接收推流数据后，进行处理和分发。用户端可以通过播放器软件或网页实时接收并播放流媒体内容。</li>
</ul>
</li>
</ol>
<h3 id="常用的推流协议和工具"><a href="#常用的推流协议和工具" class="headerlink" title="常用的推流协议和工具"></a>常用的推流协议和工具</h3><h4 id="推流协议"><a href="#推流协议" class="headerlink" title="推流协议"></a>推流协议</h4><ol>
<li><p><strong>RTMP（Real-Time Messaging Protocol）</strong>：</p>
<ul>
<li>广泛应用于直播推流，尤其是与 Adobe Flash 配合使用。尽管 Flash 技术逐渐被淘汰，但 RTMP 仍然被很多直播平台所支持。</li>
</ul>
</li>
<li><p><strong>HLS（HTTP Live Streaming）</strong>：</p>
<ul>
<li>由苹果公司开发，广泛应用于点播和直播流媒体服务。使用 HTTP 协议进行传输，兼容性好，特别适合在不同设备和网络条件下使用。</li>
</ul>
</li>
<li><p><strong>WebRTC（Web Real-Time Communication）</strong>：</p>
<ul>
<li>支持实时音视频通信，适用于视频通话、视频会议等场景。WebRTC 具有低延迟、点对点通信等优点。</li>
</ul>
</li>
</ol>
<h4 id="推流工具"><a href="#推流工具" class="headerlink" title="推流工具"></a>推流工具</h4><ol>
<li><p><strong>OBS（Open Broadcaster Software）</strong>：</p>
<ul>
<li>免费开源的推流和录屏软件，支持多种推流协议和平台。适合游戏直播、网络直播等场景。</li>
</ul>
</li>
<li><p><strong>FFmpeg</strong>：</p>
<ul>
<li>强大的多媒体处理工具，支持音视频采集、编码、封装和推流。适合高级用户和开发者。</li>
</ul>
</li>
<li><p><strong>Wirecast</strong>：</p>
<ul>
<li>专业的直播推流软件，提供丰富的功能和插件，适用于高质量直播需求。</li>
</ul>
</li>
<li><p><strong>Streamlabs OBS</strong>：</p>
<ul>
<li>基于 OBS 开发的推流工具，集成了更多直播相关的功能和插件，适合游戏直播和网络主播。</li>
</ul>
</li>
</ol>
<h3 id="示例：使用-FFmpeg-推流"><a href="#示例：使用-FFmpeg-推流" class="headerlink" title="示例：使用 FFmpeg 推流"></a>示例：使用 FFmpeg 推流</h3><p>假设你想使用 FFmpeg 将本地视频文件推流到 RTMP 服务器，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i input.mp4 -c:v libx264 -c:a aac -strict experimental -f flv rtmp://example.com/live/stream_key</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>-re</code>：按实时速率读取输入文件。</li>
<li><code>-i input.mp4</code>：指定输入文件。</li>
<li><code>-c:v libx264</code>：使用 H.264 编码器。</li>
<li><code>-c:a aac</code>：使用 AAC 音频编码器。</li>
<li><code>-strict experimental</code>：允许使用实验性 AAC 编码器。</li>
<li><code>-f flv</code>：指定输出格式为 FLV。</li>
<li><code>rtmp://example.com/live/stream_key</code>：RTMP 服务器地址和流密钥。</li>
</ul>
<h3 id="推流应用场景"><a href="#推流应用场景" class="headerlink" title="推流应用场景"></a>推流应用场景</h3><ul>
<li><strong>游戏直播</strong>：通过推流软件将游戏画面和声音实时传输到直播平台，观众可以实时观看游戏过程。</li>
<li><strong>在线教育</strong>：教师通过摄像头和麦克风实时讲解课程内容，学生可以通过网络实时观看和互动。</li>
<li><strong>视频会议</strong>：通过推流技术，多个用户可以实时进行音视频交流，适用于远程办公和在线会议。</li>
<li><strong>远程监控</strong>：通过摄像头实时推流监控画面，用户可以通过网络随时查看监控区域的情况。</li>
</ul>
<p>推流技术为各种实时音视频应用提供了基础支持，使得用户能够在不同设备和网络条件下享受到流畅的实时音视频体验。</p>
<h2 id="拉流-取流是什么"><a href="#拉流-取流是什么" class="headerlink" title="拉流&#x2F;取流是什么"></a>拉流&#x2F;取流是什么</h2><p>拉流（Pull Streaming）或取流（Fetching Stream）是指从服务器端获取实时音视频流并在客户端进行播放的过程。与推流（Push Streaming）相对应，拉流是接收端的操作，常用于观看直播、视频会议、监控等场景。</p>
<h3 id="拉流的基本原理"><a href="#拉流的基本原理" class="headerlink" title="拉流的基本原理"></a>拉流的基本原理</h3><ol>
<li><p><strong>连接服务器</strong>：</p>
<ul>
<li>客户端通过指定的协议和地址连接到流媒体服务器。</li>
</ul>
</li>
<li><p><strong>请求流</strong>：</p>
<ul>
<li>客户端向服务器发送请求，要求获取特定的流媒体内容。</li>
</ul>
</li>
<li><p><strong>接收流</strong>：</p>
<ul>
<li>服务器将实时的音视频数据发送给客户端。</li>
</ul>
</li>
<li><p><strong>解码和播放</strong>：</p>
<ul>
<li>客户端接收数据后，进行解码并播放音视频内容。</li>
</ul>
</li>
</ol>
<h3 id="常用的拉流协议和工具"><a href="#常用的拉流协议和工具" class="headerlink" title="常用的拉流协议和工具"></a>常用的拉流协议和工具</h3><h4 id="拉流协议"><a href="#拉流协议" class="headerlink" title="拉流协议"></a>拉流协议</h4><ol>
<li><p><strong>RTMP（Real-Time Messaging Protocol）</strong>：</p>
<ul>
<li>常用于直播流的传输，尤其是与 Adobe Flash 配合使用。许多直播平台仍然支持 RTMP。</li>
</ul>
</li>
<li><p><strong>HLS（HTTP Live Streaming）</strong>：</p>
<ul>
<li>由苹果公司开发，广泛应用于点播和直播流媒体服务。使用 HTTP 协议进行传输，兼容性好，特别适合在不同设备和网络条件下使用。</li>
</ul>
</li>
<li><p><strong>DASH（Dynamic Adaptive Streaming over HTTP）</strong>：</p>
<ul>
<li>一种基于 HTTP 的自适应流媒体传输协议，可以根据网络条件动态调整视频质量。</li>
</ul>
</li>
<li><p><strong>WebRTC（Web Real-Time Communication）</strong>：</p>
<ul>
<li>支持实时音视频通信，适用于视频通话、视频会议等场景。具有低延迟、点对点通信等优点。</li>
</ul>
</li>
</ol>
<h4 id="拉流工具"><a href="#拉流工具" class="headerlink" title="拉流工具"></a>拉流工具</h4><ol>
<li><p><strong>VLC Media Player</strong>：</p>
<ul>
<li>开源的多媒体播放器，支持多种流媒体协议，常用于播放 RTMP、HLS 等流媒体内容。</li>
</ul>
</li>
<li><p><strong>FFmpeg</strong>：</p>
<ul>
<li>强大的多媒体处理工具，支持音视频采集、编码、封装和拉流。适合高级用户和开发者。</li>
</ul>
</li>
<li><p><strong>OBS（Open Broadcaster Software）</strong>：</p>
<ul>
<li>虽然主要用于推流，也可以配置为接收和播放拉流内容。</li>
</ul>
</li>
<li><p><strong>Web 浏览器</strong>：</p>
<ul>
<li>现代浏览器支持 HLS、DASH 和 WebRTC，可以直接在网页中播放流媒体内容。</li>
</ul>
</li>
</ol>
<h3 id="示例：使用-FFmpeg-拉流"><a href="#示例：使用-FFmpeg-拉流" class="headerlink" title="示例：使用 FFmpeg 拉流"></a>示例：使用 FFmpeg 拉流</h3><p>假设你想使用 FFmpeg 从 RTMP 服务器拉取流媒体并保存到本地文件，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp://example.com/live/stream_key -c copy output.mp4</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>-i rtmp://example.com/live/stream_key</code>：指定输入流地址。</li>
<li><code>-c copy</code>：直接复制流媒体数据，不进行重新编码。</li>
<li><code>output.mp4</code>：指定输出文件名和格式。</li>
</ul>
<h3 id="示例：使用-VLC-拉流"><a href="#示例：使用-VLC-拉流" class="headerlink" title="示例：使用 VLC 拉流"></a>示例：使用 VLC 拉流</h3><p>假设你想使用 VLC 播放 HLS 流媒体，可以按以下步骤操作：</p>
<ol>
<li>打开 VLC Media Player。</li>
<li>选择“媒体”菜单，然后选择“打开网络串流”。</li>
<li>在网络 URL 输入框中输入 HLS 流地址，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/live/stream.m3u8</span><br></pre></td></tr></table></figure></li>
<li>点击“播放”按钮，VLC 将开始播放流媒体内容。</li>
</ol>
<h3 id="拉流应用场景"><a href="#拉流应用场景" class="headerlink" title="拉流应用场景"></a>拉流应用场景</h3><ul>
<li><strong>观看直播</strong>：用户通过拉流技术从直播服务器获取实时音视频流，观看直播节目、体育赛事、游戏直播等。</li>
<li><strong>视频会议</strong>：会议参与者通过拉流技术获取其他参与者的音视频流，实现实时交流。</li>
<li><strong>远程监控</strong>：监控系统通过拉流技术从摄像头获取实时视频流，监控人员可以随时查看监控区域的情况。</li>
<li><strong>在线教育</strong>：学生通过拉流技术观看教师的实时讲解和课程内容，进行在线学习。</li>
</ul>
<p>拉流技术是流媒体应用的重要组成部分，使用户能够在不同设备和网络条件下实时获取和播放音视频内容，为各种实时互动和直播应用提供了支持。</p>
<h2 id="流媒体服务器是什么"><a href="#流媒体服务器是什么" class="headerlink" title="流媒体服务器是什么"></a>流媒体服务器是什么</h2><p>流媒体服务器是一种专门用于传输和分发音视频内容的服务器。它可以处理实时音视频流的接收、转码、存储和分发，使得用户能够通过网络实时观看或收听音视频内容。流媒体服务器在直播、点播、视频会议和远程教育等场景中发挥着关键作用。</p>
<h3 id="流媒体服务器的主要功能"><a href="#流媒体服务器的主要功能" class="headerlink" title="流媒体服务器的主要功能"></a>流媒体服务器的主要功能</h3><ol>
<li><p><strong>接收推流</strong>：</p>
<ul>
<li>接收来自客户端或设备的实时音视频流（推流）。这些流可以来自摄像头、麦克风、编码器或其他推流设备。</li>
</ul>
</li>
<li><p><strong>转码</strong>：</p>
<ul>
<li>将音视频流转码为不同的格式或码率，以适应不同的网络条件和设备。例如，将高分辨率视频转码为多种分辨率和码率，以便用户根据自己的网络状况选择最佳的播放质量。</li>
</ul>
</li>
<li><p><strong>存储</strong>：</p>
<ul>
<li>将流媒体内容存储在服务器上，以便后续点播。存储的内容可以是完整的视频文件，也可以是分片的流媒体文件（如 HLS 的 TS 分片）。</li>
</ul>
</li>
<li><p><strong>分发拉流</strong>：</p>
<ul>
<li>将流媒体内容分发给客户端（拉流）。客户端可以是播放器、浏览器、移动应用等。</li>
</ul>
</li>
<li><p><strong>负载均衡</strong>：</p>
<ul>
<li>管理多个流媒体服务器，以处理大量的并发请求，确保系统的稳定性和高可用性。</li>
</ul>
</li>
<li><p><strong>安全性</strong>：</p>
<ul>
<li>提供访问控制、加密和认证等安全措施，确保流媒体内容的安全传输和访问。</li>
</ul>
</li>
</ol>
<h3 id="常见的流媒体服务器软件"><a href="#常见的流媒体服务器软件" class="headerlink" title="常见的流媒体服务器软件"></a>常见的流媒体服务器软件</h3><ol>
<li><p><strong>Nginx + RTMP 模块</strong>：</p>
<ul>
<li>Nginx 是一个高性能的 HTTP 服务器和反向代理服务器，通过 RTMP 模块扩展，可以实现 RTMP 推流和拉流功能。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/arut/nginx-rtmp-module">Nginx RTMP Module</a></li>
</ul>
</li>
<li><p><strong>Wowza Streaming Engine</strong>：</p>
<ul>
<li>商用的流媒体服务器，支持多种流媒体协议和功能，适用于企业级应用。</li>
<li><a target="_blank" rel="noopener" href="https://www.wowza.com/">Wowza</a></li>
</ul>
</li>
<li><p><strong>Red5</strong>：</p>
<ul>
<li>开源的流媒体服务器，支持 RTMP 和 WebRTC 等协议，适用于实时音视频通信。</li>
<li><a target="_blank" rel="noopener" href="https://red5pro.com/">Red5</a></li>
</ul>
</li>
<li><p><strong>Flussonic</strong>：</p>
<ul>
<li>商用的流媒体服务器，支持多种协议和高级功能，如转码、存储和分发。</li>
<li><a target="_blank" rel="noopener" href="https://flussonic.com/">Flussonic</a></li>
</ul>
</li>
<li><p><strong>Kurento</strong>：</p>
<ul>
<li>开源的 WebRTC 流媒体服务器，适用于视频会议和实时通信应用。</li>
<li><a target="_blank" rel="noopener" href="https://www.kurento.org/">Kurento</a></li>
</ul>
</li>
<li><p><strong>Adobe Media Server</strong>：</p>
<ul>
<li>商用的流媒体服务器，支持 RTMP 和 HLS 等协议，适用于专业的流媒体应用。</li>
<li><a target="_blank" rel="noopener" href="https://www.adobe.com/products/adobe-media-server-family.html">Adobe Media Server</a></li>
</ul>
</li>
</ol>
<h3 id="示例：使用-Nginx-RTMP-模块搭建流媒体服务器"><a href="#示例：使用-Nginx-RTMP-模块搭建流媒体服务器" class="headerlink" title="示例：使用 Nginx + RTMP 模块搭建流媒体服务器"></a>示例：使用 Nginx + RTMP 模块搭建流媒体服务器</h3><ol>
<li><p><strong>安装 Nginx 和 RTMP 模块</strong>：</p>
<ul>
<li>在 Ubuntu 系统上，首先安装必要的依赖：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install build-essential libpcre3 libpcre3-dev libssl-dev</span><br></pre></td></tr></table></figure></li>
<li>下载并编译 Nginx 和 RTMP 模块：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.19.6.tar.gz</span><br><span class="line">wget https://github.com/arut/nginx-rtmp-module/archive/master.zip</span><br><span class="line">tar -zxvf nginx-1.19.6.tar.gz</span><br><span class="line">unzip master.zip</span><br><span class="line"><span class="built_in">cd</span> nginx-1.19.6</span><br><span class="line">./configure --add-module=../nginx-rtmp-module-master --with-http_ssl_module</span><br><span class="line">make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>配置 Nginx</strong>：</p>
<ul>
<li>编辑 Nginx 配置文件（通常位于 <code>/usr/local/nginx/conf/nginx.conf</code>）：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">rtmp</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">1935</span>;</span><br><span class="line">        <span class="attribute">chunk_size</span> <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">application</span> live &#123;</span><br><span class="line">            <span class="attribute">live</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">record</span> <span class="literal">off</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>启动 Nginx</strong>：</p>
<ul>
<li>启动 Nginx 流媒体服务器：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>推流和拉流</strong>：</p>
<ul>
<li>使用推流工具（如 OBS 或 FFmpeg）将流媒体推送到服务器：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i input.mp4 -c:v libx264 -c:a aac -strict experimental -f flv rtmp://your_server_ip/live/stream_key</span><br></pre></td></tr></table></figure></li>
<li>使用拉流工具（如 VLC）从服务器获取流媒体：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtmp://your_server_ip/live/stream_key</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>流媒体服务器在现代网络音视频应用中起到了至关重要的作用，通过合理的部署和配置，可以实现高效、稳定和安全的实时音视频传输。</p>
<h2 id="linux-循环推流-详解"><a href="#linux-循环推流-详解" class="headerlink" title="linux 循环推流 详解"></a>linux 循环推流 详解</h2><p>在 Linux 上进行循环推流意味着将一个视频文件不断地推送到流媒体服务器，以便进行持续播放。这通常用于 24&#x2F;7 直播、广告循环播放等场景。使用 <code>FFmpeg</code> 是实现这一功能的常见方法，因为它非常灵活且支持多种音视频处理任务。</p>
<h3 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h3><h4 id="安装-FFmpeg"><a href="#安装-FFmpeg" class="headerlink" title="安装 FFmpeg"></a>安装 FFmpeg</h4><p>如果尚未安装 FFmpeg，请先进行安装：</p>
<p>对于 Debian&#x2F;Ubuntu 系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install ffmpeg</span><br></pre></td></tr></table></figure>

<p>对于 CentOS&#x2F;RHEL 系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install epel-release</span><br><span class="line"><span class="built_in">sudo</span> yum install ffmpeg</span><br></pre></td></tr></table></figure>

<h4 id="编写循环推流脚本"><a href="#编写循环推流脚本" class="headerlink" title="编写循环推流脚本"></a>编写循环推流脚本</h4><p>以下是一个简单的 Bash 脚本示例，用于实现视频文件的循环推流：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推流地址</span></span><br><span class="line">RTMP_URL=<span class="string">&quot;rtmp://example.com/live/stream_key&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 视频文件路径</span></span><br><span class="line">VIDEO_FILE=<span class="string">&quot;input.mp4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环推流</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    ffmpeg -re -stream_loop -1 -i <span class="string">&quot;<span class="variable">$VIDEO_FILE</span>&quot;</span> -c:v libx264 -c:a aac -f flv <span class="string">&quot;<span class="variable">$RTMP_URL</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;推流失败，等待 5 秒后重试...&quot;</span></span><br><span class="line">        <span class="built_in">sleep</span> 5</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>RTMP_URL</code>：指定 RTMP 服务器的推流地址。</li>
<li><code>VIDEO_FILE</code>：指定要推流的视频文件。</li>
<li><code>while true; do ... done</code>：无限循环执行推流命令。</li>
<li><code>ffmpeg -re -stream_loop -1 -i &quot;$VIDEO_FILE&quot; -c:v libx264 -c:a aac -f flv &quot;$RTMP_URL&quot;</code>：<ul>
<li><code>-re</code>：按实时速率读取输入文件。</li>
<li><code>-stream_loop -1</code>：无限循环输入文件。</li>
<li><code>-i &quot;$VIDEO_FILE&quot;</code>：指定输入文件。</li>
<li><code>-c:v libx264</code>：使用 H.264 视频编码器。</li>
<li><code>-c:a aac</code>：使用 AAC 音频编码器。</li>
<li><code>-f flv &quot;$RTMP_URL&quot;</code>：指定输出格式为 FLV，并推送到 RTMP 服务器。</li>
</ul>
</li>
<li><code>if [ $? -ne 0 ]; then ...</code>：如果 FFmpeg 命令失败，等待 5 秒后重试。</li>
</ul>
<h4 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h4><p>保存上述脚本为 <code>loop_stream.sh</code>，然后赋予其执行权限并运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x loop_stream.sh</span><br><span class="line">./loop_stream.sh</span><br></pre></td></tr></table></figure>

<h4 id="处理特殊情况"><a href="#处理特殊情况" class="headerlink" title="处理特殊情况"></a>处理特殊情况</h4><p>有时你可能需要在每次循环结束后对推流进行一些清理工作，或者在推流过程中处理网络中断等情况。可以通过捕捉信号或检查推流状态来实现更复杂的逻辑。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">RTMP_URL=<span class="string">&quot;rtmp://example.com/live/stream_key&quot;</span></span><br><span class="line">VIDEO_FILE=<span class="string">&quot;input.mp4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕捉退出信号以进行清理</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&#x27;echo &quot;脚本终止&quot;; exit 0&#x27;</span> SIGINT SIGTERM</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    ffmpeg -re -stream_loop -1 -i <span class="string">&quot;<span class="variable">$VIDEO_FILE</span>&quot;</span> -c:v libx264 -c:a aac -f flv <span class="string">&quot;<span class="variable">$RTMP_URL</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;推流失败，等待 5 秒后重试...&quot;</span></span><br><span class="line">        <span class="built_in">sleep</span> 5</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>此脚本在接收到中断信号（如 <code>Ctrl+C</code>）时会优雅地退出。</p>
<h3 id="其他考虑"><a href="#其他考虑" class="headerlink" title="其他考虑"></a>其他考虑</h3><ul>
<li><strong>性能优化</strong>：根据实际需求调整 FFmpeg 编码参数，以优化推流性能。</li>
<li><strong>监控和日志</strong>：可以将推流日志重定向到文件，并使用监控工具（如 <code>supervisord</code>、<code>systemd</code>）来确保推流脚本的运行和自动重启。</li>
<li><strong>多文件循环播放</strong>：如果需要循环播放多个视频文件，可以修改脚本以支持多文件循环。例如，使用 <code>ffmpeg</code> 的 <code>concat</code> 过滤器。</li>
</ul>
<h3 id="多文件循环播放示例"><a href="#多文件循环播放示例" class="headerlink" title="多文件循环播放示例"></a>多文件循环播放示例</h3><p>以下是一个多文件循环播放的脚本示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">RTMP_URL=<span class="string">&quot;rtmp://example.com/live/stream_key&quot;</span></span><br><span class="line">VIDEO_FILES=(<span class="string">&quot;video1.mp4&quot;</span> <span class="string">&quot;video2.mp4&quot;</span> <span class="string">&quot;video3.mp4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 捕捉退出信号以进行清理</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&#x27;echo &quot;脚本终止&quot;; exit 0&#x27;</span> SIGINT SIGTERM</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> VIDEO_FILE <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;VIDEO_FILES[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">        ffmpeg -re -i <span class="string">&quot;<span class="variable">$VIDEO_FILE</span>&quot;</span> -c:v libx264 -c:a aac -f flv <span class="string">&quot;<span class="variable">$RTMP_URL</span>&quot;</span></span><br><span class="line">        <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;推流失败，等待 5 秒后重试...&quot;</span></span><br><span class="line">            <span class="built_in">sleep</span> 5</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>此脚本会按顺序循环播放 <code>VIDEO_FILES</code> 列表中的每个视频文件，并在所有文件播放完毕后重新开始。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/12/notebook/Tools/2024-07-12-live555/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/12/notebook/Tools/2024-07-12-live555/" class="post-title-link" itemprop="url">live555</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-12 14:00:00" itemprop="dateCreated datePublished" datetime="2024-07-12T14:00:00+08:00">2024-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>live555开源工具的相关笔记</li>
</ul>
<h2 id="live555是什么"><a href="#live555是什么" class="headerlink" title="live555是什么"></a>live555是什么</h2><p>LIVE555 是一个开源的多媒体流媒体库，主要用于实现 RTP&#x2F;RTCP、RTSP 和 SIP 协议。它提供了一系列的 C++ 类，用于创建多媒体流媒体应用程序，例如流媒体服务器和客户端。LIVE555 可以用于流式传输各种多媒体格式，包括 H.264 视频、AAC 音频等。</p>
<p>LIVE555 的主要特点包括：</p>
<ol>
<li><strong>跨平台支持</strong>：支持多种操作系统，包括 Windows、macOS、Linux 等。</li>
<li><strong>高效性</strong>：使用 C++ 编写，具有高效的性能。</li>
<li><strong>灵活性</strong>：提供了丰富的 API，开发者可以根据需要进行定制。</li>
<li><strong>支持多种协议</strong>：支持 RTP&#x2F;RTCP、RTSP 和 SIP 协议，使其可以与许多不同类型的流媒体应用程序兼容。</li>
<li><strong>开源</strong>：LIVE555 是开源软件，可以免费使用和修改。</li>
</ol>
<p>通常，LIVE555 被用作开发实时流媒体应用程序的基础组件，例如视频监控系统、实时视频会议系统等。</p>
<h2 id="live555-详解"><a href="#live555-详解" class="headerlink" title="live555 详解"></a>live555 详解</h2><p>LIVE555 是一个开源的多媒体流媒体库，广泛应用于实时流媒体传输和接收。它由 Ross Finlayson 维护，主要用来处理 RTP&#x2F;RTCP、RTSP 和 SIP 协议，并支持多种多媒体格式的流式传输。以下是 LIVE555 的详细介绍：</p>
<h3 id="1-主要组件"><a href="#1-主要组件" class="headerlink" title="1. 主要组件"></a>1. 主要组件</h3><h4 id="a-BasicUsageEnvironment"><a href="#a-BasicUsageEnvironment" class="headerlink" title="a. BasicUsageEnvironment"></a>a. BasicUsageEnvironment</h4><p>这是 LIVE555 提供的基础环境，处理事件循环和日志记录。它为应用程序提供了一个使用基础 API 的上下文。</p>
<h4 id="b-Groupsock"><a href="#b-Groupsock" class="headerlink" title="b. Groupsock"></a>b. Groupsock</h4><p>该模块处理网络套接字的组播和单播通信，封装了 IP 地址和端口的处理逻辑。</p>
<h4 id="c-RTSPClient"><a href="#c-RTSPClient" class="headerlink" title="c. RTSPClient"></a>c. RTSPClient</h4><p>该模块用于实现 RTSP 客户端功能，能够发送 RTSP 请求（如 DESCRIBE、SETUP、PLAY、PAUSE 和 TEARDOWN）并处理 RTSP 响应。</p>
<h4 id="d-RTSPServer"><a href="#d-RTSPServer" class="headerlink" title="d. RTSPServer"></a>d. RTSPServer</h4><p>该模块用于实现 RTSP 服务器功能，能够接收和处理来自客户端的 RTSP 请求，并管理媒体流会话。</p>
<h4 id="e-MediaSession"><a href="#e-MediaSession" class="headerlink" title="e. MediaSession"></a>e. MediaSession</h4><p>该模块表示一个媒体会话，包含一个或多个媒体子会话（MediaSubsession），每个子会话表示一个媒体流（例如视频流或音频流）。</p>
<h4 id="f-MediaSink"><a href="#f-MediaSink" class="headerlink" title="f. MediaSink"></a>f. MediaSink</h4><p>该模块处理媒体数据的接收和处理，通常用于播放或保存媒体流。</p>
<h4 id="g-MediaSource"><a href="#g-MediaSource" class="headerlink" title="g. MediaSource"></a>g. MediaSource</h4><p>该模块用于生成媒体数据，可以从文件、设备或其他来源读取数据。</p>
<h3 id="2-主要协议支持"><a href="#2-主要协议支持" class="headerlink" title="2. 主要协议支持"></a>2. 主要协议支持</h3><h4 id="a-RTP-RTCP"><a href="#a-RTP-RTCP" class="headerlink" title="a. RTP&#x2F;RTCP"></a>a. RTP&#x2F;RTCP</h4><p>RTP（实时传输协议）用于实时传输多媒体数据，而 RTCP（RTP 控制协议）用于监控数据传输的质量和提供会话控制。</p>
<h4 id="b-RTSP"><a href="#b-RTSP" class="headerlink" title="b. RTSP"></a>b. RTSP</h4><p>RTSP（实时流协议）是一种网络控制协议，用于建立和控制媒体流会话。RTSP 类似于 HTTP，但专门设计用于流媒体控制。</p>
<h4 id="c-SIP"><a href="#c-SIP" class="headerlink" title="c. SIP"></a>c. SIP</h4><p>SIP（会话初始协议）用于建立、修改和终止多媒体会话（如 IP 电话呼叫）。</p>
<h3 id="3-支持的多媒体格式"><a href="#3-支持的多媒体格式" class="headerlink" title="3. 支持的多媒体格式"></a>3. 支持的多媒体格式</h3><p>LIVE555 支持多种多媒体格式的流式传输，包括但不限于：</p>
<ul>
<li>H.264 视频</li>
<li>MPEG 视频</li>
<li>AAC 音频</li>
<li>AMR 音频</li>
<li>JPEG 图像</li>
</ul>
<h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h3><ul>
<li><strong>实时视频监控系统</strong>：例如 IP 摄像机和网络视频录像机（NVR）。</li>
<li><strong>实时视频会议系统</strong>：例如视频会议软件和硬件设备。</li>
<li><strong>流媒体服务器</strong>：例如媒体流服务器，能够实时传输多媒体内容给客户端。</li>
<li><strong>多媒体播放器</strong>：能够接收和播放来自流媒体服务器的实时媒体流。</li>
</ul>
<h3 id="5-示例代码"><a href="#5-示例代码" class="headerlink" title="5. 示例代码"></a>5. 示例代码</h3><p>以下是一个简单的 RTSP 客户端示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;BasicUsageEnvironment.hh&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liveMedia.hh&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">afterPlaying</span><span class="params">(<span class="type">void</span>* clientData)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Placeholder for post-playback actions</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create the usage environment</span></span><br><span class="line">    TaskScheduler* scheduler = BasicTaskScheduler::<span class="built_in">createNew</span>();</span><br><span class="line">    UsageEnvironment* env = BasicUsageEnvironment::<span class="built_in">createNew</span>(*scheduler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the RTSP client</span></span><br><span class="line">    RTSPClient* rtspClient = RTSPClient::<span class="built_in">createNew</span>(*env, <span class="string">&quot;rtsp://example.com/stream&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the event loop</span></span><br><span class="line">    env-&gt;<span class="built_in">taskScheduler</span>().<span class="built_in">doEventLoop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cleanup</span></span><br><span class="line">    <span class="keyword">delete</span> rtspClient;</span><br><span class="line">    env-&gt;<span class="built_in">reclaim</span>();</span><br><span class="line">    <span class="keyword">delete</span> scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了如何创建一个简单的 RTSP 客户端，连接到 RTSP 流媒体服务器并进入事件循环。</p>
<h3 id="6-文档和资源"><a href="#6-文档和资源" class="headerlink" title="6. 文档和资源"></a>6. 文档和资源</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.live555.com/">LIVE555 官方网站</a></li>
<li><a target="_blank" rel="noopener" href="http://www.live555.com/liveMedia/">LIVE555 文档</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/rgaufman/live555">GitHub 代码仓库</a></li>
</ul>
<p>通过这些资源，您可以获得更多关于 LIVE555 的详细信息和使用指南。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/12/notebook/Tools/2024-07-12-LZ4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/12/notebook/Tools/2024-07-12-LZ4/" class="post-title-link" itemprop="url">lz4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-12 14:00:00" itemprop="dateCreated datePublished" datetime="2024-07-12T14:00:00+08:00">2024-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>LZ4库相关笔记</li>
</ul>
<h2 id="lz4-h-是什么"><a href="#lz4-h-是什么" class="headerlink" title="lz4.h 是什么"></a>lz4.h 是什么</h2><p><code>lz4.h</code> 是 LZ4 压缩库的头文件。LZ4 是一种非常快速的无损压缩算法，专为高性能和高压缩率设计。LZ4 库主要用于数据压缩和解压缩操作，适用于需要快速处理大量数据的应用程序。</p>
<p>LZ4 库的头文件 <code>lz4.h</code> 定义了所有必要的函数和数据结构，使得开发者可以在他们的 C 或 C++ 项目中轻松地使用 LZ4 压缩和解压缩功能。这个头文件通常包含以下内容：</p>
<ol>
<li><strong>数据类型和结构</strong>：定义了用于压缩和解压缩过程的数据类型和结构体。</li>
<li><strong>宏和常量</strong>：定义了库中使用的一些常量和宏。</li>
<li><strong>函数声明</strong>：声明了库中提供的所有函数，包括压缩和解压缩函数。</li>
</ol>
<p>常用的函数包括：</p>
<ul>
<li><code>LZ4_compress_default()</code></li>
<li><code>LZ4_decompress_safe()</code></li>
<li><code>LZ4_compressBound()</code></li>
</ul>
<p>这些函数分别用于默认压缩、解压缩和计算压缩缓冲区的最大大小。</p>
<p>以下是一个使用 <code>lz4.h</code> 的简单示例，演示如何进行压缩和解压缩：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lz4.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 原始数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* input = <span class="string">&quot;Hello, LZ4 compression!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> inputSize = <span class="built_in">strlen</span>(input) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩缓冲区</span></span><br><span class="line">    <span class="type">int</span> maxCompressedSize = LZ4_compressBound(inputSize);</span><br><span class="line">    <span class="type">char</span>* compressedData = (<span class="type">char</span>*)<span class="built_in">malloc</span>(maxCompressedSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩数据</span></span><br><span class="line">    <span class="type">int</span> compressedDataSize = LZ4_compress_default(input, compressedData, inputSize, maxCompressedSize);</span><br><span class="line">    <span class="keyword">if</span> (compressedDataSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Compression failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(compressedData);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解压缩缓冲区</span></span><br><span class="line">    <span class="type">char</span>* decompressedData = (<span class="type">char</span>*)<span class="built_in">malloc</span>(inputSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解压缩数据</span></span><br><span class="line">    <span class="type">int</span> decompressedSize = LZ4_decompress_safe(compressedData, decompressedData, compressedDataSize, inputSize);</span><br><span class="line">    <span class="keyword">if</span> (decompressedSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Decompression failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(compressedData);</span><br><span class="line">        <span class="built_in">free</span>(decompressedData);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出解压缩后的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Decompressed data: %s\n&quot;</span>, decompressedData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="built_in">free</span>(compressedData);</span><br><span class="line">    <span class="built_in">free</span>(decompressedData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了如何使用 LZ4 库进行数据的压缩和解压缩操作。</p>
<h2 id="LZ4-库是什么"><a href="#LZ4-库是什么" class="headerlink" title="LZ4 库是什么"></a>LZ4 库是什么</h2><p>LZ4 库是一个开源的压缩算法库，专注于提供高效、快速的无损压缩和解压缩功能。LZ4 是一种非常快的压缩算法，能够在保持高压缩速度的同时提供良好的压缩率。它特别适用于需要快速处理大量数据的应用程序，例如日志压缩、传输数据的实时压缩、存储系统等。</p>
<p>LZ4 库具有以下几个主要特点：</p>
<ol>
<li><strong>高速压缩和解压缩</strong>：LZ4 以其极快的压缩和解压缩速度而闻名，通常在几百MB&#x2F;s到几GB&#x2F;s的范围内。</li>
<li><strong>无损压缩</strong>：LZ4 是无损压缩算法，这意味着压缩和解压缩过程中数据不会丢失。</li>
<li><strong>简单易用</strong>：LZ4 库提供了简单易用的 API，可以很容易地集成到 C、C++ 项目中。它还提供了其他语言的绑定，例如 Python、Java 等。</li>
<li><strong>小内存占用</strong>：LZ4 的压缩和解压缩过程对内存的占用很小，适合在内存受限的环境中使用。</li>
</ol>
<h3 id="LZ4-库的使用"><a href="#LZ4-库的使用" class="headerlink" title="LZ4 库的使用"></a>LZ4 库的使用</h3><p>LZ4 库主要提供了两个核心函数：<code>LZ4_compress_default</code> 和 <code>LZ4_decompress_safe</code>。</p>
<h4 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h4><p><code>LZ4_compress_default</code> 函数用于压缩数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LZ4_compress_default</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* source, <span class="type">char</span>* dest, <span class="type">int</span> sourceSize, <span class="type">int</span> maxDestSize)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>source</code>：指向要压缩的源数据。</li>
<li><code>dest</code>：指向压缩后存储数据的目标缓冲区。</li>
<li><code>sourceSize</code>：源数据的大小。</li>
<li><code>maxDestSize</code>：目标缓冲区的最大大小。</li>
</ul>
<p>返回值是压缩后的数据大小，如果返回值为 0 或负值，则表示压缩失败。</p>
<h4 id="解压缩数据"><a href="#解压缩数据" class="headerlink" title="解压缩数据"></a>解压缩数据</h4><p><code>LZ4_decompress_safe</code> 函数用于解压缩数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LZ4_decompress_safe</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* source, <span class="type">char</span>* dest, <span class="type">int</span> compressedSize, <span class="type">int</span> maxDecompressedSize)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>source</code>：指向要解压缩的压缩数据。</li>
<li><code>dest</code>：指向解压缩后存储数据的目标缓冲区。</li>
<li><code>compressedSize</code>：压缩数据的大小。</li>
<li><code>maxDecompressedSize</code>：目标缓冲区的最大大小。</li>
</ul>
<p>返回值是解压缩后的数据大小，如果返回值为负值，则表示解压缩失败。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>下面是一个简单的示例，展示了如何使用 LZ4 库进行数据的压缩和解压缩：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lz4.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 原始数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* input = <span class="string">&quot;Hello, LZ4 compression!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> inputSize = <span class="built_in">strlen</span>(input) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩缓冲区</span></span><br><span class="line">    <span class="type">int</span> maxCompressedSize = LZ4_compressBound(inputSize);</span><br><span class="line">    <span class="type">char</span>* compressedData = (<span class="type">char</span>*)<span class="built_in">malloc</span>(maxCompressedSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩数据</span></span><br><span class="line">    <span class="type">int</span> compressedDataSize = LZ4_compress_default(input, compressedData, inputSize, maxCompressedSize);</span><br><span class="line">    <span class="keyword">if</span> (compressedDataSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Compression failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(compressedData);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解压缩缓冲区</span></span><br><span class="line">    <span class="type">char</span>* decompressedData = (<span class="type">char</span>*)<span class="built_in">malloc</span>(inputSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解压缩数据</span></span><br><span class="line">    <span class="type">int</span> decompressedSize = LZ4_decompress_safe(compressedData, decompressedData, compressedDataSize, inputSize);</span><br><span class="line">    <span class="keyword">if</span> (decompressedSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Decompression failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(compressedData);</span><br><span class="line">        <span class="built_in">free</span>(decompressedData);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出解压缩后的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Decompressed data: %s\n&quot;</span>, decompressedData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="built_in">free</span>(compressedData);</span><br><span class="line">    <span class="built_in">free</span>(decompressedData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了如何使用 LZ4 库的压缩和解压缩函数来处理字符串数据。</p>
<h2 id="LZ4库-编译安装"><a href="#LZ4库-编译安装" class="headerlink" title="LZ4库 编译安装"></a>LZ4库 编译安装</h2><p>要编译和安装 LZ4 库，你可以按照以下步骤进行。这里假设你使用的是 Unix 系统，例如 Linux 或 macOS。如果你使用的是 Windows 系统，可以参考对应的指南。</p>
<h3 id="1-下载-LZ4-源代码"><a href="#1-下载-LZ4-源代码" class="headerlink" title="1. 下载 LZ4 源代码"></a>1. 下载 LZ4 源代码</h3><p>首先，你需要从 LZ4 的 GitHub 仓库下载源代码。你可以使用 <code>git</code> 命令来克隆仓库，或者直接从 GitHub 网站下载压缩包。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lz4/lz4.git</span><br><span class="line"><span class="built_in">cd</span> lz4</span><br></pre></td></tr></table></figure>

<h3 id="2-编译-LZ4-库"><a href="#2-编译-LZ4-库" class="headerlink" title="2. 编译 LZ4 库"></a>2. 编译 LZ4 库</h3><p>进入 LZ4 源代码目录后，使用以下命令来编译库。LZ4 使用 <code>make</code> 工具来管理编译过程。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>这个命令会编译所有的源文件并生成可执行文件和库文件。</p>
<h3 id="3-安装-LZ4-库"><a href="#3-安装-LZ4-库" class="headerlink" title="3. 安装 LZ4 库"></a>3. 安装 LZ4 库</h3><p>编译完成后，你可以使用以下命令来安装 LZ4 库。默认情况下，库会安装到系统的标准位置（例如 <code>/usr/local</code>）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure>

<p>如果你希望将库安装到自定义位置，可以使用 <code>PREFIX</code> 选项来指定目标路径：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> make install PREFIX=/path/to/your/installation/directory</span><br></pre></td></tr></table></figure>

<h3 id="4-验证安装"><a href="#4-验证安装" class="headerlink" title="4. 验证安装"></a>4. 验证安装</h3><p>你可以使用以下命令来验证 LZ4 是否安装成功：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lz4 -V</span><br></pre></td></tr></table></figure>

<p>这个命令会输出 LZ4 的版本信息，表明 LZ4 已成功安装。</p>
<h3 id="5-在项目中使用-LZ4-库"><a href="#5-在项目中使用-LZ4-库" class="headerlink" title="5. 在项目中使用 LZ4 库"></a>5. 在项目中使用 LZ4 库</h3><p>在你的 C&#x2F;C++ 项目中，你需要包含 LZ4 的头文件并链接 LZ4 库。假设你已经安装 LZ4，并且头文件和库文件位于系统的标准位置，你可以使用以下示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lz4.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 原始数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* input = <span class="string">&quot;Hello, LZ4 compression!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> inputSize = <span class="built_in">strlen</span>(input) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩缓冲区</span></span><br><span class="line">    <span class="type">int</span> maxCompressedSize = LZ4_compressBound(inputSize);</span><br><span class="line">    <span class="type">char</span>* compressedData = (<span class="type">char</span>*)<span class="built_in">malloc</span>(maxCompressedSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩数据</span></span><br><span class="line">    <span class="type">int</span> compressedDataSize = LZ4_compress_default(input, compressedData, inputSize, maxCompressedSize);</span><br><span class="line">    <span class="keyword">if</span> (compressedDataSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Compression failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(compressedData);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解压缩缓冲区</span></span><br><span class="line">    <span class="type">char</span>* decompressedData = (<span class="type">char</span>*)<span class="built_in">malloc</span>(inputSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解压缩数据</span></span><br><span class="line">    <span class="type">int</span> decompressedSize = LZ4_decompress_safe(compressedData, decompressedData, compressedDataSize, inputSize);</span><br><span class="line">    <span class="keyword">if</span> (decompressedSize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Decompression failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(compressedData);</span><br><span class="line">        <span class="built_in">free</span>(decompressedData);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出解压缩后的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Decompressed data: %s\n&quot;</span>, decompressedData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理内存</span></span><br><span class="line">    <span class="built_in">free</span>(compressedData);</span><br><span class="line">    <span class="built_in">free</span>(decompressedData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译这个示例代码时，记得链接 LZ4 库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o example example.c -llz4</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，你应该能够成功地编译、安装和使用 LZ4 库。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/12/notebook/Tools/2024-07-12-ascend/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/12/notebook/Tools/2024-07-12-ascend/" class="post-title-link" itemprop="url">ascend</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-12 09:00:00" itemprop="dateCreated datePublished" datetime="2024-07-12T09:00:00+08:00">2024-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ascend相关笔记</li>
</ul>
<h2 id="ascend是什么"><a href="#ascend是什么" class="headerlink" title="ascend是什么"></a>ascend是什么</h2><ul>
<li>2023年5月6日，在昇腾AI开发者峰会上，华为正式发布了面向算子开发场景的昇腾Ascend C编程语言。Ascend C原生支持C&#x2F;C++编程规范，通过多层接口抽象、并行编程范式、孪生调试等技术，极大提高了算子的开发效率，帮助AI开发者低成本完成算子开发和模型调优部署。</li>
<li>和CUDA开发的算子运行在GPU上一样，基于Ascend C开发的算子，可以通过异构计算架构CANN（Compute Architecture for Neural Networks）运行在昇腾AI处理器（可简称NPU）上。CANN是使能昇腾AI处理器的一个软件栈，通过软硬件协同优化，能够充分发挥昇腾AI处理器的强大算力。从下面的架构图可以清楚的看到，使用Ascend C编程语言开发的算子通过编译器编译和运行时调度，最终运行在昇腾AI处理器上。<br><img src="/./ascend.png" alt="架构图"></li>
<li>我们知道，通用计算就是我们常写的一些在CPU上运行的计算，它擅长逻辑控制和串行计算，而AI计算相对通用计算来说，更擅长并行计算，可支持大规模的计算密集型任务。</li>
<li>最小计算代码能同时计算多个数据的乘加，更近一步，如果使用Cube计算单元，只需要一条语句就能完成一个矩阵乘的计算，这就是我们所说的SIMD（单指令多数据）。因此，我们通常使用AI处理器来进行大量的并行计算。</li>
<li>NPU不能独立运行，需要与CPU协同工作，可以看成是CPU的协处理器，CPU负责整个操作系统运行，管理各类资源并进行复杂的逻辑控制，而NPU主要负责并行计算任务。在基于CPU+NPU的异构计算架构中，NPU与CPU通过PCIe总线连接在一起来协同工作，CPU所在位置称为主机端（host），而NPU所在位置称为设备端（device）</li>
</ul>
<h2 id="ascend-C编程范式"><a href="#ascend-C编程范式" class="headerlink" title="ascend C编程范式"></a>ascend C编程范式</h2><ul>
<li>Ascend C 编程范式是一种流水线式的编程范式，把算子核内的处理程序，分成多个流水任务，通过队列(Queue)完成任务间通信和同步，并通过统一的内存管理模块(Pipe)管理任务间通信内存。流水编程范式应用了流水线并行计算方法。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/10/notebook/Docker/2024-07-10-docker_4_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/10/notebook/Docker/2024-07-10-docker_4_%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">docker_4_常见问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-10 09:00:00" itemprop="dateCreated datePublished" datetime="2024-07-10T09:00:00+08:00">2024-07-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-01 08:52:19" itemprop="dateModified" datetime="2025-05-01T08:52:19+08:00">2025-05-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>记录docker部署下遇到的问题及解决方法</li>
</ul>
<h2 id="docker-拉取镜像超时"><a href="#docker-拉取镜像超时" class="headerlink" title="docker 拉取镜像超时"></a>docker 拉取镜像超时</h2><ul>
<li><p>编辑或新建 &#x2F;etc&#x2F;docker&#x2F;daemon.json</p>
</li>
<li><p>粘贴以下内容：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://docker.registry.cyou&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker-cf.registry.cyou&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://dockercf.jsdelivr.fyi&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.jsdelivr.fyi&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://dockertest.jsdelivr.fyi&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.aliyuncs.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://dockerproxy.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.baidubce.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.m.daocloud.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.nju.edu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.mirrors.sjtug.sjtu.edu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.iscas.ac.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.rainbond.cc&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://do.nark.eu.org&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://dc.j8.work&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://gst6rzl9.mirror.aliyuncs.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;http://mirrors.ustc.edu.cn/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;http://mirrors.sohu.com/&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;registry.docker-cn.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;docker.mirrors.ustc.edu.cn&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;debug&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;experimental&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启docker</p>
<ul>
<li>sudo systemctl docker</li>
</ul>
</li>
<li><p>验证是否生效</p>
<ul>
<li>docker info</li>
</ul>
</li>
<li><p>镜像源要够多</p>
<ul>
<li>不是所有镜像都是用于你当前的网络环境，多加几个备用，不仅速度快，还能防止单点故障</li>
</ul>
</li>
<li><p>添加 insecure-registries</p>
<ul>
<li>有些镜像源不支持HTTPS，或你所在的网络环境中存在中间人干扰，Docker默认不会信任这些源。通过加上insecure-registries，明确告诉Docker信任</li>
</ul>
</li>
<li><p>debug和experimental参数</p>
<ul>
<li>这两个不是解决问题的核心，但是建议开启debug:true。可以打印更多日志方便后续排查</li>
</ul>
</li>
<li><p>引用</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/2301_76849350/article/details/147227440">https://blog.csdn.net/2301_76849350/article/details/147227440</a></li>
</ul>
</li>
</ul>
<h2 id="docker容器日志导致主机磁盘空间满了"><a href="#docker容器日志导致主机磁盘空间满了" class="headerlink" title="docker容器日志导致主机磁盘空间满了"></a>docker容器日志导致主机磁盘空间满了</h2><h3 id="什么是Docker日志"><a href="#什么是Docker日志" class="headerlink" title="什么是Docker日志"></a>什么是Docker日志</h3><ul>
<li>在Docker中，日志是容器生成的所有输出，该输出保存在主机计算机上的日志文件中。这些日志文件可以帮助了解Docker容器的健康问题，调试问题，并监视应用程序行为。Docker在linux上，容器日志一般存放在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;container_id&#x2F; 下面</li>
</ul>
<h3 id="为什么需要清理Docker日志"><a href="#为什么需要清理Docker日志" class="headerlink" title="为什么需要清理Docker日志"></a>为什么需要清理Docker日志</h3><ul>
<li>Docker日志文件可以变得相当大，因为他们持续记录容器生成的所有输出。如果不定期的清理这些日志文件，他们将占用大量的磁盘空间。在服务器上，磁盘空间非常重要。如果磁盘空间不足，将导致系统崩溃或者性能下降。此外，当Docker容器日志过大时，可能会导致调试问题过于复杂或深度，使用Docker日志分析工具成为不可避免的任务。</li>
</ul>
<h3 id="如何清理Docker日志"><a href="#如何清理Docker日志" class="headerlink" title="如何清理Docker日志"></a>如何清理Docker日志</h3><ul>
<li><p>清理Docker日志的最佳方法是通过Docker提供的内置支持在容器运行时管理日志级别并限制日志大小。但是，如果需要清理已经存在的日志文件，则可以用以下方法</p>
</li>
<li><p>使用Docker命令清理</p>
<ul>
<li>清空所有容器的日志文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune --filter &quot;until=24h&quot;</span><br></pre></td></tr></table></figure></li>
<li>这将会删除已经停止容器的日志，最后使用时间超过24h的容器的日志将会被保留，也可以将24h这个参数按需更改。</li>
</ul>
</li>
<li><p>手动清理Docker日志</p>
<ul>
<li>需要找出要删除的容器ID<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">ls</span> -a</span><br></pre></td></tr></table></figure></li>
<li>该命令将返回运行的，停止的和删除的容器列表，以及他们的container id， image 和 names</li>
<li>在主机上找到日志文件，Docker日志文件通常在 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;容器ID&#x2F;容器ID-json.log路径下，其中container_id为需要清理的容器ID</li>
<li>清空日志文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /dev/null &gt; /var/lib/docker/containers/容器ID/容器ID-json.log</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="启动时设置日志文件大小"><a href="#启动时设置日志文件大小" class="headerlink" title="启动时设置日志文件大小"></a>启动时设置日志文件大小</h3><ul>
<li>参考 docker 官方的文档，重启docker启动时增加参数<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --log-opt max-size=10m --log-opt max-file=3 alpine ash</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/02/notebook/Tools/2024-07-02-RTSP%E8%A7%86%E9%A2%91%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/02/notebook/Tools/2024-07-02-RTSP%E8%A7%86%E9%A2%91%E6%B5%81/" class="post-title-link" itemprop="url">RTSP视频流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-02 09:00:00" itemprop="dateCreated datePublished" datetime="2024-07-02T09:00:00+08:00">2024-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="rtsp视频流是什么"><a href="#rtsp视频流是什么" class="headerlink" title="rtsp视频流是什么"></a>rtsp视频流是什么</h2><p>RTSP（Real-Time Streaming Protocol，即实时流传输协议）是一种网络协议，用于控制音频或视频流的传输。RTSP允许客户端从服务器请求媒体流并进行播放、暂停、停止等操作。它通常用于IP摄像头、直播流媒体服务器和其他需要实时流传输的应用场景。</p>
<p>RTSP协议的主要特点包括：</p>
<ol>
<li><strong>实时性</strong>：RTSP适用于需要实时传输音视频的应用，如直播和视频会议。</li>
<li><strong>控制性</strong>：RTSP允许客户端对流媒体进行控制，例如开始、暂停、停止和快进。</li>
<li><strong>独立于传输</strong>：RTSP可以与各种传输协议（如RTP、UDP、TCP等）结合使用，以适应不同的网络环境。</li>
<li><strong>灵活性</strong>：RTSP可以支持不同的媒体格式和传输机制，使其适应各种应用需求。</li>
</ol>
<p>常见的RTSP使用场景包括：</p>
<ul>
<li>网络摄像头（IP摄像头）的实时视频监控</li>
<li>流媒体服务器的直播传输</li>
<li>视频点播（VoD）服务</li>
</ul>
<p>RTSP流的典型URL格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtsp://[用户名]:[密码]@[IP地址]:[端口]/[路径]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtsp://user:password@192.168.1.100:554/stream1</span><br></pre></td></tr></table></figure>

<p>这表示客户端可以使用RTSP协议连接到IP地址为192.168.1.100的服务器，端口为554，并请求路径为<code>/stream1</code>的媒体流。</p>
<h2 id="实时传输协议RTP与RTCP"><a href="#实时传输协议RTP与RTCP" class="headerlink" title="实时传输协议RTP与RTCP"></a>实时传输协议RTP与RTCP</h2><ul>
<li><p>RTP(Real-time Transport Protocol)是用于Internet上针对多媒体数据流的一种传输协议。</p>
</li>
<li><p>RTP协议是建立在UDP协议上的。RTP协议详细说明了在互联网上传递音频和视频的标准数据包格式。RTP协议常用于流媒体系统(配合RTCP协议)，视频会议和视频电话系统(配合H.263或SIP)</p>
</li>
<li><p>RTP本身并没有提供按时发送机制或其他服务质量(Qos)保证，它依赖于底层服务去实现这一过程。RTP并不保证传送或防止无序传送，也不确定底层网络的可靠性。</p>
</li>
<li><p>RTP中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。</p>
</li>
<li><p>实时传输控制协议(Real-time Transport Control Protocol, RTCP)是实时传输协议(RTP)的一个姐妹协议。RTCP为RTP媒体流提供信道外控制。RTCP定期在流媒体会话参加者之间传输控制数据。</p>
</li>
<li><p>RTCP的主要功能是为RTP所提供的服务质量提供反馈。RTCP收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，时延抖动，单向和双向网络延迟等等。</p>
</li>
<li><p>网络应用程序可以利用RTCP所提供的信息试图提高服务质量，比如限制信息流量或改用压缩比较小的编解码器。RTCP本身不提供数据加密或身份认证，其伴生协议STRCP(安全实时传输控制协议)则可以用于此类用途。</p>
</li>
</ul>
<h2 id="RTP协议是什么"><a href="#RTP协议是什么" class="headerlink" title="RTP协议是什么"></a>RTP协议是什么</h2><p>RTP（Real-time Transport Protocol，即实时传输协议）是一种网络协议，专门用于通过IP网络传输实时音视频数据。它是由IETF（Internet Engineering Task Force）定义的标准协议，用于在互联网上传输实时媒体流。</p>
<p>RTP协议的主要特点和功能包括：</p>
<ol>
<li><strong>实时传输</strong>：RTP适用于需要低延迟的实时应用，如视频会议、IP电话和流媒体播放。</li>
<li><strong>数据包封装</strong>：RTP将音视频数据封装成数据包，以便在网络上传输。每个RTP包包含一个序列号和时间戳，用于保证数据包的顺序和同步。</li>
<li><strong>传输质量监控</strong>：RTP通常与RTCP（Real-time Transport Control Protocol，即实时传输控制协议）一起使用。RTCP提供了传输质量的反馈信息，如丢包率、延迟和抖动等，帮助优化传输质量。</li>
<li><strong>灵活性</strong>：RTP支持各种音视频编解码器和媒体格式，使其适用于不同类型的媒体流。</li>
</ol>
<p>RTP通常与其他协议一起使用，如：</p>
<ul>
<li><strong>RTSP（实时流传输协议）</strong>：用于控制RTP流的传输。</li>
<li><strong>SIP（会话发起协议）</strong>：用于建立、修改和终止多媒体会话，如IP电话。</li>
<li><strong>SDP（会话描述协议）</strong>：用于描述多媒体会话的参数，包括媒体类型、格式、传输地址和端口等。</li>
</ul>
<p>一个典型的RTP数据包结构如下：</p>
<ul>
<li><strong>版本号</strong>：指示RTP版本。</li>
<li><strong>序列号</strong>：用于标识数据包的顺序。</li>
<li><strong>时间戳</strong>：用于同步音视频流。</li>
<li><strong>有效负载类型</strong>：指示数据包中承载的媒体类型和编码方式。</li>
<li><strong>源标识符（SSRC）</strong>：唯一标识发送RTP流的源。</li>
</ul>
<p>通过这些特性，RTP能够确保实时音视频数据的有效传输和同步，从而在互联网上提供高质量的实时多媒体通信。</p>
<h2 id="RTCP协议是什么"><a href="#RTCP协议是什么" class="headerlink" title="RTCP协议是什么"></a>RTCP协议是什么</h2><p>RTCP（Real-time Transport Control Protocol，即实时传输控制协议）是一种网络协议，用于与RTP（Real-time Transport Protocol，即实时传输协议）一起工作，提供对实时数据流传输质量的监控和控制。RTCP并不传输媒体数据本身，而是传输控制信息，帮助管理和优化媒体传输。</p>
<p>RTCP的主要功能包括：</p>
<ol>
<li><p><strong>传输质量反馈</strong>：RTCP提供有关传输质量的反馈信息，如数据包丢失率、延迟和抖动。这些信息可以帮助发送方和接收方调整传输参数，以提高传输质量。</p>
</li>
<li><p><strong>参与者标识</strong>：RTCP允许每个参与者报告其标识信息，如名称和邮箱地址。这有助于在多方通信中识别各个参与者。</p>
</li>
<li><p><strong>带宽管理</strong>：RTCP可以帮助控制会话的带宽使用。通过反馈信息，发送方可以调整传输速率，以避免网络拥塞。</p>
</li>
<li><p><strong>同步多媒体流</strong>：RTCP可以协助同步来自不同源的多个RTP流（如音频和视频），以确保它们在接收端正确地同步播放。</p>
</li>
</ol>
<p>RTCP报文类型主要有以下几种：</p>
<ol>
<li><p><strong>SR（Sender Report，发送报告）</strong>：由RTP流的发送者定期发送，包含发送的RTP包数和字节数，以及与接收者同步的时间信息。</p>
</li>
<li><p><strong>RR（Receiver Report，接收报告）</strong>：由RTP流的接收者定期发送，包含接收到的RTP包数、丢包率、往返时间等统计信息。</p>
</li>
<li><p><strong>SDES（Source Description Items，源描述项）</strong>：包含源标识符和相关的文本信息（如参与者的名字）。</p>
</li>
<li><p><strong>BYE</strong>：通知结束会话的消息，表示发送者将退出会话。</p>
</li>
<li><p><strong>APP（Application Specific Message，应用特定消息）</strong>：用于传输特定应用定义的控制信息。</p>
</li>
</ol>
<p>通过与RTP一起使用，RTCP能够提供有效的传输控制和质量管理，确保实时媒体流的传输质量和可靠性。这使得RTCP成为多媒体通信中不可或缺的协议之一。</p>
<h2 id="实时消息传输协议RTMP"><a href="#实时消息传输协议RTMP" class="headerlink" title="实时消息传输协议RTMP"></a>实时消息传输协议RTMP</h2><p>RTMP（Real-Time Messaging Protocol，即实时消息传输协议）是一种由Adobe Systems开发的协议，主要用于在互联网或局域网上进行音频、视频和数据的实时传输。RTMP最初用于支持Adobe Flash播放器，但现已被广泛用于各种流媒体传输应用，尤其是在直播流媒体中。</p>
<p>RTMP的主要特点和功能包括：</p>
<ol>
<li><strong>低延迟传输</strong>：RTMP能够实现低延迟的音视频数据传输，这使其非常适用于直播和实时互动场景。</li>
<li><strong>持续连接</strong>：RTMP通过TCP连接传输数据，保持与服务器的持久连接，以确保数据的可靠传输和最小化延迟。</li>
<li><strong>多路复用</strong>：RTMP支持将音频、视频和控制信息多路复用在一个TCP连接上，从而简化了传输过程。</li>
<li><strong>灵活性</strong>：RTMP支持多种音频和视频编解码器，包括H.264和AAC，这使其能够适应不同的媒体格式和质量要求。</li>
<li><strong>控制消息</strong>：RTMP支持多种控制消息，如暂停、播放、停止等，以便对流媒体进行实时控制。</li>
</ol>
<p>RTMP的传输过程通常分为三个阶段：</p>
<ol>
<li><strong>握手阶段</strong>：客户端和服务器通过交换握手消息建立连接，并协商通信参数。</li>
<li><strong>连接阶段</strong>：客户端向服务器发送连接请求，并建立会话。</li>
<li><strong>数据传输阶段</strong>：客户端和服务器之间开始传输音视频数据和控制消息。</li>
</ol>
<p>RTMP有几个变种，包括：</p>
<ul>
<li><strong>RTMPT（RTMP Tunneled）</strong>：通过HTTP进行封装，以绕过防火墙。</li>
<li><strong>RTMPS（RTMP Secure）</strong>：使用SSL&#x2F;TLS加密的RTMP，提供安全的数据传输。</li>
<li><strong>RTMPE（RTMP Encrypted）</strong>：使用Adobe的加密机制进行加密，提供安全的数据传输。</li>
</ul>
<p>一个典型的RTMP URL格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtmp://[服务器IP或域名]/[应用名称]/[流名称]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtmp://live.example.com/app/stream</span><br></pre></td></tr></table></figure>

<p>这表示客户端可以使用RTMP协议连接到<code>live.example.com</code>服务器，请求<code>app</code>应用中的<code>stream</code>流。</p>
<p>尽管RTMP已经不再是主流，但它仍然在许多直播平台和视频传输系统中使用。现代替代方案如HLS（HTTP Live Streaming）和DASH（Dynamic Adaptive Streaming over HTTP）在许多新应用中更为常见。</p>
<ul>
<li><p>RTMP是Adobe Systems公司为Flash播放器和服务器之间音频，视频和数据传输开发的开放协议。它有三种变种</p>
<ul>
<li>工作在TCP之上的明文协议，使用端口1935</li>
<li>RTMPT封装在HTTP请求之中，可穿越防火墙</li>
<li>RTMPS类似RTMPT，但使用的是HTTPS连接</li>
</ul>
</li>
<li><p>RTMP视频播放的特点是</p>
<ul>
<li>RTMP协议是采用实时的流式传输，所以不会缓存文件到客户端，这种特性说明用户想下载RTMP协议下的视频是比较难的。</li>
<li>视频流可以随意拖动，既可以从任意时间点向服务器发送请求进行播放，并不需要视频有关键帧。相比而言，HTTP协议下视频需要有关键帧才可以随意拖动</li>
<li>RTMP协议支持点播&#x2F;回放(通俗点讲，就是支持把flv, f4v, mp4文件放在RTMP服务器，客户端可以直接播放)，直播(边录制视频边播放)</li>
</ul>
</li>
</ul>
<h2 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h2><p>HLS（HTTP Live Streaming，即HTTP实时流传输协议）是一种基于HTTP的流媒体传输协议，由苹果公司开发。HLS最早在2009年与iOS 3.0一起发布，现已成为一种广泛使用的流媒体传输标准，适用于直播和点播视频。</p>
<p>HLS的主要特点和功能包括：</p>
<ol>
<li><strong>基于HTTP</strong>：HLS使用标准的HTTP协议传输数据，因此能够通过现有的HTTP基础设施（如CDN和HTTP缓存服务器）进行流媒体分发。</li>
<li><strong>分片传输</strong>：HLS将媒体内容分割成小的时间片段（通常是几秒钟的长度），每个片段以单独的HTTP请求进行传输。这种分片传输方式可以更好地适应网络波动，提供更流畅的观看体验。</li>
<li><strong>自适应比特率</strong>：HLS支持自适应比特率传输，客户端可以根据当前的网络状况动态选择不同质量的媒体片段，从而在网络带宽变化时提供最佳的观看体验。</li>
<li><strong>跨平台支持</strong>：HLS不仅支持苹果设备（如iPhone、iPad和Apple TV），还可以在其他操作系统和设备上使用，包括Android设备、智能电视和Web浏览器。</li>
<li><strong>简单实现</strong>：由于HLS基于HTTP协议，实现相对简单，并且容易与现有的Web技术集成。</li>
</ol>
<p>HLS工作流程如下：</p>
<ol>
<li><strong>媒体切片</strong>：服务器将媒体内容分割成一系列小的、连续的TS（MPEG-2 Transport Stream）文件，这些文件通常是几秒钟的长度。</li>
<li><strong>索引文件（M3U8）</strong>：服务器生成一个索引文件（通常是M3U8格式），列出所有媒体片段的URL。这个文件称为播放列表，包含了媒体片段的顺序和位置。</li>
<li><strong>客户端请求</strong>：客户端请求播放列表（M3U8文件），并根据播放列表中的URL逐个请求媒体片段。</li>
<li><strong>播放和缓存</strong>：客户端下载并播放媒体片段，同时可以缓存一定数量的片段以应对网络波动。</li>
</ol>
<p>一个典型的HLS播放列表文件（M3U8）的示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-VERSION:3</span><br><span class="line">#EXT-X-TARGETDURATION:10</span><br><span class="line">#EXT-X-MEDIA-SEQUENCE:0</span><br><span class="line">#EXTINF:10.0,</span><br><span class="line">http://example.com/segment0.ts</span><br><span class="line">#EXTINF:10.0,</span><br><span class="line">http://example.com/segment1.ts</span><br><span class="line">#EXTINF:10.0,</span><br><span class="line">http://example.com/segment2.ts</span><br></pre></td></tr></table></figure>

<p>这个播放列表文件指示客户端依次请求和播放<code>segment0.ts</code>、<code>segment1.ts</code>和<code>segment2.ts</code>，每个片段长度为10秒。</p>
<p>HLS在流媒体行业中得到广泛应用，特别是在直播和视频点播服务中，成为了许多视频传输解决方案的基础。</p>
<ul>
<li>HTTP Live Streaming(HLS)是苹果公司实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播，主要应用于IOS系统。HLS点播是分段HTTP点播，不同在于它的分段非常小。要实现HLS点播，重点在于对媒体文件分段，目前有不少开源工具可以使用。</li>
<li>相对于常见的流媒体直播协议，HLS直播最大的不同在于，直播客户端获得的并不是一个完整的数据流，HLS协议再服务器端将直播数据流存储为连续的，很短时长的媒体文件(MPEG-TS格式)。而客户端则不断的下载并播放这些小文件，因为服务器总是会将最新的直播数据生成新的小文件，这样客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。由此可见，基本上可以认为，HLS是以点播的技术方式实现直播。由于数据通过HTTP协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短，客户端可以很快的选择和切换码率，以适应不同带宽条件下的播放。不过HLS的这种技术特点，决定了它的延迟一般总是会高于普通的流媒体直播协议。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/06/27/notebook/Books/2024-06-27-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8-C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/27/notebook/Books/2024-06-27-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8-C++/" class="post-title-link" itemprop="url">数据结构，算法与应用 C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-27 09:00:00" itemprop="dateCreated datePublished" datetime="2024-06-27T09:00:00+08:00">2024-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>程序开发过程要求我们做到两点：<ul>
<li>高效的数据描述</li>
<li>步骤合理，可用程序实现的算法设计</li>
</ul>
</li>
<li>要做到第一点，必须具备数据结构领域的专门知识</li>
<li>要做到第二点，必须具备算法设计领域的专门知识</li>
</ul>
<h2 id="第一张-C-回顾"><a href="#第一张-C-回顾" class="headerlink" title="第一张 C++回顾"></a>第一张 C++回顾</h2><h2 id="第二章-程序性能分析"><a href="#第二章-程序性能分析" class="headerlink" title="第二章 程序性能分析"></a>第二章 程序性能分析</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>程序最重要的属性是正确性。一个程序，如果不能正确的实现算法，他就没有什么用处。</li>
<li>我们用程序性能(program performance)来指一个程序对内存和时间的需求。要对数据结构和算法设计方法给予应用的评价，就必须能够计算程序性能。</li>
<li>我们用操作数和执行步数来估计程序的运行时间。用符号法来分别描述程序在最好，最坏和平均情况下的运行时间。</li>
<li>本章开发了很多应用程序，这些程序在以后的章节中是很有用处的，他们是<ul>
<li>数组元素的查找</li>
<li>数组元素的排序：排列排序，选择排序，冒泡排序和插入排序</li>
</ul>
</li>
<li>基于霍纳法则的多项式计算</li>
<li>矩阵加法，转置和乘法</li>
</ul>
<h3 id="什么是程序性能"><a href="#什么是程序性能" class="headerlink" title="什么是程序性能"></a>什么是程序性能</h3><ul>
<li><p>所谓程序性能(performance of a program)是指运行这个程序所需要的内存和时间的多少。我们用两种方法来确定一个程序的性能，一个是分析方法，另一个是实验方法。在性能分析(performance analysis)时，采用分析方法，而在性能测量(performance measurement)时，使用实验方法。</p>
</li>
<li><p>所谓一个程序的空间复杂度(space complexity)是指该程序的运行所需内存的大小。我们对程序的空间复杂度感兴趣的主要原因如下</p>
<ul>
<li>如果一个程序要运行在一个多用户计算机系统中，那么我们需要指明该程序所需要内存的大小</li>
<li>在任何一个计算机系统上运行程序，都需要知道是否有足够的内存可以用来运行该程序</li>
<li>一个问题可能有若干个解决方案，他们对内存的需求各不相同</li>
<li>利用空间复杂度，我们可以估算一个程序所能解决的问题最大可以是什么规模。</li>
</ul>
</li>
<li><p>所谓程序的时间复杂度(time complexity)是指运行程序所需要的时间。我们对程序的时间复杂度感兴趣的主要原因如下</p>
<ul>
<li>有些计算机需要用户提供程序运行时间的上限，一旦达到了这个上限，程序将被强制结束。</li>
<li>正在开发的程序可能需要一个令人满意的实时响应。</li>
<li>如果一个问题有多种解决方案，那么具体采用哪一种方案，主要根据这些方案的性能差异。对于各种方案的时间和空间性能，我们将采用加权测量方式进行评价。</li>
</ul>
</li>
</ul>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li><p>程序所需要的空间主要由以下部分构成</p>
<ul>
<li>指令空间(instruction space), 是指编译之后的程序所需要的存储空间</li>
<li>数据空间(data space), 是指所有常量和变量所需要的存储空间。它有两个部分构成<ul>
<li>常量和简单变量所需要的存储空间</li>
<li>动态数组和动态类实例等动态对象所需要的空间</li>
</ul>
</li>
<li>环境栈空间(environment stack space)，是用来保存暂停的函数和方法在恢复运行时所需要的信息。</li>
</ul>
</li>
<li><p>指令空间的数量取决于如下因素</p>
<ul>
<li>把程序转换成机器代码的编译器</li>
<li>在编译时的编译器选项</li>
<li>目标计算机</li>
</ul>
</li>
<li><p>在决定最终代码需要多少空间的时候，编译器是一个最重要的因素。</p>
</li>
<li><p>即使采用相同的编译器，编译后的程序代码也可能不同。因为一个编译器可能具备优化选项。</p>
</li>
<li><p>编译器的覆盖选项也可以显著的减少程序空间。在覆盖模式下，空间仅分配给当前正在执行的程序模块。调用一个新模块需要从磁盘或者其他设备中读取，新模块代码将覆盖原模块的代码。因此，程序所需要的空间便是最大模块所需要的空间，而不是所有模块所需要的空间之和。</p>
</li>
<li><p>对各种数据类型，C++语言并没有指定他们的空间大小，只是大多数C++编译器有相应的空间分配。</p>
</li>
<li><p>一个结构变量的空间大小是每个结构成员所需要的空间大小之和。类似的，一个数组的空间大小是数组的长度乘以一个数组元素的空间大小。</p>
</li>
<li><p>当计算分配给一个数组的空间时，我们只关心分配给数组元素的空间。数组a的空间是100个double类型元素所占用的空间。若每个元素空间是8字节，则数组a的空间是800字节。数组maze有rows*cols个int类型的元素，占用的空间是4 * rows * cols字节。</p>
</li>
<li><p>在开始性能分析时，人们通常会忽略环境栈所需要的空间，因为他们不理解函数(特别是递归函数)是如何被调用的以及在函数调用结束时会发生什么。每当一个函数被调用时，下面的数据将被保存在环境栈中</p>
<ul>
<li>返回地址</li>
<li>正在调用的函数的所有局部变量的值以及形式参数的值(仅对递归函数而言)</li>
</ul>
</li>
<li><p>值得注意的是，有些编译器，不论对递归函数还是非递归函数，在函数调用时，都会保留局部变量和形参的值，而有些编译器仅对递归函数才会如此。因此实际使用的编译器将影响环境栈所需空间的大小。</p>
</li>
<li><p>程序要处理的问题实例都有一些特征，这些特征都包含着可以决定程序空间大小的因素(例如，输入和输出的数量或相关数的大小)。例如，对n个元素排序的程序，它所需要的空间大小是n的函数，n为其实例特征；将两个n x n矩阵累加的程序，n为其实例特征；把两个m x n矩阵相加的程序，m和n为其实例特征。</p>
</li>
<li><p>相对来说，指令空间的大小受实例特征的影响不大。</p>
</li>
<li><p>可以把一个程序所需要的空间分为两部分</p>
<ul>
<li>固定部分。它独立于实例特征。这一部分通常包括指令空间(即代码空间)，简单变量空间和常量空间等</li>
<li>可变部分。它由动态分配空间构成和递归栈空间构成。前者在某种程度上依赖实例特征，而后者主要依赖实例特征。</li>
</ul>
</li>
<li><p>任意程序P所需要的空间可以表示为： c + Sp(实例特征)</p>
<ul>
<li>其中c是一个常量，表示空间需要的固定部分，Sp表示空间需求的可变部分。</li>
</ul>
</li>
<li><p>在分析一个程序的空间复杂度时，我们将集中计算Sp对任意给定的问题，我们首先要确定哪些实例特征可以用来估算空间需求。选择实例特征是一个很具体的问题，我们需要求助于实际的例子来说明各种可能的情况。一般来说，我们的选择仅限于程序输入和输出的规模。有时我们也会对数据项之间的关系进行复杂的估算。</p>
</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li><p>用分析方法确定一个程序的运行时间是复杂的，因此只能估算运行时间。而且有两个比较容易控制的方法</p>
<ul>
<li>找出一个或多个关键操作，确定他们的执行时间</li>
<li>确定程序总的步数</li>
</ul>
</li>
<li><p>估算一个程序或函数的时间复杂度，一种方法是选择一种或者多种关键操作，例如加，乘，比较等，然后 确定每一种操作的执行次数。使用这种方法成功与否取决于是否能够找到耗时最大的操作。</p>
</li>
</ul>
<h2 id="第三章-渐近记法"><a href="#第三章-渐近记法" class="headerlink" title="第三章 渐近记法"></a>第三章 渐近记法</h2><h2 id="第四章-性能测量"><a href="#第四章-性能测量" class="headerlink" title="第四章 性能测量"></a>第四章 性能测量</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul>
<li>性能测量(performance measurement)，关注的是一个程序实际需要的空间和时间。</li>
<li>C++函数 clock() 来测量时间，它用 滴答 数来计时。在头文件 time.h 中定义了常数 CLOCK_PER_SEC，它记录每秒流逝的 滴答 数，并转换成秒。CLOCK_PER_SEC&#x3D;1000，滴答一次等于一毫秒。</li>
</ul>
<h2 id="第五章-线性表-数组描述"><a href="#第五章-线性表-数组描述" class="headerlink" title="第五章 线性表-数组描述"></a>第五章 线性表-数组描述</h2><ul>
<li><p>从本章开始研究数据结构，一直到第16章为止。第5章和第6章集中研究线性表，但主要是介绍数据的描述方法，即数据在计算机内存和磁盘上的存储方式。在随后的章节中，我们研究其他常用的数据结构描述方法。这些数据结构有矩阵，栈，队列，字典，优先级队列，竞赛树，搜索树和图。</p>
</li>
<li><p>C++程序常用的数据描述方法是数组描述和链式描述。线性表可以用来说明这两种方法。</p>
</li>
<li><p>STL容器(vector和list)大致相当于线性表描述方法和链式描述方法。STL的类还有很多其他的方法。在建立线性表的数组描述和链式描述中，我们使用的函数名和签名与STL代码所使用的相同。</p>
</li>
<li><p>数组描述方法将元素存储在一个数组中，用一个数学公式来确定每个元素存储的位置，即在数组中的索引。这是最简单的一种存储方式，所有元素依次存储在一片连续的存储空间中，这就是通常所说的顺序表。</p>
</li>
<li><p>本章引用的数据结构的概念如下</p>
<ul>
<li>抽象数据类型和相应的C++抽象类</li>
<li>线性表</li>
<li>变长数组和数组容量倍增</li>
<li>数组描述</li>
<li>数据结构迭代器</li>
</ul>
</li>
<li><p>本章新增的C++概念</p>
<ul>
<li>抽象类</li>
<li>迭代器</li>
</ul>
</li>
</ul>
<h3 id="数据对象和数据结构"><a href="#数据对象和数据结构" class="headerlink" title="数据对象和数据结构"></a>数据对象和数据结构</h3><ul>
<li><p>数据对象(data object)是一组实例或者值，例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean = &#123;<span class="literal">false</span>, <span class="literal">true</span>&#125;;</span><br><span class="line">digit = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>boolean, digit都是数据对象，true和false是boolean的实例，而0，1—9是digit的实例。</p>
</li>
<li><p>数据对象的一个实例，要么是一个不可再分的原子，要么是由另一个数据对象的实例作为成员复合而成。对后一种情形，用元素(element)来表示这些成员。</p>
</li>
<li><p>数据对象的实例以及构成实例的元素通常都有某种相关性。例如，自然数0是最小的自然数，1是仅比0大的自然数。在串good中，g是第一个字母，o是第二个和第三个字母，而d是最后一个字母。</p>
</li>
<li><p>数据结构(data structure)是一个数据对象，同时这个对象的实例以及构成实例的元素都存在着联系，而且这些联系由相关的函数来规定。</p>
</li>
<li><p>研究数据结构，关心的是数据对象(实际上是实例)的描述以及相关函数的具体实现。数据对象描述的好，函数的实现就会高效。</p>
</li>
</ul>
<h3 id="线性表数据结构"><a href="#线性表数据结构" class="headerlink" title="线性表数据结构"></a>线性表数据结构</h3><ul>
<li><p>线性表(linear list)也称有序表(ordered list)，它的每一个实例都是元素的一个有序集合。</p>
</li>
<li><p>一个线性表可以用一个抽象数据类型(abstract data type, ADT)来说明，既说明它的实例，也说明对他的操作。抽象数据类型的说明独立于任何程序语言的描述。所有对抽象数据类型的语言描述必须满足抽象数据类型的说明，抽象数据类型的说明保证了程序语言描述的有效性。另外，所有满足抽象数据类型说明的语言描述，都可以在应用中替换使用。</p>
</li>
</ul>
<h3 id="数组描述"><a href="#数组描述" class="headerlink" title="数组描述"></a>数组描述</h3><ul>
<li><p>在数组描述(array representation)中，用数组来存储线性表的元素。虽然可以用一个数组存储若干个线性表的实例，但是用不同数组存储每个实例更加容易一些。我们可以用一个数学公式来确定一个线性表的元素在数组中的位置。</p>
</li>
<li><p>假定使用一个一维数组element来存储线性表的元素。数组element的位置有 element[0] — element[arrayLength - 1]，其中arrayLength是数组长度或者容量。数组的每一个位置都可以存储线性表的一个元素。我们需要一个映射，使线性表的一个元素对应数组的一个位置。线性表的第0个元素在数组的什么位置？线性表的最后一个元素在数组的什么位置？这种映射可以用下面的一个公式来表示</p>
<ul>
<li>location(i) &#x3D; i</li>
</ul>
</li>
<li><p>一维数组a，线性表元素存储在a[0:n-1]中，要增加或者减少这个数组的长度，首先要建立一个具有新长度的数组，然后把数组a的元素复制到这个新数组，最后改变数组a的值，使它能够引用到新数组。</p>
</li>
<li><p>当数组满而需要加大数组长度时，数组长度常常是要加倍的。这个过程称为数组倍增(array doubling)。数组倍增的时间，从渐近意义上考量，不会大于元素插入的总时间。</p>
</li>
<li><p>为什么数组长度不是增加1或2，而是要加倍呢？数组长度每次增加1或2，虽然不影响插入操作的最坏时间复杂度，但是影响连续插入时的渐近时间复杂度。</p>
</li>
<li><p>定理：如果我们总是按一个乘法因子来增加数组长度，那么实施一系列线性表的操作所需要的时间与不用改变数组长度时相比，至多增加一个常数因子。</p>
</li>
</ul>
<h3 id="C-迭代器"><a href="#C-迭代器" class="headerlink" title="C++ 迭代器"></a>C++ 迭代器</h3><ul>
<li><p>一个迭代器(iterator)是一个指针，指向对象的一个元素(例如，一个指向数组元素的指针)。顾名思义，一个迭代器可以用来逐个访问对象的所有元素。</p>
</li>
<li><p>迭代器是编写C++通用算法的基础概念。STL的copy函数便是用来复制任何具有迭代器的对象的元素。</p>
</li>
<li><p>为了简化迭代器的开发和基于迭代器的通用算法的分类，C++的STL定义了5中迭代器：</p>
<ul>
<li>输入，输出，向前，双向和随机访问</li>
</ul>
</li>
<li><p>所有迭代器都具备操作符 &#x3D;&#x3D; ， !&#x3D; 和解引用操作符 *</p>
</li>
<li><p>另外，输入迭代器还提供了对其指向元素的只读操作以及前++和后++操作符。输出迭代器提供了对其指向元素的写操作和++操作符。向前迭代器具有++操作符，而双向迭代器既具有++操作符也具有–操作符。随机访问迭代器是最一般的迭代器，它既可以随意的实现跳跃移动，也可以通过指针算术运算来实现跳跃移动。</p>
</li>
</ul>
<h3 id="vector的描述"><a href="#vector的描述" class="headerlink" title="vector的描述"></a>vector的描述</h3><ul>
<li>STL提供了一个基于数组的类 vector。</li>
</ul>
<h2 id="第六章-链式描述"><a href="#第六章-链式描述" class="headerlink" title="第六章 链式描述"></a>第六章 链式描述</h2><ul>
<li>用数组描述线性表是很自然的，因此你可能以为没有其他的描述方法了。</li>
<li>在链式描述中，线性表的元素在内存中的存储位置是随即的。每个元素都有一个明确的指针或链(指针和链是一个意思)指向线性表的下一个元素的位置(即地址)</li>
<li>在基于数组的描述中，元素的地质是由数学公式决定的。而在链式描述中，元素的地址是随即分布的。</li>
<li>STL的容器类list使用带有头节点的双向循环链表来描述实例。它的方法与vector的方法具有相同的签名和操作。因此，他的erase和insert的签名和抽象类型linearList的要求不同，然而和vector一样，它可以用来设计从抽象类linearList的方法具有相同的签名和操作。</li>
</ul>
<h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><ul>
<li><p>描述</p>
<ul>
<li>在链式描述中，数据对象实例的每一个元素都用一个单元或节点来描述。节点不必是数组成员，因此不是用公式来确定元素的位置。取而代之的是，每一个节点都明确包含另一个相关节点的位置信息，这个信息称为链(link)或指针(pointer)</li>
<li>在对这个线性表的一个可能的链式描述中，每个元素都在一个单独的节点中描述，每一个节点都有一个链域，它的值是线性表的下一个元素的位置，即地址。</li>
<li>一般来说，为了找到索引为theIndex的元素，需要从firstNode开始，跟踪theIndex个指针才能找到。</li>
</ul>
</li>
<li><p>每一个节点只有一个链，这种结构称为单向链表(singly linked list)。链表从左到右，每一个节点(最后一个节点除外)都链接着下一个节点，最后一个节点的链阈值为NULL。这样的结构也称为链条(chain)</p>
</li>
<li><p>结构chainNode</p>
<ul>
<li>为了用链表描述线性表，我们要定义一个结构chainNode和一个类chain。</li>
</ul>
</li>
<li><p>类chain</p>
<ul>
<li>类chain用单向链表实现了线性表，其中最后一个节点的指针域为NULL，即它用单向链接的一组节点实现线性表。</li>
</ul>
</li>
</ul>
<h3 id="循环链表和头节点"><a href="#循环链表和头节点" class="headerlink" title="循环链表和头节点"></a>循环链表和头节点</h3><ul>
<li>两条措施，可以使链表的应用代码简洁和高效<ul>
<li>把线性表描述成一个单向循环链表(singly linked circular list)(简称循环链表)，而不是单向链表</li>
<li>在链表的前面增加一个节点，称为头节点(header node)。只要将单向链表的尾节点与头节点链接起来，单向链表就成为循环链表。</li>
</ul>
</li>
</ul>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><ul>
<li>对于线性表的大多数应用来说，采用链表和&#x2F;或循环链表已经足够了。然而，对于有些应用，如果每个元素节点既有一个指向后继的指针，又有一个指向前驱的指针，就会更加方便。</li>
<li>双向链表(doubly linked list)便是这样一个有序的节点序列，其中每个节点都有两个指针nest和previous。<ul>
<li>next指针指向右边节点(如果存在)</li>
<li>previous指针指向左边节点(如果存在)</li>
</ul>
</li>
</ul>
<h2 id="第七章-数组和矩阵"><a href="#第七章-数组和矩阵" class="headerlink" title="第七章 数组和矩阵"></a>第七章 数组和矩阵</h2><ul>
<li>在实际应用中，数据通常以表的形式出现。尽管用数组来描述表是最自然的方式，但为了减少程序所需的时间和空间，经常采用自定义的描述方式。</li>
<li>本章首先检查了多维数组的行主描述方式和列主描述方式。这些描述方式把多维数组映射成一维数组。</li>
<li>矩阵经常用二维数组来表示。然后，矩阵的索引通过从1开始，而C++的二维数组是从0开始。矩阵的操作有加法，减法和转置，但是C++的二维数组不支持这些操作。因此我们开发了类matrix，它与矩阵的关系密切</li>
<li>我们还要考察具有特殊结构的矩阵，例如对角矩阵，三对角矩阵，三角矩阵和对陈矩阵。关于这些矩阵的描述方法，自定义数组与二维数组相比，不仅大大减少了存储空间安，也减少了大多数矩阵操作的运行时间。</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>抽象数据类型</li>
<li>一个数组的每一个实例都是形如(索引，值)的数对集合，其中任意两个数对的索引(index)都不相同。有关数组的操作如下<ul>
<li>取值： 对一个给定的索引，取对应数对中的值</li>
<li>存值： 把一个新数对加到数对集合中。如果已存在一个索引相同的数对，就用新数对覆盖</li>
</ul>
</li>
<li>这两个操作定义了抽象数据类型array</li>
</ul>
<h3 id="行主映射和列主映射"><a href="#行主映射和列主映射" class="headerlink" title="行主映射和列主映射"></a>行主映射和列主映射</h3><ul>
<li>数组的应用需要我们把数组元素序列化，即按一维顺序排列。例如，数组元素只能一次输出或输入一个。因此，我们必须确定一个输入或输出的顺序。</li>
<li>从第一行开始，依次对每一行的索引从左至右连续编号。它把二维数组的索引映射为 [0, n-1]中的数，这种映射方式称为行主映射(row major mapping)。索引对应的数称为行主次序</li>
<li>另一种映射方式，称为列主映射(column major mapping)。在列主映射中，对索引的编号从最左列开始，依次对每一列的索引从上到下连续编号。</li>
</ul>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><ul>
<li><p>一个m * n的矩阵(matrix)是一个m行，n列的表，m和n是矩阵的维数(dimension)</p>
</li>
<li><p>矩阵通常用来组织数据。</p>
</li>
<li><p>矩阵最常见的操作是矩阵转置，矩阵相加，矩阵相乘。</p>
</li>
<li><p>两个矩阵仅当维数相同时(即它们的行数和列数都分别相等)才可以相加。两个m * n的矩阵A和B相加之后是一个m * n的矩阵C </p>
</li>
<li><p>一个m * n的矩阵A和一个q * p的矩阵B，只有当A的列数等于B的行数(即n&#x3D;q)时，才可以相乘A<em>B。A</em>B的结果是一个m * p的矩阵C</p>
</li>
<li><p>特殊矩阵</p>
<ul>
<li>方阵(square matrix)是行数和列数相同的矩阵。一些常用的特殊方阵如下</li>
<li>对角矩阵(diagonal)</li>
<li>三对角矩阵(tridiagonal)</li>
<li>下三角矩阵(lower triangular)</li>
<li>上三角矩阵(upper triangular)</li>
<li>对陈矩阵(symmetric)</li>
</ul>
</li>
<li><p>一个m * n的矩阵，如果大多数元素都是0,则称为稀疏矩阵(spare matrix)。一个矩阵如果不是稀疏的，就成为稠密矩阵(dense matrix)</p>
</li>
</ul>
<h2 id="第八章-栈"><a href="#第八章-栈" class="headerlink" title="第八章 栈"></a>第八章 栈</h2><ul>
<li><p>栈和队列很可能是应用频率最高的数据结构。在第五章和第六章曾经广泛研究了线性表和有序表数据结构，而栈和队列是它们的限制版。</p>
</li>
<li><p>栈和队列的应用广泛，以至于C++的标准类模板库STL都提供了用数组实现的栈和队列。</p>
</li>
<li><p>把线性表的插入和删除操作限制在同一端进行，就得到栈数据结构。因此，栈是一个后进先出(last-in-first-out, FIFO)的数据结构。因为栈是一种特殊的线性表，所以从相应的线性表类派生出栈类是很自然的事情。</p>
</li>
</ul>
<h3 id="定义和应用"><a href="#定义和应用" class="headerlink" title="定义和应用"></a>定义和应用</h3><ul>
<li><p>栈(stack)是一种特殊的线性表，其插入(也称入栈或压栈)和删除(也称出栈或弹栈)操作都在表的同一端进行。这一端称为栈顶(top),另一端称为栈底(bottom)</p>
</li>
<li><p>计算机是如何执行递归函数？</p>
<ul>
<li>使用递归工作栈(recursion stack)。当一个函数被调用时，一个返回地址(即被调函数一旦执行完，接下去要执行的程序指令的地址)和被调函数的局部变量和形参的值都要存储在递归工作栈中。当执行一次返回时，被调函数的局部变量和形参的值被恢复为调用之前的值(这些值存储在递归工作栈的顶部)，而且程序从返回地址处继续执行，这个返回地址也存储在递归工作栈的顶部。</li>
</ul>
</li>
<li><p>抽象数据类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stack</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">stack</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 返回true，当且仅当栈为空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 返回栈中元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">top</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 返回栈顶元素的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 删除栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; theElement)</span> </span>= <span class="number">0</span>;  <span class="comment">// 将元素theElement压入栈顶</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/06/25/notebook/Tools/2024-06-25-%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%92%8C%E5%88%86%E8%BE%A8%E7%8E%87%E7%9A%84%E8%A7%A3%E9%87%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/25/notebook/Tools/2024-06-25-%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%92%8C%E5%88%86%E8%BE%A8%E7%8E%87%E7%9A%84%E8%A7%A3%E9%87%8A/" class="post-title-link" itemprop="url">显示屏和分辨率的解释</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-25 09:00:00" itemprop="dateCreated datePublished" datetime="2024-06-25T09:00:00+08:00">2024-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="SD、HD、FHD、UHD、FUHD"><a href="#SD、HD、FHD、UHD、FUHD" class="headerlink" title="SD、HD、FHD、UHD、FUHD"></a>SD、HD、FHD、UHD、FUHD</h2><ul>
<li><p>SD(Standard Definition)，标清</p>
<ul>
<li>480p</li>
<li>576p</li>
</ul>
</li>
<li><p>HD(High Definition)，高清</p>
<ul>
<li>720p</li>
</ul>
</li>
<li><p>FHD(Full High Definition)，全高清</p>
<ul>
<li>1080p</li>
</ul>
</li>
<li><p>UHD(Ultra High Definition)，超高清，4k UHD</p>
<ul>
<li>4k</li>
</ul>
</li>
<li><p>FUHD(Full Ultra High Definition)，8k超高清，8k UHD</p>
<ul>
<li>8k</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/06/25/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-06-25-return%E4%B8%8Eexit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/25/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-06-25-return%E4%B8%8Eexit/" class="post-title-link" itemprop="url">return 与 exit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-25 09:00:00" itemprop="dateCreated datePublished" datetime="2024-06-25T09:00:00+08:00">2024-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><ul>
<li><p>return，它的主要任务是在函数结束时将控制权交还给调用他的代码。</p>
</li>
<li><p>return不仅可以返回基本数据类型，还可以返回复杂的数据结构，例如对象和数组。</p>
</li>
<li><p>合理使用return，可以使代码更加简洁明了。在进行条件判断时，我们可以在条件满足时立即返回，避免不必要的嵌套。</p>
</li>
</ul>
<h2 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h2><ul>
<li><p>exit，它不仅仅是结束当前的函数，而是终止整个程序的执行，立即返回给操作系统。</p>
</li>
<li><p>应急处理和日志记录。在一些关键任务中，遇到不可恢复的错误时，我们可以使用exit来终止程序，并在退出前记录错误日志，以便后续分析。</p>
</li>
<li><p>注册清理函数。使用atexit函数，我们可以在程序终止时执行一些清理工作，例如释放资源或者保存程序状态</p>
</li>
</ul>
<h2 id="return-与-exit的对比和选择"><a href="#return-与-exit的对比和选择" class="headerlink" title="return 与 exit的对比和选择"></a>return 与 exit的对比和选择</h2><ul>
<li><p>作用范围</p>
<ul>
<li>return 仅终止当前函数，返回到调用者</li>
<li>exit 终止整个程序的执行</li>
</ul>
</li>
<li><p>清理操作</p>
<ul>
<li>return 执行当前函数的清理工作</li>
<li>exit 执行全局和静态对象的析沟函数，并调用通过atexit注册的函数</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li>return 用于函数结束后返回结果</li>
<li>exit 用于遇到不可恢复错误或者需要立即终止程序的情况</li>
</ul>
</li>
<li><p>综合考虑</p>
<ul>
<li>在实际开发中，我们应该优先使用return进行正常的函数返回，以保持代码的可读性和可维护性。而exit应仅在特殊情况下使用，确保在调用前做好必要的清理工作和日志记录。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/06/22/notebook/Tools/2024-06-22-cpu_gpu_npu_tpu%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/22/notebook/Tools/2024-06-22-cpu_gpu_npu_tpu%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">CPU,GPU,NPT,TPU的联系和区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-06-22T09:00:00+08:00">2024-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>CPU(Central Processing Unit),即中央处理器</li>
<li>GPU(Graphics Processing Unit), 即图形处理器</li>
<li>TPU(Tensor Processing Unit), 即张量处理器(谷歌)</li>
<li>NPU(Neual network Processing Unit),即神经网络处理器</li>
</ul>
<h2 id="概括三者的区别"><a href="#概括三者的区别" class="headerlink" title="概括三者的区别"></a>概括三者的区别</h2><ul>
<li>CPU虽然有多核，但一般也就几个，每个核都有足够大的缓存和足够多的数字和逻辑运算单元，需要很强的通用性来处理各种不同的数据类型，同时又要逻辑判断又会引入大量的分支跳转和中断的处理，并辅助有很多加速分支判断甚至更复杂的逻辑判断的硬件;</li>
<li>GPU的核数远超CPU，被称为众核(NVIDIA Fermi有512个核)。每个核拥有的缓存大小相对小，数字逻辑运算单元也少而简单(GPU初始时在浮点计算上一直弱于CPU)，面对的则是类型高度统一的、相互无依赖的大规模数据和不需要被打断的纯净的计算环境</li>
<li>TPU是一款为机器学习而定制的芯片，经过了专门深度机器学习方面的训练，它有更高效能(每瓦计算能力)。大致上，相对于现在的处理器有7年的领先优势，宽容度更高，每秒在芯片中可以挤出更多的操作时间，使用更复杂和强大的机器学习模型，将之更快的部署，用户也会更加迅速地获得更智能的结果</li>
<li>所谓NPU， 即神经网络处理器，用电路模拟人类的神经元和突触结构</li>
</ul>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><ul>
<li>CPU（CentralProcessing Unit）中央处理器，是一块超大规模的集成电路，主要逻辑架构包括控制单元Control，运算单元ALU和高速缓冲存储器（Cache）及实现它们之间联系的数据（Data）、控制及状态的总线（Bus）。简单说，就是计算单元、控制单元和存储单元。</li>
<li>CPU遵循的是冯·诺依曼架构，其核心是存储程序&#x2F;数据、串行顺序执行。因此CPU的架构中需要大量的空间去放置存储单元（Cache）和控制单元（Control），相比之下计算单元（ALU）只占据了很小的一部分，所以CPU在进行大规模并行计算方面受到限制，相对而言更擅长于处理逻辑控制。</li>
<li>CPU无法做到大量数据并行计算的能力，但GPU可以。</li>
</ul>
<h2 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h2><ul>
<li>GPU（GraphicsProcessing Unit），即图形处理器，是一种由大量运算单元组成的大规模并行计算架构，早先由CPU中分出来专门用于处理图像并行计算数据，专为同时处理多重并行计算任务而设计。</li>
<li>GPU中也包含基本的计算单元、控制单元和存储单元，但GPU的架构与CPU有很大不同。</li>
<li>与CPU相比，CPU芯片空间的不到20%是ALU，而GPU芯片空间的80%以上是ALU。即GPU拥有更多的ALU用于数据并行处理。</li>
<li>GPU具有如下特点：<ul>
<li>多线程，提供了多核并行计算的基础结构，且核心数非常多，可以支撑大量数据的并行计算，处理神经网络数据远远高效于CPU。</li>
<li>拥有更高的访存速度。</li>
<li>更高的浮点运算能力。</li>
</ul>
</li>
<li>因此，GPU比CPU更适合深度学习中的大量训练数据、大量矩阵、卷积运算。</li>
<li>GPU虽然在并行计算能力上尽显优势，但并不能单独工作，需要CPU的协同处理，对于神经网络模型的构建和数据流的传递还是在CPU上进行。</li>
<li>但是GPU也有天生缺陷，那就是功耗高，体积大，价格贵。</li>
<li>性能越高的GPU体积越大，功耗越高，价格也昂贵，对于一些小型设备、移动设备来说将无法使用。</li>
<li>因此，一种体积小、功耗低、计算性能高、计算效率高的ASIC专用芯片NPU诞生了。</li>
</ul>
<h2 id="NPU"><a href="#NPU" class="headerlink" title="NPU"></a>NPU</h2><ul>
<li>NPU （NeuralNetworks Process Units）神经网络处理单元。其针对于矩阵运算进行了专门的优化设计，解决了传统芯片在神经网络运算时效率低下的问题。NPU工作原理是在电路层模拟人类神经元和突触，并且用深度学习指令集直接处理大规模的神经元和突触，一条指令完成一组神经元的处理。相比于CPU和GPU，NPU通过突出权重实现存储和计算一体化，从而提高运行效率。</li>
<li>神经网络处理器（NPU）<strong>采用“数据驱动并行计算”的架构，</strong>特别擅长处理视频、图像类的海量多媒体数据。NPU处理器专门为物联网人工智能而设计，用于加速神经网络的运算，解决传统芯片在神经网络运算时效率低下的问题。</li>
<li>NPU是模仿生物神经网络而构建的，CPU、GPU处理器需要用数千条指令完成的神经元处理，NPU只要一条或几条就能完成，因此在深度学习的处理效率方面优势明显。</li>
<li>神经网络中存储和处理是一体化的，都是通过突触权重来体现。 冯·诺伊曼结构中，存储和处理是分离的，分别由存储器和运算器来实现，二者之间存在巨大的差异。当用现有的基于冯·诺伊曼结构的经典计算机（如X86处理器和英伟达GPU）来跑神经网络应用时，就不可避免地受到存储和处理分离式结构的制约，因而影响效率。这也就是专门针对人工智能的专业芯片能够对传统芯片有一定先天优势的原因之一。</li>
</ul>
<h2 id="CPU-如何辅助NPU实现加速"><a href="#CPU-如何辅助NPU实现加速" class="headerlink" title="CPU 如何辅助NPU实现加速"></a>CPU 如何辅助NPU实现加速</h2><ul>
<li>NPU与GPU加速不同，主要体现为每层神经元计算结果不用输出到主内存，而是按照神经网络的连接传递到下层神经元继续计算，因此其在运算性能和功耗上都有很大的提升。</li>
<li>CPU将编译好的神经网络模型文件和权重文件交由专用芯片加载，完成硬件编程</li>
</ul>
<h2 id="关于RK1126平台项目的小思考"><a href="#关于RK1126平台项目的小思考" class="headerlink" title="关于RK1126平台项目的小思考"></a>关于RK1126平台项目的小思考</h2><ul>
<li><p>在瑞芯微的1126芯片上有NPU，我接触的有四种检测模型：安全帽检测，区域入侵检测，反光衣检测，烟火检测。软件具体运行流程为：底层视频结构化引擎运行，后端服务运行，将模型配置文件发送给引擎，加载检测模型，将流媒体地址发送给引擎，引擎将视频流解码为一帧帧图片，将图片处理为检测模型需要的格式，这一步一般称为预处理，由检测模型返回检测结果，引擎处理成结构化数据。</p>
</li>
<li><p>检测模型就是神经网络模型文件和权重文件。底层引擎通过平台提供的接口，将检测模型加载到NPU上。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/06/20/notebook/Compiler/2024-06-20-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/20/notebook/Compiler/2024-06-20-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">交叉编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-20 09:00:00" itemprop="dateCreated datePublished" datetime="2024-06-20T09:00:00+08:00">2024-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Compiler/" itemprop="url" rel="index"><span itemprop="name">Compiler</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>交叉编译相关笔记</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/06/20/notebook/Compiler/2024-06-20-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
