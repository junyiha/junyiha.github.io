<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/11/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/07/02/notebook/Tools/2024-07-02-RTSP%E8%A7%86%E9%A2%91%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/02/notebook/Tools/2024-07-02-RTSP%E8%A7%86%E9%A2%91%E6%B5%81/" class="post-title-link" itemprop="url">RTSP视频流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-07-02 09:00:00" itemprop="dateCreated datePublished" datetime="2024-07-02T09:00:00+08:00">2024-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="rtsp视频流是什么"><a href="#rtsp视频流是什么" class="headerlink" title="rtsp视频流是什么"></a>rtsp视频流是什么</h2><p>RTSP（Real-Time Streaming Protocol，即实时流传输协议）是一种网络协议，用于控制音频或视频流的传输。RTSP允许客户端从服务器请求媒体流并进行播放、暂停、停止等操作。它通常用于IP摄像头、直播流媒体服务器和其他需要实时流传输的应用场景。</p>
<p>RTSP协议的主要特点包括：</p>
<ol>
<li><strong>实时性</strong>：RTSP适用于需要实时传输音视频的应用，如直播和视频会议。</li>
<li><strong>控制性</strong>：RTSP允许客户端对流媒体进行控制，例如开始、暂停、停止和快进。</li>
<li><strong>独立于传输</strong>：RTSP可以与各种传输协议（如RTP、UDP、TCP等）结合使用，以适应不同的网络环境。</li>
<li><strong>灵活性</strong>：RTSP可以支持不同的媒体格式和传输机制，使其适应各种应用需求。</li>
</ol>
<p>常见的RTSP使用场景包括：</p>
<ul>
<li>网络摄像头（IP摄像头）的实时视频监控</li>
<li>流媒体服务器的直播传输</li>
<li>视频点播（VoD）服务</li>
</ul>
<p>RTSP流的典型URL格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtsp://[用户名]:[密码]@[IP地址]:[端口]/[路径]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtsp://user:password@192.168.1.100:554/stream1</span><br></pre></td></tr></table></figure>

<p>这表示客户端可以使用RTSP协议连接到IP地址为192.168.1.100的服务器，端口为554，并请求路径为<code>/stream1</code>的媒体流。</p>
<h2 id="实时传输协议RTP与RTCP"><a href="#实时传输协议RTP与RTCP" class="headerlink" title="实时传输协议RTP与RTCP"></a>实时传输协议RTP与RTCP</h2><ul>
<li><p>RTP(Real-time Transport Protocol)是用于Internet上针对多媒体数据流的一种传输协议。</p>
</li>
<li><p>RTP协议是建立在UDP协议上的。RTP协议详细说明了在互联网上传递音频和视频的标准数据包格式。RTP协议常用于流媒体系统(配合RTCP协议)，视频会议和视频电话系统(配合H.263或SIP)</p>
</li>
<li><p>RTP本身并没有提供按时发送机制或其他服务质量(Qos)保证，它依赖于底层服务去实现这一过程。RTP并不保证传送或防止无序传送，也不确定底层网络的可靠性。</p>
</li>
<li><p>RTP中的序列号允许接收方重组发送方的包序列，同时序列号也能用于决定适当的包位置，例如：在视频解码中，就不需要顺序解码。</p>
</li>
<li><p>实时传输控制协议(Real-time Transport Control Protocol, RTCP)是实时传输协议(RTP)的一个姐妹协议。RTCP为RTP媒体流提供信道外控制。RTCP定期在流媒体会话参加者之间传输控制数据。</p>
</li>
<li><p>RTCP的主要功能是为RTP所提供的服务质量提供反馈。RTCP收集相关媒体连接的统计信息，例如：传输字节数，传输分组数，丢失分组数，时延抖动，单向和双向网络延迟等等。</p>
</li>
<li><p>网络应用程序可以利用RTCP所提供的信息试图提高服务质量，比如限制信息流量或改用压缩比较小的编解码器。RTCP本身不提供数据加密或身份认证，其伴生协议STRCP(安全实时传输控制协议)则可以用于此类用途。</p>
</li>
</ul>
<h2 id="RTP协议是什么"><a href="#RTP协议是什么" class="headerlink" title="RTP协议是什么"></a>RTP协议是什么</h2><p>RTP（Real-time Transport Protocol，即实时传输协议）是一种网络协议，专门用于通过IP网络传输实时音视频数据。它是由IETF（Internet Engineering Task Force）定义的标准协议，用于在互联网上传输实时媒体流。</p>
<p>RTP协议的主要特点和功能包括：</p>
<ol>
<li><strong>实时传输</strong>：RTP适用于需要低延迟的实时应用，如视频会议、IP电话和流媒体播放。</li>
<li><strong>数据包封装</strong>：RTP将音视频数据封装成数据包，以便在网络上传输。每个RTP包包含一个序列号和时间戳，用于保证数据包的顺序和同步。</li>
<li><strong>传输质量监控</strong>：RTP通常与RTCP（Real-time Transport Control Protocol，即实时传输控制协议）一起使用。RTCP提供了传输质量的反馈信息，如丢包率、延迟和抖动等，帮助优化传输质量。</li>
<li><strong>灵活性</strong>：RTP支持各种音视频编解码器和媒体格式，使其适用于不同类型的媒体流。</li>
</ol>
<p>RTP通常与其他协议一起使用，如：</p>
<ul>
<li><strong>RTSP（实时流传输协议）</strong>：用于控制RTP流的传输。</li>
<li><strong>SIP（会话发起协议）</strong>：用于建立、修改和终止多媒体会话，如IP电话。</li>
<li><strong>SDP（会话描述协议）</strong>：用于描述多媒体会话的参数，包括媒体类型、格式、传输地址和端口等。</li>
</ul>
<p>一个典型的RTP数据包结构如下：</p>
<ul>
<li><strong>版本号</strong>：指示RTP版本。</li>
<li><strong>序列号</strong>：用于标识数据包的顺序。</li>
<li><strong>时间戳</strong>：用于同步音视频流。</li>
<li><strong>有效负载类型</strong>：指示数据包中承载的媒体类型和编码方式。</li>
<li><strong>源标识符（SSRC）</strong>：唯一标识发送RTP流的源。</li>
</ul>
<p>通过这些特性，RTP能够确保实时音视频数据的有效传输和同步，从而在互联网上提供高质量的实时多媒体通信。</p>
<h2 id="RTCP协议是什么"><a href="#RTCP协议是什么" class="headerlink" title="RTCP协议是什么"></a>RTCP协议是什么</h2><p>RTCP（Real-time Transport Control Protocol，即实时传输控制协议）是一种网络协议，用于与RTP（Real-time Transport Protocol，即实时传输协议）一起工作，提供对实时数据流传输质量的监控和控制。RTCP并不传输媒体数据本身，而是传输控制信息，帮助管理和优化媒体传输。</p>
<p>RTCP的主要功能包括：</p>
<ol>
<li><p><strong>传输质量反馈</strong>：RTCP提供有关传输质量的反馈信息，如数据包丢失率、延迟和抖动。这些信息可以帮助发送方和接收方调整传输参数，以提高传输质量。</p>
</li>
<li><p><strong>参与者标识</strong>：RTCP允许每个参与者报告其标识信息，如名称和邮箱地址。这有助于在多方通信中识别各个参与者。</p>
</li>
<li><p><strong>带宽管理</strong>：RTCP可以帮助控制会话的带宽使用。通过反馈信息，发送方可以调整传输速率，以避免网络拥塞。</p>
</li>
<li><p><strong>同步多媒体流</strong>：RTCP可以协助同步来自不同源的多个RTP流（如音频和视频），以确保它们在接收端正确地同步播放。</p>
</li>
</ol>
<p>RTCP报文类型主要有以下几种：</p>
<ol>
<li><p><strong>SR（Sender Report，发送报告）</strong>：由RTP流的发送者定期发送，包含发送的RTP包数和字节数，以及与接收者同步的时间信息。</p>
</li>
<li><p><strong>RR（Receiver Report，接收报告）</strong>：由RTP流的接收者定期发送，包含接收到的RTP包数、丢包率、往返时间等统计信息。</p>
</li>
<li><p><strong>SDES（Source Description Items，源描述项）</strong>：包含源标识符和相关的文本信息（如参与者的名字）。</p>
</li>
<li><p><strong>BYE</strong>：通知结束会话的消息，表示发送者将退出会话。</p>
</li>
<li><p><strong>APP（Application Specific Message，应用特定消息）</strong>：用于传输特定应用定义的控制信息。</p>
</li>
</ol>
<p>通过与RTP一起使用，RTCP能够提供有效的传输控制和质量管理，确保实时媒体流的传输质量和可靠性。这使得RTCP成为多媒体通信中不可或缺的协议之一。</p>
<h2 id="实时消息传输协议RTMP"><a href="#实时消息传输协议RTMP" class="headerlink" title="实时消息传输协议RTMP"></a>实时消息传输协议RTMP</h2><p>RTMP（Real-Time Messaging Protocol，即实时消息传输协议）是一种由Adobe Systems开发的协议，主要用于在互联网或局域网上进行音频、视频和数据的实时传输。RTMP最初用于支持Adobe Flash播放器，但现已被广泛用于各种流媒体传输应用，尤其是在直播流媒体中。</p>
<p>RTMP的主要特点和功能包括：</p>
<ol>
<li><strong>低延迟传输</strong>：RTMP能够实现低延迟的音视频数据传输，这使其非常适用于直播和实时互动场景。</li>
<li><strong>持续连接</strong>：RTMP通过TCP连接传输数据，保持与服务器的持久连接，以确保数据的可靠传输和最小化延迟。</li>
<li><strong>多路复用</strong>：RTMP支持将音频、视频和控制信息多路复用在一个TCP连接上，从而简化了传输过程。</li>
<li><strong>灵活性</strong>：RTMP支持多种音频和视频编解码器，包括H.264和AAC，这使其能够适应不同的媒体格式和质量要求。</li>
<li><strong>控制消息</strong>：RTMP支持多种控制消息，如暂停、播放、停止等，以便对流媒体进行实时控制。</li>
</ol>
<p>RTMP的传输过程通常分为三个阶段：</p>
<ol>
<li><strong>握手阶段</strong>：客户端和服务器通过交换握手消息建立连接，并协商通信参数。</li>
<li><strong>连接阶段</strong>：客户端向服务器发送连接请求，并建立会话。</li>
<li><strong>数据传输阶段</strong>：客户端和服务器之间开始传输音视频数据和控制消息。</li>
</ol>
<p>RTMP有几个变种，包括：</p>
<ul>
<li><strong>RTMPT（RTMP Tunneled）</strong>：通过HTTP进行封装，以绕过防火墙。</li>
<li><strong>RTMPS（RTMP Secure）</strong>：使用SSL&#x2F;TLS加密的RTMP，提供安全的数据传输。</li>
<li><strong>RTMPE（RTMP Encrypted）</strong>：使用Adobe的加密机制进行加密，提供安全的数据传输。</li>
</ul>
<p>一个典型的RTMP URL格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtmp://[服务器IP或域名]/[应用名称]/[流名称]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtmp://live.example.com/app/stream</span><br></pre></td></tr></table></figure>

<p>这表示客户端可以使用RTMP协议连接到<code>live.example.com</code>服务器，请求<code>app</code>应用中的<code>stream</code>流。</p>
<p>尽管RTMP已经不再是主流，但它仍然在许多直播平台和视频传输系统中使用。现代替代方案如HLS（HTTP Live Streaming）和DASH（Dynamic Adaptive Streaming over HTTP）在许多新应用中更为常见。</p>
<ul>
<li><p>RTMP是Adobe Systems公司为Flash播放器和服务器之间音频，视频和数据传输开发的开放协议。它有三种变种</p>
<ul>
<li>工作在TCP之上的明文协议，使用端口1935</li>
<li>RTMPT封装在HTTP请求之中，可穿越防火墙</li>
<li>RTMPS类似RTMPT，但使用的是HTTPS连接</li>
</ul>
</li>
<li><p>RTMP视频播放的特点是</p>
<ul>
<li>RTMP协议是采用实时的流式传输，所以不会缓存文件到客户端，这种特性说明用户想下载RTMP协议下的视频是比较难的。</li>
<li>视频流可以随意拖动，既可以从任意时间点向服务器发送请求进行播放，并不需要视频有关键帧。相比而言，HTTP协议下视频需要有关键帧才可以随意拖动</li>
<li>RTMP协议支持点播&#x2F;回放(通俗点讲，就是支持把flv, f4v, mp4文件放在RTMP服务器，客户端可以直接播放)，直播(边录制视频边播放)</li>
</ul>
</li>
</ul>
<h2 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h2><p>HLS（HTTP Live Streaming，即HTTP实时流传输协议）是一种基于HTTP的流媒体传输协议，由苹果公司开发。HLS最早在2009年与iOS 3.0一起发布，现已成为一种广泛使用的流媒体传输标准，适用于直播和点播视频。</p>
<p>HLS的主要特点和功能包括：</p>
<ol>
<li><strong>基于HTTP</strong>：HLS使用标准的HTTP协议传输数据，因此能够通过现有的HTTP基础设施（如CDN和HTTP缓存服务器）进行流媒体分发。</li>
<li><strong>分片传输</strong>：HLS将媒体内容分割成小的时间片段（通常是几秒钟的长度），每个片段以单独的HTTP请求进行传输。这种分片传输方式可以更好地适应网络波动，提供更流畅的观看体验。</li>
<li><strong>自适应比特率</strong>：HLS支持自适应比特率传输，客户端可以根据当前的网络状况动态选择不同质量的媒体片段，从而在网络带宽变化时提供最佳的观看体验。</li>
<li><strong>跨平台支持</strong>：HLS不仅支持苹果设备（如iPhone、iPad和Apple TV），还可以在其他操作系统和设备上使用，包括Android设备、智能电视和Web浏览器。</li>
<li><strong>简单实现</strong>：由于HLS基于HTTP协议，实现相对简单，并且容易与现有的Web技术集成。</li>
</ol>
<p>HLS工作流程如下：</p>
<ol>
<li><strong>媒体切片</strong>：服务器将媒体内容分割成一系列小的、连续的TS（MPEG-2 Transport Stream）文件，这些文件通常是几秒钟的长度。</li>
<li><strong>索引文件（M3U8）</strong>：服务器生成一个索引文件（通常是M3U8格式），列出所有媒体片段的URL。这个文件称为播放列表，包含了媒体片段的顺序和位置。</li>
<li><strong>客户端请求</strong>：客户端请求播放列表（M3U8文件），并根据播放列表中的URL逐个请求媒体片段。</li>
<li><strong>播放和缓存</strong>：客户端下载并播放媒体片段，同时可以缓存一定数量的片段以应对网络波动。</li>
</ol>
<p>一个典型的HLS播放列表文件（M3U8）的示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-VERSION:3</span><br><span class="line">#EXT-X-TARGETDURATION:10</span><br><span class="line">#EXT-X-MEDIA-SEQUENCE:0</span><br><span class="line">#EXTINF:10.0,</span><br><span class="line">http://example.com/segment0.ts</span><br><span class="line">#EXTINF:10.0,</span><br><span class="line">http://example.com/segment1.ts</span><br><span class="line">#EXTINF:10.0,</span><br><span class="line">http://example.com/segment2.ts</span><br></pre></td></tr></table></figure>

<p>这个播放列表文件指示客户端依次请求和播放<code>segment0.ts</code>、<code>segment1.ts</code>和<code>segment2.ts</code>，每个片段长度为10秒。</p>
<p>HLS在流媒体行业中得到广泛应用，特别是在直播和视频点播服务中，成为了许多视频传输解决方案的基础。</p>
<ul>
<li>HTTP Live Streaming(HLS)是苹果公司实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播，主要应用于IOS系统。HLS点播是分段HTTP点播，不同在于它的分段非常小。要实现HLS点播，重点在于对媒体文件分段，目前有不少开源工具可以使用。</li>
<li>相对于常见的流媒体直播协议，HLS直播最大的不同在于，直播客户端获得的并不是一个完整的数据流，HLS协议再服务器端将直播数据流存储为连续的，很短时长的媒体文件(MPEG-TS格式)。而客户端则不断的下载并播放这些小文件，因为服务器总是会将最新的直播数据生成新的小文件，这样客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。由此可见，基本上可以认为，HLS是以点播的技术方式实现直播。由于数据通过HTTP协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短，客户端可以很快的选择和切换码率，以适应不同带宽条件下的播放。不过HLS的这种技术特点，决定了它的延迟一般总是会高于普通的流媒体直播协议。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/06/27/notebook/Books/2024-06-27-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8-C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/27/notebook/Books/2024-06-27-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8-C++/" class="post-title-link" itemprop="url">数据结构，算法与应用 C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-27 09:00:00" itemprop="dateCreated datePublished" datetime="2024-06-27T09:00:00+08:00">2024-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>程序开发过程要求我们做到两点：<ul>
<li>高效的数据描述</li>
<li>步骤合理，可用程序实现的算法设计</li>
</ul>
</li>
<li>要做到第一点，必须具备数据结构领域的专门知识</li>
<li>要做到第二点，必须具备算法设计领域的专门知识</li>
</ul>
<h2 id="第一张-C-回顾"><a href="#第一张-C-回顾" class="headerlink" title="第一张 C++回顾"></a>第一张 C++回顾</h2><h2 id="第二章-程序性能分析"><a href="#第二章-程序性能分析" class="headerlink" title="第二章 程序性能分析"></a>第二章 程序性能分析</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>程序最重要的属性是正确性。一个程序，如果不能正确的实现算法，他就没有什么用处。</li>
<li>我们用程序性能(program performance)来指一个程序对内存和时间的需求。要对数据结构和算法设计方法给予应用的评价，就必须能够计算程序性能。</li>
<li>我们用操作数和执行步数来估计程序的运行时间。用符号法来分别描述程序在最好，最坏和平均情况下的运行时间。</li>
<li>本章开发了很多应用程序，这些程序在以后的章节中是很有用处的，他们是<ul>
<li>数组元素的查找</li>
<li>数组元素的排序：排列排序，选择排序，冒泡排序和插入排序</li>
</ul>
</li>
<li>基于霍纳法则的多项式计算</li>
<li>矩阵加法，转置和乘法</li>
</ul>
<h3 id="什么是程序性能"><a href="#什么是程序性能" class="headerlink" title="什么是程序性能"></a>什么是程序性能</h3><ul>
<li><p>所谓程序性能(performance of a program)是指运行这个程序所需要的内存和时间的多少。我们用两种方法来确定一个程序的性能，一个是分析方法，另一个是实验方法。在性能分析(performance analysis)时，采用分析方法，而在性能测量(performance measurement)时，使用实验方法。</p>
</li>
<li><p>所谓一个程序的空间复杂度(space complexity)是指该程序的运行所需内存的大小。我们对程序的空间复杂度感兴趣的主要原因如下</p>
<ul>
<li>如果一个程序要运行在一个多用户计算机系统中，那么我们需要指明该程序所需要内存的大小</li>
<li>在任何一个计算机系统上运行程序，都需要知道是否有足够的内存可以用来运行该程序</li>
<li>一个问题可能有若干个解决方案，他们对内存的需求各不相同</li>
<li>利用空间复杂度，我们可以估算一个程序所能解决的问题最大可以是什么规模。</li>
</ul>
</li>
<li><p>所谓程序的时间复杂度(time complexity)是指运行程序所需要的时间。我们对程序的时间复杂度感兴趣的主要原因如下</p>
<ul>
<li>有些计算机需要用户提供程序运行时间的上限，一旦达到了这个上限，程序将被强制结束。</li>
<li>正在开发的程序可能需要一个令人满意的实时响应。</li>
<li>如果一个问题有多种解决方案，那么具体采用哪一种方案，主要根据这些方案的性能差异。对于各种方案的时间和空间性能，我们将采用加权测量方式进行评价。</li>
</ul>
</li>
</ul>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><ul>
<li><p>程序所需要的空间主要由以下部分构成</p>
<ul>
<li>指令空间(instruction space), 是指编译之后的程序所需要的存储空间</li>
<li>数据空间(data space), 是指所有常量和变量所需要的存储空间。它有两个部分构成<ul>
<li>常量和简单变量所需要的存储空间</li>
<li>动态数组和动态类实例等动态对象所需要的空间</li>
</ul>
</li>
<li>环境栈空间(environment stack space)，是用来保存暂停的函数和方法在恢复运行时所需要的信息。</li>
</ul>
</li>
<li><p>指令空间的数量取决于如下因素</p>
<ul>
<li>把程序转换成机器代码的编译器</li>
<li>在编译时的编译器选项</li>
<li>目标计算机</li>
</ul>
</li>
<li><p>在决定最终代码需要多少空间的时候，编译器是一个最重要的因素。</p>
</li>
<li><p>即使采用相同的编译器，编译后的程序代码也可能不同。因为一个编译器可能具备优化选项。</p>
</li>
<li><p>编译器的覆盖选项也可以显著的减少程序空间。在覆盖模式下，空间仅分配给当前正在执行的程序模块。调用一个新模块需要从磁盘或者其他设备中读取，新模块代码将覆盖原模块的代码。因此，程序所需要的空间便是最大模块所需要的空间，而不是所有模块所需要的空间之和。</p>
</li>
<li><p>对各种数据类型，C++语言并没有指定他们的空间大小，只是大多数C++编译器有相应的空间分配。</p>
</li>
<li><p>一个结构变量的空间大小是每个结构成员所需要的空间大小之和。类似的，一个数组的空间大小是数组的长度乘以一个数组元素的空间大小。</p>
</li>
<li><p>当计算分配给一个数组的空间时，我们只关心分配给数组元素的空间。数组a的空间是100个double类型元素所占用的空间。若每个元素空间是8字节，则数组a的空间是800字节。数组maze有rows*cols个int类型的元素，占用的空间是4 * rows * cols字节。</p>
</li>
<li><p>在开始性能分析时，人们通常会忽略环境栈所需要的空间，因为他们不理解函数(特别是递归函数)是如何被调用的以及在函数调用结束时会发生什么。每当一个函数被调用时，下面的数据将被保存在环境栈中</p>
<ul>
<li>返回地址</li>
<li>正在调用的函数的所有局部变量的值以及形式参数的值(仅对递归函数而言)</li>
</ul>
</li>
<li><p>值得注意的是，有些编译器，不论对递归函数还是非递归函数，在函数调用时，都会保留局部变量和形参的值，而有些编译器仅对递归函数才会如此。因此实际使用的编译器将影响环境栈所需空间的大小。</p>
</li>
<li><p>程序要处理的问题实例都有一些特征，这些特征都包含着可以决定程序空间大小的因素(例如，输入和输出的数量或相关数的大小)。例如，对n个元素排序的程序，它所需要的空间大小是n的函数，n为其实例特征；将两个n x n矩阵累加的程序，n为其实例特征；把两个m x n矩阵相加的程序，m和n为其实例特征。</p>
</li>
<li><p>相对来说，指令空间的大小受实例特征的影响不大。</p>
</li>
<li><p>可以把一个程序所需要的空间分为两部分</p>
<ul>
<li>固定部分。它独立于实例特征。这一部分通常包括指令空间(即代码空间)，简单变量空间和常量空间等</li>
<li>可变部分。它由动态分配空间构成和递归栈空间构成。前者在某种程度上依赖实例特征，而后者主要依赖实例特征。</li>
</ul>
</li>
<li><p>任意程序P所需要的空间可以表示为： c + Sp(实例特征)</p>
<ul>
<li>其中c是一个常量，表示空间需要的固定部分，Sp表示空间需求的可变部分。</li>
</ul>
</li>
<li><p>在分析一个程序的空间复杂度时，我们将集中计算Sp对任意给定的问题，我们首先要确定哪些实例特征可以用来估算空间需求。选择实例特征是一个很具体的问题，我们需要求助于实际的例子来说明各种可能的情况。一般来说，我们的选择仅限于程序输入和输出的规模。有时我们也会对数据项之间的关系进行复杂的估算。</p>
</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li><p>用分析方法确定一个程序的运行时间是复杂的，因此只能估算运行时间。而且有两个比较容易控制的方法</p>
<ul>
<li>找出一个或多个关键操作，确定他们的执行时间</li>
<li>确定程序总的步数</li>
</ul>
</li>
<li><p>估算一个程序或函数的时间复杂度，一种方法是选择一种或者多种关键操作，例如加，乘，比较等，然后 确定每一种操作的执行次数。使用这种方法成功与否取决于是否能够找到耗时最大的操作。</p>
</li>
</ul>
<h2 id="第三章-渐近记法"><a href="#第三章-渐近记法" class="headerlink" title="第三章 渐近记法"></a>第三章 渐近记法</h2><h2 id="第四章-性能测量"><a href="#第四章-性能测量" class="headerlink" title="第四章 性能测量"></a>第四章 性能测量</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul>
<li>性能测量(performance measurement)，关注的是一个程序实际需要的空间和时间。</li>
<li>C++函数 clock() 来测量时间，它用 滴答 数来计时。在头文件 time.h 中定义了常数 CLOCK_PER_SEC，它记录每秒流逝的 滴答 数，并转换成秒。CLOCK_PER_SEC&#x3D;1000，滴答一次等于一毫秒。</li>
</ul>
<h2 id="第五章-线性表-数组描述"><a href="#第五章-线性表-数组描述" class="headerlink" title="第五章 线性表-数组描述"></a>第五章 线性表-数组描述</h2><ul>
<li><p>从本章开始研究数据结构，一直到第16章为止。第5章和第6章集中研究线性表，但主要是介绍数据的描述方法，即数据在计算机内存和磁盘上的存储方式。在随后的章节中，我们研究其他常用的数据结构描述方法。这些数据结构有矩阵，栈，队列，字典，优先级队列，竞赛树，搜索树和图。</p>
</li>
<li><p>C++程序常用的数据描述方法是数组描述和链式描述。线性表可以用来说明这两种方法。</p>
</li>
<li><p>STL容器(vector和list)大致相当于线性表描述方法和链式描述方法。STL的类还有很多其他的方法。在建立线性表的数组描述和链式描述中，我们使用的函数名和签名与STL代码所使用的相同。</p>
</li>
<li><p>数组描述方法将元素存储在一个数组中，用一个数学公式来确定每个元素存储的位置，即在数组中的索引。这是最简单的一种存储方式，所有元素依次存储在一片连续的存储空间中，这就是通常所说的顺序表。</p>
</li>
<li><p>本章引用的数据结构的概念如下</p>
<ul>
<li>抽象数据类型和相应的C++抽象类</li>
<li>线性表</li>
<li>变长数组和数组容量倍增</li>
<li>数组描述</li>
<li>数据结构迭代器</li>
</ul>
</li>
<li><p>本章新增的C++概念</p>
<ul>
<li>抽象类</li>
<li>迭代器</li>
</ul>
</li>
</ul>
<h3 id="数据对象和数据结构"><a href="#数据对象和数据结构" class="headerlink" title="数据对象和数据结构"></a>数据对象和数据结构</h3><ul>
<li><p>数据对象(data object)是一组实例或者值，例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean = &#123;<span class="literal">false</span>, <span class="literal">true</span>&#125;;</span><br><span class="line">digit = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>boolean, digit都是数据对象，true和false是boolean的实例，而0，1—9是digit的实例。</p>
</li>
<li><p>数据对象的一个实例，要么是一个不可再分的原子，要么是由另一个数据对象的实例作为成员复合而成。对后一种情形，用元素(element)来表示这些成员。</p>
</li>
<li><p>数据对象的实例以及构成实例的元素通常都有某种相关性。例如，自然数0是最小的自然数，1是仅比0大的自然数。在串good中，g是第一个字母，o是第二个和第三个字母，而d是最后一个字母。</p>
</li>
<li><p>数据结构(data structure)是一个数据对象，同时这个对象的实例以及构成实例的元素都存在着联系，而且这些联系由相关的函数来规定。</p>
</li>
<li><p>研究数据结构，关心的是数据对象(实际上是实例)的描述以及相关函数的具体实现。数据对象描述的好，函数的实现就会高效。</p>
</li>
</ul>
<h3 id="线性表数据结构"><a href="#线性表数据结构" class="headerlink" title="线性表数据结构"></a>线性表数据结构</h3><ul>
<li><p>线性表(linear list)也称有序表(ordered list)，它的每一个实例都是元素的一个有序集合。</p>
</li>
<li><p>一个线性表可以用一个抽象数据类型(abstract data type, ADT)来说明，既说明它的实例，也说明对他的操作。抽象数据类型的说明独立于任何程序语言的描述。所有对抽象数据类型的语言描述必须满足抽象数据类型的说明，抽象数据类型的说明保证了程序语言描述的有效性。另外，所有满足抽象数据类型说明的语言描述，都可以在应用中替换使用。</p>
</li>
</ul>
<h3 id="数组描述"><a href="#数组描述" class="headerlink" title="数组描述"></a>数组描述</h3><ul>
<li><p>在数组描述(array representation)中，用数组来存储线性表的元素。虽然可以用一个数组存储若干个线性表的实例，但是用不同数组存储每个实例更加容易一些。我们可以用一个数学公式来确定一个线性表的元素在数组中的位置。</p>
</li>
<li><p>假定使用一个一维数组element来存储线性表的元素。数组element的位置有 element[0] — element[arrayLength - 1]，其中arrayLength是数组长度或者容量。数组的每一个位置都可以存储线性表的一个元素。我们需要一个映射，使线性表的一个元素对应数组的一个位置。线性表的第0个元素在数组的什么位置？线性表的最后一个元素在数组的什么位置？这种映射可以用下面的一个公式来表示</p>
<ul>
<li>location(i) &#x3D; i</li>
</ul>
</li>
<li><p>一维数组a，线性表元素存储在a[0:n-1]中，要增加或者减少这个数组的长度，首先要建立一个具有新长度的数组，然后把数组a的元素复制到这个新数组，最后改变数组a的值，使它能够引用到新数组。</p>
</li>
<li><p>当数组满而需要加大数组长度时，数组长度常常是要加倍的。这个过程称为数组倍增(array doubling)。数组倍增的时间，从渐近意义上考量，不会大于元素插入的总时间。</p>
</li>
<li><p>为什么数组长度不是增加1或2，而是要加倍呢？数组长度每次增加1或2，虽然不影响插入操作的最坏时间复杂度，但是影响连续插入时的渐近时间复杂度。</p>
</li>
<li><p>定理：如果我们总是按一个乘法因子来增加数组长度，那么实施一系列线性表的操作所需要的时间与不用改变数组长度时相比，至多增加一个常数因子。</p>
</li>
</ul>
<h3 id="C-迭代器"><a href="#C-迭代器" class="headerlink" title="C++ 迭代器"></a>C++ 迭代器</h3><ul>
<li><p>一个迭代器(iterator)是一个指针，指向对象的一个元素(例如，一个指向数组元素的指针)。顾名思义，一个迭代器可以用来逐个访问对象的所有元素。</p>
</li>
<li><p>迭代器是编写C++通用算法的基础概念。STL的copy函数便是用来复制任何具有迭代器的对象的元素。</p>
</li>
<li><p>为了简化迭代器的开发和基于迭代器的通用算法的分类，C++的STL定义了5中迭代器：</p>
<ul>
<li>输入，输出，向前，双向和随机访问</li>
</ul>
</li>
<li><p>所有迭代器都具备操作符 &#x3D;&#x3D; ， !&#x3D; 和解引用操作符 *</p>
</li>
<li><p>另外，输入迭代器还提供了对其指向元素的只读操作以及前++和后++操作符。输出迭代器提供了对其指向元素的写操作和++操作符。向前迭代器具有++操作符，而双向迭代器既具有++操作符也具有–操作符。随机访问迭代器是最一般的迭代器，它既可以随意的实现跳跃移动，也可以通过指针算术运算来实现跳跃移动。</p>
</li>
</ul>
<h3 id="vector的描述"><a href="#vector的描述" class="headerlink" title="vector的描述"></a>vector的描述</h3><ul>
<li>STL提供了一个基于数组的类 vector。</li>
</ul>
<h2 id="第六章-链式描述"><a href="#第六章-链式描述" class="headerlink" title="第六章 链式描述"></a>第六章 链式描述</h2><ul>
<li>用数组描述线性表是很自然的，因此你可能以为没有其他的描述方法了。</li>
<li>在链式描述中，线性表的元素在内存中的存储位置是随即的。每个元素都有一个明确的指针或链(指针和链是一个意思)指向线性表的下一个元素的位置(即地址)</li>
<li>在基于数组的描述中，元素的地质是由数学公式决定的。而在链式描述中，元素的地址是随即分布的。</li>
<li>STL的容器类list使用带有头节点的双向循环链表来描述实例。它的方法与vector的方法具有相同的签名和操作。因此，他的erase和insert的签名和抽象类型linearList的要求不同，然而和vector一样，它可以用来设计从抽象类linearList的方法具有相同的签名和操作。</li>
</ul>
<h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><ul>
<li><p>描述</p>
<ul>
<li>在链式描述中，数据对象实例的每一个元素都用一个单元或节点来描述。节点不必是数组成员，因此不是用公式来确定元素的位置。取而代之的是，每一个节点都明确包含另一个相关节点的位置信息，这个信息称为链(link)或指针(pointer)</li>
<li>在对这个线性表的一个可能的链式描述中，每个元素都在一个单独的节点中描述，每一个节点都有一个链域，它的值是线性表的下一个元素的位置，即地址。</li>
<li>一般来说，为了找到索引为theIndex的元素，需要从firstNode开始，跟踪theIndex个指针才能找到。</li>
</ul>
</li>
<li><p>每一个节点只有一个链，这种结构称为单向链表(singly linked list)。链表从左到右，每一个节点(最后一个节点除外)都链接着下一个节点，最后一个节点的链阈值为NULL。这样的结构也称为链条(chain)</p>
</li>
<li><p>结构chainNode</p>
<ul>
<li>为了用链表描述线性表，我们要定义一个结构chainNode和一个类chain。</li>
</ul>
</li>
<li><p>类chain</p>
<ul>
<li>类chain用单向链表实现了线性表，其中最后一个节点的指针域为NULL，即它用单向链接的一组节点实现线性表。</li>
</ul>
</li>
</ul>
<h3 id="循环链表和头节点"><a href="#循环链表和头节点" class="headerlink" title="循环链表和头节点"></a>循环链表和头节点</h3><ul>
<li>两条措施，可以使链表的应用代码简洁和高效<ul>
<li>把线性表描述成一个单向循环链表(singly linked circular list)(简称循环链表)，而不是单向链表</li>
<li>在链表的前面增加一个节点，称为头节点(header node)。只要将单向链表的尾节点与头节点链接起来，单向链表就成为循环链表。</li>
</ul>
</li>
</ul>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><ul>
<li>对于线性表的大多数应用来说，采用链表和&#x2F;或循环链表已经足够了。然而，对于有些应用，如果每个元素节点既有一个指向后继的指针，又有一个指向前驱的指针，就会更加方便。</li>
<li>双向链表(doubly linked list)便是这样一个有序的节点序列，其中每个节点都有两个指针nest和previous。<ul>
<li>next指针指向右边节点(如果存在)</li>
<li>previous指针指向左边节点(如果存在)</li>
</ul>
</li>
</ul>
<h2 id="第七章-数组和矩阵"><a href="#第七章-数组和矩阵" class="headerlink" title="第七章 数组和矩阵"></a>第七章 数组和矩阵</h2><ul>
<li>在实际应用中，数据通常以表的形式出现。尽管用数组来描述表是最自然的方式，但为了减少程序所需的时间和空间，经常采用自定义的描述方式。</li>
<li>本章首先检查了多维数组的行主描述方式和列主描述方式。这些描述方式把多维数组映射成一维数组。</li>
<li>矩阵经常用二维数组来表示。然后，矩阵的索引通过从1开始，而C++的二维数组是从0开始。矩阵的操作有加法，减法和转置，但是C++的二维数组不支持这些操作。因此我们开发了类matrix，它与矩阵的关系密切</li>
<li>我们还要考察具有特殊结构的矩阵，例如对角矩阵，三对角矩阵，三角矩阵和对陈矩阵。关于这些矩阵的描述方法，自定义数组与二维数组相比，不仅大大减少了存储空间安，也减少了大多数矩阵操作的运行时间。</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>抽象数据类型</li>
<li>一个数组的每一个实例都是形如(索引，值)的数对集合，其中任意两个数对的索引(index)都不相同。有关数组的操作如下<ul>
<li>取值： 对一个给定的索引，取对应数对中的值</li>
<li>存值： 把一个新数对加到数对集合中。如果已存在一个索引相同的数对，就用新数对覆盖</li>
</ul>
</li>
<li>这两个操作定义了抽象数据类型array</li>
</ul>
<h3 id="行主映射和列主映射"><a href="#行主映射和列主映射" class="headerlink" title="行主映射和列主映射"></a>行主映射和列主映射</h3><ul>
<li>数组的应用需要我们把数组元素序列化，即按一维顺序排列。例如，数组元素只能一次输出或输入一个。因此，我们必须确定一个输入或输出的顺序。</li>
<li>从第一行开始，依次对每一行的索引从左至右连续编号。它把二维数组的索引映射为 [0, n-1]中的数，这种映射方式称为行主映射(row major mapping)。索引对应的数称为行主次序</li>
<li>另一种映射方式，称为列主映射(column major mapping)。在列主映射中，对索引的编号从最左列开始，依次对每一列的索引从上到下连续编号。</li>
</ul>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><ul>
<li><p>一个m * n的矩阵(matrix)是一个m行，n列的表，m和n是矩阵的维数(dimension)</p>
</li>
<li><p>矩阵通常用来组织数据。</p>
</li>
<li><p>矩阵最常见的操作是矩阵转置，矩阵相加，矩阵相乘。</p>
</li>
<li><p>两个矩阵仅当维数相同时(即它们的行数和列数都分别相等)才可以相加。两个m * n的矩阵A和B相加之后是一个m * n的矩阵C </p>
</li>
<li><p>一个m * n的矩阵A和一个q * p的矩阵B，只有当A的列数等于B的行数(即n&#x3D;q)时，才可以相乘A<em>B。A</em>B的结果是一个m * p的矩阵C</p>
</li>
<li><p>特殊矩阵</p>
<ul>
<li>方阵(square matrix)是行数和列数相同的矩阵。一些常用的特殊方阵如下</li>
<li>对角矩阵(diagonal)</li>
<li>三对角矩阵(tridiagonal)</li>
<li>下三角矩阵(lower triangular)</li>
<li>上三角矩阵(upper triangular)</li>
<li>对陈矩阵(symmetric)</li>
</ul>
</li>
<li><p>一个m * n的矩阵，如果大多数元素都是0,则称为稀疏矩阵(spare matrix)。一个矩阵如果不是稀疏的，就成为稠密矩阵(dense matrix)</p>
</li>
</ul>
<h2 id="第八章-栈"><a href="#第八章-栈" class="headerlink" title="第八章 栈"></a>第八章 栈</h2><ul>
<li><p>栈和队列很可能是应用频率最高的数据结构。在第五章和第六章曾经广泛研究了线性表和有序表数据结构，而栈和队列是它们的限制版。</p>
</li>
<li><p>栈和队列的应用广泛，以至于C++的标准类模板库STL都提供了用数组实现的栈和队列。</p>
</li>
<li><p>把线性表的插入和删除操作限制在同一端进行，就得到栈数据结构。因此，栈是一个后进先出(last-in-first-out, FIFO)的数据结构。因为栈是一种特殊的线性表，所以从相应的线性表类派生出栈类是很自然的事情。</p>
</li>
</ul>
<h3 id="定义和应用"><a href="#定义和应用" class="headerlink" title="定义和应用"></a>定义和应用</h3><ul>
<li><p>栈(stack)是一种特殊的线性表，其插入(也称入栈或压栈)和删除(也称出栈或弹栈)操作都在表的同一端进行。这一端称为栈顶(top),另一端称为栈底(bottom)</p>
</li>
<li><p>计算机是如何执行递归函数？</p>
<ul>
<li>使用递归工作栈(recursion stack)。当一个函数被调用时，一个返回地址(即被调函数一旦执行完，接下去要执行的程序指令的地址)和被调函数的局部变量和形参的值都要存储在递归工作栈中。当执行一次返回时，被调函数的局部变量和形参的值被恢复为调用之前的值(这些值存储在递归工作栈的顶部)，而且程序从返回地址处继续执行，这个返回地址也存储在递归工作栈的顶部。</li>
</ul>
</li>
<li><p>抽象数据类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stack</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">stack</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 返回true，当且仅当栈为空</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">// 返回栈中元素个数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">top</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 返回栈顶元素的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 删除栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp; theElement)</span> </span>= <span class="number">0</span>;  <span class="comment">// 将元素theElement压入栈顶</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/06/25/notebook/Tools/2024-06-25-%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%92%8C%E5%88%86%E8%BE%A8%E7%8E%87%E7%9A%84%E8%A7%A3%E9%87%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/25/notebook/Tools/2024-06-25-%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%92%8C%E5%88%86%E8%BE%A8%E7%8E%87%E7%9A%84%E8%A7%A3%E9%87%8A/" class="post-title-link" itemprop="url">显示屏和分辨率的解释</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-25 09:00:00" itemprop="dateCreated datePublished" datetime="2024-06-25T09:00:00+08:00">2024-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="SD、HD、FHD、UHD、FUHD"><a href="#SD、HD、FHD、UHD、FUHD" class="headerlink" title="SD、HD、FHD、UHD、FUHD"></a>SD、HD、FHD、UHD、FUHD</h2><ul>
<li><p>SD(Standard Definition)，标清</p>
<ul>
<li>480p</li>
<li>576p</li>
</ul>
</li>
<li><p>HD(High Definition)，高清</p>
<ul>
<li>720p</li>
</ul>
</li>
<li><p>FHD(Full High Definition)，全高清</p>
<ul>
<li>1080p</li>
</ul>
</li>
<li><p>UHD(Ultra High Definition)，超高清，4k UHD</p>
<ul>
<li>4k</li>
</ul>
</li>
<li><p>FUHD(Full Ultra High Definition)，8k超高清，8k UHD</p>
<ul>
<li>8k</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/06/25/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-06-25-return%E4%B8%8Eexit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/25/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-06-25-return%E4%B8%8Eexit/" class="post-title-link" itemprop="url">return 与 exit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-25 09:00:00" itemprop="dateCreated datePublished" datetime="2024-06-25T09:00:00+08:00">2024-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><ul>
<li><p>return，它的主要任务是在函数结束时将控制权交还给调用他的代码。</p>
</li>
<li><p>return不仅可以返回基本数据类型，还可以返回复杂的数据结构，例如对象和数组。</p>
</li>
<li><p>合理使用return，可以使代码更加简洁明了。在进行条件判断时，我们可以在条件满足时立即返回，避免不必要的嵌套。</p>
</li>
</ul>
<h2 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h2><ul>
<li><p>exit，它不仅仅是结束当前的函数，而是终止整个程序的执行，立即返回给操作系统。</p>
</li>
<li><p>应急处理和日志记录。在一些关键任务中，遇到不可恢复的错误时，我们可以使用exit来终止程序，并在退出前记录错误日志，以便后续分析。</p>
</li>
<li><p>注册清理函数。使用atexit函数，我们可以在程序终止时执行一些清理工作，例如释放资源或者保存程序状态</p>
</li>
</ul>
<h2 id="return-与-exit的对比和选择"><a href="#return-与-exit的对比和选择" class="headerlink" title="return 与 exit的对比和选择"></a>return 与 exit的对比和选择</h2><ul>
<li><p>作用范围</p>
<ul>
<li>return 仅终止当前函数，返回到调用者</li>
<li>exit 终止整个程序的执行</li>
</ul>
</li>
<li><p>清理操作</p>
<ul>
<li>return 执行当前函数的清理工作</li>
<li>exit 执行全局和静态对象的析沟函数，并调用通过atexit注册的函数</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li>return 用于函数结束后返回结果</li>
<li>exit 用于遇到不可恢复错误或者需要立即终止程序的情况</li>
</ul>
</li>
<li><p>综合考虑</p>
<ul>
<li>在实际开发中，我们应该优先使用return进行正常的函数返回，以保持代码的可读性和可维护性。而exit应仅在特殊情况下使用，确保在调用前做好必要的清理工作和日志记录。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/06/22/notebook/Tools/2024-06-22-cpu_gpu_npu_tpu%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/22/notebook/Tools/2024-06-22-cpu_gpu_npu_tpu%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">CPU,GPU,NPT,TPU的联系和区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-06-22T09:00:00+08:00">2024-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>CPU(Central Processing Unit),即中央处理器</li>
<li>GPU(Graphics Processing Unit), 即图形处理器</li>
<li>TPU(Tensor Processing Unit), 即张量处理器(谷歌)</li>
<li>NPU(Neual network Processing Unit),即神经网络处理器</li>
</ul>
<h2 id="概括三者的区别"><a href="#概括三者的区别" class="headerlink" title="概括三者的区别"></a>概括三者的区别</h2><ul>
<li>CPU虽然有多核，但一般也就几个，每个核都有足够大的缓存和足够多的数字和逻辑运算单元，需要很强的通用性来处理各种不同的数据类型，同时又要逻辑判断又会引入大量的分支跳转和中断的处理，并辅助有很多加速分支判断甚至更复杂的逻辑判断的硬件;</li>
<li>GPU的核数远超CPU，被称为众核(NVIDIA Fermi有512个核)。每个核拥有的缓存大小相对小，数字逻辑运算单元也少而简单(GPU初始时在浮点计算上一直弱于CPU)，面对的则是类型高度统一的、相互无依赖的大规模数据和不需要被打断的纯净的计算环境</li>
<li>TPU是一款为机器学习而定制的芯片，经过了专门深度机器学习方面的训练，它有更高效能(每瓦计算能力)。大致上，相对于现在的处理器有7年的领先优势，宽容度更高，每秒在芯片中可以挤出更多的操作时间，使用更复杂和强大的机器学习模型，将之更快的部署，用户也会更加迅速地获得更智能的结果</li>
<li>所谓NPU， 即神经网络处理器，用电路模拟人类的神经元和突触结构</li>
</ul>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><ul>
<li>CPU（CentralProcessing Unit）中央处理器，是一块超大规模的集成电路，主要逻辑架构包括控制单元Control，运算单元ALU和高速缓冲存储器（Cache）及实现它们之间联系的数据（Data）、控制及状态的总线（Bus）。简单说，就是计算单元、控制单元和存储单元。</li>
<li>CPU遵循的是冯·诺依曼架构，其核心是存储程序&#x2F;数据、串行顺序执行。因此CPU的架构中需要大量的空间去放置存储单元（Cache）和控制单元（Control），相比之下计算单元（ALU）只占据了很小的一部分，所以CPU在进行大规模并行计算方面受到限制，相对而言更擅长于处理逻辑控制。</li>
<li>CPU无法做到大量数据并行计算的能力，但GPU可以。</li>
</ul>
<h2 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h2><ul>
<li>GPU（GraphicsProcessing Unit），即图形处理器，是一种由大量运算单元组成的大规模并行计算架构，早先由CPU中分出来专门用于处理图像并行计算数据，专为同时处理多重并行计算任务而设计。</li>
<li>GPU中也包含基本的计算单元、控制单元和存储单元，但GPU的架构与CPU有很大不同。</li>
<li>与CPU相比，CPU芯片空间的不到20%是ALU，而GPU芯片空间的80%以上是ALU。即GPU拥有更多的ALU用于数据并行处理。</li>
<li>GPU具有如下特点：<ul>
<li>多线程，提供了多核并行计算的基础结构，且核心数非常多，可以支撑大量数据的并行计算，处理神经网络数据远远高效于CPU。</li>
<li>拥有更高的访存速度。</li>
<li>更高的浮点运算能力。</li>
</ul>
</li>
<li>因此，GPU比CPU更适合深度学习中的大量训练数据、大量矩阵、卷积运算。</li>
<li>GPU虽然在并行计算能力上尽显优势，但并不能单独工作，需要CPU的协同处理，对于神经网络模型的构建和数据流的传递还是在CPU上进行。</li>
<li>但是GPU也有天生缺陷，那就是功耗高，体积大，价格贵。</li>
<li>性能越高的GPU体积越大，功耗越高，价格也昂贵，对于一些小型设备、移动设备来说将无法使用。</li>
<li>因此，一种体积小、功耗低、计算性能高、计算效率高的ASIC专用芯片NPU诞生了。</li>
</ul>
<h2 id="NPU"><a href="#NPU" class="headerlink" title="NPU"></a>NPU</h2><ul>
<li>NPU （NeuralNetworks Process Units）神经网络处理单元。其针对于矩阵运算进行了专门的优化设计，解决了传统芯片在神经网络运算时效率低下的问题。NPU工作原理是在电路层模拟人类神经元和突触，并且用深度学习指令集直接处理大规模的神经元和突触，一条指令完成一组神经元的处理。相比于CPU和GPU，NPU通过突出权重实现存储和计算一体化，从而提高运行效率。</li>
<li>神经网络处理器（NPU）<strong>采用“数据驱动并行计算”的架构，</strong>特别擅长处理视频、图像类的海量多媒体数据。NPU处理器专门为物联网人工智能而设计，用于加速神经网络的运算，解决传统芯片在神经网络运算时效率低下的问题。</li>
<li>NPU是模仿生物神经网络而构建的，CPU、GPU处理器需要用数千条指令完成的神经元处理，NPU只要一条或几条就能完成，因此在深度学习的处理效率方面优势明显。</li>
<li>神经网络中存储和处理是一体化的，都是通过突触权重来体现。 冯·诺伊曼结构中，存储和处理是分离的，分别由存储器和运算器来实现，二者之间存在巨大的差异。当用现有的基于冯·诺伊曼结构的经典计算机（如X86处理器和英伟达GPU）来跑神经网络应用时，就不可避免地受到存储和处理分离式结构的制约，因而影响效率。这也就是专门针对人工智能的专业芯片能够对传统芯片有一定先天优势的原因之一。</li>
</ul>
<h2 id="CPU-如何辅助NPU实现加速"><a href="#CPU-如何辅助NPU实现加速" class="headerlink" title="CPU 如何辅助NPU实现加速"></a>CPU 如何辅助NPU实现加速</h2><ul>
<li>NPU与GPU加速不同，主要体现为每层神经元计算结果不用输出到主内存，而是按照神经网络的连接传递到下层神经元继续计算，因此其在运算性能和功耗上都有很大的提升。</li>
<li>CPU将编译好的神经网络模型文件和权重文件交由专用芯片加载，完成硬件编程</li>
</ul>
<h2 id="关于RK1126平台项目的小思考"><a href="#关于RK1126平台项目的小思考" class="headerlink" title="关于RK1126平台项目的小思考"></a>关于RK1126平台项目的小思考</h2><ul>
<li><p>在瑞芯微的1126芯片上有NPU，我接触的有四种检测模型：安全帽检测，区域入侵检测，反光衣检测，烟火检测。软件具体运行流程为：底层视频结构化引擎运行，后端服务运行，将模型配置文件发送给引擎，加载检测模型，将流媒体地址发送给引擎，引擎将视频流解码为一帧帧图片，将图片处理为检测模型需要的格式，这一步一般称为预处理，由检测模型返回检测结果，引擎处理成结构化数据。</p>
</li>
<li><p>检测模型就是神经网络模型文件和权重文件。底层引擎通过平台提供的接口，将检测模型加载到NPU上。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/06/20/notebook/Compiler/2024-06-20-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/20/notebook/Compiler/2024-06-20-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/" class="post-title-link" itemprop="url">交叉编译</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-20 09:00:00" itemprop="dateCreated datePublished" datetime="2024-06-20T09:00:00+08:00">2024-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Compiler/" itemprop="url" rel="index"><span itemprop="name">Compiler</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>交叉编译相关笔记</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/06/20/notebook/Compiler/2024-06-20-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/06/19/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-06-19-C++%E4%B8%AD%E7%9A%84NaN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/19/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-06-19-C++%E4%B8%AD%E7%9A%84NaN/" class="post-title-link" itemprop="url">C++中的NaN 产生原因，特性及处理方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-19 09:00:00" itemprop="dateCreated datePublished" datetime="2024-06-19T09:00:00+08:00">2024-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>在C++编程中， NaN(Not a number)是浮点数类型(例如float, double, long double)中的一种特殊值，用于表示无法定义的数值或者操作结果。NaN在数值计算和科学计算中十分常见，正确理解和处理NaN对于编写健壮和可靠的代码至关重要。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/06/19/notebook/C++/C++_05_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-06-19-C++%E4%B8%AD%E7%9A%84NaN/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/06/19/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-06-19-linux_2_96_rsync/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/19/notebook/Linux/linux_2_%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/2024-06-19-linux_2_96_rsync/" class="post-title-link" itemprop="url">linux_2_96_rsync</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-06-19 09:00:00" itemprop="dateCreated datePublished" datetime="2024-06-19T09:00:00+08:00">2024-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="linux-rsync命令是什么"><a href="#linux-rsync命令是什么" class="headerlink" title="linux rsync命令是什么"></a>linux rsync命令是什么</h2><p><code>rsync</code> 是一个用于在本地或远程同步文件和目录的开源实用工具。它非常强大和灵活，支持递归传输、保持文件权限、压缩传输等功能，使其成为文件同步和备份的首选工具之一。</p>
<p>以下是 <code>rsync</code> 的一些常用选项和示例：</p>
<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><ul>
<li><code>-a, --archive</code>：归档模式，等同于 <code>-rlptgoD</code>，保留文件的权限、时间戳、符号链接等。</li>
<li><code>-v, --verbose</code>：详细模式，显示传输过程中的详细信息。</li>
<li><code>-z, --compress</code>：在传输过程中压缩文件以节省带宽。</li>
<li><code>-P</code>：显示传输进度并部分保留已传输的文件（等同于 <code>--partial --progress</code>）。</li>
<li><code>--exclude</code>：排除指定的文件或目录。</li>
<li><code>--delete</code>：删除目标目录中在源目录中不存在的文件。</li>
</ul>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="本地复制"><a href="#本地复制" class="headerlink" title="本地复制"></a>本地复制</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av /source/directory /destination/directory</span><br></pre></td></tr></table></figure>
<p>将 <code>/source/directory</code> 复制到 <code>/destination/directory</code>。</p>
<h4 id="远程复制"><a href="#远程复制" class="headerlink" title="远程复制"></a>远程复制</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av /local/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>
<p>将本地目录 <code>/local/directory</code> 复制到远程主机 <code>remote_host</code> 的 <code>/remote/directory</code>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av user@remote_host:/remote/directory /local/directory</span><br></pre></td></tr></table></figure>
<p>将远程主机 <code>remote_host</code> 的 <code>/remote/directory</code> 复制到本地目录 <code>/local/directory</code>。</p>
<h4 id="使用-exclude-排除特定目录"><a href="#使用-exclude-排除特定目录" class="headerlink" title="使用 --exclude 排除特定目录"></a>使用 <code>--exclude</code> 排除特定目录</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;exclude_directory&#x27;</span> /source/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>
<p>将本地目录 <code>/source/directory</code> 复制到远程主机 <code>remote_host</code> 的 <code>/remote/directory</code>，但排除 <code>exclude_directory</code> 目录。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol>
<li><p><strong>同步本地目录</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av /home/user/data /backup</span><br></pre></td></tr></table></figure>
<p>将 <code>/home/user/data</code> 目录同步到 <code>/backup</code> 目录。</p>
</li>
<li><p><strong>排除特定目录</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;tmp&#x27;</span> /home/user/data /backup</span><br></pre></td></tr></table></figure>
<p>将 <code>/home/user/data</code> 目录同步到 <code>/backup</code> 目录，但排除 <code>tmp</code> 目录。</p>
</li>
<li><p><strong>同步到远程主机</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz /home/user/data user@remote_host:/backup</span><br></pre></td></tr></table></figure>
<p>将本地 <code>/home/user/data</code> 目录同步到远程主机 <code>remote_host</code> 的 <code>/backup</code> 目录，并在传输过程中进行压缩。</p>
</li>
<li><p><strong>从远程主机同步到本地</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz user@remote_host:/backup /home/user/data</span><br></pre></td></tr></table></figure>
<p>将远程主机 <code>remote_host</code> 的 <code>/backup</code> 目录同步到本地的 <code>/home/user/data</code> 目录，并在传输过程中进行压缩。</p>
</li>
<li><p><strong>显示进度</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avP /home/user/data user@remote_host:/backup</span><br></pre></td></tr></table></figure>
<p>将本地 <code>/home/user/data</code> 目录同步到远程主机 <code>remote_host</code> 的 <code>/backup</code> 目录，并显示传输进度。</p>
</li>
</ol>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>rsync</code> 是一个非常强大且灵活的工具，适用于各种文件同步和备份需求。通过熟练使用 <code>rsync</code> 的各种选项，你可以高效地完成复杂的文件传输和同步任务。</p>
<h2 id="linux-rsync命令-详解"><a href="#linux-rsync命令-详解" class="headerlink" title="linux rsync命令 详解"></a>linux rsync命令 详解</h2><p><code>rsync</code> 是一个强大的文件同步工具，常用于在本地或远程主机之间复制和同步文件和目录。它支持增量传输、保持文件权限、压缩传输等功能。以下是 <code>rsync</code> 的详细说明和一些示例。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync [OPTION]... SRC [SRC]... DEST</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SRC</code>：源文件或目录</li>
<li><code>DEST</code>：目标文件或目录</li>
</ul>
<h3 id="常用选项-1"><a href="#常用选项-1" class="headerlink" title="常用选项"></a>常用选项</h3><ul>
<li><code>-a, --archive</code>：归档模式，相当于 <code>-rlptgoD</code>，保留文件属性。<ul>
<li><code>-r, --recursive</code>：递归处理目录。</li>
<li><code>-l, --links</code>：保留符号链接。</li>
<li><code>-p, --perms</code>：保留文件权限。</li>
<li><code>-t, --times</code>：保持文件修改时间。</li>
<li><code>-g, --group</code>：保留文件组信息。</li>
<li><code>-o, --owner</code>：保留文件所有者信息。</li>
<li><code>-D</code>：保留设备文件和特殊文件。</li>
</ul>
</li>
<li><code>-v, --verbose</code>：详细输出。</li>
<li><code>-z, --compress</code>：在传输过程中压缩文件。</li>
<li><code>-P</code>：显示传输进度和部分传输的文件（等同于 <code>--partial --progress</code>）。<ul>
<li><code>--partial</code>：保留部分传输的文件，以便恢复。</li>
<li><code>--progress</code>：显示传输进度。</li>
</ul>
</li>
<li><code>--exclude</code>：指定排除的文件或目录模式。</li>
<li><code>--delete</code>：删除目标目录中在源目录中不存在的文件。</li>
<li><code>--bwlimit=RATE</code>：限制 I&#x2F;O 带宽，单位为 KB&#x2F;s。</li>
<li><code>-e, --rsh=COMMAND</code>：指定远程 shell 程序。</li>
<li><code>--checksum</code>：基于文件校验和进行比较，而不是文件大小和修改时间。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h4 id="本地复制-1"><a href="#本地复制-1" class="headerlink" title="本地复制"></a>本地复制</h4><p>将本地目录 <code>/source/directory</code> 复制到 <code>/destination/directory</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av /source/directory /destination/directory</span><br></pre></td></tr></table></figure>

<h4 id="远程复制-1"><a href="#远程复制-1" class="headerlink" title="远程复制"></a>远程复制</h4><p>将本地目录 <code>/local/directory</code> 复制到远程主机 <code>remote_host</code> 的 <code>/remote/directory</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av /local/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>

<p>将远程主机 <code>remote_host</code> 的 <code>/remote/directory</code> 复制到本地目录 <code>/local/directory</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av user@remote_host:/remote/directory /local/directory</span><br></pre></td></tr></table></figure>

<h4 id="排除特定目录"><a href="#排除特定目录" class="headerlink" title="排除特定目录"></a>排除特定目录</h4><p>将本地目录 <code>/source/directory</code> 复制到远程主机 <code>remote_host</code> 的 <code>/remote/directory</code>，但排除 <code>exclude_directory</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;exclude_directory&#x27;</span> /source/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>

<h4 id="显示进度"><a href="#显示进度" class="headerlink" title="显示进度"></a>显示进度</h4><p>在传输过程中显示进度：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avP /source/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>

<h4 id="同步文件并删除目标目录中多余的文件"><a href="#同步文件并删除目标目录中多余的文件" class="headerlink" title="同步文件并删除目标目录中多余的文件"></a>同步文件并删除目标目录中多余的文件</h4><p>将本地目录 <code>/source/directory</code> 同步到远程主机 <code>remote_host</code> 的 <code>/remote/directory</code>，并删除目标目录中多余的文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --delete /source/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>

<h4 id="限制传输带宽"><a href="#限制传输带宽" class="headerlink" title="限制传输带宽"></a>限制传输带宽</h4><p>将本地目录 <code>/source/directory</code> 复制到远程主机 <code>remote_host</code> 的 <code>/remote/directory</code>，并限制传输带宽为 500 KB&#x2F;s：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --bwlimit=500 /source/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>

<h4 id="使用-SSH-进行传输"><a href="#使用-SSH-进行传输" class="headerlink" title="使用 SSH 进行传输"></a>使用 SSH 进行传输</h4><p>通过 SSH 进行文件传输：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz -e ssh /source/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>

<h4 id="基于校验和进行比较"><a href="#基于校验和进行比较" class="headerlink" title="基于校验和进行比较"></a>基于校验和进行比较</h4><p>基于文件校验和进行比较，而不是文件大小和修改时间：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -avz --checksum /source/directory user@remote_host:/remote/directory</span><br></pre></td></tr></table></figure>

<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p><code>rsync</code> 是一个非常强大且灵活的工具，可以满足各种文件同步和备份需求。通过掌握 <code>rsync</code> 的各种选项和用法，你可以高效地完成复杂的文件传输和同步任务。</p>
<h2 id="linux-rsync命令-拷贝目录并且忽略指定目录"><a href="#linux-rsync命令-拷贝目录并且忽略指定目录" class="headerlink" title="linux rsync命令 拷贝目录并且忽略指定目录"></a>linux rsync命令 拷贝目录并且忽略指定目录</h2><p>在 Linux 上使用 <code>rsync</code> 拷贝目录并且忽略指定目录的具体步骤如下。假设你要拷贝 <code>/source/directory</code> 到目标目录 <code>/destination/directory</code>，但要忽略 <code>ignore_directory</code> 目录。</p>
<h3 id="示例命令"><a href="#示例命令" class="headerlink" title="示例命令"></a>示例命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;ignore_directory&#x27;</span> /source/directory/ /destination/directory/</span><br></pre></td></tr></table></figure>

<h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><ul>
<li><code>-a, --archive</code>：归档模式，表示递归复制目录，并保持文件属性。</li>
<li><code>-v, --verbose</code>：详细模式，显示传输过程中的信息。</li>
<li><code>--exclude &#39;ignore_directory&#39;</code>：指定要排除的目录 <code>ignore_directory</code>。</li>
<li><code>/source/directory/</code>：源目录路径，末尾的 <code>/</code> 表示拷贝目录内的内容。</li>
<li><code>/destination/directory/</code>：目标目录路径，末尾的 <code>/</code> 表示将内容复制到该目录中。</li>
</ul>
<h3 id="更详细的例子"><a href="#更详细的例子" class="headerlink" title="更详细的例子"></a>更详细的例子</h3><p>假设有如下目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/source/directory/</span><br><span class="line">├── file1.txt</span><br><span class="line">├── file2.txt</span><br><span class="line">└── ignore_directory/</span><br><span class="line">    ├── file3.txt</span><br><span class="line">    └── file4.txt</span><br></pre></td></tr></table></figure>

<p>使用上述 <code>rsync</code> 命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;ignore_directory&#x27;</span> /source/directory/ /destination/directory/</span><br></pre></td></tr></table></figure>

<p>结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/destination/directory/</span><br><span class="line">├── file1.txt</span><br><span class="line">└── file2.txt</span><br></pre></td></tr></table></figure>

<h3 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h3><ul>
<li>如果你有多个目录或文件需要排除，可以使用多个 <code>--exclude</code> 选项：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;ignore_directory1&#x27;</span> --exclude <span class="string">&#x27;ignore_directory2&#x27;</span> /source/directory/ /destination/directory/</span><br></pre></td></tr></table></figure>

<ul>
<li>你也可以使用 <code>--exclude-from</code> 选项从文件中读取排除的目录和文件列表。假设排除列表文件 <code>exclude-list.txt</code> 内容如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ignore_directory1</span><br><span class="line">ignore_directory2</span><br><span class="line">ignore_file.txt</span><br></pre></td></tr></table></figure>

<p>使用命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude-from=<span class="string">&#x27;exclude-list.txt&#x27;</span> /source/directory/ /destination/directory/</span><br></pre></td></tr></table></figure>

<h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>通过以上方法，你可以使用 <code>rsync</code> 高效地复制目录，同时忽略指定的目录或文件。这些选项提供了灵活的排除机制，使 <code>rsync</code> 成为处理文件同步和备份任务的强大工具。</p>
<h2 id="linux-rsync命令-远程拷贝目录并且忽略指定目录"><a href="#linux-rsync命令-远程拷贝目录并且忽略指定目录" class="headerlink" title="linux rsync命令 远程拷贝目录并且忽略指定目录"></a>linux rsync命令 远程拷贝目录并且忽略指定目录</h2><p>使用 <code>rsync</code> 命令可以实现远程拷贝目录并且忽略指定目录。以下是详细步骤和示例。</p>
<h3 id="示例命令-1"><a href="#示例命令-1" class="headerlink" title="示例命令"></a>示例命令</h3><p>假设你要将本地的 <code>/source/directory</code> 目录拷贝到远程主机 <code>remote_host</code> 的 <code>/destination/directory</code>，但要忽略 <code>ignore_directory</code> 目录。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;ignore_directory&#x27;</span> /source/directory/ user@remote_host:/destination/directory/</span><br></pre></td></tr></table></figure>

<h3 id="详细说明-1"><a href="#详细说明-1" class="headerlink" title="详细说明"></a>详细说明</h3><ul>
<li><code>-a, --archive</code>：归档模式，表示递归复制目录，并保持文件属性。</li>
<li><code>-v, --verbose</code>：详细模式，显示传输过程中的信息。</li>
<li><code>--exclude &#39;ignore_directory&#39;</code>：指定要排除的目录 <code>ignore_directory</code>。</li>
<li><code>/source/directory/</code>：源目录路径，末尾的 <code>/</code> 表示拷贝目录内的内容。</li>
<li><code>user@remote_host:/destination/directory/</code>：目标目录路径，格式为 <code>user@host:/path</code>。</li>
</ul>
<h3 id="更详细的例子-1"><a href="#更详细的例子-1" class="headerlink" title="更详细的例子"></a>更详细的例子</h3><p>假设有如下本地目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/source/directory/</span><br><span class="line">├── file1.txt</span><br><span class="line">├── file2.txt</span><br><span class="line">└── ignore_directory/</span><br><span class="line">    ├── file3.txt</span><br><span class="line">    └── file4.txt</span><br></pre></td></tr></table></figure>

<p>使用上述 <code>rsync</code> 命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;ignore_directory&#x27;</span> /source/directory/ user@remote_host:/destination/directory/</span><br></pre></td></tr></table></figure>

<p>结果是远程主机 <code>remote_host</code> 上的 <code>/destination/directory/</code> 目录结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/destination/directory/</span><br><span class="line">├── file1.txt</span><br><span class="line">└── file2.txt</span><br></pre></td></tr></table></figure>

<h3 id="使用多个排除选项"><a href="#使用多个排除选项" class="headerlink" title="使用多个排除选项"></a>使用多个排除选项</h3><p>如果你有多个目录或文件需要排除，可以使用多个 <code>--exclude</code> 选项：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude <span class="string">&#x27;ignore_directory1&#x27;</span> --exclude <span class="string">&#x27;ignore_directory2&#x27;</span> /source/directory/ user@remote_host:/destination/directory/</span><br></pre></td></tr></table></figure>

<h3 id="使用排除列表文件"><a href="#使用排除列表文件" class="headerlink" title="使用排除列表文件"></a>使用排除列表文件</h3><p>你也可以使用 <code>--exclude-from</code> 选项从文件中读取排除的目录和文件列表。假设排除列表文件 <code>exclude-list.txt</code> 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ignore_directory1</span><br><span class="line">ignore_directory2</span><br><span class="line">ignore_file.txt</span><br></pre></td></tr></table></figure>

<p>使用命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --exclude-from=<span class="string">&#x27;exclude-list.txt&#x27;</span> /source/directory/ user@remote_host:/destination/directory/</span><br></pre></td></tr></table></figure>

<h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p>通过以上方法，你可以使用 <code>rsync</code> 高效地实现远程目录拷贝，同时忽略指定的目录或文件。这些选项提供了灵活的排除机制，使 <code>rsync</code> 成为处理远程文件同步和备份任务的强大工具。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/27/notebook/Tools/2024-05-27-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/27/notebook/Tools/2024-05-27-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-27 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-27T09:00:00+08:00">2024-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>数据结构相关笔记</p>
</li>
<li><p>数据结构(data structure)是计算机中存储，组织数据的方式</p>
</li>
<li><p>数据结构是一种具有一定逻辑关系，在计算机中应用某种数据结构，并且封装了相应操作的数据元素集合。它包含三方面的内容，逻辑关系，存储关系及操作。</p>
</li>
<li><p>不同种类的数据结构适合于不同种类的应用，而部分甚至专门用于特定的作业任务。例如，计算机网络依赖于路由表运作，B树高度适用于数据库的封装。</p>
</li>
<li><p>数据结构研究的内容：就是如何按一定的逻辑结构，把数据组织起来，并选择适当的存储表示方法把逻辑结构组织好的数据存储到计算机的存储器里。</p>
</li>
</ul>
<h2 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h2><ul>
<li>栈(stack)： 栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据节点的插入和删除操作</li>
<li>队列(queue)：队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作</li>
<li>数组(array)：数据是一种聚合数据类型，它是将具有相同相同类型的若干变量有序的组织在一起的集合。</li>
<li>链表(linked list)：链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。</li>
<li>树(tree)：树是典型的非线性结构，它是包括，2 个结点的有穷集合 K</li>
<li>图(graph)：图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。</li>
<li>堆(heap)：堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。</li>
<li>散列表(hash table)：散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/27/notebook/Tools/2024-05-27-%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/27/notebook/Tools/2024-05-27-%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-27 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-27T09:00:00+08:00">2024-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Tools/" itemprop="url" rel="index"><span itemprop="name">Tools</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>数据结构研究的内容：就是如何按一定的逻辑结构，把数据组织起来，并选择适当的存储表示方法把逻辑结构组织好的数据存储到计算机的存储器里。</li>
<li>算法研究的目的是为了更有效的处理数据，提高数据运算效率。数据的运算是定义在数据的逻辑结构上，但是运算的具体实现要在存储结构上进行。一般有以下几种常用运算<ul>
<li>检索：检索就是在数据结构里查找满足一定条件的节点。一般是给定一个某字段的值，找具有该字段的节点</li>
<li>插入：往数据结构中增加新的节点</li>
<li>删除：把指定的节点从数据结构中去掉</li>
<li>更新：改变指定节点的一个或者多个字段的值</li>
<li>排序：把节点按某种指定的顺序重新排列。例如递增或者递减</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/24/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-05-24-python_3_os%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/24/notebook/Python/python_3_%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/2024-05-24-python_3_os%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">python_3_os模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-24 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-24T09:00:00+08:00">2024-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-14 08:45:41" itemprop="dateModified" datetime="2025-05-14T08:45:41+08:00">2025-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>os模块相关笔记</li>
</ul>
<h2 id="python3-os模块-详解"><a href="#python3-os模块-详解" class="headerlink" title="python3 os模块 详解"></a>python3 os模块 详解</h2><p><code>os</code>模块是Python中用于与操作系统进行交互的标准库之一。它提供了许多函数来执行文件和目录管理，处理文件路径，以及与操作系统交互的其他功能。下面是对<code>os</code>模块的一些主要功能的详解：</p>
<h3 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h3><ol>
<li><p><strong>创建目录</strong></p>
<ul>
<li><code>os.mkdir(path)</code>: 创建单级目录。</li>
<li><code>os.makedirs(path)</code>: 递归创建多级目录。</li>
</ul>
</li>
<li><p><strong>删除目录</strong></p>
<ul>
<li><code>os.rmdir(path)</code>: 删除指定目录。</li>
<li><code>os.removedirs(path)</code>: 递归删除目录，直到指定目录。</li>
</ul>
</li>
<li><p><strong>文件和目录存在性检查</strong></p>
<ul>
<li><code>os.path.exists(path)</code>: 检查文件或目录是否存在。</li>
<li><code>os.path.isfile(path)</code>: 检查给定路径是否是文件。</li>
<li><code>os.path.isdir(path)</code>: 检查给定路径是否是目录。</li>
</ul>
</li>
<li><p><strong>重命名和移动</strong></p>
<ul>
<li><code>os.rename(src, dst)</code>: 重命名文件或目录。</li>
<li><code>os.replace(src, dst)</code>: 替换文件或目录，如果目标已经存在。</li>
</ul>
</li>
<li><p><strong>列出目录内容</strong></p>
<ul>
<li><code>os.listdir(path)</code>: 返回目录中的所有文件和目录的列表。</li>
</ul>
</li>
<li><p><strong>删除文件</strong></p>
<ul>
<li><code>os.remove(path)</code>: 删除指定文件。</li>
</ul>
</li>
</ol>
<h3 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h3><ol>
<li><p><strong>连接路径</strong></p>
<ul>
<li><code>os.path.join(path1, path2, ...)</code>: 将多个路径组合成一个路径。</li>
</ul>
</li>
<li><p><strong>获取文件名和目录名</strong></p>
<ul>
<li><code>os.path.basename(path)</code>: 返回路径的基本名称（文件名或目录名）。</li>
<li><code>os.path.dirname(path)</code>: 返回路径的目录部分。</li>
</ul>
</li>
<li><p><strong>获取路径信息</strong></p>
<ul>
<li><code>os.path.abspath(path)</code>: 返回路径的绝对路径。</li>
<li><code>os.path.split(path)</code>: 将路径拆分为目录和文件名的元组。</li>
<li><code>os.path.splitext(path)</code>: 将路径拆分为文件名和扩展名的元组。</li>
</ul>
</li>
<li><p><strong>检查路径属性</strong></p>
<ul>
<li><code>os.path.isabs(path)</code>: 检查路径是否是绝对路径。</li>
<li><code>os.path.islink(path)</code>: 检查路径是否是符号链接。</li>
<li><code>os.path.realpath(path)</code>: 返回符号链接的绝对路径。</li>
</ul>
</li>
</ol>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ol>
<li><p><strong>执行系统命令</strong></p>
<ul>
<li><code>os.system(command)</code>: 在系统上执行命令。</li>
</ul>
</li>
<li><p><strong>获取环境变量</strong></p>
<ul>
<li><code>os.getenv(name)</code>: 获取环境变量的值。</li>
<li><code>os.putenv(name, value)</code>: 设置环境变量的值。</li>
</ul>
</li>
<li><p><strong>进程控制</strong></p>
<ul>
<li><code>os.getpid()</code>: 获取当前进程的PID。</li>
<li><code>os.kill(pid, signal)</code>: 向指定PID的进程发送信号。</li>
</ul>
</li>
<li><p><strong>文件描述符操作</strong></p>
<ul>
<li><code>os.open(file, flags[, mode])</code>: 打开文件并返回文件描述符。</li>
<li><code>os.close(fd)</code>: 关闭文件描述符。</li>
</ul>
</li>
</ol>
<p>这些只是<code>os</code>模块中的一部分功能，但覆盖了许多常见的文件和目录操作，以及与操作系统进行交互的基本操作。</p>
<h2 id="python3-os模块-os-walk-函数-详解"><a href="#python3-os模块-os-walk-函数-详解" class="headerlink" title="python3 os模块 os.walk() 函数 详解"></a>python3 os模块 os.walk() 函数 详解</h2><p><code>os.walk()</code> 是 Python <code>os</code> 模块中非常常用的一个函数，主要用于<strong>遍历目录树</strong>。它可以递归地访问一个目录下的所有子目录和文件，非常适合查找文件或批量处理。</p>
<hr>
<h2 id="🔍-一、基本语法"><a href="#🔍-一、基本语法" class="headerlink" title="🔍 一、基本语法"></a>🔍 一、基本语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dirpath, dirnames, filenames <span class="keyword">in</span> os.walk(top, topdown=<span class="literal">True</span>, onerror=<span class="literal">None</span>, followlinks=<span class="literal">False</span>):</span><br><span class="line">    <span class="comment"># 你的代码</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧩-二、参数说明"><a href="#🧩-二、参数说明" class="headerlink" title="🧩 二、参数说明"></a>🧩 二、参数说明</h2><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>top</code></td>
<td>要遍历的目录路径（字符串）</td>
</tr>
<tr>
<td><code>topdown</code></td>
<td>默认为 <code>True</code>，表示从上到下遍历（先访问当前目录，再访问子目录）<br>若为 <code>False</code>，则从下往上遍历（先子目录后当前目录）</td>
</tr>
<tr>
<td><code>onerror</code></td>
<td>可选的错误处理函数（当访问目录出错时调用）</td>
</tr>
<tr>
<td><code>followlinks</code></td>
<td>是否跟踪符号链接（默认为 <code>False</code>）</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔁-三、返回值说明"><a href="#🔁-三、返回值说明" class="headerlink" title="🔁 三、返回值说明"></a>🔁 三、返回值说明</h2><p><code>os.walk()</code> 返回的是一个 <strong>生成器</strong>，每次迭代返回一个 3 元组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(dirpath, dirnames, filenames)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>元素</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>dirpath</code></td>
<td>字符串</td>
<td>当前遍历到的目录路径</td>
</tr>
<tr>
<td><code>dirnames</code></td>
<td>列表[str]</td>
<td>当前目录下的子目录名（不含路径）</td>
</tr>
<tr>
<td><code>filenames</code></td>
<td>列表[str]</td>
<td>当前目录下的文件名（不含路径）</td>
</tr>
</tbody></table>
<hr>
<h2 id="📌-四、简单示例"><a href="#📌-四、简单示例" class="headerlink" title="📌 四、简单示例"></a>📌 四、简单示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">root_dir = <span class="string">&#x27;./test_dir&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dirpath, dirnames, filenames <span class="keyword">in</span> os.walk(root_dir):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;当前目录: <span class="subst">&#123;dirpath&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子目录: <span class="subst">&#123;dirnames&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;文件: <span class="subst">&#123;filenames&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当前目录: ./test_dir</span><br><span class="line">子目录: [&#x27;images&#x27;, &#x27;texts&#x27;]</span><br><span class="line">文件: [&#x27;readme.txt&#x27;]</span><br><span class="line"></span><br><span class="line">当前目录: ./test_dir/images</span><br><span class="line">子目录: []</span><br><span class="line">文件: [&#x27;pic1.jpg&#x27;, &#x27;pic2.jpg&#x27;]</span><br><span class="line"></span><br><span class="line">当前目录: ./test_dir/texts</span><br><span class="line">子目录: []</span><br><span class="line">文件: [&#x27;a.txt&#x27;, &#x27;b.txt&#x27;]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🎯-五、常见用法示例"><a href="#🎯-五、常见用法示例" class="headerlink" title="🎯 五、常见用法示例"></a>🎯 五、常见用法示例</h2><h3 id="1-获取所有文件的完整路径"><a href="#1-获取所有文件的完整路径" class="headerlink" title="1. 获取所有文件的完整路径"></a>1. 获取所有文件的完整路径</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dirpath, _, filenames <span class="keyword">in</span> os.walk(root_dir):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        full_path = os.path.join(dirpath, filename)</span><br><span class="line">        <span class="built_in">print</span>(full_path)</span><br></pre></td></tr></table></figure>

<h3 id="2-只查找指定类型的文件（如-txt）"><a href="#2-只查找指定类型的文件（如-txt）" class="headerlink" title="2. 只查找指定类型的文件（如 .txt）"></a>2. 只查找指定类型的文件（如 <code>.txt</code>）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dirpath, _, filenames <span class="keyword">in</span> os.walk(root_dir):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        <span class="keyword">if</span> filename.endswith(<span class="string">&#x27;.txt&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(os.path.join(dirpath, filename))</span><br></pre></td></tr></table></figure>

<hr>
<p>如果你有特定场景，比如只查一层目录、跳过某些文件、或组合 <code>os.walk()</code> 和正则，我也可以进一步讲解。需要吗？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/VSCode/2024-05-22-2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/VSCode/2024-05-22-2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">vscode-常用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 18:21:03" itemprop="dateCreated datePublished" datetime="2024-05-22T18:21:03+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vscode/" itemprop="url" rel="index"><span itemprop="name">vscode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>VSCode 编辑器常用的技巧</li>
</ul>
<h2 id="vscode-windows下PATH环境变量更新，vscode未识别"><a href="#vscode-windows下PATH环境变量更新，vscode未识别" class="headerlink" title="vscode windows下PATH环境变量更新，vscode未识别"></a>vscode windows下PATH环境变量更新，vscode未识别</h2><ul>
<li>先退出VSCode</li>
<li>打开cmd窗口，输入并执行 code 命令</li>
<li>在新打开的VSCode的终端里，环境变量已经是最新的</li>
</ul>
<h2 id="vscode-页面切换到左侧工具栏"><a href="#vscode-页面切换到左侧工具栏" class="headerlink" title="vscode 页面切换到左侧工具栏"></a>vscode 页面切换到左侧工具栏</h2><p>在 Visual Studio Code 中，如果你希望将焦点从编辑器切换到左侧的侧边栏（也称为 Activity Bar），可以使用以下方法：</p>
<ol>
<li><p><strong>使用键盘快捷键</strong>：</p>
<ul>
<li>按下 <code>Ctrl + 0</code>（Windows&#x2F;Linux）或者 <code>Cmd + 0</code>（Mac）可以将焦点从编辑器切换到侧边栏的第一个图标。</li>
<li>使用 <code>Ctrl + 1</code>、<code>Ctrl + 2</code>、<code>Ctrl + 3</code> 等数字键（Windows&#x2F;Linux）或者 <code>Cmd + 1</code>、<code>Cmd + 2</code>、<code>Cmd + 3</code> 等数字键（Mac）可以将焦点切换到侧边栏的不同图标。</li>
</ul>
</li>
<li><p><strong>使用鼠标</strong>：</p>
<ul>
<li>直接点击侧边栏的图标来切换到相应的视图，例如资源管理器、搜索、源代码管理等。</li>
</ul>
</li>
</ol>
<p>这些方法可以帮助你快速地将焦点从编辑器切换到左侧的工具栏，以便访问不同的功能和视图。</p>
<h2 id="vscode-分屏显示-切换"><a href="#vscode-分屏显示-切换" class="headerlink" title="vscode 分屏显示 切换"></a>vscode 分屏显示 切换</h2><p>在 Visual Studio Code 中，你可以使用以下快捷键来实现分屏显示和切换：</p>
<ol>
<li><p><strong>分屏显示</strong>：</p>
<ul>
<li>打开第一个文件后，按下 <code>Ctrl + \</code>（Windows&#x2F;Linux）或者 <code>Cmd + \</code>（Mac）来进行分屏显示。这会在当前编辑器的右侧打开一个新的编辑器。</li>
<li>或者，你可以通过右键点击文件选项卡，选择 “Split Editor”。</li>
</ul>
</li>
<li><p><strong>切换焦点</strong>：</p>
<ul>
<li>使用 <code>Ctrl + 1</code>、<code>Ctrl + 2</code> 等数字键（Windows&#x2F;Linux）或者 <code>Cmd + 1</code>、<code>Cmd + 2</code> 等数字键（Mac）来切换到不同的编辑器。</li>
<li>或者，你可以使用 <code>Ctrl + \</code>（Windows&#x2F;Linux）或者 <code>Cmd + \</code>（Mac）来切换焦点到分屏的另一个编辑器。</li>
</ul>
</li>
<li><p><strong>关闭分屏</strong>：</p>
<ul>
<li>在分屏模式下，将鼠标悬停在编辑器的右上角，会看到一个关闭按钮（’X’）。点击该按钮可以关闭分屏。</li>
</ul>
</li>
<li><p><strong>重新分屏</strong>：</p>
<ul>
<li>如果你只剩下一个编辑器，但是想要重新进行分屏，你可以使用 <code>Ctrl + \</code>（Windows&#x2F;Linux）或者 <code>Cmd + \</code>（Mac）来重新分屏。</li>
</ul>
</li>
</ol>
<p>通过这些快捷键，你可以方便地在 Visual Studio Code 中进行分屏显示和切换。</p>
<h2 id="日志断点调试"><a href="#日志断点调试" class="headerlink" title="日志断点调试"></a>日志断点调试</h2><ul>
<li>断点模式设置为日志断点，输入表达式，随即会在output一栏输出</li>
<li>例如输出变量command,则表达式为{command}，随后回车就会输出</li>
</ul>
<h2 id="配置C-智能匹配"><a href="#配置C-智能匹配" class="headerlink" title="配置C++智能匹配"></a>配置C++智能匹配</h2><ul>
<li>open the Command Palette (Ctrl+Shift+P) </li>
<li>enter Select IntelliSense Configuration.</li>
</ul>
<h2 id="配置C"><a href="#配置C" class="headerlink" title="配置C++"></a>配置C++</h2><ul>
<li>You can view the C&#x2F;C++ configuration UI by running the command C&#x2F;C++: Edit Configurations (UI) from the Command Palette (Ctrl+Shift+P).</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/VSCode/2024-05-22-1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/VSCode/2024-05-22-1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">vscode-理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 18:21:03" itemprop="dateCreated datePublished" datetime="2024-05-22T18:21:03+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vscode/" itemprop="url" rel="index"><span itemprop="name">vscode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="VSCode-基础"><a href="#VSCode-基础" class="headerlink" title="VSCode 基础"></a>VSCode 基础</h1><h2 id="vscode-c-cpp-properties-json-excludePath参数-详解"><a href="#vscode-c-cpp-properties-json-excludePath参数-详解" class="headerlink" title="vscode c_cpp_properties.json excludePath参数 详解"></a>vscode c_cpp_properties.json excludePath参数 详解</h2><p>在Visual Studio Code中，<code>c_cpp_properties.json</code>文件是用于配置C&#x2F;C++扩展的解析设置的文件。在该文件中，<code>excludePath</code>参数用于指定应该在解析期间排除的目录。以下是对<code>excludePath</code>参数的详细解释：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;My Configuration&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c11&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gcc-x64&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;excludePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;$&#123;workspaceFolder&#125;/path/to/excluded_directory&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;$&#123;workspaceFolder&#125;/another/excluded_directory/**/*.cpp&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong><code>$&#123;workspaceFolder&#125;</code></strong>: 这是一个变量，表示当前工作区的根目录。<code>$&#123;workspaceFolder&#125;/**</code>表示将包括工作区中的所有文件和子目录。</p>
</li>
<li><p><strong><code>excludePath</code>数组</strong>: 用于指定要在解析期间排除的目录。可以指定一个或多个目录，并使用相对于<code>$&#123;workspaceFolder&#125;</code>的路径。在上面的示例中，两个目录都被排除了。</p>
<ul>
<li><code>$&#123;workspaceFolder&#125;/path/to/excluded_directory</code>: 表示要排除的第一个目录。</li>
<li><code>$&#123;workspaceFolder&#125;/another/excluded_directory/**/*.cpp</code>: 使用通配符<code>**</code>表示所有子目录和其中的所有<code>.cpp</code>文件都应该被排除。</li>
</ul>
</li>
<li><p><strong>注意事项</strong>:</p>
<ul>
<li>在配置<code>excludePath</code>时，确保使用正确的相对路径，并确保路径是以<code>$&#123;workspaceFolder&#125;</code>为基础的。</li>
<li>你可以使用通配符<code>**</code>来匹配任意目录或文件。在示例中，<code>/**/*.cpp</code>表示匹配任意子目录下的所有<code>.cpp</code>文件。</li>
<li>更改完成后，需要重启Visual Studio Code以使更改生效。</li>
</ul>
</li>
</ol>
<p>通过使用<code>excludePath</code>参数，你可以控制C&#x2F;C++扩展在解析代码时忽略特定的目录，这对于排除不需要进行代码分析的目录非常有用。</p>
<h2 id="解决cpptools-high-cpu问题"><a href="#解决cpptools-high-cpu问题" class="headerlink" title="解决cpptools high cpu问题"></a>解决cpptools high cpu问题</h2><ul>
<li>在VScode菜单栏文件-&gt;首选项-&gt;设置 搜索C_Cpp.intelliSenseCacheSize,修改默认的5120为512</li>
<li></li>
</ul>
<h2 id="调试模式-设置环境变量"><a href="#调试模式-设置环境变量" class="headerlink" title="调试模式 设置环境变量"></a>调试模式 设置环境变量</h2><p>在Visual Studio Code (VSCode) 中，<code>launch.json</code> 文件用于配置调试器的启动选项。当您在VSCode中使用C++进行调试时，可以使用 <code>launch.json</code> 文件设置环境变量以定制调试过程。</p>
<p>以下是如何在 <code>launch.json</code> 文件中设置环境变量的步骤：</p>
<ol>
<li><p>打开 VSCode，并在您的 C++ 项目文件夹中找到或创建 <code>launch.json</code> 文件。通常，该文件位于 <code>.vscode</code> 文件夹中。</p>
</li>
<li><p>在 <code>configurations</code> 字段中添加一个调试配置。如果该字段为空，请复制以下 JSON 代码并粘贴到 <code>launch.json</code> 文件中：</p>
</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C++ Launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/&lt;your_executable&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在上面的代码中，<code>environment</code> 字段用于设置环境变量。您可以将需要的环境变量添加到该字段中。每个环境变量都以键值对的形式表示，键和值之间使用冒号分隔。例如，如果要设置名为 <code>MY_ENV_VAR</code> 的环境变量，可以添加如下配置：</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MY_ENV_VAR&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;your_value&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>保存 <code>launch.json</code> 文件。</p>
</li>
<li><p>在 VSCode 中打开您的 C++ 源代码文件，并在需要调试的行上设置断点。</p>
</li>
<li><p>单击 VSCode 左侧的调试图标（虫子图标），然后点击绿色的“启动调试”按钮。调试器将启动，并在设置的断点处停止。</p>
</li>
<li><p>如果有设置环境变量，它们将在调试过程中生效，您可以在调试过程中使用它们。</p>
</li>
</ol>
<p>请注意：</p>
<ul>
<li>有些调试器可能不支持在 <code>launch.json</code> 文件中设置环境变量。确保您使用的调试器支持此功能。</li>
<li>在 <code>launch.json</code> 文件中设置的环境变量仅对该特定的调试配置生效。如果您有多个调试配置，每个配置可能需要不同的环境变量设置。</li>
</ul>
<p>以上步骤是为了在 VSCode 中通过 <code>launch.json</code> 文件设置 C++ 调试的环境变量。如果您在调试过程中遇到问题，请确保配置正确，并查看调试器的文档以获取更多帮助。</p>
<h2 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h2><ul>
<li><code>word wrap</code></li>
</ul>
<h2 id="VScode-extensions-xhr-failure"><a href="#VScode-extensions-xhr-failure" class="headerlink" title="VScode extensions xhr:failure"></a>VScode extensions xhr:failure</h2><ul>
<li>setting-&gt;details-&gt;Data&amp;Time-&gt;Automatic Time Zone <ul>
<li>open</li>
</ul>
</li>
</ul>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul>
<li><p>首先，在官网找到需要下载的文件，点击下载，并将下载连接复制下来，例如：</p>
<ul>
<li><code>https://az764295.vo.msecnd.net/stable/97dec172d3256f8ca4bfb2143f3f76b503ca0534/code_1.74.3-1673284829_amd64.deb</code></li>
</ul>
</li>
<li><p>然后，将<code>az764295.vo.msecnd.net</code>替换为<code>vscode.cdn.azure.cn</code>，例如：</p>
<ul>
<li><code>https://vscode.cdn.azure.cn/stable/97dec172d3256f8ca4bfb2143f3f76b503ca0534/code_1.74.3-1673284829_amd64.deb</code></li>
</ul>
</li>
<li><p>这就是国内的镜像</p>
</li>
</ul>
<h2 id="使用root用户打开vscode"><a href="#使用root用户打开vscode" class="headerlink" title="使用root用户打开vscode"></a>使用root用户打开vscode</h2><ul>
<li><p>背景：</p>
<ul>
<li>在远程调试机械臂的时候，需要使用到root权限来运行程序，所以在调试的时候需要使用到root权限</li>
</ul>
</li>
<li><p>方法：</p>
<ul>
<li>示例：<code>code --no-sandbox --disable-gpu-sandbox --user-data-dir=&quot;.vscode-root&quot;</code></li>
</ul>
<!-- + 在`.bashrc`中加入一行代码：
  + `alias code='/usr/share/code/code . --no-sandbox --unity-lanuch'`
+ 然后，直接在终端使用vscode命令打开vscode : `code` --></li>
</ul>
<h2 id="VSCode-是什么"><a href="#VSCode-是什么" class="headerlink" title="VSCode 是什么"></a>VSCode 是什么</h2><ul>
<li><p>VSCode 是什么，VS Code的全称是Visual Studio Code，但这全名实在是太长了，很多用户喜欢叫它VS Code。说起VS Code，官方定义它是一个免费的、开源的跨平台编辑器。之所以强调“编辑器”，我想是因为 VS Code 并无意成为一个全尺寸的集成开发环境，也就是IDE</p>
</li>
<li><p>很多人都把编辑器等同于IDE，其实从专业角度来讲并非这样。IDE 更为关注开箱即用的编程体验、对代码往往有很好的智能理解，同时侧重于工程项目，为代码调试、测试、工作流等都有图形化界面的支持，因此相对笨重，Java程序员常用的Eclipse定位就是IDE；而编辑器则相对更轻量，侧重于文件或者文件夹，语言和工作流的支持更丰富和自由，VS Code 把自己定位在编辑器这个方向上，但又不完全局限于此。</p>
</li>
<li><p>要理解VS Code代码编辑器的设计思路，就需要先看看VS Code的发展轨迹。</p>
</li>
<li><p>从我的角度看，不管你是学习编程语言，还是框架、编辑器，都应该先去看看它的来龙去脉，了解它们是怎么发展而来的，曾经遇到了什么问题，又是怎么解决的，这些信息都便于你从大局上提高对事情本质的认识</p>
</li>
<li><p>VSCode 发展历史：<code>https://geek-docs.com/vscode/vscode-tutorials/what-is-vscode.html</code></p>
</li>
</ul>
<h2 id="VSCode的学习路线"><a href="#VSCode的学习路线" class="headerlink" title="VSCode的学习路线"></a>VSCode的学习路线</h2><ul>
<li><p>简短地了解了 VS Code 的历史后，如果你也认同它的设计哲学和使命，你肯定还想知道该如何把 VS Code 的这一套转化为自己的内力。我在第一讲 “学编辑器，到底应该‘学’什么？” 里讲过编辑器学习的通用办法，在 VS Code 身上也是适用的。你可以按照以下三个步骤来逐步掌握 VS Code。</p>
<ul>
<li>核心编辑器的使用。VS Code 有一套自己的快捷键，你可以通过快捷键的学习了解核心编辑器所支持的功能。同时， VS Code 允许自定义快捷键的映射，如果你有自己熟悉的一套快捷键操作，也可以无缝地在 VS Code 上使用。除了快捷键，VS Code 对鼠标操作、多光标、搜索都有完备的支持；在编程语言的支持上面，VS Code 也向 IDE 看齐，自动补全、代码片段等一应俱全。掌握了核心编辑器，VS Code 就能够胜任你的日常通用编辑器。</li>
<li>工作台、工作区的使用。VS Code 中除了编辑器区域，还有很多其他的功能，像是资源管理器、跨文件搜索、插件管理等，它们一起组成了统一的界面，我们称之为工作台。这个工作台的设计，代表了 VS Code 对工作流的选择。内置的软件版本管理，终端模拟器，调试器等，掌握这些 VS Code “钦定”的工具，进一步提升工作效率。</li>
<li>VS Code 定制和插件开发。作为一个百万级别用户量的工具，很多功能的默认设置不可能满足每个人或者每个工作场景，你可以学习如何定制 VS Code 的各个部件，不能永远按部就班；对于 VS Code 没有实现的功能，还可以学习一下如何使用 JavaScript 书写插件，把自己的想法，变成工具的一部分。</li>
</ul>
</li>
<li><p>通过这三个步骤，你在使用 VS Code 时就能够“随心所欲”了。除此之外，我也建议你关注 VS Code 每月的发布更新日志，官方团队会详细讲解每个版本新增的功能。VS Code 的官方博客也非常值得订阅，团队成员会经常分享开发过程的心得感悟，算得上是最前沿的技术分享。</p>
</li>
</ul>
<h2 id="VSCode入门"><a href="#VSCode入门" class="headerlink" title="VSCode入门"></a>VSCode入门</h2><ul>
<li>主要讲一下“学习”区域的三个功能：命令面板、界面概览和交互式演习场</li>
</ul>
<h3 id="命令面板"><a href="#命令面板" class="headerlink" title="命令面板"></a>命令面板</h3><ul>
<li>首先来看命令面板，它是 VS Code 快捷键的主要交互界面，你可以通过 F1 或者“Cmd+Shift+P ”(Windows 上是 “Ctrl+Shift+P”) 打开。这里提醒一下，如无特殊说明，我在这个专栏里默认基于macOS平台进行讲解，但也会本着为你提供方便的原则，同时给出Windows或Linux平台下的操作说明。通过编辑器来实现高效编程的思路是一致的，这和具体的使用平台无关，所以你大可不必为此担心。</li>
<li>你可以在命令面板中快速搜索命令并且执行。如果你的 VS Code 是简体中文版，那么你可以在命令面板里使用中文或者英文来搜索命令。VS Code 的绝大多数命令都可以在命令面板里搜到，所以熟练使用命令面板，你就可以摆脱鼠标，完全通过键盘操作来完成全部编码工作。</li>
</ul>
<h3 id="界面概览"><a href="#界面概览" class="headerlink" title="界面概览"></a>界面概览</h3><ul>
<li>第二个是界面概览，它展示了 VS Code 默认界面里的不同部件的位置、名称和快捷键。VS Code 强调无鼠标操作，但是对于初学者而言快捷键的记忆是个麻烦，这个界面恰好可以帮助你渡过最初的不适应阶段。</li>
</ul>
<h3 id="交互式演习场"><a href="#交互式演习场" class="headerlink" title="交互式演习场"></a>交互式演习场</h3><ul>
<li>第三个是交互式演习场，打开这个界面，你会看到一个全英文的初学者教程，其中通过各种交互示例给出了 VS Code 的核心功能，展示了一些高级代码编辑功能的使用，每个功能都会有一个代码片段和编辑器供你实时使用。</li>
</ul>
<h3 id="命令行的使用"><a href="#命令行的使用" class="headerlink" title="命令行的使用"></a>命令行的使用</h3><ul>
<li><p>如果你是 Windows用户，安装并重启系统后，你就可以在命令行中使用 code 或者 code-insiders了，如果你希望立刻而不是等待重启后使用，可以将 VS Code 的安装目录添加到系统环境变量 PATH中， Windows 64 位下的 VS Code 安装路径是 C:\Program FIles\Microsoft VS Code下。</p>
</li>
<li><p>如果你希望使用已经打开的窗口来打开文件，可以在 code 命令后添加参数 -r来进行窗口的复用。</p>
</li>
<li><p>你也可以使用参数 <code>-g &lt;file:line[:character]&gt;</code> 打开文件，然后滚动到文件中某个特定的行和列，比如:</p>
<ul>
<li>输入 <code>code -r -g package.json:128</code>命令，你就可以打开 <code>package.json</code> 这个文件，然后自动跳转到 128 行。</li>
<li>这个命令可以方便你从终端里快速地在 VS Code 里打开一个文件进行预览，一个特别常见的例子就是当我们使用脚本执行某个命令，这个命令告诉我们某个文件的某一行出现了错误，我们就能够快速定位了。</li>
</ul>
</li>
<li><p>VS Code 也可以用来比较两个文件的内容，你只需使用 -d参数，并传入两个文件路径，比如:</p>
<ul>
<li>输入 <code>code -r -d a.txt b.txt</code>命令，就可以比较<code>a.txt</code>和<code>b.txt</code>两个文件的内容了。</li>
<li>有了这个命令，你就可以既使用命令行运行脚本，也可以借助 VS Code 的图形化界面进行文件内容的对比了。</li>
</ul>
</li>
<li><p>VS Code 命令行除了支持打开磁盘上的文件以外，也接受来自管道中的数据。这样你就可以将原本在命令行中展示的内容，实时地展示在 VS Code 里，然后在编辑器中搜索和修改。比如,你可以把当前目录下所有的文件名都展示在编辑器里，此时只需使用<code>ls | code -</code>命令。</p>
</li>
</ul>
<h2 id="VSCode-键盘操作"><a href="#VSCode-键盘操作" class="headerlink" title="VSCode 键盘操作"></a>VSCode 键盘操作</h2><ul>
<li>VSCode 键盘操作，做到双手不离键盘，今天先来谈一谈核心的键盘操作：光标的移动、文本的选择、文本的删除，以及如何为编辑器命令绑定快捷键。</li>
</ul>
<h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><ul>
<li><p>移动光标最常用的就是方向键，但是方向键每次只能把光标移动一个位置，可以说是一种相对低效的方式。</p>
</li>
<li><p>首先是针对单词的光标移动。这个你应该比较熟悉，绝大多数原生的编辑应用和文本框都支持。这也是我自己最常用的一组快捷键。</p>
<ul>
<li>下面这张图显示，第一行代码中的第一个单词是 function，一共8个字符，光标的位置在第五个字符 t 的后面。当你想把光标直接移动到整个单词，也就是 function 的前面，你只需按下 Option（Windows 上是 Ctrl 键）和左方向键。相反，如果要把光标移动到单词的末尾，只需要按下 Option 和右方向键就好了。</li>
<li>我们都知道，一直按着方向键，光标就可以不停地，一个字符一个字符地在文档中移动。但如果你同时按住 Option 和方向键，那么光标移动的颗粒度就变成了单词，你就可以在文档中以单词为单位不停地移动光标了</li>
</ul>
</li>
<li><p>第二种方式是把光标移动到行首或者行末。比如第一行代码是 function foo() {，你只需按住 Cmd + 左方向键（Windows 上是 Home 键），就可以把光标移动到了这行的第一列；而如果你按住 Cmd 和右方向键（Windows 上是 End 键），光标就会被移动到 { 的后面。</p>
</li>
<li><p>接下来一种是对于<strong>代码块的光标移动</strong>。很多编程语言都使用花括号将代码块包裹起来，比如 if、for 语句等，你很可能会希望通过一个快捷键，就能实现在代码块的始末快速跳转。比如在这5行代码示例中，第一行到第三行代码是函数 foo 的定义，由一对花括号包裹起来，当你把光标放在花括号上时，只需按下 Cmd + Shift + \（Windows 上是 <code>Ctrl + Shift + \</code>），就可以在这对花括号之间跳转。</p>
</li>
<li><p>最后一种基础的光标操作就是移动到文档的第一行或者最后一行，你只需按下 Cmd 和上下方向键即可（Windows 上是 <code>Ctrl + Home/End</code> 键）。</p>
</li>
</ul>
<h3 id="文本选择"><a href="#文本选择" class="headerlink" title="文本选择"></a>文本选择</h3><ul>
<li>掌握了上面的快捷键之后，你还可以非常轻松地掌握文本选择的操作。因为对于基于单词、行和整个文档的光标操作，你只需要多按一个 Shift 键，就可以在移动光标的同时选中其中的文本</li>
</ul>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><ul>
<li><p>比如你想把当前行中光标之前的文本全部删除，就可以先选中这段文本（Windows&#x2F;Linux: Home + Shift，macOS: Cmd + Left + Shift )，然后再按删除键。不过对于频繁使用的删除操作，你肯定希望单次操作就可以完成任务，而不是重复地选择文本然后删除，那么你需要记住下面几个命令。</p>
</li>
<li><p>假设你把光标放在第二行代码的中间位置，然后按下 Cmd 和 Backspace（MacOS上就是“fn + delete”的组合，Windows 上未绑定快捷键，可以打开命令面板运行“删除右侧所有内容”），就能够把第二行代码光标后（右侧）的字符全部删掉。</p>
</li>
<li><p>按下 Cmd 和 Delete 键则是删除当前行中光标前（左侧）的所有内容（Windows 上未绑定快捷键，可以打开命令面板运行“删除左侧所有内容”）</p>
</li>
<li><p>删除单词内的字符与此类似。假设把光标放在第一行第四个字符 c 的后面。Option 加左方向键把光标移动到 function 这个单词的开头，Option加左方向键再加 Shift 即可选中 func 这四个字符，而Option 加 Delete 则会删除 func 这四个字符。这里你可能看出来了，这些快捷键共同的是 Option 键，然后通过按下 Shift 或者 Delete 键，来达到不同的效果。</p>
</li>
<li><p>相反地，Option 加 Backspace（MacOS上就是“fn + delete”的组合） 则会删除 function 的后四个字符 tion。</p>
</li>
</ul>
<h3 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h3><ul>
<li><p>前面我们提到，VS Code 内置了很多的命令，但是并没有为每个命令都提供一个快捷键，毕竟快捷键的组合总是有限的。不过 VS Code 提供了快捷键的修改和自定义功能，这样你就可以根据自己的使用习惯，给自己常用的命令指定顺手的快捷键。</p>
</li>
<li><p>首先你可以打开命令面板（你还记得它的快捷键不？），搜索“打开键盘快捷方式”然后执行，这时你将看到相对应的界面。</p>
</li>
<li><p>然后通过搜索找到你希望修改快捷键的命令，双击，接下来你只要按下你期望的快捷键，最后按下回车键就可以了。</p>
</li>
<li><p>比如，你可以搜索“选择括号内所有内容”，双击，按下”Cmd + Shift + ]”，然后按下回车，这个快捷键就绑定上了。</p>
</li>
<li><p>VS Code 的快捷键修改界面已经考虑到了这一点，你可以在搜索框内搜索你使用的快捷键，然后就可以看到这个快捷键当前对应的命令是哪个。</p>
</li>
</ul>
<h2 id="VSCode-代码行编辑"><a href="#VSCode-代码行编辑" class="headerlink" title="VSCode 代码行编辑"></a>VSCode 代码行编辑</h2><ul>
<li><p>要删掉一行代码，你可以选中它，然后再按 Delete 键。不过还有一个快捷键，那就是直接按下 “ Cmd + Shift + K ” (Windows 上是 “Ctrl + Shift + K”)，当前代码行就可以被删除了。</p>
</li>
<li><p>如果你只是想要剪切这行代码，那么你直接按下 “ Cmd + x ” (Windows 上是 “Ctrl + x”) 即可。</p>
</li>
<li><p>我想你肯定很清楚，“Enter” 键的基础作用是能在编辑器里光标所在的位置添加一个换行符。但是很多时候你可能并不是单纯地要将一行分成两段，而是希望在这行的下面或者上面开始一段新的代码。</p>
</li>
<li><p>这个功能对应的快捷键非常好记，它跟 “Enter”键十分接近。当你想在当前行的下面新开始一行时，你只需按下 “Cmd + Enter” （Windows 上是 “Ctrl + Enter”）；而当你想在当前行的上面新开始一行时，你只要按下 “Cmd + Shift + Enter” （Windows 上是 “Ctrl + Shift + Enter”）就行了</p>
</li>
<li><p>当你想移动一段代码时，一般你可能会分三步走：先选中，再剪切，最后粘贴。不过我更喜欢的是按住 “Option + 上下方向键”（Windows中就是“Alt + 上下方向键”） ，将当前行，或者当前选中的几行代码，在编辑器里上下移动。</p>
</li>
<li><p>如果你同时按住 “Shift” 键的话，也就是 “Option + Shift + 上下方向键”（Windows中就是“Alt + shift + 上下方向键”），那就可以复制这几行，然后粘贴到当前行的上面或者下面。</p>
</li>
<li><p>另外，你在尝试“Option + 上下方向键”这个快捷键“上下移动”时，可能也发现了，当你把一段代码移动到花括号里面或者外面时，代码前的制表符或者空格的数量会自动发生改变，这样你就不需要移动完代码后再调整了。</p>
</li>
</ul>
<h2 id="VSCode-撤销光标移动"><a href="#VSCode-撤销光标移动" class="headerlink" title="VSCode 撤销光标移动"></a>VSCode 撤销光标移动</h2><ul>
<li>VSCode 撤销光标移动，撤销光标的移动和选择。有的时候你移动完光标之后，又希望把光标回退到上一个位置，这时你只需按下 “Cmd + U”（Windows 上是 <code>Ctrl + U</code>），就可以撤销这一次光标的移动。</li>
</ul>
<h2 id="VSCode-行排序"><a href="#VSCode-行排序" class="headerlink" title="VSCode 行排序"></a>VSCode 行排序</h2><ul>
<li>VSCode 行排序。无论是你在写代码，还是写 Markdown，你都可以把代码行按照字母序进行重新排序。不过这个命令比较小众，VS Code 并没有给这个命令指定快捷键，你可以调出命令面板，然后搜索 “按升序排列行” 或者 “按降序排列行” 命令执行。</li>
</ul>
<h2 id="VSCode-合并代码行"><a href="#VSCode-合并代码行" class="headerlink" title="VSCode 合并代码行"></a>VSCode 合并代码行</h2><ul>
<li>VSCode 合并代码行。有的时候你可能会为了避免代码看起来过于冗余，就会把比较短小的几行代码合并到一行里面去。这时，你只需要按下 “ Ctrl + j ” （Windows 上未绑定快捷键，可以打开命令面板，搜索 ”合并行“）就可以了，而不需要不断地调整光标、删除换行符。</li>
</ul>
<h2 id="VSCode-调整字符大小写"><a href="#VSCode-调整字符大小写" class="headerlink" title="VSCode 调整字符大小写"></a>VSCode 调整字符大小写</h2><ul>
<li>VSCode 调整字符大小写，我估计这个你会经常用到。你可以选中一串字符，然后在命令面板里运行“转换为大写”或 “转换为小写”, 来变换字符的大小写。</li>
</ul>
<h2 id="VSCode-调换字符位置"><a href="#VSCode-调换字符位置" class="headerlink" title="VSCode 调换字符位置"></a>VSCode 调换字符位置</h2><ul>
<li>VSCode 调换字符的位置。你可以按下 “Ctrl + t” （Windows 上未绑定快捷键，可以打开命令面板，搜索 ”转置游标处的字符“） 来把当前光标前后的字符调换位置。</li>
</ul>
<h2 id="VSCode-代码缩进"><a href="#VSCode-代码缩进" class="headerlink" title="VSCode 代码缩进"></a>VSCode 代码缩进</h2><ul>
<li>VSCode 代码缩进，有的时候，你会觉得代码格式化太重了，需要的可能只是把代码里的缩进调整一下。这时你可以打开命令面板（快捷键“Cmd + Shift + P”），搜索 “缩进”，然后使用 “重新缩进行” 将整个文档的缩进进行调整，但更多时候，你只需要运行 “重新缩进选中行” 来调整部分选中代码行的缩进。</li>
</ul>
<h2 id="VSCode-代码格式化快捷键"><a href="#VSCode-代码格式化快捷键" class="headerlink" title="VSCode 代码格式化快捷键"></a>VSCode 代码格式化快捷键</h2><ul>
<li><p>VSCode 代码格式化快捷键，我们平常在做自己的小项目或者随便写一些脚本的时候，可能不会太在意代码的格式。不过一旦开始团队合作，整个项目组则会选择同一个代码风格和格式以有效降低协同成本。所以定期对自己写的代码进行格式化是个很好的习惯。</p>
</li>
<li><p>你可以按下 “Option + Shift + F” （Windows 上是 <code>Alt + Shift + F</code>）来对整个文档进行格式化，VS Code 也会根据你当前的语言，选择相关的插件。当然，前提条件是你已经安装了相关插件。</p>
</li>
<li><p>你也可以选中一段代码，然后按下 “Cmd + K Cmd + F” （Windows 上是 Ctrl + K Ctrl + F），这样只有这段被选中的代码才会被格式化。</p>
</li>
</ul>
<h2 id="VSCode-添加代码注释"><a href="#VSCode-添加代码注释" class="headerlink" title="VSCode 添加代码注释"></a>VSCode 添加代码注释</h2><ul>
<li>VSCode 添加代码注释，你在调试代码时，肯定经常需要临时地把一些代码注释掉。如果你要将一行代码注释掉，你只需按下 Cmd + &#x2F; （Windows 上时 <code>Ctrl + /</code>）。如果你需要把一整段代码注释掉，按下 Option + Shift + A即可。</li>
</ul>
<h2 id="VSCode-自动补全"><a href="#VSCode-自动补全" class="headerlink" title="VSCode 自动补全"></a>VSCode 自动补全</h2><ul>
<li><p>VS Code自动补全,VS Code 当中的自动补全内容，其实是由语言服务来提供的。本文介绍VS Code自动补全功能和VS Code自动补全设置。</p>
</li>
<li><p>VS Code 为编程语言工作者提供了统一的 API ，即 Language Server Protocol，每种语言都能够通过实现这个 API 在 VS Code 上得到类似 IDE 的开发体验，而各个语言根据这个 API 实现的服务，就被称为语言服务。</p>
</li>
<li><p>语言服务会根据当前的项目、当前的文件，以及光标所在的位置，为我们提供一个建议列表。这个列表包含了在当前光标位置下我们可能会输入的代码。当我们不断地输入字符，VS Code 就会根据当前输入的字符，在这个列表进行过滤。</p>
</li>
<li><p>如果我们偶尔觉得这个自动补全窗口是多余的，希望暂时不看到它，可以按下 Escape 键将其隐藏。后续如果希望再次看到这个窗口，除了通过打字来将其调出以外，我们还可以按下 <code>“Ctrl + 空格键”</code>来手动地调出建议列表。</p>
</li>
<li><p>刚才我们提到，VS Code 会根据我们输入的字符在这个建议列表里进行过滤。同时，这个过滤是允许我们犯一点小错误的，比如打字特别快的时候少打一个字母，VS Code 也能处理这个情况。比如在下面的动图里，我想使用 console 里的 debug 函数，但是我只打了 db 两个字母，建议列表依然为我提供了 debug 这个选项。</p>
</li>
<li><p>上面的这几个窗口，它们都是通过我们输入的内容自动触发的，也就是说，编程语言决定了我们什么时候看到什么内容。虽然我们可以通过快捷键将其快速地关闭和唤出，但是有的时候自动补全窗口出现得过于频繁，也是会影响我们的编程体验的，毕竟悬浮窗口会遮盖一部分代码，影响我们的阅读。</p>
</li>
<li><p>不过，我们可以通过几个设置，控制自动补全窗口出现的频率和方式，甚至这个窗口的大小。</p>
</li>
<li><p>首先我们可以通过设置 “editor.quickSuggestions” 来决定在什么语境下自动补全窗口会被唤出。默认设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;editor.quickSuggestions&quot;: &#123;</span><br><span class="line">   &quot;other&quot;: true,</span><br><span class="line">   &quot;comments&quot;: false,</span><br><span class="line">   &quot;strings&quot;: false</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个配置有三个选项：other、comments和strings。其中，comments 就是代码注释，strings 就是指字符串。默认情况下，当光标在代码注释或者字符串里，自动补全窗口就不会被自动唤出了。但如果你希望这个窗口永远不被自动唤出，那么你就需要将“other” 也改为 “false”。</li>
</ul>
</li>
<li><p>这时你可能会问了，如果关闭了这个设置，我想看到自动补全该怎么办呢？不用担心，当你按下 “Ctrl + 空格键” 之后，这个窗口依然会被打开，不管设置是关闭还是开启的状态。看到这个设置，你肯定也就明白了，为什么默认情况下你在写注释的时候没有代码自动补全的提示了吧。</p>
</li>
<li><p>参数预览窗口也是一样的，你可以通过参数 “editor.parameterHints.enabled” 将其关闭。当你觉得自己需要看一看参数预览时，按下快捷键或者通过命令面板就能够将其打开了。 </p>
</li>
<li><p>上面的这个设置决定“是与否”的问题，但你也可以控制自动补全窗口出现的时间。自动补全窗口监听文件内容的变化，当你停止输入时，它就会试着给你提供建议。但是有的时候你打字稍微快一些，自动补全窗口才刚刚出现，你就输入了更多的内容，紧接着代码服务就要重新计算并提供建议了。如果你希望减少这种不必要的提示，可以增大设置 “editor.quickSuggestionsDelay” 的值，这样在你输入完代码后，自动补全窗口就会多等一会儿，然后再跳出来。</p>
</li>
<li><p>其他几个自动补全的设置，你可以在设置里搜一搜 “editor.suggest”，自己修改玩一玩。</p>
</li>
<li><p>上面提到的几个功能，它们都依托于语言服务来提供内容。但是有的时候，语言服务并不完美。编辑器于是提供了一种相对 “笨” 一些的提示，那就是基于单词的提示。编辑器通过分析当前的文件里的内容，进行简单的正则表达式匹配，给我们建议已经出现过的单词。</p>
</li>
</ul>
<h2 id="VSCode-文本选择"><a href="#VSCode-文本选择" class="headerlink" title="VSCode 文本选择"></a>VSCode 文本选择</h2><ul>
<li><p>最简单的方式，也是我们每个人最熟悉的方式，就是按住鼠标左键，然后拖动鼠标，直到选中所有我们想要选择的文字为止，再松开鼠标即可。</p>
</li>
<li><p>那是不是说鼠标用户要完成类似的操作，就只能“一点、二拖、三松手”呢？当然不是，VS Code 其实给鼠标也配备了类似的快捷键。</p>
</li>
<li><p>在VS Code中：</p>
<ul>
<li>你单击鼠标左键就可以把光标移动到相应的位置。</li>
<li>而双击鼠标左键，则会将当前光标下的单词选中。</li>
<li>连续三次按下鼠标左键，则会选中当前这一行代码。</li>
<li>最后是连续四次按下鼠标左键，则会选中整个文档。</li>
</ul>
</li>
<li><p>到这里你可能会问，如果我想要使用鼠标，选中其中的多行代码该怎么办？VS Code也考虑到了这个情况，在编辑器的最左边，显示的是每一行的行号。如果你单击行号，就能够直接选中这一行。如果你在某个行号上按下鼠标，然后上下移动，则能够选中多行代码。</p>
</li>
</ul>
<h2 id="VSCode-快速预览"><a href="#VSCode-快速预览" class="headerlink" title="VSCode 快速预览"></a>VSCode 快速预览</h2><ul>
<li>VS Code快速预览是指，有的时候，当我们看到一个建议列表里的某个函数名，我们可能并不能够立刻想起它的作用是什么，它的参数定义是什么样的。</li>
<li>这时候我们可以单击当前这一项建议的最右侧的蓝色图标。</li>
<li>点击这个图标后，建议列表旁边就有出现一个快速预览的窗口，而这个窗口里面呈现的就是这个函数的定义。具体如下图：</li>
<li>除了使用鼠标键外，我们还可以使用 “Ctrl+空格键”组合键来快速调出这个快速预览窗口。</li>
</ul>
<h2 id="VSCode-参数预览"><a href="#VSCode-参数预览" class="headerlink" title="VSCode 参数预览"></a>VSCode 参数预览</h2><ul>
<li>VS Code参数预览,当我们从建议列表选择了一个函数，然后输入括号，准备开始输入参数时，我们会看到一个参数预览的悬浮框。通过这个参数预览的窗口，我们可以知道这个函数可以传入哪些参数，它们的参数类型又是什么样的。</li>
<li>同样的，隐藏这个窗口的快捷键也是 Escape。如果你想再次将其调出的话，需要按下 “Cmd + Shift + Space” （Windows 上是 Ctrl + Shift + Space）。</li>
</ul>
<h2 id="VSCode-重构"><a href="#VSCode-重构" class="headerlink" title="VSCode 重构"></a>VSCode 重构</h2><ul>
<li><p>当我们想要修改一个函数或者变量的名字的时候，我们只需要把光标放到函数或者变量名上，然后按下F2，这样这个函数或者变量出现的地方就都会被修改</p>
</li>
<li><p>这个操作并不是一个粗暴的搜索关键词并替换，在上面的动图中你可以看到，最后一行代码里有个 bar3函数调用，但当我们去重命名 bar这个函数时，bar3并没有受到影响。</p>
</li>
<li><p>除了重命名外，另一个常用的重构的操作就是把一段长代码抽取出来转成一个单独的函数。在VS Code中，我们只需选中那段代码，点击黄色的灯泡图标，然后选择对应的重构操作即可。</p>
</li>
<li><p>要注意的是，并不是每个语言服务都支持重构的操作。如果你选中一段代码后，但没有看到那个黄色的灯泡图标，那么也就是说你使用的这门语言可能还没有支持快速重构。</p>
</li>
</ul>
<h2 id="VSCode-文本编辑"><a href="#VSCode-文本编辑" class="headerlink" title="VSCode 文本编辑"></a>VSCode 文本编辑</h2><ul>
<li><p>VS Code文本编辑，在 VS Code中，我们除了能够使用鼠标来选择文本以外，还能够使用鼠标对文本进行一定程度的修改，我们把它称为拖放功能（drag and drop）。</p>
</li>
<li><p>比如在今天的示例代码中，我们选中 bar 这个函数，然后将鼠标移到这段选中的代码之上，按下鼠标左键不松开。这时你可以看到，鼠标指针已经从一条竖线，变成了一个箭头。这时候我们移动鼠标的话，就可以把这段文本拖拽到我们想要的位置。</p>
</li>
<li><p>在移动的过程当中，我们能够在编辑器中看到一个由虚线构成的光标，当我们松开鼠标左键的时候，这段文本就会被移动到这个虚拟的光标所在的位置。</p>
</li>
<li><p>如果我们在拖拽这段文本的同时，按下 Option 键（Windows 上是 Ctrl 键），鼠标指针上会多一个加号，这时候我们再移动鼠标或虚拟光标至我们想要的位置，然后当我们松开鼠标左键的时候，这段文本将会被复制粘贴到虚拟光标所在的位置，也就是我们既定的目标位置。</p>
</li>
<li><p>你看，在移动鼠标的过程中，多按了个 Option 键（Windows 上是 Ctrl 键），操作结果就由原来的“剪切+粘贴”变为“复制+粘贴”了。</p>
</li>
</ul>
<h2 id="VSCode-多光标"><a href="#VSCode-多光标" class="headerlink" title="VSCode 多光标"></a>VSCode 多光标</h2><ul>
<li><p>VSCode 多光标特性，在我们的日常编码过程中，有很多工作，它本身就是具有“重复”属性的。比如你需要把多个单词的第一个字母从小写变成大写，这种跟业务逻辑相关的重复性操作，编辑器很难为它们一个个单独做优化。</p>
</li>
<li><p>而 VS Code 的多光标特性其实就是用来解决这类问题的。当你在一个文本框或者某个输入框里打入字符时，会有一个竖线来显示你将要输入文字的位置，这就是“光标”。顾名思义，多光标其实就是多个输入位置，这里你可以脑补下多个竖线的场景。</p>
</li>
<li><p>多光标特性允许你在输入框的多个位置创建光标，这样你就可以在多个不同的位置同时输入文字或者执行其他操作</p>
</li>
<li><p>“Cmd + D” 这个命令的作用是，第一次按下时，它会选中光标附近的单词；第二次按下时，它会找到这个单词第二次出现的位置，创建一个新的光标，并且选中它。这样只需要按下三次，你就选中了所有的“5”。这个时候你再按下 “右方向键”，输入“px”，即可完成任务。</p>
</li>
<li><p>接下来讲讲第二种，是跟代码行批量处理有关，也还是用的前面的代码。首先你选择多行代码，然后按下 “Option + Shift + i” （Windows 上是 Alt + Shift + i），这样操作的结果是：每一行的最后都会创建一个新的光标。</p>
</li>
<li><p>不过，VS Code 中还有一个更加便捷的鼠标创建多光标的方式。当然，这首先要求你的鼠标拥有中键。你只需按下鼠标中键，然后对着一段文档拖出一个框，在这个框中的代码就都被选中了，而且每一行被选中的代码，都拥有一个独立的光标。</p>
</li>
</ul>
<h2 id="VSCode-代码跳转和链接"><a href="#VSCode-代码跳转和链接" class="headerlink" title="VSCode 代码跳转和链接"></a>VSCode 代码跳转和链接</h2><ul>
<li>我们还是把鼠标移动到示例代码的第五行 foo 上，然后按下 Cmd 键，这时候 foo下面出现了一个下划线。然后当我们按下鼠标左键，就跳转到了 foo函数的定义处。</li>
</ul>
<h2 id="VSCode-文件跳转"><a href="#VSCode-文件跳转" class="headerlink" title="VSCode 文件跳转"></a>VSCode 文件跳转</h2><ul>
<li>在VS Code中，解决这个问题的第一个方法，就是按下 “Ctrl+Tab”，然后继续按着 “Ctrl”键但是松开 “Tab” 键，这样你就可以打开一个文件列表，这个列表罗列了当前打开的所有文件。接下来，你可以通过按下 “Tab”键在这个列表里跳转，选择你想要打开的文件。最后选到你想打开的文件后，松开 “Ctrl” 键，这个文件就被打开了</li>
<li>还好，VS Code 在命令面板里提供了一种支持搜索的文件跳转方式。当你按下 “Cmd + P” （Windows 上是 Ctrl + P）时，就会跳出一个最近打开文件的列表，同时在列表的顶部还有一个搜索框。</li>
<li>看到这里想必你应该明白了，你可以使用这个搜索框来快速地找到你想要的文件，然后按下 “Enter” 键直接打开，这整个过程简单而且顺畅。</li>
</ul>
<h2 id="VSCode-行跳转"><a href="#VSCode-行跳转" class="headerlink" title="VSCode 行跳转"></a>VSCode 行跳转</h2><ul>
<li>VS Code也提供了一种极为简单的方式来支持行跳转，你只需要按下 “Ctrl + g”，紧接着编辑器就会出现一个输入框</li>
<li>如果你想跳转到某个文件的某一行，你只需要先按下 “Cmd + P”，输入文件名，然后在这之后加上 “:”和指定行号即可。跳转到指定文件的指定行数</li>
</ul>
<h2 id="VSCode-符号跳转"><a href="#VSCode-符号跳转" class="headerlink" title="VSCode 符号跳转"></a>VSCode 符号跳转</h2><ul>
<li><p>VS Code符号跳转，文件跳转和行跳转，是代码跳转的基本操作，也是日常编码中的高频操作。不过有的时候，你可能会希望能够立刻跳转到文件里的类定义，或者函数定义的位置。为了支持这种跳转，VS Code 提供了一套 API 给语言服务插件，它们可以分析代码，告诉 VS Code 项目或者文件里有哪些类、哪些函数或者标识符（我们把这些统称为符号）。</p>
</li>
<li><p>如果要在一个文件里的符号之间跳转，你只需按下 “Cmd + Shift + O” （Windows 上是 Ctrl + Shift + O），就能够看到当前文件里的所有符号。</p>
</li>
<li><p>使用方向键，或者搜索，找到你想要的符号后，按下回车，就能够立刻跳转到那个符号的位置。如下图所示：通过符号功能跳转到指定的代码位置</p>
</li>
<li><p>请注意，在按下 “Cmd + Shift +O”后，输入框里有一个 “@”符号，这个符号在这里的意义，我会在后面的章节里去介绍，你可以先留个心眼。这时，如果你输入 “:”，就可以将当前文件的所有符号，进行分类，这样搜索符号也就更加方便。</p>
</li>
<li><p>有些语言除了提供单个文件里的符号，还支持在多个文件里进行符号跳转。比如在 VS Code 里，如果你打开了多个 JavaScript 文件，就可以按下 “Cmd + T” （Windows 上是 Ctrl + T），搜索这些文件里的符号。</p>
</li>
<li><p>通过“Cmd + T”，搜索多个文件的符号</p>
</li>
</ul>
<h2 id="VSCode-定义和实现间跳转"><a href="#VSCode-定义和实现间跳转" class="headerlink" title="VSCode 定义和实现间跳转"></a>VSCode 定义和实现间跳转</h2><ul>
<li>F12跳转到函数定义的位置</li>
<li>也可以按下 “Cmd + F12” （Windows 上是 Ctrl + F12），跳转到函数的实现的位置。</li>
</ul>
<h2 id="VSCode-跳转到引用的地方"><a href="#VSCode-跳转到引用的地方" class="headerlink" title="VSCode 跳转到引用的地方"></a>VSCode 跳转到引用的地方</h2><ul>
<li><p>VS Code引用跳转，很多时候，除了要知道一个函数或者类的定义和实现以外，你可能还希望知道它们被谁引用了，以及在哪里被引用了。这时你只需要将光标移动到函数或者类上面，然后按下 “Shift + F12”，VS Code 就会打开一个引用列表和一个内嵌的编辑器。在这个引用列表里，你选中某个引用，VS Code 就会把这个引用附近的代码展示在这个内嵌的编辑器里。</p>
</li>
<li><p>Shift+ F12打开函数引用预览</p>
</li>
</ul>
<h2 id="VSCode-代码片段"><a href="#VSCode-代码片段" class="headerlink" title="VSCode 代码片段"></a>VSCode 代码片段</h2><ul>
<li><p>VSCode代码片段，有的时候，我们经常输入的代码是业务强相关的，语言服务没法做出优化；或者是一些我们经常使用的定式，比如循环语句、创建一个新的类或者一个 UI 控件，我们经常写类似的代码，只不过每次都要做细微的修改。对于这些代码，我们可以将它们抽象成模板，保存起来，等下次要使用的时候直接调用即可。</p>
</li>
<li><p>代码片段是对常用代码的一个抽象，它保留了大部分不变的代码，然后把需要经常变动的部分，换成变量，这样等下次调用它的时候，只需要把这些变量换成我们需要的就可以了</p>
</li>
<li><p>首先，我们打开命令面板，搜索“配置用户代码片段”（Configure User Snippets）并且执行。这时候我们会看到一个列表，让我们选择语言。这里我们依然选择 JavaScript 作为我们的示例语言，不用担心，代码都是非常简单和易于理解的。命令面板，搜索“配置用户代码片段”并且执行</p>
</li>
<li><p>选择完语言后，我们就能看到一个 JSON 文件被打开了，这个文件里的内容，现在都是被注释掉的。我们可以选中第七行到第十四行，按下 Cmd+ &#x2F; 取消注释。</p>
</li>
<li><p>在上面的例子里，这个代码片段的名字叫做 Print to console 。这个代码片段对象的值，也就是花括号里的代码，必须要包含 “prefix” 前缀和 “body” 内容这两个属性。同时，这个值还可以包含 “description” 描述这个属性，但这个属性不是必须的。</p>
</li>
<li><p>“prefix” 的作用是，当我们在编辑器里打出跟 “prefix” 一样的字符时，我们就能在建议列表里看到这个代码片段的选项，然后我们按下 Tab 键，就能够将这个代码片段的 “body” 里面的内容插入到编辑器里。如果这个代码片段有 “description” 这个属性的话，那么我们还能够在建议列表的快速查看窗口里看到这段 “description”。</p>
</li>
<li><p>输入 log 即可看到 Print to console 代码片段，然后再按下回车或者 Tab 键，就能够将这个代码片段插入编辑器了。</p>
</li>
</ul>
<h2 id="VSCode-折叠代码快捷键"><a href="#VSCode-折叠代码快捷键" class="headerlink" title="VSCode 折叠代码快捷键"></a>VSCode 折叠代码快捷键</h2><ul>
<li><p>VSCode折叠代码快捷键，我们再来一起看一下有哪些折叠和展开代码的快捷键。首先是折叠和展开代码的两个快捷键。</p>
</li>
<li><p>当我们按下 “Cmd + Option + 左方括号”（Windows 上是 Ctrl + Shift + 左方括号），当前光标所处的最内层的、可以被折叠的代码就会被折叠起来。请注意，我们在这里加了两个限制条件，“最内层”和“可以被折叠”。我们可以先用下面一个小例子来理解这两个条件。</p>
</li>
</ul>
<h2 id="VSCode-小地图"><a href="#VSCode-小地图" class="headerlink" title="VSCode 小地图"></a>VSCode 小地图</h2><ul>
<li><p>如果你是在一个比较大的屏幕上工作，需要快速了解整个文件的全貌，并且还能靠鼠标快速地移动，那么这时小地图就很有用了。这个功能默认是打开的，所以你无需特别设置。这个使用起来比较简单，你可以像我在图中展示的那样试着打开一个较大的文件，感受一下它的妙处。</p>
</li>
<li><p>很多游戏中也有类似的小地图功能，不知道你有没有似曾相识的感觉。</p>
</li>
<li><p>除了控制小地图是否打开，编辑器还为我们提供了几个渲染的配置项。比如说，默认情况下，小地图会将每个字符都渲染出来。但是我们并不能真正地通过小地图来看代码，我们只是要看个大概结构罢了，那么我们可以打开命令面板，搜索“打开设置”（Open Settings），进入设置界面后，搜索 “editor.minimap.renderCharacters” ，找到后将其关闭，这样一来，所有的字符，都会被渲染成一个个小色块。</p>
</li>
<li><p>同样的，我们还可以通过 “editor.minimap.maxColumn” 来控制小地图里每一行渲染多少个字符。很多时候我们只需看下每行代码前的缩进和前面的代码高亮，就能看出个大概来了。</p>
</li>
</ul>
<h2 id="VSCode-单文件搜索"><a href="#VSCode-单文件搜索" class="headerlink" title="VSCode 单文件搜索"></a>VSCode 单文件搜索</h2><ul>
<li><p>VSCode单文件搜索，今天我们重新回到原点，来看一下如何使用编辑器自带的文本搜索功能，快速地穿梭于海量的代码之中。在我看来，一个功能丰富且快速的搜索，在很多情况下甚至会比语言服务还要来得有用。</p>
</li>
<li><p>我们把光标放在编辑器当中，然后按下 “Cmd + F” （Windows 上是 Ctrl + F），就能够快速地调出搜索窗口（可能这个命令你早就发现了或者经常使用了）。当我们调出搜索窗口的时候，编辑器就会把当前光标所在位置的单词自动填充到搜索框中。与此同时，当前文件里和搜索关键词相同的单词都会被高亮出来。</p>
</li>
<li><p>自动填充搜索关键词的好处在于，当我们按下 “Cmd +F” 搜索这个单词之后，我们还能够立刻通过回车键或者 “shift+回车键” 在所有搜索结果当中快速跳转。</p>
</li>
<li><p>这里需要注意的事情是，当我们开始搜索的时候，光标已经被移动到了搜索框当中，如果在这时候我们继续打字的话，那原有的搜索关键词将会被修改。</p>
</li>
<li><p>如果我们希望找到搜索结果后，接下来就直接修改编辑器中的内容，那么就得将光标重新移动到编辑器当中，听起来就挺不方便的，是不是？</p>
</li>
<li><p>这种情况下，我们不妨换一个快捷键。首先我们将光标移动到我们想要搜索的单词处，然后按下 “Cmd + G” （Windows 上是 F3），此时我们同样调出了搜索框，但与前面 “Cmd +F ” 这个快捷键不同的是，这时光标依然是在编辑器当中，而不是在搜索框中。</p>
</li>
<li><p>下面我们再一起来看下这个搜索框中都有哪些功能。</p>
</li>
<li><p>当我们在搜索框中打字的时候，搜索操作是自动触发的，而无需我们再按下回车键去手动地执行搜索这个操作。</p>
</li>
<li><p>除了搜索纯文本以外，搜索框还支持多种不同的搜索方式。比如，在搜索框的最右侧，就有三个配置按钮。</p>
<ul>
<li>第一个是大小写敏感。 这个很好理解，就是在文档中搜索关键词的时候，搜索的结果是否要跟关键词大小写完全一致。默认情况下，VS Code 的搜索是不区分大小写的，也就是说哪怕大小写不一样，也会算到搜索结果里去。但如果我们不想要这个特性，就可以点击这个按钮，或者按下 “Cmd+Option+C” （Windows 上是 Alt + C）来关闭它。</li>
<li>第二个是全单词匹配。 有的时候我们搜索的单词恰好是别的某个单词中间的一部分，如果我们不希望这样的结果出现在搜索结果中，那么就可以点击这个按钮或按下 “Cmd+Option+W” （Windows 上是 Alt + W）来关闭它。</li>
<li>第三个，就是正则表达式匹配了。 当我们点击这个按钮或按下 “Cmd + Option + R” （Windows 上是 Alt + R ），就能够打开正则表达式的支持，然后在搜索框中输入正则表达式来搜索。要注意的是，编辑器中的这个搜索框，它里面的正则表达式使用的是 JavaScript 的正则引擎。</li>
</ul>
</li>
<li><p>这三个功能的快捷键的配置，相信你已经看出其中的诀窍了，它们分别使用了 Case、Word 和 Regular Expression 的第一个字母作为快捷键的一部分，若你知道是这几个单词，那相信对应的快捷键你就不会容易忘了。</p>
</li>
<li><p>我们可以先选中一段文本，然后按下 “Cmd + F” 调出搜索框，这之后点击这个按钮，就可以将这段文本的范围设置为接下来的搜索区域。然后当我们在输入框里输入关键字后，编辑器就只会在这个区域里进行搜索。</p>
</li>
<li><p>上面我们提到的功能，都是 VS Code 的默认行为。但也有部分用户不喜欢搜索框的一部分行为，比如说自动填充搜索关键词。那你可以打开设置，搜索 “editor.find.seedSearchStringFromSelection” 来关闭它。</p>
</li>
<li><p>也有个别用户觉得，如果选中了多行文本，那么当开始搜索时，应该自动地只在这几行代码里进行搜索。要达成这样的目的，你则需要打开设置 “editor.find.autoFindInSelection” 。</p>
</li>
</ul>
<h2 id="VSCode-单文件替换"><a href="#VSCode-单文件替换" class="headerlink" title="VSCode 单文件替换"></a>VSCode 单文件替换</h2><ul>
<li>VSCode单文件替换，在搜索到我们想要的结果之后，我们可以直接在文件中进行修改，也可以使用替换窗口进行批量替换。如果你在使用鼠标或者是触控板的话，只需按一下搜索窗口最左侧的箭头按钮即可打开替换框。</li>
<li>替换框的后面，一共有两个按钮：第一个能够替换单个搜索结果，第二个则能够替换全部的搜索结果。它们对应的快捷键我就不多加赘述，我们只需把鼠标指针移动到它们上面，就能够看到了。</li>
<li>我们也可以通过快捷键直接调出替换窗口。最常用的命令就是按下 “Cmd + Option + F”（Windows 上是 Ctrl + H）键，这样当前光标所在的单词就会被用作为搜索关键词，同时编辑器将光标移动到替换窗口中，我们只需直接输入想要替换的关键词就行了，是不是很便捷呢？</li>
<li>当然，如果你在书写完替换文本后，觉得搜索关键词需要修改，那你可以按下 “Shift + Tab” 键将光标移动到上面的搜索输入框里。“Tab” 和 “Shift + Tab” 键能够帮助你在这两个输入框直接进行跳转。</li>
</ul>
<h2 id="VSCode-多文件搜索和替换"><a href="#VSCode-多文件搜索和替换" class="headerlink" title="VSCode 多文件搜索和替换"></a>VSCode 多文件搜索和替换</h2><ul>
<li><p>多文件搜索的运行方法跟单文件搜索非常类似。单文件搜索，我们是通过按下“Cmd+ F” 来调出搜索窗口的，而多文件搜索则是通过按下 “Cmd + Shift + F” （Windows 上是 Ctrl + Shift + F）来调出多文件搜索的视图。</p>
</li>
<li><p>默认情况下，当我们调出多文件搜索的视图时，VS Code 会在当前打开的文件夹下进行搜索。不过，要发挥多文件搜索的更大功效，我们可以通过书写配置来决定在哪些子文件夹下进行搜索，以及过滤掉哪些特殊的文件或者文件夹。</p>
</li>
<li><p>要完成这样的配置，我们需要点击搜索框下三个点形状的图标，点开后，我们能看到两个输入框，它们的名字分别是“包含的文件” 和 “排除的文件”。这两个配置的书写格式是 glob，很多编程语言和配置都会使用 glob 来模糊匹配文件名和文件夹，估计你已经有所了解。而如果你不熟悉的话，就当作是课后作业了，这一定不是你最后一次需要书写 glob。</p>
</li>
<li><p>第一个是 “search.collapseResults” 。它是用来控制是否自动展开搜索结果。默认的配置是 “auto” 自动， 也就是说，VS Code 会根据搜索结果的多少来决定是否要将某个文件下的搜索结果展开，如果某个文件夹下的结果过多的话，就会将其暂时折叠，用户需要展开结果。我自己喜欢将其设置为 “alwaysExpand”，这样我每次都能直接看到结果了。</p>
</li>
<li><p>第二个是 “search.location” ，也就是多文件搜索视图的位置。默认情况下，搜索视图会出现在侧边栏。但是 VS Code 同样允许你把搜索视图放到底部面板中去，你只需将其修改为 “panel” 即可。相信很多用户都跟我一样，使用过非常多把搜索视图放在底部的开发工具，并且很习惯了，那这个设置就能够帮助到我们。</p>
</li>
</ul>
<h2 id="VSCode-行号"><a href="#VSCode-行号" class="headerlink" title="VSCode 行号"></a>VSCode 行号</h2><ul>
<li>我则是通过更改设置 editor.renderLineHighlight: “all” 把当前代码行的行号下的背景色也修改了，所以你可以看到图 2 的行号 5 的背景色也成为了绿色，整体上看起来更统一。</li>
</ul>
<h2 id="VSCode-渲染出空格符和制表符"><a href="#VSCode-渲染出空格符和制表符" class="headerlink" title="VSCode 渲染出空格符和制表符"></a>VSCode 渲染出空格符和制表符</h2><ul>
<li>在图2中你能够在不少代码行前面看到灰色的“点”，这每一个“点”都代表着一个空格符。你可以通过设置 editor.renderWhitespace: all 让编辑器将所有的空格符、制表符等全部都渲染出来。这样你就能够一眼看出这个文件中使用的究竟是制表符还是空格符，以及有没有在哪里不小心多打了一个空格等。</li>
</ul>
<h2 id="VSCode-缩进参考线和垂直标尺"><a href="#VSCode-缩进参考线和垂直标尺" class="headerlink" title="VSCode 缩进参考线和垂直标尺"></a>VSCode 缩进参考线和垂直标尺</h2><ul>
<li><p>编辑器会根据你指定的制表符的长度，来决定缩进参考线的位置。这样你就可以非常清楚地知道代码有没有正确地缩进，而且也方便你区分出不同代码块之间的层级关系。这个功能是可以通过 editor.renderIndentGuides 来控制开关的。</p>
</li>
<li><p>而图2中的竖线则不一样了，它叫做垂直标尺。如果你的项目中有规定说每一行代码不得超过多少个字符，比如说120个字符，那么你就可以将标尺设置为 120，即 editor.rulers: [120]。这样的话编辑器就会在第120个字符所在的位置处画出这样一条垂直的竖线，所以你一眼就可以看出自己的代码是否达标。</p>
</li>
</ul>
<h2 id="VSCode-光标样式"><a href="#VSCode-光标样式" class="headerlink" title="VSCode 光标样式"></a>VSCode 光标样式</h2><ul>
<li>在图1中，光标是一条竖线，而在图2中光标则相对粗一些。编辑器中的光标样式有非常多种，你可以控制粗细，也可以控制它怎么闪烁。你需要调整的设置是 editor.cursorBlinking editor.cursorStyle 和 editor.cursorWidth。</li>
</ul>
<h2 id="VSCode-如何管理文件和文件夹"><a href="#VSCode-如何管理文件和文件夹" class="headerlink" title="VSCode 如何管理文件和文件夹"></a>VSCode 如何管理文件和文件夹</h2><ul>
<li><p>VS Code是如何管理文件和文件夹，首先需要说明的是，VS Code 的各个功能，都是基于当前打开的文件或者文件夹的。</p>
</li>
<li><p>该怎么去理解这个概念呢？</p>
<ul>
<li>如果你使用过 IDE 的话， 你应该记得在第一次打开 IDE 的时候，它们往往需要你创建一个工程，这个工程会生成一个特殊的工程文件。这个工程文件记载了这个项目有哪些相关的文件、项目的配置、构建脚本等等。这个文件记录着 IDE 管理工程的元信息，开发团队也能够通过共享这个工程文件保证成员工作环境的一致性。但是工程文件对用户体验就不太友好了，比如说项目文件可能对 IDE 的版本有所要求，项目文件损坏了 IDE 读取不了但是我们也不知道如何修复，等等。</li>
</ul>
</li>
<li><p>VS Code 则选择了一种相对轻量，而且大家都易于理解的方式，那就是所有的操作都基于文件和文件夹。当你打开一个文件夹，VS Code 的核心功能就会对这个文件夹进行分析，并提供对应的功能。比如，在打开的文件夹下检测到有 .git 文件，就加载 Git 插件来提供版本管理的功能；或者发现文件夹下有 tsconfig.json ，就会激活 TypeScript 插件提供语言服务</p>
</li>
<li><p>当你第一次打开 VS Code 的时候，工作台中还没有打开任何文件夹。这时候在欢迎界面的左上方，你能够看到：“新建文件”和“打开文件夹”等这样的快捷键。</p>
</li>
<li><p>未打开文件夹，状态栏为紫色</p>
</li>
<li><p>这时候请注意工作台最下方的状态栏，当 VS Code 没有打开任何文件夹的时候，它的颜色是紫色的。而如果在工作台中打开了某个文件夹，状态栏的颜色就会变成蓝色。</p>
</li>
</ul>
<h2 id="VSCode-多文件夹工作区"><a href="#VSCode-多文件夹工作区" class="headerlink" title="VSCode 多文件夹工作区"></a>VSCode 多文件夹工作区</h2><ul>
<li><p>VS Code 多文件夹工作区，多文件夹工作区（multi-root workspace）。老实说呢，这个概念是有一定的理解难度的。</p>
</li>
<li><p>上面我们提到的基于文件夹的这种项目管理方式，从 VS Code 第一天开始就存在了。也几乎从第一天开始，我们就收到了用户对于这一个设计不满的反馈。对于这些不满的用户而言，他们的痛点在于他们经常需要同时对多个文件夹下的代码进行操作。但是 VS Code 关于单个文件夹的这种操作模式，要求了他们必须同时打开多个窗口，并不停地在它们之间切换。</p>
</li>
<li><p>多文件夹工作区就是为了针对这个问题而实现的解决方案。那下面我们就一起来看一看怎样去创建一个多文件夹工作区。</p>
</li>
<li><p>首先，在 VS Code 中打开一个文件夹，此时 VS Code 处于一个单文件夹的状态。然后你可以调出命令面板，搜索 “将文件夹添加到工作区” （add folder to workspace）并执行，或者使用菜单，“文件 —&gt; 将文件夹添加到工作区”，这之后，选择你想要在当前窗口打开的文件夹。</p>
</li>
<li><p>此时在资源管理器里的标题栏里，你能看到“无标题 （工作区）”这样的文字，这说明当前的工作区已经有多个文件夹了，只是现在你还没有保存这个多文件工作区，也没有给它指定一个名字。</p>
</li>
<li><p>要保存这个工作区，接下来你可以调出命令面板，搜索“将工作区另存为” （save workspace as），VS Code 就会为这个工作区创建一个文件，这个文件的后缀名是 “code-workspace”。比如，在下面的动图中，我给这个工作区取名为 sample，然后指定在 Code中这个文件夹下保存。这样操作后，VS Code 就会在 Code 文件夹下创建一个 sample.code-workspace 文件。</p>
</li>
<li><p>你可以看到，操作完之后资源管理器的标题栏已经相应地改变了。另外，sample.code-workspace 虽然有个特殊的后缀，但这个文件的格式其实也是 JSON，你可以自行打开这个文件查看一下。</p>
</li>
<li><p>这个 JSON 文件，默认有两个键（key）。第一个是 folders 文件夹，它里面罗列的是这个多文件工作区里有哪些文件夹。可以看出，这些文件夹的地址，都是这个 sample.code-workspace 文件的相对路径。第二个则是 settings 设置，你可以在这个值里面添加专属于这个多文件夹工作区的设置。它的作用，跟上面我们介绍的 .vscode 文件夹下的 settings.json 文件是类似的。</p>
</li>
</ul>
<h2 id="VSCode-工作区切换"><a href="#VSCode-工作区切换" class="headerlink" title="VSCode 工作区切换"></a>VSCode 工作区切换</h2><ul>
<li>VSCode 工作区切换，如果你同时打开了多个窗口，可以按下 Ctrl + W，或者调出命令面板，搜索 “切换窗口（Switch Window）”，然后选择你要跳转的那个文件夹中去。</li>
<li>如果你只是要跳转到上一个打开的窗口，那就更方便了。打开命令面板，搜索“快速切换窗口（Quick Switch Window）”并执行，就能够直接跳转到之前的窗口了，而无需再做选择。这里我倒是非常建议你给这个命令指定一个快捷键，这样你就能在窗口之间一键切换了。</li>
<li>如果你同一时间只会关注一个项目，那你也大可不必使用多个窗口。我就经常只用一个显示器和一个窗口，然后当我想在另外一个项目上工作时，我就会按下 Ctrl + R（或者使用命令面板，搜索 “打开最近的文件”），此时我就能够看到最近操作过的文件夹并按下回车键进行切换了。</li>
<li>当你按下 Ctrl + R 调出最近打开的文件夹的列表后，也能够按下 Cmd + 回车键，将它在一个新的窗口中打开。</li>
<li>正是因为有上面这几个命令的存在，让我觉得没有多文件夹工作区也是可以的。当然，多文件夹工作区在某些方面的优势是不可比拟的，比如说跨文件夹的代码调试，这个我们后面也会介绍。</li>
</ul>
<h2 id="VSCode-代码调试器"><a href="#VSCode-代码调试器" class="headerlink" title="VSCode 代码调试器"></a>VSCode 代码调试器</h2><ul>
<li><p>VSCode 代码调试器，和语言功能一样，VS Code 是把调试功能的最终实现交给插件来完成的。VS Code 提供了一套通用的图形界面和交互方式，比如怎么创建断点、如何添加条件断点、如何查看当前调试状态下参数的值，等等。无论你使用哪个编程语言或者调试器，这一套交互流程都是相似的。</p>
</li>
<li><p>而对于插件作者而言，他们需要完成的是如何把真正的调试工作跟 VS Code 的界面和交互结合起来，为此 VS Code 为插件作者提供了一套统一的接口，叫做Debug Adapter Protocol（DAP）。当用户在界面上完成一系列调试相关的操作时，VS Code 则通过 DAP 唤起调试插件，由插件完成最终的操作。</p>
</li>
<li><p>VS Code 中有一个专门的用于管理调试功能的视图。我们可以点击界面左侧“昆虫”（也就是 bug 啦）形状的按钮，或者按下 “Cmd + Shift + D” （Windows 上是 Ctrl + Shift + D）来唤出调试视图。</p>
</li>
<li><p>在视图的最上侧，有个绿色的箭头按钮。这个按钮是用于启动调试器的。但是在上面的截图里，你可以看到在绿色箭头的右侧写着 “没有配置”。这说明现在 VS Code 还不知道该使用什么调试器来调试当前的代码。此时点击这个按钮或者按下 F5，我们能够看到一个列表。</p>
</li>
<li><p>首先，我们将鼠标移动到第五行代码的行号前面，点击鼠标左键，我们能够看到一个红色的圆点被创建了出来，这就是断点。当然，我们也可以把光标移动到第五行，然后按下 F9，同样可以在第五行创建断点。</p>
</li>
<li><p>此时，当我们再次点击调试视图上面的绿色箭头按钮，或者按下 F5，启动调试器，并且选择 Node.js ，VS Code 就会进入调试模式。</p>
</li>
<li><p>VSCode 代码调试器配置launch.json介绍，在调试视图的最上方，我们能够看到一个齿轮形状的按钮，它可以用于创建和修改 launch.json 文件。由于当前文件夹下没有 launch.json 文件，所以这个按钮的右上角有个红色的点，它告诉我们当前的调试配置有一点问题，让我们点击这个按钮。</p>
</li>
<li><p>这个 JSON 文件里的 configurations 的值就是当前文件夹下所有的配置了。现在我们只有一个调试配置，它有四个属性：</p>
<ul>
<li>第一个是 type，代表着调试器的类型。它决定了 VS Code 会使用哪个调试插件来调试代码。</li>
<li>第二个是 request，代表着该如何启动调试器。如果我们的代码已经运行起来了，则可以将它的值设为 attach，那么我们则是使用调试器来调试这个已有的代码进程；而如果它的值是 launch，则意味着我们会使用调试器直接启动代码并且调试</li>
<li>第三个属性 name，就是这个配置的名字了。</li>
<li>第四个属性 program，就是告诉 Node.js 调试器，我们想要调试哪个文件。这个值支持预定义参数，比如在上面的例子里，我们使用了${file}，也就是当前编辑器里打开的文件。</li>
</ul>
</li>
<li><p>下面我们把 program 的值改为 ${workspaceFolder}&#x2F;index.js，其中${workspaceFolder} 是代表当前工作区文件夹地址的预定义参数，使用它就能够准确地定位当前工作区里 index.js 文件了。（关于在配置文件里可以使用的预定义参数，请参考Visual Studio Code Variables Reference。 <code>https://code.visualstudio.com/docs/editor/variables-reference</code>）</p>
</li>
<li><p>通用属性</p>
</li>
<li><p>虽然每个调试器各自控制着用户可以使用哪些属性，但是调试器之间还是有很多相同的地方，调试插件在很多时候都会使用相同的属性名来代表同样的功能。比如，我自己就是 Ruby 插件的作者，我在实现 Ruby 调试插件的时候，参考了很多 Node.js 和 PHP 调试插件对于属性的命名和使用。我在书写不同语言的调试配置时，经常使用的有下面这些：</p>
<ul>
<li>program 一般用于指定将要调试的文件。</li>
<li>stopOnEntry，当调试器启动后，是否在第一行代码处暂停代码的执行。这个属性非常方便，如果没有设置断点而代码执行非常快的话，我们就会像文章的最开头那样，代码调试一闪而过，而没有办法在代码执行的过程中暂停了。而设置了 stopOnEntry 后，代码会自动在第一行停下来，然后我们就可以继续我们的代码调试了。</li>
<li>args 参数。相信你应该记得在前面任务系统配置的文章里，我已经说明了可以使用 args 来控制传入任务脚本的参数，同样的，我们也可以通过 args 来把参数传给将要被调试的代码。</li>
<li>env 环境变量。大部分调试器都使用它来控制调试进程的特殊环境变量。</li>
<li>cwd 控制调试程序的工作目录。</li>
<li>port 是调试时使用的端口。</li>
</ul>
</li>
</ul>
<h2 id="VSCode-经典插件推荐"><a href="#VSCode-经典插件推荐" class="headerlink" title="VSCode 经典插件推荐"></a>VSCode 经典插件推荐</h2><ul>
<li>VSCode 经典插件推荐，今天我要介绍的是：能够在某些领域大幅度提高VS Code使用效率和体验的工具。能够取代 VS Code原有功能的工具。对插件 API 的使用别出心裁的工具。</li>
</ul>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul>
<li><p>GitLens</p>
</li>
<li><p>VS Code中的 Git 体验在易用性和完整性之间取得了一个不错的平衡，大部分用户都能够使用它完成工作，同时又不会被太多的功能吓到。但是很多硬核的 Git 用户肯定会觉得功能还不够用。包括但不限于：</p>
<ul>
<li>不能查看某个 commit 中的代码改动；</li>
<li>不能比较两个 commit 或者 branch，然后阅览代码改动；</li>
<li>不能查看代码历史记录。</li>
</ul>
</li>
<li><p>RemoteHub</p>
</li>
<li><p>GitLens 作者 Eric Amodio 又出一款力作——RemoteHub。安装这个插件后，当你想在本地看某个 GitHub repository的代码时，你就不需要将代码 clone 下来了，你可以直接打开这个 repository 相关的工作区，所有文件、文件夹都是从 GitHub 按需下载下来。如果你连接 GitHub 的网速不错的话，那么使用体验可是比 GitHub 网站要好得多。</p>
</li>
<li><p>GitHub Pull Request </p>
</li>
<li><p>除了 Git 支持以外，一个呼声一直非常高的需求，就是在 VS Code中查看和审核 GitHub 上的 Pull Request。好消息是，VS Code团队和 GitHub 的 Editor Tools 团队一起合作，为我们提供了 GitHub Pull Request这个插件。</p>
</li>
</ul>
<h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><ul>
<li><p>Settings Sync</p>
</li>
<li><p>如何在不同设备之间同步个人设置？VS Code自己并没有提供设置的同步，但通过 Settings Sync这个插件，你可以将个人设置同步到 Gist 中。</p>
</li>
<li><p>不过值得注意的是，虽然你的设置是同步到自己私人的 Gist 中，但是如果你的设置中有一些隐私信息，像密码、Token 之类的，还是不要使用此插件比较好。</p>
</li>
<li><p>Project Manager</p>
</li>
<li><p>我们在工作台的部分，介绍过 VS Code支持多文件夹工作区（multi-root workspace），以及如何通过快捷键在不同的项目之间来回切换。如果你不喜欢 VS Code默认的方式，那么你也可以试试 Project Manager。Project Manager 甚至还有一个专门的视图来展示所有的项目，非常方便。</p>
</li>
</ul>
<h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul>
<li><p>VIM</p>
</li>
<li><p>编辑器相关的插件中最厉害的应该就是 Vim 相关的插件了，VS Code提供了一个 API 保证了 Vim 插件能够被正确地实现。不过 Vim 插件并不只有一个，下载量最大的，也是我参与的就是 VSCodeVim，它对 Vim keybings 的覆盖程度非常高。另一个非常受大家欢迎的就是amVim，它的性能也非常不错。</p>
</li>
<li><p>Rainbow Brackets</p>
</li>
<li><p>不管你是不是写函数式语言，当你的代码中有比较多的花括号时，要保证它们对称可以说是非常困难了。Rainbow Brackets这个插件，为同一对花括号指定一个单独的配色，这样你就能够轻松地一眼看出花括号的配对了。</p>
</li>
<li><p>Indent Rainbow</p>
</li>
<li><p>上面的 Rainbow brackets 是给花括号加上多种颜色，而 Indent Rainbow则是为你的代码缩进提供颜色上的提示：</p>
</li>
<li><p>这两个插件有异曲同工之妙，当然我还是建议写代码的时候，不要有太多的层级。</p>
</li>
<li><p>Pigment</p>
</li>
<li><p>既然说到颜色，就不得不提Pigment 这个插件。在介绍择色器（Color Picker）的时候我介绍过，VS Code会在每个颜色前面加上一个方块，用方块来展示代码所对应的颜色。Pigment 则是将颜色渲染在这段代码的下面，我自己还是蛮喜欢这种方式的。</p>
</li>
<li><p>Import Cost</p>
</li>
<li><p>JavaScript 经常被吐槽的一个地方，就是大家对 npm 库的使用程度非常高，经常为了一个简单的功能，引入了几兆甚至十几兆的 npm 包。Import Cost这个插件，很好地在代码中给我们以提示，告诉我们引入的某个包，它最终会导致整个项目的大小增加多少。</p>
</li>
</ul>
<h3 id="调试：Debugger-for-Chrome"><a href="#调试：Debugger-for-Chrome" class="headerlink" title="调试：Debugger for Chrome"></a>调试：Debugger for Chrome</h3><ul>
<li>虽然我们并不介绍语言相关的插件，但是还是有一个调试相关的插件值得一提，那就是 Debugger for Chrome。这个插件，允许在 VS Code中调试前段代码，这样你就不需要再使用 Chrome Dev Tools 了。你可以直接在自己的代码上加上断点，发现错误后直接修改，非常方便。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><p>Rest Client</p>
</li>
<li><p>我们使用 REST API 的时候，经常需要发送一些样例数据对 API 进行测试，这时我们可以使用 Postman 这类的独立应用，也可以在 VS Code中使用 Rest Client插件，直接在编辑器里发送 REST 请求。</p>
</li>
<li><p>Code Runner</p>
</li>
<li><p>macOS 用户对 Code Runner 这个应用一定非常熟悉了，你可以使用 Code Runner 快速地书写代码并且执行，而无需设置环境配置工程之类的。VS Code里也有这样的插件，如果你有类似的需求，可以试一试。</p>
</li>
<li><p>Live Share</p>
</li>
<li><p>Live Share是微软官方出品的非常强大的服务，通过 Live Share service，你可以将你本地的工作区，直接分享给你的同伴，然后你的同伴就可以直接编辑你的代码，与你共享代码调试、集成终端等等，而无需安装任何环境。Atom 也有类似的服务叫做 Teletype。我工作中每次要和同事 Pair Programming 的时候，就会使用 Live Share。<br>同时 Live Share 服务还支持语音通讯，不过需要安装另一个插件 Live Share Audio。</p>
</li>
</ul>
<h3 id="如何分享插件"><a href="#如何分享插件" class="headerlink" title="如何分享插件"></a>如何分享插件</h3><ul>
<li><p>当然有！你可以通过在项目的 .vscode 文件夹下，创建一个文件 extensions.json。你很熟悉了，这又是一个 JSON 文件，在这个 JSON 文件里，你只需提供一个键（key） recommendations，然后将你想要推荐给这个项目的其他工程师的插件的 ID 们，全部放入到这个数组中。当他们打开这个项目，而且并没有安装这些插件时，VS Code就会给他们提示了。</p>
</li>
<li><p>除了在 .vscode&#x2F;extensions.json 文件推荐插件，如果你在使用多文件夹工作区（multi-root workspace），也可以在多文件夹工作区的配置文件里添加如下的设置：</p>
</li>
</ul>
<h1 id="VSCode-C-配置"><a href="#VSCode-C-配置" class="headerlink" title="VSCode C++ 配置"></a>VSCode C++ 配置</h1><h2 id="三个文件-task-json-launch-json-c-cpp-properties-json"><a href="#三个文件-task-json-launch-json-c-cpp-properties-json" class="headerlink" title="三个文件:task.json launch.json c_cpp_properties.json"></a>三个文件:<code>task.json</code> <code>launch.json</code> <code>c_cpp_properties.json</code></h2><ol>
<li>IntelliSense：Intelligence Sense，代码自动补全</li>
<li>Task.json:<br> 告诉VScode如何编译.cpp文件，配置后将调用g++编译器基于源代码创建可执行文件。<br> 参数：<br> command：设置要运行的指定程序<br> args：参数数组指明要传送给g++的命令行参数，这些参数必须按照编译器要求的顺序来说明<br> ${file}：g++执行的活动文件<br> ${fileDirname}：当前目录<br> label：任务列表中显示的值</li>
<li>launch.json：使用F5启动GDB调试器来调试程序</li>
<li>c_cpp_properties.json：对c&#x2F;c++扩展实现更多控制，可以改变编译器的路径，C++标准以及更多</li>
</ol>
<h2 id="变量替换"><a href="#变量替换" class="headerlink" title="变量替换"></a>变量替换</h2><ul>
<li>VScode在<code>launch.json</code>调试文件和<code>task.json</code>任务文件中是支持变量替换的，这就意味着可以很方便的使用VScode一些预定以的变量。</li>
<li>变量的使用方式：<code>$&#123;variableName&#125;</code></li>
<li>常用的变量：<ul>
<li><code>$&#123;workspaceFolder&#125;</code> : 项目文件夹在<code>VScode</code>中打开的路径</li>
<li><code>$&#123;file&#125;</code> : 当前打开的文件</li>
<li><code>$&#123;relativeFile&#125;</code> : 相对于<code>$&#123;workspaceFolder&#125;</code>的文件路径</li>
<li><code>$&#123;fileBasename&#125;</code> : 当前打开文件的名称</li>
<li><code>$&#123;fileBasenameNoExtension&#125;</code> : 当前打开文件的名称，不带扩展名</li>
<li><code>$&#123;fileExtname&#125;</code> : 当前打开文件的扩展名</li>
<li><code>$&#123;fileDirname&#125;</code> : 当前打开文件的文件夹名称</li>
</ul>
</li>
</ul>
<h2 id="调试-断点"><a href="#调试-断点" class="headerlink" title="调试 断点"></a>调试 断点</h2><h3 id="日志点，Logpoints"><a href="#日志点，Logpoints" class="headerlink" title="日志点，Logpoints"></a>日志点，<code>Logpoints</code></h3><ul>
<li>日志点是断点的变体，它不会“中断”到调试器中，而是将消息记录到控制台。日志点对于再调试无法暂停或停止的生产服务器时注入日志记录特别有用。(A Logpoint is a variant of a breakpoint that does not “break” into the debugger but instead logs a message to the console. Logpoints are especially useful for injecting logging while debugging production servers that cannot be paused or stopped)</li>
<li>日志消息是纯文本，但可以包含表达式，需要使用花括号</li>
</ul>
<h3 id="表达式条件断点"><a href="#表达式条件断点" class="headerlink" title="表达式条件断点"></a>表达式条件断点</h3><ul>
<li>条件断点是表达式结果为<code>true</code>时才会进行断点</li>
</ul>
<h3 id="命中计数断点"><a href="#命中计数断点" class="headerlink" title="命中计数断点"></a>命中计数断点</h3><ul>
<li>只有该行代码命中了指定次数，才会进行断点</li>
</ul>
<h3 id="内联断点"><a href="#内联断点" class="headerlink" title="内联断点"></a>内联断点</h3><ul>
<li>仅当执行到达与内联断点关联的列时，才会命中内联断点。</li>
<li>这在调试一行中包含多个语句的缩小代码时特别有用。比如for循环，短路运算符等一行代码包含多个表达式时</li>
<li>在指定位置按<code>shift + F9</code></li>
</ul>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li><code>ctrl + p</code> ： 快速搜索文件并跳转，添加<code>:</code>可以跳转到指定行</li>
<li><code>alt + 鼠标左键</code> : 选中多行同时编辑</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Asio/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Asio/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">1_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Asio/" itemprop="url" rel="index"><span itemprop="name">Asio</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>Asio库相关的理论基础知识</p>
</li>
<li><p>Asio库是仅包含头文件的库</p>
</li>
</ul>
<h2 id="C-Asio库独立版本详解"><a href="#C-Asio库独立版本详解" class="headerlink" title="C++ Asio库独立版本详解"></a>C++ Asio库独立版本详解</h2><p>Boost.Asio 是一个非常流行的 C++ 库，用于实现异步 I&#x2F;O 操作和网络编程。它最初作为 Boost C++ 库的一部分，但后来成为 C++ 标准库的一部分（自 C++11 起）。因此，Boost.Asio 的某些版本也包含在 Boost 库中。</p>
<p>独立版本的 Boost.Asio 是指可单独使用、独立于 Boost 库的版本。它通常是从 Boost 库中分离出来的、具有更轻量级的库。这样的版本可以更容易地集成到项目中，而无需包含整个 Boost 库。</p>
<p>独立版本的 Boost.Asio 通常具有以下特点：</p>
<ol>
<li><strong>独立性：</strong> 它不需要完整的 Boost 库作为依赖，可以单独使用。</li>
<li><strong>轻量级：</strong> 与完整的 Boost 库相比，其体积较小，减少了不必要的依赖。</li>
<li><strong>简化构建和集成：</strong> 由于它是一个独立的库，因此在项目中使用起来更加方便，构建和集成更简单。</li>
</ol>
<p>Boost.Asio 独立版本的详细内容和特性与原始的 Boost.Asio 库非常相似，主要提供异步 I&#x2F;O、TCP、UDP、定时器和网络编程相关的功能。它仍然支持异步事件和异步操作，提供了用于管理 I&#x2F;O 对象、定时器和网络通信的类和函数。</p>
<p>要使用独立版本的 Boost.Asio，你可以从官方的 GitHub 仓库或下载页获取源代码，并按照提供的指南进行构建和集成。通常，独立版本的 Boost.Asio 具有更加现代化和改进的特性，因为它们可能是从较新版本的 Boost 库中提取出来的。</p>
<p>请注意，独立版本的 Boost.Asio 可能会有所不同，具体取决于版本和发布的时间。因此，建议查看官方文档和版本说明以获取特定版本的详细信息和使用说明。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Asio/2024-05-22-1_2_%E5%B8%B8%E7%94%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Asio/2024-05-22-1_2_%E5%B8%B8%E7%94%A8%E7%B1%BB/" class="post-title-link" itemprop="url">1_2_常用类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Asio/" itemprop="url" rel="index"><span itemprop="name">Asio</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Asio常用的类</li>
</ul>
<h2 id="Asio-asio-io-context-详解"><a href="#Asio-asio-io-context-详解" class="headerlink" title="Asio asio::io_context 详解"></a>Asio asio::io_context 详解</h2><p><code>asio::io_context</code> 是 Boost.Asio 库（也是 C++ 标准库中的一部分，自 C++17 起）中的核心类之一。它是实现异步 I&#x2F;O 操作的关键部分，用于驱动异步事件处理。</p>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ul>
<li><strong>提供 I&#x2F;O 上下文：</strong> <code>io_context</code> 对象是异步操作的执行上下文，用于管理异步操作、事件处理、任务队列和事件循环。</li>
<li><strong>事件驱动：</strong> 通过 <code>io_context</code>，可以注册异步操作（如套接字操作、定时器事件等），<code>io_context</code> 将在合适的时机进行调度、执行和完成这些异步操作。</li>
</ul>
<h3 id="主要功能和方法："><a href="#主要功能和方法：" class="headerlink" title="主要功能和方法："></a>主要功能和方法：</h3><ul>
<li><strong><code>run()</code>：</strong> 开始 <code>io_context</code> 上的事件循环，处理已注册的所有异步操作，直到所有操作完成或 <code>io_context</code> 被停止。</li>
<li><strong><code>stop()</code>：</strong> 停止 <code>io_context</code> 上的事件循环。停止后，<code>run()</code> 函数将在处理完当前已注册的操作后立即返回。</li>
<li><strong><code>poll()</code>：</strong> 执行 <code>io_context</code> 上的事件循环，但仅处理当前可立即完成的操作，然后立即返回。</li>
<li><strong><code>restart()</code>：</strong> 重新启动已经停止的 <code>io_context</code>。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个定时器</span></span><br><span class="line">    boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(io_context, boost::asio::chrono::seconds(<span class="number">5</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步等待定时器完成</span></span><br><span class="line">    timer.<span class="built_in">async_wait</span>([](<span class="type">const</span> boost::system::error_code&amp; ec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Timer expired!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 io_context 上的事件循环，直到所有操作完成</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>io_context</code> 用于驱动异步操作（这里是一个定时器异步等待）。通过调用 <code>run()</code> 方法，<code>io_context</code> 开始处理已注册的异步操作，并在完成所有操作或者遇到停止指令时返回。</p>
<p><code>io_context</code> 是 Boost.Asio 中非常重要的一个类，它为异步操作提供了执行环境，能够有效地管理和调度异步事件，是异步编程的核心。</p>
<h2 id="Asio-asio-thread-pool-详解"><a href="#Asio-asio-thread-pool-详解" class="headerlink" title="Asio asio::thread_pool 详解"></a>Asio asio::thread_pool 详解</h2><p><code>asio::thread_pool</code> 是 Boost.Asio 库中的一个类，它提供了一个线程池，用于管理和执行异步操作。线程池是一种用于管理线程的技术，它可以预先创建一组线程，以便在需要时执行任务或处理异步操作。</p>
<h3 id="主要作用："><a href="#主要作用：" class="headerlink" title="主要作用："></a>主要作用：</h3><ul>
<li><strong>管理线程：</strong> <code>asio::thread_pool</code> 提供了线程池，可用于执行异步操作，避免了频繁创建和销毁线程的开销。</li>
<li><strong>处理异步操作：</strong> 可以将异步操作（如定时器、套接字操作等）提交给线程池，线程池会自动将其分配到可用的线程上执行。</li>
</ul>
<h3 id="主要方法和功能："><a href="#主要方法和功能：" class="headerlink" title="主要方法和功能："></a>主要方法和功能：</h3><ul>
<li><strong><code>asio::thread_pool(size_t num_threads)</code> 构造函数：</strong> 创建具有指定数量线程的线程池。</li>
<li><strong><code>~thread_pool()</code> 析构函数：</strong> 销毁线程池，等待所有线程执行完毕并释放资源。</li>
<li><strong><code>submit(Function &amp;&amp; function)</code>：</strong> 提交任务到线程池，执行 <code>function</code> 函数。</li>
<li><strong><code>stop()</code>：</strong> 停止线程池，不再接受新的任务，等待所有任务执行完毕后销毁线程池。</li>
<li><strong><code>join()</code>：</strong> 阻塞等待线程池中的所有任务执行完成。</li>
<li><strong><code>notify_one()</code> 和 <code>notify_all()</code>：</strong> 用于唤醒正在等待的线程。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/thread_pool.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio/post.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Task executed in thread: &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::<span class="function">asio::thread_pool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>; <span class="comment">// 创建有4个线程的线程池</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务到线程池</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        boost::asio::<span class="built_in">post</span>(pool, task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有任务完成</span></span><br><span class="line">    pool.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，创建了一个具有 4 个线程的线程池 <code>pool</code>，然后向线程池提交了 8 个任务。这些任务会被线程池中的线程异步执行。最后，调用 <code>pool.join()</code> 阻塞等待所有任务执行完成。</p>
<p><code>asio::thread_pool</code> 提供了一种有效地管理和执行异步操作的方式，避免了线程频繁创建和销毁的开销，并提高了异步操作的执行效率。</p>
<h2 id="Asio-asio-ip-tcp-socket-详解"><a href="#Asio-asio-ip-tcp-socket-详解" class="headerlink" title="Asio asio::ip::tcp::socket 详解"></a>Asio asio::ip::tcp::socket 详解</h2><p><code>asio::ip::tcp::socket</code> 是 Boost.Asio 库中用于 TCP 协议的套接字类，用于在 C++ 中进行 TCP 网络通信。</p>
<h3 id="主要作用：-1"><a href="#主要作用：-1" class="headerlink" title="主要作用："></a>主要作用：</h3><ul>
<li><strong>实现 TCP 客户端和服务器：</strong> <code>asio::ip::tcp::socket</code> 允许 C++ 应用程序创建 TCP 客户端或服务器套接字，并进行数据传输。</li>
</ul>
<h3 id="主要方法和功能：-1"><a href="#主要方法和功能：-1" class="headerlink" title="主要方法和功能："></a>主要方法和功能：</h3><ul>
<li><strong><code>constructor</code> 构造函数：</strong> 创建 TCP 套接字。</li>
<li><strong><code>open()</code>：</strong> 打开套接字。</li>
<li><strong><code>close()</code>：</strong> 关闭套接字。</li>
<li><strong><code>connect()</code>：</strong> 用于客户端，连接到远程服务器。</li>
<li><strong><code>async_connect()</code>：</strong> 异步连接到远程服务器。</li>
<li><strong><code>bind()</code>：</strong> 将套接字与本地端口或地址绑定。</li>
<li><strong><code>async_bind()</code>：</strong> 异步绑定套接字。</li>
<li><strong><code>listen()</code>：</strong> 在服务器上监听传入连接请求。</li>
<li><strong><code>accept()</code>：</strong> 接受传入的连接请求。</li>
<li><strong><code>async_accept()</code>：</strong> 异步接受传入的连接请求。</li>
<li><strong><code>read_some()</code> 和 <code>write_some()</code>：</strong> 同步读取和写入数据。</li>
<li><strong><code>async_read_some()</code> 和 <code>async_write_some()</code>：</strong> 异步读取和写入数据。</li>
<li><strong><code>shutdown()</code>：</strong> 关闭套接字的输入、输出或全部流。</li>
</ul>
<h3 id="示例（简化的服务器端）："><a href="#示例（简化的服务器端）：" class="headerlink" title="示例（简化的服务器端）："></a>示例（简化的服务器端）：</h3><p>下面是一个简化的 Boost.Asio TCP 服务器端示例，展示了如何使用 <code>asio::ip::tcp::socket</code> 接受连接和读取数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, tcp::endpoint(tcp::v4(), <span class="number">8080</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">        acceptor.<span class="built_in">accept</span>(socket);</span><br><span class="line"></span><br><span class="line">        std::array&lt;<span class="type">char</span>, 128&gt; buffer;</span><br><span class="line">        boost::system::error_code error;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        <span class="type">size_t</span> len = socket.<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(buffer), error);</span><br><span class="line">        <span class="keyword">if</span> (error == boost::asio::error::eof) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Connection closed by peer.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; error.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Received data: &quot;</span> &lt;&lt; std::<span class="built_in">string</span>(buffer.<span class="built_in">data</span>(), len) &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>asio::ip::tcp::socket</code> 是 Boost.Asio 中用于 TCP 通信的关键类之一，提供了处理 TCP 套接字的方法和功能，可以用于创建 TCP 客户端或服务器，并进行数据的读写操作。</p>
<h2 id="Asio-asio-steady-timer详解"><a href="#Asio-asio-steady-timer详解" class="headerlink" title="Asio asio::steady_timer详解"></a>Asio asio::steady_timer详解</h2><p><code>asio::steady_timer</code> 是 Boost.Asio 库中的一个定时器类，用于在指定时间点执行或触发操作。</p>
<h3 id="主要作用：-2"><a href="#主要作用：-2" class="headerlink" title="主要作用："></a>主要作用：</h3><ul>
<li><strong>定时触发事件：</strong> <code>asio::steady_timer</code> 用于创建定时器对象，可以在设定的时间点之后触发回调函数。</li>
</ul>
<h3 id="主要方法和功能：-2"><a href="#主要方法和功能：-2" class="headerlink" title="主要方法和功能："></a>主要方法和功能：</h3><ul>
<li><strong><code>constructor</code> 构造函数：</strong> 创建定时器对象。</li>
<li><strong><code>expires_at()</code> 和 <code>expires_from_now()</code>：</strong> 分别设置定时器的到期时间和到期时刻的相对偏移量。</li>
<li><strong><code>async_wait()</code>：</strong> 异步等待定时器触发。可以向定时器对象提交一个回调函数，在指定时间点触发回调。</li>
<li><strong><code>cancel()</code>：</strong> 取消定时器，终止尚未触发的操作。</li>
<li><strong><code>wait()</code>：</strong> 阻塞等待定时器触发。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><p>下面是一个简单的 Boost.Asio 定时器示例，演示了 <code>asio::steady_timer</code> 的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_handler</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Timer expired!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(io_context, boost::asio::chrono::seconds(<span class="number">5</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步等待定时器触发，并指定回调函数</span></span><br><span class="line">    timer.<span class="built_in">async_wait</span>(timer_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 io_context 上的事件循环</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，创建了一个 <code>asio::steady_timer</code> 对象 <code>timer</code>，设置定时器在 5 秒后触发。然后使用 <code>timer.async_wait()</code> 异步等待定时器的触发，并指定了一个回调函数 <code>timer_handler</code>。最后，调用 <code>io_context.run()</code> 运行事件循环，等待定时器触发并执行回调函数。</p>
<p><code>asio::steady_timer</code> 类是 Boost.Asio 中用于管理定时器的重要类之一，允许程序在指定的时间点执行特定操作，通常用于实现定时任务、超时控制等功能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Asio/2024-05-22-1_3_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Asio/2024-05-22-1_3_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">1_3_常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Asio/" itemprop="url" rel="index"><span itemprop="name">Asio</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Asio相关的函数</li>
</ul>
<h2 id="Asio-asio-chrono-seconds-函数-详解"><a href="#Asio-asio-chrono-seconds-函数-详解" class="headerlink" title="Asio asio::chrono::seconds()函数 详解"></a>Asio asio::chrono::seconds()函数 详解</h2><p>在 Boost.Asio 中，<code>asio::chrono::seconds()</code> 函数是用于创建时间持续时间（<code>duration</code>）对象的函数，表示以秒为单位的时间段。</p>
<p>这个函数位于 Boost.Asio 的时间相关命名空间中，<code>asio::chrono</code>，用于创建与时间相关的持续时间对象，其中包括 <code>std::chrono::duration</code> 的各种变种。</p>
<h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 asio::chrono::seconds() 创建秒数为 5 的持续时间对象</span></span><br><span class="line">    boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(boost::asio::chrono::seconds(<span class="number">5</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印定时器的过期时间（当前时间加上 5 秒）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Timer will expire after 5 seconds.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>asio::chrono::seconds(5)</code> 创建了一个表示 5 秒的时间段，然后将该时间段传递给 <code>boost::asio::steady_timer</code> 的构造函数，用于设置定时器在 5 秒后触发。</p>
<p>此函数的作用在于以秒为单位创建时间段，可以用于设置定时器、指定等待时间等场景。 Boost.Asio 中的这些时间函数通常是与异步操作和定时器相关的，使得在异步编程中方便地创建和管理时间段。</p>
<h2 id="Asio-asio-steady-timer-async-wait-函数-详解"><a href="#Asio-asio-steady-timer-async-wait-函数-详解" class="headerlink" title="Asio asio::steady_timer::async_wait() 函数 详解"></a>Asio asio::steady_timer::async_wait() 函数 详解</h2><p><code>asio::steady_timer::async_wait()</code> 是 Boost.Asio 中 <code>steady_timer</code> 类的成员函数，用于异步等待定时器到期并触发回调函数。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> WaitHandler&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">async_wait</span><span class="params">(WaitHandler&amp;&amp; handler)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><ul>
<li><code>WaitHandler</code>：一个可调用对象，用于处理定时器到期时触发的回调函数。可以是函数指针、函数对象、lambda 函数等。</li>
</ul>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><p><code>async_wait()</code> 函数安排一个异步操作，在指定的定时器到期时执行回调操作。该函数不会阻塞当前线程，而是在设置的时间段之后触发回调函数。</p>
<h3 id="使用示例：-1"><a href="#使用示例：-1" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_handler</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Timer expired!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(io_context, boost::asio::chrono::seconds(<span class="number">5</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步等待定时器触发，并指定回调函数</span></span><br><span class="line">    timer.<span class="built_in">async_wait</span>(timer_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 io_context 上的事件循环</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>async_wait()</code> 函数用于异步等待定时器 <code>timer</code> 到期，并指定了一个名为 <code>timer_handler</code> 的回调函数处理定时器到期时的操作。<code>io_context.run()</code> 开始运行事件循环，等待定时器触发并执行回调函数。</p>
<p>该函数常用于异步编程中，用于设置定时器的到期事件，并在到期时执行相应的操作或回调函数。</p>
<h2 id="Asio-asio-steady-timer-expires-at-函数-详解"><a href="#Asio-asio-steady-timer-expires-at-函数-详解" class="headerlink" title="Asio asio::steady_timer::expires_at() 函数 详解"></a>Asio asio::steady_timer::expires_at() 函数 详解</h2><p><code>asio::steady_timer::expires_at()</code> 是 Boost.Asio 中 <code>steady_timer</code> 类的成员函数之一，用于设置定时器的到期时间点。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TimePoint&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">expires_at</span><span class="params">(<span class="type">const</span> TimePoint&amp; time_point)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h3><ul>
<li><code>TimePoint</code>：表示时间点的类型，通常为 <code>std::chrono::time_point</code>，用于指定定时器的到期时间点。</li>
</ul>
<h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h3><p><code>expires_at()</code> 函数用于设置定时器 <code>steady_timer</code> 的到期时间点。当调用该函数并传递一个特定的时间点参数时，定时器将在指定的时间点触发，即执行定时器的回调函数或触发定时器到期事件。</p>
<h3 id="使用示例：-2"><a href="#使用示例：-2" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器到期时间点为当前时间加上 5 秒</span></span><br><span class="line">    timer.<span class="built_in">expires_at</span>(std::chrono::steady_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步等待定时器触发</span></span><br><span class="line">    timer.<span class="built_in">async_wait</span>([](<span class="type">const</span> boost::system::error_code&amp; ec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Timer expired!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行 io_context 上的事件循环</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>timer.expires_at()</code> 用于设置定时器 <code>timer</code> 的到期时间点为当前时间加上 5 秒。随后使用 <code>timer.async_wait()</code> 异步等待定时器触发，在定时器到期时执行回调函数。最后，通过 <code>io_context.run()</code> 开始运行事件循环，等待定时器到期并执行回调函数。</p>
<p><code>expires_at()</code> 函数对于预先设置定时器的到期时间非常有用，允许在稍后的时间点触发异步操作，使得在异步编程中更容易地控制定时器的触发时间。</p>
<h2 id="Asio-asio-steady-timer-expiry-详解"><a href="#Asio-asio-steady-timer-expiry-详解" class="headerlink" title="Asio asio::steady_timer::expiry()  详解"></a>Asio asio::steady_timer::expiry()  详解</h2><p>在 Boost.Asio 中，<code>asio::steady_timer::expiry()</code> 是 <code>steady_timer</code> 类的成员函数，用于获取定时器的到期时间点。</p>
<h3 id="方法签名："><a href="#方法签名：" class="headerlink" title="方法签名："></a>方法签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::chrono::<span class="function">steady_clock::time_point <span class="title">expiry</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h3><p><code>expiry()</code> 方法用于获取当前设置的定时器 <code>steady_timer</code> 的到期时间点。返回的是一个 <code>std::chrono::steady_clock::time_point</code> 对象，表示定时器将会到期的时间点。</p>
<h3 id="使用示例：-3"><a href="#使用示例：-3" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line">    boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器到期时间点为当前时间加上 5 秒</span></span><br><span class="line">    timer.<span class="built_in">expires_at</span>(std::chrono::steady_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取定时器的到期时间点并打印</span></span><br><span class="line">    std::chrono::steady_clock::time_point expiry_time = timer.<span class="built_in">expiry</span>();</span><br><span class="line">    std::<span class="type">time_t</span> expiry_time_c = std::chrono::steady_clock::<span class="built_in">to_time_t</span>(expiry_time);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Timer will expire at: &quot;</span> &lt;&lt; std::<span class="built_in">ctime</span>(&amp;expiry_time_c);</span><br><span class="line"></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，使用 <code>timer.expires_at()</code> 将定时器 <code>timer</code> 的到期时间点设置为当前时间加上 5 秒。然后调用 <code>expiry()</code> 方法获取定时器的到期时间点，并将其转换为 <code>std::time_t</code> 格式，最后使用 <code>std::ctime()</code> 打印定时器将会到期的时间点。</p>
<p><code>expiry()</code> 方法对于需要了解定时器何时到期的情况非常有用，它允许程序员检查定时器当前的到期时间点，以便在需要时执行相应的操作。</p>
<h2 id="Asio-asio-make-strand-详解"><a href="#Asio-asio-make-strand-详解" class="headerlink" title="Asio asio::make_strand() 详解"></a>Asio asio::make_strand() 详解</h2><p>在 Boost.Asio 中，<code>asio::make_strand()</code> 是一个用于创建 <code>strand</code> 对象的工厂函数。<code>strand</code> 提供了一种同步操作访问序列化（serialized）的方式，用于确保异步操作在多个线程中按照顺序执行，避免出现竞争条件。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ExecutionContext&gt;</span><br><span class="line"><span class="keyword">typename</span> associated_executor&lt;ExecutionContext&gt;::<span class="function">type <span class="title">make_strand</span><span class="params">(ExecutionContext&amp; context)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数说明：-2"><a href="#参数说明：-2" class="headerlink" title="参数说明："></a>参数说明：</h3><ul>
<li><code>ExecutionContext</code>：表示执行上下文的类型，可以是 <code>io_context</code>、<code>strand</code> 或其他支持的执行上下文类型。</li>
</ul>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回创建的 <code>strand</code> 对象。</li>
</ul>
<h3 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a>功能：</h3><p><code>make_strand()</code> 函数用于创建一个 <code>strand</code>，它实际上是一个执行器（executor），可以确保在同一个 <code>strand</code> 内排队的操作按顺序执行，而不会发生竞争条件。</p>
<h3 id="使用示例：-4"><a href="#使用示例：-4" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 strand 对象</span></span><br><span class="line">    <span class="keyword">auto</span> strand = boost::asio::<span class="built_in">make_strand</span>(io_context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 strand 内执行异步操作</span></span><br><span class="line">    boost::asio::<span class="built_in">post</span>(strand, []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Task 1 executed in strand!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    boost::asio::<span class="built_in">post</span>(strand, []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Task 2 executed in strand!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>make_strand()</code> 创建了一个 <code>strand</code> 对象 <code>strand</code>，然后使用 <code>boost::asio::post()</code> 将两个任务（lambda 函数）提交到 <code>strand</code> 内执行。由于这两个任务被提交到同一个 <code>strand</code> 中，它们会按照顺序在该 <code>strand</code> 中执行，避免了并发操作可能引发的竞争条件。</p>
<p><code>strand</code> 对于需要序列化异步操作的情况非常有用，可以确保在一个特定的执行上下文中操作按顺序执行，增加了程序的可靠性和安全性。</p>
<h2 id="Asio-asio-bind-executor-详解"><a href="#Asio-asio-bind-executor-详解" class="headerlink" title="Asio asio::bind_executor() 详解"></a>Asio asio::bind_executor() 详解</h2><p>在 Boost.Asio 中，<code>asio::bind_executor()</code> 是一个用于绑定执行上下文（executor）到处理器（handler）上的函数，它用于创建一个新的处理器对象，将给定的执行上下文绑定到现有的处理器上，从而确保处理器在指定的执行上下文中执行。</p>
<h3 id="函数签名：-3"><a href="#函数签名：-3" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Executor, <span class="keyword">typename</span> Handler&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">bind_executor</span><span class="params">(<span class="type">const</span> Executor&amp; ex, Handler&amp;&amp; handler)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数说明：-3"><a href="#参数说明：-3" class="headerlink" title="参数说明："></a>参数说明：</h3><ul>
<li><code>Executor</code>：表示执行上下文的类型，例如 <code>io_context</code> 或 <code>strand</code>。</li>
<li><code>Handler</code>：表示处理器的类型，可以是函数对象、函数指针或者可调用对象。</li>
</ul>
<h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回一个新的处理器对象，将给定的执行上下文与原有的处理器绑定在一起。</li>
</ul>
<h3 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a>功能：</h3><p><code>bind_executor()</code> 函数用于创建一个新的处理器对象，它在调用原始处理器时，会确保使用提供的执行上下文（executor）进行执行。这样做可以确保处理器在指定的执行上下文中运行，从而实现异步操作的序列化和控制。</p>
<h3 id="使用示例：-5"><a href="#使用示例：-5" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context io_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 strand 对象</span></span><br><span class="line">    boost::<span class="function">asio::strand&lt;boost::asio::io_context::executor_type&gt; <span class="title">strand</span><span class="params">(io_context.get_executor())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定执行上下文到处理器</span></span><br><span class="line">    <span class="keyword">auto</span> handler = asio::<span class="built_in">bind_executor</span>(strand, [](<span class="type">const</span> boost::system::error_code&amp; ec) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Handler executed in strand!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行处理器（实际上是在 strand 内执行）</span></span><br><span class="line">    <span class="built_in">handler</span>(boost::system::<span class="built_in">error_code</span>()); <span class="comment">// 模拟传递错误码</span></span><br><span class="line"></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>asio::bind_executor()</code> 函数将一个处理器对象（lambda 函数）与一个执行上下文（strand）绑定在一起。然后，通过调用返回的新处理器对象 <code>handler</code>，可以确保该处理器在指定的 <code>strand</code> 中运行，从而保证了处理器的操作在该执行上下文中进行。这种绑定执行上下文到处理器的方式常用于确保异步操作的顺序执行或者将处理器绑定到特定的执行上下文中执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-C++17%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-C++17%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/" class="post-title-link" itemprop="url">C++17代码整洁之道</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++17代码整洁之道阅读笔记</li>
</ul>
<h2 id="第二章-构建安全体系"><a href="#第二章-构建安全体系" class="headerlink" title="第二章 构建安全体系"></a>第二章 构建安全体系</h2><h3 id="2-3-单元测试"><a href="#2-3-单元测试" class="headerlink" title="2.3 单元测试"></a>2.3 单元测试</h3><ul>
<li><p>单元测试是一小段代码，在特定上下文环境中，单元测试能够执行产品的一部分代码。单元测试能够在很短的时间内，展示出你的代码是否达到了预期的运行结果。</p>
</li>
<li><p>单元测试框架</p>
<ul>
<li>C++的单元测试框架有很多种，例如: CppUnit, Boost.Test, CUTE, Google Test等</li>
<li>一般而言，几个单元测试框架的集合成为xUnit，所有遵循所谓的xUnit的基本设计的单元测试的框架，其结构和功能都是从Smalltalk的SUnit集成而来的。</li>
</ul>
</li>
</ul>
<h3 id="2-5-良好的单元测试原则"><a href="#2-5-良好的单元测试原则" class="headerlink" title="2.5 良好的单元测试原则"></a>2.5 良好的单元测试原则</h3><ul>
<li><p>单元测试的代码的质量</p>
<ul>
<li>高质量的要求产品代码，同样高质量的要求单元测试的代码。更进一步的讲，理论上，产品代码和测试代码之间不应该有任何区别</li>
</ul>
</li>
<li><p>单元测试的命名</p>
<ul>
<li>如果单元测试失败，开发人员希望立即知道以下信息：<ul>
<li>测试单元的名称是什么？谁的单元测试失败了？</li>
<li>单元测试测试了什么？单元测试的环境是怎么样的(测试场景)</li>
<li>预期的单元测试结果是什么？单元测试失败的实例测试结果又是什么</li>
</ul>
</li>
<li>因此，单元测试的命名需要具备直观性和描述性，这是非常重要的</li>
</ul>
</li>
<li><p>首先，以这样的方式命名单元测试模块(依赖于单元测试框架，称为测试用具或者测试夹具)是很好的做法，这样单元测试代码很容易衍生于单元测试框架。单元测试应该有一个像 <Unit_under_Test>Test的名字，很显然，必须用测试对象的名字来替换 <Unit_under_Test>占位符</p>
</li>
<li><p>例如，如果被测试的系统(SUT)是Money单位，与该测试单元对应的单元测试夹具，以及所有的单元测试用例都应该命名为MoneyTest</p>
</li>
<li><p>除此之外，单元测试必须有直观的且易理解的名称，如果单元测试的名称或多或少没有意义，那么单元测试的名称不会有太大的帮助。通过下面的建议，可以为单元测试取一个好名字</p>
<ul>
<li>一般来说，可以在不同场景下使用多种用途的类，一个直观的且易理解的名称应该包含以下三点：<ul>
<li>单元测试的前置条件，也就是执行单元测试之前的SUT的状态</li>
<li>被单元测试测试的部分，通常是被测试的过程，函数或者方法（API）的名称</li>
<li>单元测试预期的测试结果</li>
</ul>
</li>
<li>遵循以上三点建议，测试过程或方法的单元测试命名的模板，如下所示<ul>
<li><PreconditionAndStateOfUnitUnderTest><em><TestedPartOfAPI></em><ExpectedBehavior></li>
</ul>
</li>
<li>示例<ul>
<li>void CustomerCacheTest::cacheIsEmpty_addElement_sizeIsOne();</li>
<li>void MoneyTest::giveTwoMoneyObjectsWithDifferentBalance_theInequalityComparison_Works();</li>
</ul>
</li>
<li>另一个构建直观的且易理解的单元测试名称的方法，就是在单元测试名称中显示特定的需求。这样的单元测试的名称通常能够反应应用程序域的需求</li>
<li>示例<ul>
<li>void UserAccountTest::creatingNewAccountWithExistingEmailAddressThrowsException();</li>
<li>void BookInventoryTest::aBookThatIsAlreadyBorrowedCanNotBeBorrowedTwice();</li>
</ul>
</li>
<li>几乎所有的单元测试框架都会把失败的单元测试名称输出到标准输出</li>
</ul>
</li>
<li><p>单元测试的独立性</p>
<ul>
<li>每个单元测试和其他的单元测试都必须是独立的。如果单元测试之间是以特定的顺序指定的，那么这将是致命的</li>
<li>永远不要编写 一个单元测试的输出是另一个单元测试的输入 的单元测试。当离开一个单元测试的时候，不应该改变测试单元的状态，这是后续单元测试执行的先决条件</li>
</ul>
</li>
<li><p>单元测试环境的独立初始化</p>
<ul>
<li>在运行所有单元测试时，每个单元测试都必须是应用程序的一个独立的可运行的实例，每个单元测试都必须完全自行设置和初始化其所需的环境，着同样适用于执行单元测试后的清理工作。</li>
</ul>
</li>
<li><p>不对getters和setter做单元测试</p>
</li>
<li><p>不对第三方代码做单元测试</p>
<ul>
<li>我们可以预测第三方代码都有自己的单元测试。在你的项目中，不使用那么没有自己的单元测试和质量可疑的库或框架，这是一种明智的架构选择。</li>
</ul>
</li>
<li><p>不对外部系统做单元测试。</p>
</li>
<li><p>如何处理数据库的访问</p>
<ul>
<li>能不使用数据库进行单元测试，就不使用数据库进行单元测试。</li>
<li>只在内存中执行所有的单元测试。</li>
<li>单元测试不要访问数据库，磁盘，网络等外设</li>
<li>数据库测试不是单元测试的内容，它是系统集成和系统测试级别的内容</li>
</ul>
</li>
<li><p>不要混淆测试代码和产品代码</p>
</li>
<li><p>测试必须快速执行</p>
</li>
</ul>
<h2 id="第三章-原则"><a href="#第三章-原则" class="headerlink" title="第三章 原则"></a>第三章 原则</h2><ul>
<li><p>我建议学生们把更多的精力放在学习基本思想上，而不是新技术上，因为新技术在他们毕业之前就有可能过时，而基本思想则永远不会过时。</p>
</li>
<li><p>一般来说，不仅是软件开发，把生活中的一切事情变得尽可能简单并不一定都是坏事。</p>
</li>
<li><p>也就是说，下面这些原则我们不应该学一次就忘掉，建议熟练掌握它们。这些原则非常重要，理想情况下，它们会成为每个开发人员的第二天性。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Asio/2024-12-14-endpoint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Asio/2024-12-14-endpoint/" class="post-title-link" itemprop="url">endpoint</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Asio/" itemprop="url" rel="index"><span itemprop="name">Asio</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Asio-asio-ip-tcp-endpoint-是什么"><a href="#Asio-asio-ip-tcp-endpoint-是什么" class="headerlink" title="Asio asio::ip::tcp::endpoint 是什么"></a>Asio asio::ip::tcp::endpoint 是什么</h2><p>在 <strong>Asio</strong>（或 Boost.Asio）中，<code>asio::ip::tcp::endpoint</code> 是一个类，表示一个 <strong>TCP 端点</strong>。它包含了 IP 地址和端口号，用于描述 TCP 网络通信中的目标或源。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><p><code>asio::ip::tcp::endpoint</code> 是 TCP 套接字（<code>asio::ip::tcp::socket</code>）操作中的核心组件，用来：</p>
<ol>
<li>指定服务器的地址和端口，作为客户端的目标。</li>
<li>指定本地地址和端口，用于绑定监听服务器或设置客户端绑定信息。</li>
<li>在连接建立后获取对等端的网络信息（如对端 IP 和端口）。</li>
</ol>
<hr>
<h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a><strong>类定义</strong></h3><p><code>asio::ip::tcp::endpoint</code> 是 <code>asio::ip::basic_endpoint&lt;tcp&gt;</code> 的具体实现，用于 TCP 协议。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> asio &#123;</span><br><span class="line"><span class="keyword">namespace</span> ip &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">tcp</span>::endpoint &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="built_in">endpoint</span>();                               <span class="comment">// 默认构造，地址为 unspecified，端口为 0</span></span><br><span class="line">        <span class="built_in">endpoint</span>(<span class="type">const</span> address&amp; addr, <span class="type">unsigned</span> <span class="type">short</span> port); <span class="comment">// 使用地址和端口初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置/获取地址</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">address</span><span class="params">(<span class="type">const</span> address&amp; addr)</span></span>;</span><br><span class="line">        <span class="function">address <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置/获取端口</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">port</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">port</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较运算符</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> endpoint&amp; other) <span class="type">const</span>;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> endpoint&amp; other) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他函数</span></span><br><span class="line">        <span class="function">std::string <span class="title">to_string</span><span class="params">()</span> <span class="type">const</span></span>;           <span class="comment">// 返回可读的字符串表示</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a><strong>常见操作</strong></h3><h4 id="1-创建端点"><a href="#1-创建端点" class="headerlink" title="1. 创建端点"></a><strong>1. 创建端点</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::address addr = asio::ip::<span class="built_in">make_address</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(addr, <span class="number">8080</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这表示一个 TCP 端点，IP 地址是 <code>127.0.0.1</code>，端口号是 <code>8080</code>。</p>
<h4 id="2-默认构造"><a href="#2-默认构造" class="headerlink" title="2. 默认构造"></a><strong>2. 默认构造</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::tcp::endpoint endpoint;</span><br></pre></td></tr></table></figure>
<p>创建一个默认的端点，地址为 <code>0.0.0.0</code>（未指定地址），端口为 <code>0</code>。</p>
<h4 id="3-动态绑定（服务器）"><a href="#3-动态绑定（服务器）" class="headerlink" title="3. 动态绑定（服务器）"></a><strong>3. 动态绑定（服务器）</strong></h4><p>当服务器需要绑定一个本地端口时，可以使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line">asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(asio::ip::tcp::v4(), <span class="number">8080</span>)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">open</span>(endpoint.<span class="built_in">protocol</span>());</span><br><span class="line">acceptor.<span class="built_in">bind</span>(endpoint);</span><br><span class="line">acceptor.<span class="built_in">listen</span>();</span><br></pre></td></tr></table></figure>
<p>此处，<code>endpoint</code> 表示监听在 IPv4 地址的所有网络接口（<code>0.0.0.0</code>）上的端口 <code>8080</code>。</p>
<h4 id="4-解析客户端或服务器端地址"><a href="#4-解析客户端或服务器端地址" class="headerlink" title="4. 解析客户端或服务器端地址"></a><strong>4. 解析客户端或服务器端地址</strong></h4><ul>
<li>客户端连接时，解析服务器端点：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::<span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(io_context)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> endpoints = resolver.<span class="built_in">resolve</span>(<span class="string">&quot;example.com&quot;</span>, <span class="string">&quot;80&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>在服务器端，从已接受的连接中获取对端的 IP 和端口：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">accept</span>(socket);</span><br><span class="line">asio::ip::tcp::endpoint remote_endpoint = socket.<span class="built_in">remote_endpoint</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Connected to &quot;</span> &lt;&lt; remote_endpoint.<span class="built_in">address</span>().<span class="built_in">to_string</span>() </span><br><span class="line">          &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; remote_endpoint.<span class="built_in">port</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-转换为字符串"><a href="#5-转换为字符串" class="headerlink" title="5. 转换为字符串"></a><strong>5. 转换为字符串</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(asio::ip::make_address(<span class="string">&quot;192.168.1.1&quot;</span>), <span class="number">12345</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Endpoint: &quot;</span> &lt;&lt; endpoint.<span class="built_in">to_string</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Endpoint: 192.168.1.1:12345</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="重要成员函数"><a href="#重要成员函数" class="headerlink" title="重要成员函数"></a><strong>重要成员函数</strong></h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><strong>构造函数</strong></h4><ol>
<li><p><strong>默认构造</strong></p>
<ul>
<li>创建一个未指定地址和端口的端点（<code>0.0.0.0:0</code> 或 <code>[::]:0</code>）。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::tcp::<span class="built_in">endpoint</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>地址和端口构造</strong></p>
<ul>
<li>使用指定的 <code>asio::ip::address</code> 和端口初始化。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::tcp::<span class="built_in">endpoint</span>(<span class="type">const</span> asio::ip::address&amp; addr, <span class="type">unsigned</span> <span class="type">short</span> port);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>协议构造</strong></p>
<ul>
<li>使用协议（IPv4&#x2F;IPv6）和端口初始化，地址为未指定。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::tcp::<span class="built_in">endpoint</span>(asio::ip::tcp::<span class="built_in">v4</span>(), <span class="number">8080</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a><strong>成员函数</strong></h4><ol>
<li><p><strong>设置地址</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">address</span><span class="params">(<span class="type">const</span> asio::ip::address&amp; addr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>修改端点的 IP 地址。</p>
</li>
<li><p><strong>获取地址</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::<span class="function">ip::address <span class="title">address</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回端点的 IP 地址。</p>
</li>
<li><p><strong>设置端口</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">port</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port)</span></span>;</span><br></pre></td></tr></table></figure>
<p>修改端点的端口号。</p>
</li>
<li><p><strong>获取端口</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">port</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回端点的端口号。</p>
</li>
<li><p><strong>转换为字符串</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回端点的字符串表示形式，例如 <code>127.0.0.1:8080</code>。</p>
</li>
</ol>
<hr>
<h3 id="典型用例"><a href="#典型用例" class="headerlink" title="典型用例"></a><strong>典型用例</strong></h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><strong>客户端</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asio::io_context io_context;</span><br><span class="line"><span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(io_context)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> endpoints = resolver.<span class="built_in">resolve</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;8080&quot;</span>);</span><br><span class="line"><span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">asio::<span class="built_in">connect</span>(socket, endpoints);</span><br></pre></td></tr></table></figure>

<h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a><strong>服务器</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">asio::io_context io_context;</span><br><span class="line"><span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, tcp::endpoint(tcp::v4(), <span class="number">8080</span>))</span></span>;</span><br><span class="line"><span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">accept</span>(socket);</span><br><span class="line"></span><br><span class="line">tcp::endpoint remote_endpoint = socket.<span class="built_in">remote_endpoint</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Connected from &quot;</span> &lt;&lt; remote_endpoint.<span class="built_in">to_string</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p><code>asio::ip::tcp::endpoint</code> 是 TCP 通信中的一个核心组件，用于描述通信双方的网络位置。它不仅简单易用，而且与其他 Asio 组件（如 <code>tcp::resolver</code>、<code>tcp::socket</code>）紧密配合，为构建高效的网络程序提供了强大支持。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-C++%E6%B2%89%E6%80%9D%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-C++%E6%B2%89%E6%80%9D%E5%BD%95/" class="post-title-link" itemprop="url">C++沉思录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>抽象，是有选择的忽略。</li>
<li>编程依赖于一种选择，<strong>选择什么</strong>和<strong>何时忽略</strong>。</li>
<li>编程就是通过建立抽象来葫芦俄那些我们此刻并不重视的因素</li>
<li>本书坚持以两个思想为核心：实用和抽象</li>
</ul>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ul>
<li><p>在处理大问题的时候，这样的工具总是能够帮助将问题分解成<strong>独立的子问题</strong>，并能确保它们相互独立，也就是说当处理问题的某个部分的时候，完全不必担心其他部分</p>
</li>
<li><p>有些抽象不是语言的一部分</p>
</li>
<li><p>文件的概念</p>
<ul>
<li>事实上每种操作系统都以某种方式使文件能为用户所用。在大多数情况下，文件根本不是物理存在的。</li>
<li>文件只是组织长期存储的数据的一种方式，并且由程序和数据结构的集合提供支持来实现这个抽象。</li>
</ul>
</li>
<li><p><strong>通常，我们不可能为特定的工具挑选合适的问题</strong></p>
</li>
</ul>
<h2 id="面向对象编程-OOP"><a href="#面向对象编程-OOP" class="headerlink" title="面向对象编程(OOP)"></a>面向对象编程(OOP)</h2><ul>
<li><p>面向对象编程，指使用继承和动态绑定的编程方式</p>
</li>
<li><p>继承，是一种抽象，它允许程序员在某些时候忽略相似对象间的差异，又在其它时候利用这些差异。</p>
</li>
<li><p>采用这种编译时检查的方式，是因为C++能够为动态绑定的函数调用快速生成代码</p>
</li>
<li><p><strong>只有在程序通过指向基类对象的指针或者基类对象的引用调用虚函数时，才会发生运行时的多态现象。</strong></p>
</li>
<li><p><strong>任何虚函数只有在继承的情况下才有用</strong></p>
</li>
<li><p>对象的创建和复制不是运行时多态的。所以容器：无论是类似于数组或者结构体的内建容器还是用户自定义容器类：<strong>只能获得编译时类型已知的元素值</strong></p>
</li>
<li><p>如果有一系列类之间存在继承关系，当需要创建，复制和存储对象，而这些对象的确切类型只有到运行时才能够知道时，这种编译时的检查会带来一些麻烦</p>
</li>
<li><p>通常，解决这个问题的方法是增加一个间接层。C++采用了一种更自然的方法。就是：定义一个类来提供并且隐藏这个间接层，这种类，通常叫做<strong>句柄(handle)类</strong></p>
</li>
<li><p>句柄类采用最简单的形式，把一个单一类型的对象与一个与之有某种特定继承关系的任意类型的对象捆绑起来。</p>
</li>
<li><p>句柄类的一个常见用户就是通过避免不必要的复制来优化内存管理</p>
</li>
<li><p>容器通常只能包含一种类型的对象，所以很难在容器中存储对象本身</p>
</li>
<li><p>存储指向对象的指针，虽然允许通过继承来处理类型不同的问题，但是也增加了内存分配的额外负担</p>
</li>
<li><p>定义一个行为和<code>Vehicle</code>对象相似，而有潜在地表示了所有继承自<code>Vehicle</code>类的对象的东西。我们把这中类的对象叫做代理(<code>surrogate</code>)</p>
</li>
</ul>
<h2 id="handle-classe"><a href="#handle-classe" class="headerlink" title="handle classe"></a>handle classe</h2><ul>
<li>需要一种方法，让我们在避免某些缺点（如缺乏安全性）的同时能够获取指针的某些优点，尤其是能够在保持多态性的前提下避免复制对象的代价。</li>
<li>C++的解决方法就是定义一个适当的类，由于这些类的对象通常被绑定到它们所控制的类的对象上，所以这些类常被称为<code>handle</code>类(<code>handle classe</code>)。因为这些handle的行为类似指针，所以有时也被称为<strong>智能指针</strong>（<code>smart pointer</code>）</li>
</ul>
<h3 id="引用计数型句柄"><a href="#引用计数型句柄" class="headerlink" title="引用计数型句柄"></a>引用计数型句柄</h3><ul>
<li>之所以要使用句柄，原因之一就是为了避免不必要的对象复制。也就是说，得允许多个句柄绑定到单个对象上</li>
<li>写时复制，<code>copy on write</code>。其有点是只有在绝对必要时才进行复制，从而避免了不必要的复制。在涉及句柄的类库中，这一技术经常用到</li>
</ul>
<h3 id="面向对象程序范例"><a href="#面向对象程序范例" class="headerlink" title="面向对象程序范例"></a>面向对象程序范例</h3><ul>
<li>通常认为，面向对象编程有三个要素：<strong>数据抽象，继承以及动态绑定</strong></li>
<li>解决方法的实质是要对希望模拟的下层系统中的对象进行<strong>建模</strong>。当我们分析出表达式树是有节点和边所构成，便可以设计数据抽象来对树进行建模。</li>
<li>继承让我们抓住了各种节点类型之间的相似之处，而动态绑定帮助我们为各种类型节点定义操作，让编译器来负责安排在运行时能够调用正确的函数。</li>
<li>这样，数据抽象加上动态绑定可以让我们集中精力考虑每个类型的行为和实现，而不必关心与其他对象的交互。</li>
</ul>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><ul>
<li>在解决问题的时候，有一点要始终牢记，<strong>不仅要看到眼前的问题，还要看到长远的变化。</strong></li>
<li>在实际开发中，灵活性通常是有意义的，因为它使我们面对需求的变更不至于一切推翻重来。至于应当为这种灵活性付出多大代价，当然有一个工程上的权衡问题，只能根据对环境的理解来作出回答。</li>
<li>我们必须清楚，在选择一个设计方案之前，必须首先把问题及其背景搞清楚</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul>
<li><strong>虚函数是C++的基本组成部分，也是面向对象编程所必需的</strong>。然而，虚函数并不一定总是适用的</li>
<li>关于虚函数为什么不总是适用，大致有三个原因：<ol>
<li>虚函数有时候会带来很大的消耗</li>
<li>虚函数不总是提供所需的行为</li>
<li>有时候我们写一个类时，可能不想考虑派生的问题</li>
</ol>
</li>
<li>另一个方面，我们还知道了一种必须使用虚函数的情况。当需要删除一个<strong>表面上指向基类对象，实际上却是指向派生类对象的指针，就是需要虚析构函数。</strong></li>
</ul>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul>
<li><p>从某种意义上来说，模板只不过是语法宏的一种受限形式</p>
</li>
<li><p><strong>通常将容器称为模板，而容器内的对象的类型就是模板参数</strong></p>
</li>
<li><p>因此，对于任意类型T，可以想象容器可以是<code>List&lt;T&gt;</code>或者<code>Set&lt;T&gt;</code></p>
</li>
<li><p>模板是<strong>泛型编程</strong>的基础，泛型编程即以一种独立于任何特定类型的方式编写代码</p>
</li>
<li><p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p>
</li>
<li><p>每个容器都有一个单一的定义，比如向量，我们可以定义许多不同类型的向量，比如<code>vector&lt;int&gt;</code> 或者<code>vector &lt;string&gt;</code></p>
</li>
<li><p>可以使用模板来定义函数和类</p>
</li>
<li><p>模板函数定义的一般形式如下：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename type&gt; ret-type func-name(parameter list)&#123;</span><br><span class="line">    // 函数主体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在这里，type是函数所使用的数据类型的占位符的名称，这个名称可以在函数定义中使用</p>
</li>
<li><p>类模板，正如定义函数模板一样，也可以定义类模板，泛型类声明的一般形式如下：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class type&gt; class class-name&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在这里，type是占位符类型名称，可以在类被实例化的时候进行指定。可以使用一个逗号分隔的列表来定义多个泛型数据类型</p>
</li>
<li><p>C++最基本的设计原则就是用类来表示概念。指针把数组的标识和内部空间结合在一起</p>
</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li>通常情况下，每个容器类都有一个或者多个相关的迭代器类型。迭代器能使我们在不暴露容器内部结构的情况下访问容器的元素。</li>
</ul>
<h2 id="模板和泛型算法"><a href="#模板和泛型算法" class="headerlink" title="模板和泛型算法"></a>模板和泛型算法</h2><ul>
<li>1994年7月，在安大略基其纳召开的C++标准会议上，委员会投票通过了一项由Alex Stepanov提出的建议，即将他和他的同事们在Hewlett-Packard实验室开发的一系列泛型算法作为一部分收录到标准C++标准库中。这些被包含到库中的类和算法合起来称为标准模板库（<code>Standard Template Library, STL</code>）</li>
<li>所谓泛型算法，就是这样的算法：对于所操作的数据结构的细节信息，只加入最低限度的了解。当然，理想的情况应该是根本不需要这样的信息，但是现实却不是这样，作为一种折中，STL根据数据结构能够支持的有效操作，将这些数据结构进行分类，然后对于每个算法，它会指出该算法所需要的数据结构类别</li>
<li>被分类的不是算法，也不是数据结构，而是用来访问数据结构的类型。这些类型的对象叫做迭代器。</li>
<li>迭代器共有五种：输入迭代器，输出迭代器，前向迭代器，双向迭代器和随即存取迭代器。</li>
<li>概念继承将这些种类关联起来，之所以称之为“概念的”，是因为这些种类本身都是概念，而不是类型或者对象。</li>
</ul>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><ul>
<li>除了迭代器和配接器外，STL还提供了一种称为函数对象（function object）的概念。</li>
<li>简单地说，函数对象提供了一种方法，将要调用的函数与准备传递给这个函数的隐式参数捆绑起来，这就允许我们使用相当简单的语法来建立复杂的表达式</li>
<li>函数对象表示了一种操作。通过组合函数对象，我们可以得到复杂的操作。</li>
</ul>
<h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><ul>
<li><p>抽象数据类型，ADT</p>
</li>
<li><p>数据抽象的目的就是控制复杂度</p>
</li>
<li><p>C++中的一个更为重要的思想（尽管这个思想不是C++特有的）是：<strong>用户自定义类型可以很容易地当作内建类型使用。通过定义新类型，用户可以为了他们自己的目的来定制语言</strong></p>
</li>
</ul>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><ul>
<li>如果我们准备在接口和实现之间实现完全隔离，就会希望语言支持数据抽象。</li>
<li><strong>C++语言中将接口与实现分隔开的最基本的方法之一就是采用构造函数和析构函数</strong>。正是这两个函数允许类设计者能够说：这个类的对象使用对象本身内容之外的信息。<ul>
<li>构造函数本身提供了生成给定类对象的方法</li>
<li>析构函数则提供了与构造函数相反的行为</li>
</ul>
</li>
</ul>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul>
<li>命名空间解决了一种在C中十分突出而在C++中愈加严重的问题：如何防止不同的程序库设计者为各自组建采用相同的名字</li>
<li>本质上，命名空间允许库设计者对会被库放到全局作用域的所有名称指定一个<strong>包装器（wrapper）</strong>。</li>
</ul>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul>
<li><p>C++的一个基本思想就是：<strong>通过类定义可以明确指明当这个类的对象被构造，销毁，复制和赋值时应该发生什么事情</strong>。这意味着设计的当的类可以为理解程序的动态行为提供一个强有力的工具，这一点往往比人们所认识的更重要</p>
</li>
<li><p>C++程序经常要为一整组对象分配内存，随后将他们同时释放。解决这个问题的方法之一是定义一个包含这样的集合的类。事实证明，为了让一个集合包含不相关的类的对象，一个好方法是使用多重继承。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>一种常见对C++的批评是说该语言太复杂。我认为只有在孤立地看待C++时，这种观点才成立。设计任何一门语言，也可以说是任何软件，都是有特定的背景。</li>
<li>C++面向的是特定的用户群。这个用户群要应付各种复杂的问题，写出要运行相当长时间的解决方案。这些解决方案必须满足任意的性能需求，要工作在不同的硬件和操作平台上，还要和许多已经存在的系统共存。</li>
<li>学习和使用C++的建议：<ul>
<li>做理解的事情；理解要做的事情</li>
<li>逐步加深扩展理解</li>
<li>做练习时要把握分寸，过犹不及</li>
<li>依据操作思考。从C到C++最大的观念性变化就是要停止考虑程序的结构，而开始考虑程序数据的行为。</li>
<li>早些考虑测试</li>
<li>思考。所有的建议都只是建议。是否对你有用是由你决定的。你可以依照我的建议做任何事情，尽量确切的遵循它，或者拼命反其道而行之，或者忽略它，或者对此嗤之以鼻。不管怎么对待，<strong>你都要清楚为什么要这样做</strong>。不管你理不理解都要对结果负责。</li>
</ul>
</li>
</ul>
<h2 id="采访"><a href="#采访" class="headerlink" title="采访"></a>采访</h2><ul>
<li><p>是否应该更加重视标准库教育，而不是语言细节的教育？</p>
</li>
<li><p>当然是库优先于语言细节。两个原因：</p>
<ul>
<li>首先，学生们可以不必费力包装低层次的语言细节，从而更容易建立整体语言的全局观念，了解到其真实威力。不过根据我们的经验，<strong>学生们首先掌握如何使用程序库之后，就会很容易理解类的概念，学会如何构造类的技术</strong>。如果首先去学习语言细节，那么就很难理解类的概念及其功能。这种理解上的缺陷，使他们很难设计和构造自己的类。</li>
<li>更重要的一点是，首先学习程序库，能够是学生培养起良好的习惯，就是复用库代码，而不是凡事自己动手。首先学习语言细节的学生，最后的编程风格往往是C类型的，而不是C++风格。他们不会充分地运用库，而自己的程序带有严重的C主义倾向：指针满天飞，整个程序都是低层次的。结果是，在很多情况下，你为C++的复杂性付出了高昂代价，却没有从中获得任何好处。</li>
</ul>
</li>
<li><p>一个问题产生良好的设计方案的途径，就是使用一种允许你进行各种设计的工具。这样一来，你就可以选择最适合该问题的设计方案。如果你选择了这样的工具，那么你就必须负责选择合适的设计方案。</p>
</li>
<li><p>为什么认为“基于对象”和“基于模板”的抽象机制优先于面向对象抽象机制？</p>
</li>
<li><p>所谓面向对象编程，就是使用继承和动态绑定机制编程。如果你知道有一个很好的程序使用了继承和动态绑定，你能作出怎样的推断？在我们看来，这意味着该程序中有两个或两个以上的类型，至少有一个共同的操作，也至少有一个不同的操作。否则就不需要继承机制。此外，程序中必然有一个场景，需要在运行时从这些类型中挑选出一个，否则就不需要动态绑定机制</p>
</li>
<li><p>某些面向对象编程语言，如Python，其所有类型都是动态的，那么技术书籍的作者就不会面对这样的问题。例如，C++中的容器类大多数用模板写成，因其可以容纳毫无共同之处的对象，所以要求元素类型必须是某个共同基类的派生类毫无道理。然而，在Python中，容器类中本来就可以放置任何对象，所以类似模板那样的类型机制就不必要了。</p>
</li>
<li><p>所以，我认为你所看到的问题，其实是因为很难找到又小又好的面向对象程序做范例，才会产生的。而且，对于其他语言必须依赖动态类型才能解决的问题，C++能够使用模板来高效地解决。</p>
</li>
<li><p>如果我说我只能记住你的一句话，那一定是：用类来表示概念。假设再记住一句话，应该是什么？</p>
</li>
<li><p>避免重复。如果发现自己在程序的两个不同部分里做了相同的事情，试着把这两个部分合并到一个子过程中。如果发现两个类的行为相近，试着把这两个类的相似部分统一到基类或模板中</p>
</li>
<li><p>我们都希望成为更好的C++程序员，请给我们三那个你认为最重要的建议。</p>
<ul>
<li>避免使用指针</li>
<li>提倡使用程序库</li>
<li>使用类来表示概念</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/Books/2024-05-22-C++Primerplus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/Books/2024-05-22-C++Primerplus/" class="post-title-link" itemprop="url">C++Primerplus</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Books/" itemprop="url" rel="index"><span itemprop="name">Books</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="C-简介"><a href="#C-简介" class="headerlink" title="C++简介"></a>C++简介</h3><ul>
<li>C++融合了三种不同的编程方式：<ul>
<li>C语言代表的过程性语言</li>
<li>C++在C语言基础上添加的类代表的面向对象语言</li>
<li>C++模板支持的泛型编程</li>
</ul>
</li>
</ul>
<h3 id="C-简史"><a href="#C-简史" class="headerlink" title="C++简史"></a>C++简史</h3><ul>
<li><p>汇编语言，依赖于计算机的内部机器语言。</p>
</li>
<li><p>它是低级语言(low-level)，即直接操作硬件，例如直接访问CPU寄存器和内存单元。因此，汇编语言针对于特定的计算机处理器，要将汇编程序移植到另一种计算机上，必须使用不同的汇编语言重新编写程序</p>
</li>
<li><p>高级语言(high-level)，致力于解决问题，而不针对特定的硬件。</p>
</li>
<li><p>一种被称为<strong>编译器</strong>的特殊程序将高级语言翻译成特定计算机的内部语言。这样，就可以通过对每个平台使用不同的编译器来在不同的平台上使用同一个高级语言程序了</p>
</li>
<li><p>一般来说，计算机语言要处理两个概念–数据和算法</p>
<ul>
<li>数据，是程序使用和处理的信息</li>
<li>算法，是程序使用的方法</li>
</ul>
</li>
<li><p>结构化编程，将分支（决定接下来应执行哪个指令）限制为一小组行为良好的结构。</p>
</li>
<li><p>C语言的词汇表中就包含了这些结构：for循环，while循环，do while循环，if else语句</p>
</li>
<li><p><strong>结构化编程技术反映了过程性编程的思想，根据执行的操作来构思一个程序</strong></p>
</li>
<li><p>面向对象编程(OOP)，与强调算法的过程性编程不同的是，OOP强调的是数据。它不像过程性编程那样，试图使问题满足语言的过程性方法，而是试图<strong>让语言来满足问题的要求</strong>。其理念是设计与问题的本质特性相对应的数据格式。</p>
</li>
<li><p><strong>在C++中，类是一种规范，它描述了这种新型数据格式，对象是根据这种规范构造的特定数据结构。</strong></p>
</li>
<li><p>OOP程序设计方法首先设计类，它们准确地表示了程序要处理的东西。类定义描述了对每个类可执行的操作，然后便可以设计一个使用这些类的对象的程序。</p>
</li>
<li><p>从低级组织（如类）到高级组织（如程序）的处理过程，叫做自下向上(bottom-up)的编程</p>
</li>
<li><p>OOP编程并不仅仅是将数据和方法合并为类定义。</p>
<ul>
<li>它还有助于创建可重用的代码，这将减少大量的工作。</li>
<li>信息隐藏可以保护数据</li>
<li>多态能够为运算符和函数创建多个定义，通过编程上下文来确定使用哪个定义</li>
<li>继承能够使用旧类派生出新类</li>
</ul>
</li>
<li><p>OOP引入了很多新的理念，使用的编程方法不同于过程性编程。它不是将重点放在任务上，而是放在表示概念上。</p>
</li>
<li><p>泛型编程(generic programming)是C++支持的另一种编程模式。它与OOP的目标相同，即使重用代码和抽象通用概念的技术更简单。</p>
</li>
<li><p>不过OOP强调的是编程的数据方便，而泛型编程强调的是独立于特定数据类型。它们的侧重点不同。</p>
</li>
<li><p>OOP是一个管理大型项目的工具，而泛型编程提供了执行常见任务（例如对数据排序或合并链表）的工具。</p>
</li>
<li><p>术语泛型(generic)指的是，创建独立于类型的代码。</p>
<ul>
<li>C++的数据表示有多种类型–整数，小数，字符，字符串，用户定义的，由多种类型组成的符合结构。</li>
<li>例如，要对不同类型的数据进行排序，通常必需为每种类型创建一个排序函数。</li>
<li>泛型编程需要对语言进行扩展，以便可以只编写一个泛型（即不是特定类型的）函数，并将其用于各种实际类型。</li>
<li>C++模板提供了完成这种任务的机制。</li>
</ul>
</li>
</ul>
<h2 id="第二章-开始学习C"><a href="#第二章-开始学习C" class="headerlink" title="第二章 开始学习C++"></a>第二章 开始学习C++</h2><ul>
<li><p>语句，是要执行的操作。</p>
</li>
<li><p>为理解源代码，编译器需要直到一条语句何时结束，另一条语句何时开始。有些语句使用语句分隔符。</p>
</li>
<li><p>C++与C一样，使用终止符(terminator)，而不是分隔符。</p>
</li>
<li><p>终止符是一个分号，它是语句的结束标记，是语句的组成部分，而不是语句之间的标记</p>
</li>
<li><p>结论：在C++中，不能省略分号</p>
</li>
<li><p>通常，C++函数可被其他函数激活或调用</p>
</li>
<li><p>函数头描述了函数与调用它的函数之间的接口。</p>
</li>
<li><p>位于函数名前面的部分叫做函数返回类型，<strong>它描述的是从函数返回给调用它的函数的信息</strong>。</p>
</li>
<li><p>函数名后括号中的部分叫做形参列表(argument list)或参数列表(parameter list)。它描述的是从调用函数传递给被调用的函数的信息。</p>
</li>
<li><p>C++注释以双斜杠(<code>//</code>)打头，到行尾结束。注释可以位于单独的一行上，也可以和代码位于同一行</p>
</li>
<li><p>C-风格注释，包括在符号<code>/*</code>和<code>*/</code>之间。由于C-风格注释以<code>*/</code>结束，而不是到行尾结束，因此可以跨越多行。事实上，C99标准也在C语言中添加了<code>//</code>注释</p>
</li>
<li><p>源代码中的标记和空白</p>
<ul>
<li>一行代码中不可分隔的元素叫做标记(token)。</li>
<li>通常，必需用空格，制表符或回车将两个标记分开。空格，制表符和回车统称为空白(white space)。</li>
</ul>
</li>
<li><p>C++源代码风格</p>
<ul>
<li>每条语句占一行</li>
<li>每个函数都有一个开始花括号和一个结束花括号，这两个花括号各占一行</li>
<li>函数中的语句都相对于花括号进行缩进</li>
<li>与函数名称相关的圆括号周围没有空白。</li>
</ul>
</li>
<li><p>C++程序是一组函数，而每个函数又是一组语句</p>
</li>
<li><p>计算机是一种精确的，有条理的机器。要将信息项存储在计算机中，必须指出信息的存储位置和所需的内存空间。</p>
</li>
<li><p>在C++中，完成这种任务的一种相对简便的方法，是使用声明语句来指出存储类型并提供位置标签。</p>
</li>
<li><p>程序中的声明语句叫做定义声明(defining declaration)语句，简称为定义(definition)。这意味着它将导致编译器为变量分配内存空间。在较为复杂的情况下，还可能有引用声明(reference declaration)</p>
</li>
<li><p>总结</p>
<ol>
<li>C++程序由一个或多个被称为函数的模块组成。程序从main()函数开始执行，因此该函数必不可少。函数由函数头和函数体组成。函数头指出函数的返回值的类型和函数期望通过参数传递给它的信息的类型。函数体由一系列位于花括号<code>&#123;&#125;</code>中的C++语句组成</li>
<li>有多种类型的C++语句，包括：<ul>
<li>声明语句，定义函数中使用的变量的名称和类型</li>
<li>赋值语句，使用赋值运算符<code>=</code>给变量赋值</li>
<li>消息语句，将消息发送给对象，激发某种行为</li>
<li>函数调用，执行函数。被调用的函数执行完毕后，程序返回到函数调用语句后面的语句</li>
<li>函数原型，声明函数的返回类型，函数接受的参数数量和类型</li>
<li>返回语句，将一个值从被调用的函数那里返回到调用函数中。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="第三章-处理数据"><a href="#第三章-处理数据" class="headerlink" title="第三章 处理数据"></a>第三章 处理数据</h2><ul>
<li>计算机内存的基本单元是位(bit)。</li>
<li>可以将位看作电子开关，可以开，也可以关。关表示值0，开表示值1。</li>
<li>8为的内存块可以设置出256中不同的组合，因为每一位都可以有两种设置，所以8位的总组合数为256。</li>
<li>字节(byte)，<strong>通常指的是8位的内存单元</strong>。从这个意义上来说，<strong>字节指的就是描述计算机内存量的度量单位</strong>，1KB等于1024字节，1MB等于1024KB。</li>
</ul>
<h2 id="第四章-复合类型"><a href="#第四章-复合类型" class="headerlink" title="第四章 复合类型"></a>第四章 复合类型</h2><h3 id="指针与C-基本原理"><a href="#指针与C-基本原理" class="headerlink" title="指针与C++基本原理"></a>指针与C++基本原理</h3><ul>
<li>面向对象编程与传统的过程性编程的区别在于，OOP强调的是在<strong>运行阶段（而不是编译阶段）进行决策</strong>。<ul>
<li>运行阶段，指的是程序正在运行时</li>
<li>编译阶段，指的是编译器将程序组合起来时。</li>
</ul>
</li>
<li>运行阶段决策，就好比度假时，选择参观那些景点取决于天气和当时的心情；而编译阶段决策更像不管在什么条件下，都坚持预先设定的日程安排。</li>
<li>运行阶段决策提供了灵活性，可以根据当时的情况进行调整</li>
</ul>
<h3 id="指针小结"><a href="#指针小结" class="headerlink" title="指针小结"></a>指针小结</h3><ul>
<li>声明指针</li>
<li>给指针赋值。应将内存地址赋给指针。<strong>可以对变量名应用<code>&amp;</code>运算符，来获得被命名的内存的地址，new运算符返回未命名的内存的地址</strong>。</li>
<li>对指针解除引用。<ul>
<li>对指针解除引用意味着获得指针指向的值。对指针应用解除引用或间接值运算符(<code>*</code>)来解除引用。</li>
<li>另一种对指针解除引用的方法是<strong>使用数组表示法</strong>。例如，<code>pn[0]</code>与<code>*pn</code>是一样的。一定不要对未被初始化为适当地址的指针解除引用。</li>
</ul>
</li>
<li>区分指针和指针所指向的值</li>
<li>数组名。在多数情况下，C++将数组名视为数组的第一个元素的地址。一种例外情况是，将sizeof运算符用于数组名时，此时将返回整个数组的长度（单位为字节）</li>
<li>指针算术</li>
<li>数组的动态联编和静态联编<ul>
<li>使用数组声明来创建数组时，将采用静态联编，即数组的长度在编译时设置</li>
<li>使用<code>new[]</code>运算符创建数组时，将采用动态联编(动态数组),即将在运行时为数组分配空间，其长度也将在运行时设置。使用完这种数组后，应该使用<code>delete[]</code>释放其占用的内存</li>
</ul>
</li>
<li>数组表示法和指针表示法<ul>
<li>使用方括号数组表示法等同于对指针解除引用</li>
<li>数组名和指针变量都是如此，因此对于指针和数组名，即可以使用指针表示法，也可以使用数组表示法</li>
</ul>
</li>
</ul>
<h3 id="自动存储，静态存储和动态存储"><a href="#自动存储，静态存储和动态存储" class="headerlink" title="自动存储，静态存储和动态存储"></a>自动存储，静态存储和动态存储</h3><ul>
<li><p>自动存储</p>
<ul>
<li>在函数内部定义的常规变量使用自动存储空间，被称为自动变量(automatic variable)，这意味着它们在所属的函数被调用时自动产生，在该函数结束时小王</li>
<li>实际上，自动变量是一个局部变量，其作用域为包含它的代码块。代码块是被包含在花括号中的一段代码。</li>
<li>自动变量通常存储在栈中。这意味着执行代码块时，其中的变量将依次加入到栈中，而在离开代码块时，将按相反的顺序释放这些变量，这被称为后进先出(LIFO)。因此，在程序执行过程中，栈将不断地增大和缩小。</li>
</ul>
</li>
<li><p>静态存储</p>
<ul>
<li>静态存储是整个程序执行期间都存在的存储方式。</li>
<li>使变量成为静态的方式有两种：一种是在函数外面定义它，另一种是在声明变量时使用关键字<code>static</code></li>
</ul>
</li>
<li><p>动态存储</p>
<ul>
<li>new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。</li>
<li>它们管理了一个内存池，这在C++中被称为自由存储空间(free store)或堆(heap)。</li>
<li>该内存池同用于静态变量和自动变量的内存是分开的。new和delete能够在一个函数中分配内存，而在另一个函数中释放它。因此数据的生命周期不完全受程序或函数的生存时间控制。</li>
</ul>
</li>
<li><p>栈，堆和内存泄漏</p>
<ul>
<li>如果使用new运算符在自由存储空间（或堆）上创建变量后，没有调用delete，则即使包含指针的内存由于作用域规则和对象生命周期的原因而被释放，在自由存储空间上动态分配的变量或结构也将继续存在。</li>
<li>实际上，将会无法访问自由存储空间中的结构，因为指向这些内存的指针无效。这将导致内存泄漏。被泄漏的内存将在程序的整个生命周期内都不可使用；这些内存被分配出去，但无法收回。</li>
<li>极端情况（不过不常见）是，内存泄漏可能会非常严重，以致于应用程序可用的内存被耗尽，出现内存耗尽错误，导致程序崩溃。另外，这种泄漏还会给一些操作系统或在相同的内存空间中运行的应用程序带来负面影响，导致它们崩溃。</li>
</ul>
</li>
</ul>
<h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><ul>
<li><p>内联函数是C++为提供程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。</p>
</li>
<li><p>编译过程的最终产品是可执行程序–由一组机器语言指令组成。运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。</p>
</li>
<li><p>引用变量</p>
<ul>
<li>引用是已定义的变量的别名（另一个名称）</li>
<li>引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的</li>
<li><code>int rats; int &amp; rodents = rats;  // make rodents an alias for rate</code></li>
<li>其中，<code>&amp;</code>不是地址运算符，而是类型标识符的一部分。就像声明中的<code>char*</code>指的是指向<code>char</code>的指针一样，<code>int&amp;</code>指的是指向int的引用。</li>
</ul>
<ul>
<li>引用经常被用作函数参数，使得函数中的变量名称为调用程序中的变量的别名，这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量</li>
</ul>
</li>
</ul>
<h3 id="实例化和具体化"><a href="#实例化和具体化" class="headerlink" title="实例化和具体化"></a>实例化和具体化</h3><ul>
<li>为进一步了解模板，必需理解术语：实例化和具体化</li>
<li>谨记：在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例(instantiation)<ul>
<li>例如，函数调用<code>Swap(i, j)</code>导致编译器生成<code>Swap()</code>的一个实例，该实例使用int类型。模板并非函数定义，但是使用int的模板实例是函数定义。**这种实例化方式被称为隐式实例化(implicit instantiation),因为编译器之所以知道需要进行定义，是由于程序调用<code>Swap()</code>函数时提供了int参数。</li>
<li>最初，编译器只能通过隐式实例化，来使用模板生成函数定义，但是现在C++还允许显式实例化(explicit instantiation)。这意味着可以直接命令编译器创建特定的实例，例如<code>Swap&lt;int&gt;()</code>。其语法是，声明所需要的种类–使用<code>&lt;&gt;</code>符号指示类型，并在声明前加上关键字<code>template</code> – <code>template void Swap&lt;int&gt;(int, int);  // explicit instantiation</code></li>
</ul>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>引用变量是一种伪装指针，它允许为变量创建别名（另一个名称）。引用变量主要被用作处理结构和类对象的函数的参数。</p>
</li>
<li><p>通常，被声明为特定类型引用的标识符只能指向这种类型的数据；然而，如果一个类是从另一个类派生出来的，则基类引用可以指向派生类对象</p>
</li>
<li><p>函数的特征标是它的参数列表。程序员可以定义两个同名函数，只要其特征标不同。这被称为函数多态或函数重载。</p>
</li>
<li><p><strong>通常，通过重载函数来为不同的数据类型提供相同的服务</strong>。</p>
</li>
<li><p>函数模板自动完成重载函数的过程。只需使用泛型和具体算法来定义函数，编译器将为程序中使用的特定参数类型生成正确的函数定义</p>
</li>
</ul>
<h2 id="第九章-内存模型和名称空间"><a href="#第九章-内存模型和名称空间" class="headerlink" title="第九章 内存模型和名称空间"></a>第九章 内存模型和名称空间</h2><h3 id="头文件管理"><a href="#头文件管理" class="headerlink" title="头文件管理"></a>头文件管理</h3><ul>
<li>在同一个文件中只能将同一个头文件包含一次。记住这个规则很容易，但很可能在不知情的情况下将头文件包含多次。<ul>
<li>例如，可能使用包含了另一个头文件的头文件。有一种标准的C&#x2F;C++技术可以避免多次包含同一个文件。</li>
</ul>
</li>
<li>它是基于预处理编译指令<code>#ifndef</code>（即if not defined)</li>
</ul>
<h3 id="自动变量和栈"><a href="#自动变量和栈" class="headerlink" title="自动变量和栈"></a>自动变量和栈</h3><ul>
<li><p>了解典型的C++编译器如何实现自动变量，有助于更深入地了解自动变量</p>
</li>
<li><p>由于自动变量的数目随函数的开始和结束而增减，因此程序必须在运行时对自动变量进行管理。</p>
</li>
<li><p>常用的方法是留出一段内存，并将其视为栈，以管理变量的增减。之所以被称为栈，是由于新数据被象征性地放在原有数据的上面（也就是说，在相邻的内存单元中，而不是在同一个内存单元中），当程序使用完后，将其从栈中删除。栈的默认长度取决于实现，但编译器通常提供改变栈长度的选项。</p>
</li>
<li><p>程序使用两个指针来跟踪栈，一个指针指向栈底–栈的开始位置，另一个指针指向栈顶–下一个可用内存单元。当函数被调用时，其自动变量将被加入到栈中，栈顶指针指向变量后面的下一个可用的内存单元。函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。</p>
</li>
<li><p>栈是LIFO（后进先出）的，即最后加入到栈中的变量首先被弹出。这种设计简化了参数传递。函数调用将其参数的值放在栈顶，然后重新设置栈顶指针。被调用的函数根据其形参描述来确定每个参数的地址。</p>
</li>
</ul>
<h3 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h3><ul>
<li>关键字<code>register</code>最初是由C语言引入的，它建议编译器使用CPU寄存器来存储自动变量，这样的目的是–提高访问变量的速度。</li>
</ul>
<h3 id="说明符和限定符"><a href="#说明符和限定符" class="headerlink" title="说明符和限定符"></a>说明符和限定符</h3><ul>
<li><p>有些被称为存储说明符(storage class specifier)或cv-限定符(cv-qualifier)的C++关键字提供了其他有关存储的信息</p>
</li>
<li><p>存储说明符</p>
<ol>
<li><code>auto</code>（在C++11中不再是说明符）<ul>
<li>在C++11之前，可以在声明中使用关键字<code>auto</code>指出变量为自动变量</li>
<li>在C++11中，<code>auto</code>用于自动类型推断。</li>
</ul>
</li>
<li><code>register</code><ul>
<li>用于在声明中指示寄存器存储，</li>
<li>在C++11中，它只是显式地指出变量是自动的</li>
</ul>
</li>
<li><code>static</code><ul>
<li>它被用在作用域为整个文件的声明中时，表示内部链接性</li>
<li>被用于局部声明中，表示局部变量的存储持续性为静态的</li>
</ul>
</li>
<li><code>extern</code><ul>
<li>它表明是引用声明，即声明引用在其他地方定义的变量</li>
</ul>
</li>
<li><code>thread_local</code>（C++11新增加的，可与<code>static</code>或<code>extern</code>结合使用）<ul>
<li>它指出变量的持续性与其所属线程的持续性相同</li>
<li><code>thread_local</code>变量之于线程，犹如常规静态变量之于整个程序</li>
</ul>
</li>
<li><code>mutable</code><ul>
<li>它的含义将根据const来解释</li>
<li>可以用它来指出，即时结构（或类）变量为const，其某个成员也可以被修改</li>
</ul>
</li>
</ol>
</li>
<li><p>cv-限定符(cv表示const volatile)</p>
<ol>
<li><code>const</code> <ul>
<li>它是最常用的cv-限定符，它表明–内存被初始化后，程序便不能再对它进行修改</li>
</ul>
</li>
<li><code>volatile</code><ul>
<li>它表明，即时程序代码没有对内存单元进行修改，其值也可能发生变化；该关键字的作用是为了改善编译器的优化能力</li>
<li>例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会变化。如果不将变量声明为<code>volatile</code>，则编译器将进行这种优化；将变量声明为<code>volatile</code>，相当于告诉编译器，不要进行这种优化。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>C++鼓励程序员在开发程序时使用多个文件。一种有效的组织策略是，使用头文件来定义用户类型，为操纵给用户类型的函数提供函数原型；并将函数定义放在一个独立的源代码文件中。头文件和源代码文件一起定义和实现了用户定义的类型及其使用方式。最后，将<code>main()</code>和其他使用这些函数的函数放在第三个文件中</li>
</ul>
<h2 id="第十章-对象和类"><a href="#第十章-对象和类" class="headerlink" title="第十章 对象和类"></a>第十章 对象和类</h2><ul>
<li><p>过程性编程方法 – 首先考虑要遵循的步骤，然后考虑如何表示这些数据（并不需要程序一直运行，用户可能希望能够将数据存储在一个文件中，然后从这个文件中读取数据）</p>
</li>
<li><p>OOP方法 – 首先从用户的角度考虑对象，描述对象所需的数据以及描述用户与数据交互所需的操作。完成对接口的描述后，需要确定如何实现接口和数据存储。最后，使用新的设计方案创建出程序。</p>
</li>
<li><p>指定基本类型完成了三项工作</p>
<ul>
<li>决定数据对象需要的内存数量</li>
<li>决定如何解释内存中的位（long和float在内存中占用的位数相同，但将它们转换为数值的方法不同）</li>
<li>决定可使用数据对象执行的操作或方法</li>
</ul>
</li>
<li><p>类，是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包</p>
</li>
<li><p>类规范由两个部分组成</p>
<ul>
<li>类声明：以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述公有接口</li>
<li>类方法定义：描述如何实现类成员函数</li>
<li>简单地说，类声明提供了类的蓝图，而方法定义则提供了细节</li>
</ul>
</li>
</ul>
<h3 id="什么是接口？"><a href="#什么是接口？" class="headerlink" title="什么是接口？"></a>什么是接口？</h3><ul>
<li><p>接口，是一个共享框架，供两个系统（例如在计算机和打印机之间或者用户和计算机程序之间）交互时使用</p>
</li>
<li><p>对于类，我们说公共接口。在这里，公共(public)是使用类的程序，交互系统由类对象组成，而接口由编写类的人提供的方法组成。</p>
</li>
<li><p>接口，让程序员能够编写与类对象交互的代码，从而让程序能够使用类对象。</p>
</li>
<li><p>为开发一个类并编写一个使用它的程序，需要完成多个步骤。这里将开发过程分成多个阶段，而不是一次性完成。</p>
</li>
<li><p>通常，C++程序员将接口（类定义）放在头文件中，并将实现（类方法的代码）放在源代码文件中。</p>
</li>
</ul>
<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><ul>
<li><p>使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数来访问对象的私有成员。</p>
</li>
<li><p>因此，公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。防止程序直接访问数据被称为数据隐藏</p>
</li>
<li><p>类设计尽可能将公有接口与实现细节分开。</p>
<ul>
<li>公有接口表示设计的抽象组件。将实现细节放在一起并将它们与抽象分开被称为封装。</li>
<li>数据隐藏（将数据放在类的私有部分中）是一种封装，将实现的细节隐藏在私有部分中，也是一种封装</li>
<li>封装的另一个例子是，将类函数定义和类声明放在不同的文件中</li>
</ul>
</li>
<li><p>类和结构</p>
<ul>
<li>类描述看上去很像是包含成员函数以及public和private可见性标签的结构声明。</li>
<li>实际上，C++对结构进行了扩展，使之具有与类相同的特性。它们之间唯一的区别是，结构的默认访问类型是public，而类为private。C++程序员通常使用类来实现类描述，而把结构限制为只表示纯粹的数据对象（常被称为普通老式数据结构）</li>
</ul>
</li>
</ul>
<h3 id="实现类成员函数"><a href="#实现类成员函数" class="headerlink" title="实现类成员函数"></a>实现类成员函数</h3><ul>
<li><p>创建类描述的第二个部分：为那些由类声明中的原型表示的成员函数提供代码。</p>
</li>
<li><p>成员函数定义与常规函数定义非常相似，它们有函数头和函数体，也可以有返回类型和参数。但是它们还有两个特殊的特征：</p>
<ul>
<li><strong>定义成员函数时，使用作用域解析运算符(<code>::</code>)来表示函数所属的类</strong></li>
<li><strong>类方法可以访问类的<code>private</code>组件</strong></li>
</ul>
</li>
<li><p>成员函数的函数头使用作用域运算符解析(<code>::</code>)来指出函数所属的类。因此，作用域解析运算符确定了方法定义对应的类的身份。</p>
</li>
</ul>
<h3 id="内联方法"><a href="#内联方法" class="headerlink" title="内联方法"></a>内联方法</h3><ul>
<li><p>定义位于类声明中的函数都将自动成为内联函数</p>
</li>
<li><p>内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。确保内联定义对多文件程序中的所有文件都可用的，最简便的方法是：将内联定义放在定义类的头文件中（有些开发系统包含智能链接程序，允许将内联定义放在一个独立的实现文件）</p>
</li>
</ul>
<h3 id="方法使用哪个对象"><a href="#方法使用哪个对象" class="headerlink" title="方法使用哪个对象"></a>方法使用哪个对象</h3><ul>
<li><p>所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象共享同一组类方法，即每种方法只有一个副本。</p>
<ul>
<li>例如，假设kate和joe都是Stock对象，则<code>kate.shares</code>将占据一个内存块，而<code>joe.shares</code>占用另一个内存块，但<code>kate.show()</code>和<code>joe.show()</code>都调用同一个方法，也就是说，它们将执行同一个代码块，只是将这些代码用于不同的数据。</li>
</ul>
</li>
<li><p>在OOP中，调用成员函数被成为发送消息，因此将同样的消息发送给两个不同的对象将调用同一个方法，但是该方法被用于两个不同的对象。</p>
</li>
</ul>
<h3 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h3><ul>
<li><p>在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。</p>
</li>
<li><p>另外，类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此。也就是说，要调用公有成员函数，必需通过对象</p>
</li>
<li><p>同样，在定义成员函数时，必需使用作用域解析运算符</p>
</li>
<li><p>总之，在类声明或成员函数定义中，可以使用未修饰的成员名称。</p>
</li>
<li><p>构造函数名称在被调用时，才能被识别，因为它的名称与类名相同</p>
</li>
<li><p>其他情况下，使用类成员名时，必需根据上下文使用直接成员运算符(<code>.</code>)，间接成员运算符(<code>-&gt;</code>)或作用域解析运算符(<code>::</code>)</p>
</li>
</ul>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>面向对象编程强调的是程序如何表示数据。使用OOP方法解决编程问题的第一步是根据它与程序之间的接口来描述数据，从而指定如何使用数据。然后，设计一个类来实现该接口。一般来说，私有数据成员存储信息，公有成员函数（又称方法）提供访问数据的唯一途径。类将数据和方法组合成一个单元，其私有性实现数据隐藏</p>
</li>
<li><p>类是用户定义的类型，对象是类的实例。这意味着对象是这种类型的变量。例如由new按类描述分配的内存</p>
</li>
</ul>
<h2 id="第十一章-使用类"><a href="#第十一章-使用类" class="headerlink" title="第十一章 使用类"></a>第十一章 使用类</h2><ul>
<li><p>学习C++的难点之一是需要记住大量的东西，但在拥有丰富的实践经验之前，根本不可能全部记住这些东西。</p>
</li>
<li><p>掌握知识的好的方法是，在自己开发的C++程序中使用其中的新特性。对这些新特性有了充分的认知后就可以添加其他C++特性</p>
</li>
<li><p>正如C++创始人<code>Bjarne Stroustrup</code>在一次C++专业程序员大会上所建议的：<strong>轻松地使用这种语言。不要觉得必须使用所有的特性，不要在第一次学习时就试图使用所有的特性</strong></p>
</li>
</ul>
<h2 id="第十二章-类和动态内存分配"><a href="#第十二章-类和动态内存分配" class="headerlink" title="第十二章 类和动态内存分配"></a>第十二章 类和动态内存分配</h2><h3 id="指针和对象小结"><a href="#指针和对象小结" class="headerlink" title="指针和对象小结"></a>指针和对象小结</h3><ul>
<li><p>使用常规表示法来声明指向对象的指针 – <code>String* gla;</code></p>
</li>
<li><p>可以将指针初始化为指向已有的对象 – <code>String* first = &amp;saying[0];</code></p>
</li>
<li><p>可以使用new来初始化指针，这将创建一个新的对象 – <code>String* favorite = new String(sayings[choice])</code></p>
</li>
<li><p>对类使用new将调用相应的类构造函数来初始化新创建的对象</p>
</li>
<li><p>可以使用<code>-&gt;</code>运算符通过指针访问类方法 – <code>shortest-&gt;length()</code></p>
</li>
<li><p>可以对对象指针应用解除引用运算符(<code>*</code>)来获得对象 – <code>first = &amp;saying[i];</code></p>
</li>
</ul>
<h2 id="第十三章-类继承"><a href="#第十三章-类继承" class="headerlink" title="第十三章 类继承"></a>第十三章 类继承</h2><ul>
<li><p>希望同一个方法在派生类和基类中的行为是不同的。换句话来说，方法的行为应该取决于调用方法的对象。这种较复杂的行为称为多态–具有多种形态，即同一个方法的行为随上下文而异。</p>
</li>
<li><p>有两种重要的机制可用于实现多态公有继承：</p>
<ul>
<li>在派生类中重新定义基类的方法</li>
<li>使用虚方法</li>
</ul>
</li>
<li><p><strong>注意</strong> </p>
<ul>
<li>如果要在派生类中重新定义基类的方法，通常<strong>应将基类方法声明为虚的</strong>。这样，程序将根据对象类型而不是引用或指针的类型来选择方法版本。</li>
<li>为基类声明一个虚析构函数也是一种惯例</li>
</ul>
</li>
</ul>
<h3 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a>静态联编和动态联编</h3><ul>
<li><p>程序调用函数时，将使用哪一个可执行代码块？  编译器负责回答这个问题</p>
</li>
<li><p>将源代码中的函数调用解释为执行特定的函数代码块被称为<strong>函数名联编(binding)</strong></p>
</li>
<li><p>在C语言中，这非常简单，因为每个函数名都对应一个不同的函数</p>
</li>
<li><p>在C++中，由于函数重载的远古，这项任务更复杂。编译器必须查看函数参数及函数名才能确定使用哪一个函数。</p>
</li>
<li><p>C&#x2F;++编译器可以在编译过程完成这种联编。在编译过程中进行联编被称为<strong>静态联编(static binding)，又称为早期联编(early binding)</strong></p>
</li>
<li><p>然而，虚函数使这项工作变得更困难。因为虚函数使得 – 使用哪一个函数是不能在编译时确定的。因为编译器不知道用户将选择那种类型的对象，所以，编译器必须生成能够在程序运行时选择正确的虚函数的代码，这被称为<strong>动态联编(dynamic binding)，又称为晚期联编(late binding)</strong></p>
</li>
<li><p>将派生类引用或指针转转为基类引用或指针 被称为<strong>向上强制转换(upcasting)</strong>,这使公有继承不需要进行显式类型转换。</p>
</li>
<li><p>相反的过程 – 将基类指针或引用转换为派生类指针或引用 被称为<strong>向下强制转换(downcasting)</strong></p>
</li>
<li><p>编译器对非虚方法使用静态联编</p>
</li>
<li><p>为什么有两种类型的联编以及为什么默认为静态联编？ – 效率和概念模型</p>
</li>
<li><p>效率</p>
<ul>
<li>为了使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，这增加了额外的处理开销</li>
<li>C++的指导原则之一是 – 不要为不使用的特性付出代价（内存或处理时间）。仅当程序设计确实需要虚函数时，才适用它们</li>
</ul>
</li>
<li><p>虚函数的工作原理</p>
<ol>
<li>通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表(virtual function table, vtbl)。</li>
<li>虚函数表中存储了为类对象进行声明的虚函数的地址。</li>
</ol>
<ul>
<li>例如，基类对象包含了一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也将被添加到vtbl中</li>
<li>调用虚函数时，程序将查看存储在对象中的vtbl地址，然后转向相应的函数地址表。如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个函数地址，并执行具有该地址的函数。如果使用类声明中的第三个虚函数，程序将使用地址为数组中第三个元素的函数。</li>
</ul>
</li>
<li><p>总之，使用虚函数时，在内存和执行速度方面有一定的成本，包括</p>
<ul>
<li>每个对象都将增大，增大量为存储地址的空间</li>
<li>对于每个类，编译器都要创建一个虚函数地址表（数组)</li>
<li>对于每个函数调用，都需要执行一项额外的操作，即在表中查找地址</li>
</ul>
</li>
<li><p><strong>有关虚函数注意事项</strong></p>
<ul>
<li>在基类方法的声明中使用关键字<code>virtual</code>可以使该方法在基类以及所有的派生类（包括从派生类派生出来的类）中是虚的</li>
<li>如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要。因为这样基类指针或引用可以指向派生类对象</li>
<li>如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。</li>
</ul>
</li>
<li><p>当基类和派生类都采用动态内存分配时，派生类的析构函数，复制构造函数，赋值运算符都必须使用相应的基类方法来处理基类元素。</p>
</li>
<li><p>这种要求是要通过三种不同的方式来满足的。对于析构函数，这是自动完成的；对于构造函数，这是通过在初始化成员列表中调用基类的复制构造函数来完成的；如果不这样做，将自动调用基类的默认构造函数。对于赋值运算符，这是通过使用作用域解析运算符显式地调用基类的赋值运算符来完成的。</p>
</li>
</ul>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul>
<li>继承，通过使用已有的类（基类）定义新的类（派生类），使得能够根据需要修改编程代码。</li>
</ul>
<h2 id="C-中的代码重用"><a href="#C-中的代码重用" class="headerlink" title="C++中的代码重用"></a>C++中的代码重用</h2><ul>
<li><p>C++的一个主要目标是促进代码重用。公有继承是实现这种目标的机制之一，但并不是唯一的机制。</p>
</li>
<li><p>方法之一是使用这样的类成员–本身是另一个类的对象。这种方法称为包含(containment), 组合(composition)或层次化(layering)</p>
</li>
<li><p>另一种方法是使用私有或保护继承。通常，包含，私有继承和保护继承用于实现<code>has-a</code>关系，即新的类将包含另一个类的对象。</p>
</li>
<li><p>C++和约束</p>
<ul>
<li>C++包含让程序员能够限制程序结构的特性–使用<code>explicit</code>防止单参数构造函数的隐式转换，使用const限制方法修改数据，等等。</li>
<li>这样做的根本原因是：**在编译阶段出现错误优于在运行阶段出现错误</li>
</ul>
</li>
<li><p>使用包含还是私有继承？</p>
<ul>
<li>由于即可以使用包含，也可以使用私有继承来建立<code>has-a</code>关系，那么应该使用那种方式？</li>
<li>通常，应该使用包含来建立<code>has-a</code>关系；</li>
<li>如果新类需要访问原有类的保护成员，或者需要重新定义虚函数，则应该使用私有继承</li>
</ul>
</li>
</ul>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><ul>
<li><code>template &lt;class Type&gt;</code></li>
<li>关键字<code>template</code>告诉编译器，将要定义一个模板。尖括号中的内容相当于函数的参数列表。可以把关键字class看作是变量的类型名，该变量接受类型作为其值，把<code>Type</code>看作是该变量的名称。</li>
<li>这里使用class并不意味着<code>Type</code>必须是一个类；而只是表明<code>Type</code>是一个通用的类型说明符，在使用模板时，将使用实际的类型替换它。较新的C++实现<strong>允许在这种情况下使用不太容易混淆的关键字<code>typename</code>代替class</strong><ul>
<li><code>template &lt;typename Type&gt;  // newer choice</code></li>
</ul>
</li>
<li>可以使用自己的泛型名代替<code>Type</code>，其命名规则与其他标识符相同。**当前流行的选项包括<code>T</code>和<code>Type</code>。</li>
<li>当模板被调用时，<code>Type</code>将被具体的类型值（例如int， string）取代。在模板定义中，可以使用泛型名来表示要存储在栈中的类型。</li>
</ul>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>C++提供了几种重用代码的手段</p>
</li>
<li><p>公有继承能够建立<code>is-a</code>关系，这样派生类可以重用基类的代码</p>
</li>
<li><p>私有继承和保护继承也使得能够重用基类的代码，但是建立的是<code>has-a</code>关系</p>
<ul>
<li>使用私有继承时，基类的公有成员和保护成员将称为派生类的私有成员</li>
<li>使用保护继承时，基类的公有成员和保护成员将成为派生类的保护成员</li>
</ul>
</li>
<li><p><strong>无论使用哪一种继承，基类的公有接口都将成为派生类的内部接口，这有时候被称为继承实现，但并不继承接口，因为派生类对象不能显式地使用基类的接口。因此，不能将派生对象看作是一种基类对象。由于这个原因，在不进行显式类型转换的情况下，基类指针或引用将不能指向派生类对象。</strong></p>
</li>
<li><p>还可以通过开发包含对象成员的类来重用类代码，这种方法被称为包含，层次化或组合。</p>
</li>
<li><p>它建立的是<code>has-a</code>关系。与私有继承和保护继承相比，包含更容易实现和使用，所以通常优先采用这种方式。</p>
</li>
<li><p>然而，私有继承和保护继承比包含有一些不同的功能。例如，继承允许派生类访问基类的保护成员；还允许派生类重新定义从基类那里继承的徐函数。因为包含不是继承，所以通过包含来重用类代码时，不能使用这些功能</p>
</li>
<li><p>另一个方面，如果需要使用某个类的几个对象，则用包含更加合适。</p>
</li>
<li><p>所有这些机制的目的都是为了让程序员能够重用经过测试的代码，而不用手工复制它们，这样可以简化编程工作，提供程序的可靠性。</p>
</li>
</ul>
<h2 id="第十五章-友元，异常和其他"><a href="#第十五章-友元，异常和其他" class="headerlink" title="第十五章 友元，异常和其他"></a>第十五章 友元，异常和其他</h2><ul>
<li>在C++中，可以将类声明放在另一个类中。在另一个类中声明的类称为嵌套类(nested class)，它通过提供新的类型类作用域来避免名称混乱。</li>
<li>包含的类的成员函数可以创建和使用被嵌套类的对象；而仅当声明位于公有部分，才能在包含类的外面使用嵌套类，而且必须使用作用域解析运算符。</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul>
<li>如果其中一个参数是另一个参数的负值，则调用abort（）函数。Abort（）的函数原型位于头文件<code>cstdlib</code>中，其典型实现是向标准错误流(即<code>cerr</code>使用的错误流)发送消息<code>abnormal program termination（程序异常终止）</code>，然后终止程序。它还返回一个随实现而异的值，告诉操作系统（如果程序是由另一个程序调用的，则告诉父进程）处理失败。</li>
<li><code>abort()</code>是否刷新文件缓冲区（用于存储读写到文件中的数据的内存区域）取决于实现。</li>
</ul>
<h3 id="返回错误码"><a href="#返回错误码" class="headerlink" title="返回错误码"></a>返回错误码</h3><ul>
<li>一种比异常终止更灵活的方法是，使用函数的返回值来指出问题</li>
</ul>
<h3 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h3><ul>
<li><p>C++异常是对程序运行过程中发生的异常情况的一种响应。</p>
</li>
<li><p>异常提供了将控制权从程序的一个部分传递到另一个部分的途径。</p>
</li>
<li><p>对异常的处理有3个组成部分：</p>
<ul>
<li>引发异常；</li>
<li>使用处理程序捕获异常</li>
<li>使用try块</li>
</ul>
</li>
<li><p>程序在出现问题时将引发异常。**<code>throw</code>语句实际上是跳转，即命令程序跳到另一条语句**。</p>
</li>
<li><p><code>throw</code>关键字表示引发异常，紧随其后的值（例如字符串或对象）指出了异常的特征。</p>
</li>
<li><p>程序使用异常处理程序(<code>exception handler</code>)来捕获异常，异常处理程序位于要处理问题的程序中。</p>
</li>
<li><p><code>catch</code>关键字表示捕获异常。处理程序以关键字<code>catch</code>开头，随后是位于括号中的类型声明，它指出了异常处理程序要响应的异常类型；然后是一个用花括号括起来的代码块，指出要采取的措施。</p>
</li>
<li><p><code>catch</code>关键字和异常类型用作标签，指出当异常被引发时，程序应该跳到这个位置执行。异常处理程序也被称为<code>catch</code>块</p>
</li>
<li><p><code>try</code>块标识其中特定的异常可能被激活的代码块，它后面跟一个或多个<code>catch</code>块。<code>try</code>块是由关键字<code>try</code>指示的，关键字<code>try</code>的后面是一个由花括号括起来的代码块，表明需要注意这些代码引发的异常。</p>
</li>
<li><p>通常，引发异常的函数将传递一个对象。这样做的重要优点之一是，可以使用不同的异常类型来区分不同的函数在不同的情况下引发的异常。</p>
</li>
<li><p>另外，对象可以携带信息，程序员可以根据这些信息来确定引发异常的原因。同时，<code>catch</code>块可以根据这些信息来决定采取什么样的措施</p>
</li>
</ul>
<h3 id="栈解退"><a href="#栈解退" class="headerlink" title="栈解退"></a>栈解退</h3><ul>
<li><p>C++通常是如何处理函数调用和返回的。</p>
</li>
<li><p>C++通常通过将信息放在栈中来处理函数调用。具体地说，程序将调用函数的指令的地址（返回地址）放到栈中。当被调用的函数执行完毕后，程序将使用该地址来确定从哪里开始继续执行。另外，函数调用将函数参数放到栈中。在栈中，这些函数参数都被视为自动变量。如果被调用的函数创建了新的自动变量，则这些变量也将被添加到栈中。如果被调用的函数调用了另一个函数，则后者的信息将被添加到栈中，依次类推。</p>
</li>
<li><p>当函数结束时，程序流程将跳到该函数被调用时存储的地址处，同时栈顶的元素被释放。因此，函数通常都返回到调用它的函数，依次类推，同时每个函数都在结束时释放其自动变量。如果自动变量是类对象，则类的析构函数将被调用。</p>
</li>
<li><p>现在假设函数由于出现异常（而不是由于返回）而终止，则程序也将释放栈中的内存，但不会在释放栈的第一个返回地址后停止，而是继续释放栈，直到找到一个位于<code>try</code>块中的返回地址。随后，控制权将转到块尾的异常处理程序，而不是函数调用后面的第一条语句。这个过程被称为<strong>栈解退</strong></p>
</li>
</ul>
<h2 id="第十六章-string类和标准模板库"><a href="#第十六章-string类和标准模板库" class="headerlink" title="第十六章 string类和标准模板库"></a>第十六章 string类和标准模板库</h2><ul>
<li><p><code>STL</code>提供了一组表示容器，迭代器，函数对象和算法的模板。</p>
</li>
<li><p>容器是一个与数组类似的单元，可以存储若干个值。 STL容器是同质的，即存储的值的类型相同</p>
</li>
<li><p>算法是完成特定任务（如对数组进行排序或在链表中查找特定值）的处方</p>
</li>
<li><p>迭代器能够用来遍历容器的对象，与能够遍历数组的指针类似，是广义指针；</p>
</li>
<li><p>函数对象是类似于函数的对象，可以是类对象或函数指针（包含函数名，因为函数名被用作指针）。</p>
</li>
<li><p>STL使得能够构造各种容器（包括数组，队列和链表）和执行各种操作（包括搜索，排序和随机排列）</p>
</li>
</ul>
<h3 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h3><ul>
<li><p><code>STL</code>是一种泛型编程(<code>generic programming</code>)。面向对象编程关注的编程的数据方面，而泛型编程关注的是算法。它们之间的共同点是抽象和创建可重用代码，但它们的理念绝然不同。</p>
</li>
<li><p>泛型编程旨在编写独立于数据类型的代码。在C++中，完成通用程序的工具是模板。当然，模板使得能够按泛型定义函数或类，而STL通过通用算法更进了一步。模板让这一切成为可能，但必须对元素进行仔细地设计。为了解模板和设计是如何协同工作的，来看一看需要迭代器的原因。</p>
</li>
<li><p><strong>理解迭代器是理解<code>STL</code>的关键所在</strong>。模板使得算法独立于存储的数据类型，而迭代器使得算法独立于使用的容器类型。因此，它们都是STL通用方法的重要组成部分。</p>
</li>
<li><p>泛型编程旨在使用同一个find函数来处理数组，链表或任何其他容器类型。即函数不仅独立于容器中存储的数据类型，而且独立于容器本身的俄数据结构。模板提供了存储在容器中的数据类型的通用表示，因此还需要遍历容器中的值的通用表示，迭代器正是这样的通用表示。</p>
</li>
<li><p>每个容器类(<code>vector list deque等</code>)定义了相应的迭代器类型。对于其中的某个类，迭代器可能是指针；而对于另一个类，则可能是对象。不管实现方式如何，迭代器都将提供所需的操作。</p>
</li>
<li><p>其次，每个容器类都有一个超尾标记，当迭代器递增到超越容器的最后一个值后，这个值将被赋给迭代器。每个容器类都有<code>begin()</code>和<code>end()</code>方法，它们分别返回一个指向容器的第一个元素和超尾位置的迭代器。每个容器都有++操作，让迭代器从指向第一个元素逐步指向超尾位置，从而遍历容器中的每一个元素。</p>
</li>
<li><p>使用容器类时，无需知道其迭代器是如何实现的，也无需知道超尾是如何实现的，而只需要知道它有迭代器，其<code>begin()</code>返回一个指向第一个元素的迭代器，<code>end()</code>返回一个指向超尾位置的迭代器即可。</p>
</li>
<li><p>总结一下<code>STL</code>方法。首先是处理容器的算法，应尽可能通用的术语来表达算法，使之独立于数据类型和容器类型。为使通用算法能够适用于具体情况，应定义能够满足算法需求的迭代器，并把要求加到容器设计上。即基于算法的要求，设计基本迭代器的特征和容器特征。</p>
</li>
</ul>
<h4 id="如何理解迭代？？"><a href="#如何理解迭代？？" class="headerlink" title="如何理解迭代？？"></a>如何理解迭代？？</h4><ul>
<li><p>迭代，是一个重复的过程，每次重复都是基于上一次的结果而继续的，<strong>单纯的重复并不是迭代</strong>，例如，A + B &#x3D;》 E ，生成的过程就是迭代，克隆就不是迭代</p>
</li>
<li><p>迭代器，指的是迭代取值的工具。而涉及到把多个值循环取出来的类型有：列表，字符串，元组，字典，集合，打开的文件对象</p>
</li>
<li><p>实现一个简单的迭代取值（基于索引）的方式，只适用于有索引的数据类型：列表，字符串，字典</p>
</li>
<li><p><strong>为了解决基于索引迭代取值的局限性，就必须提供一种能够不依赖索引的取值方式，这就是迭代</strong></p>
</li>
<li><p>在一个迭代器取值干净的情况下，再对其取值，取不到，必须再调用一次迭代器才能取值</p>
</li>
</ul>
<hr>
<ul>
<li><code>STL</code>定义了五种迭代器，并根据所需要的迭代器类型对算法进行了描述。这五种迭代器分别是输入迭代器，输出迭代器，正向迭代器，双向迭代器和随机访问迭代器。<ul>
<li>输入迭代器 – 被程序用来读取容器中的信息，是单向迭代器，可以递增，但不能倒退</li>
<li>输出迭代器 – 用于将信息从程序传输到容器的迭代器，因此程序的输出就是容器的输入。</li>
<li>正向迭代器 – 每次沿容器向前移动一个元素，并总是按照相同的顺序遍历一系列值</li>
<li>双向迭代器 – 具有正向迭代器的所有特性，同时支持两种（前缀和后缀）递减运算符</li>
<li>随机访问迭代器 – 具有双向迭代器的所有特性，同时添加了支持随机访问的操作和用于对元素进行排序的关系运算符</li>
</ul>
</li>
</ul>
<hr>
<h3 id="概念，改进和模型"><a href="#概念，改进和模型" class="headerlink" title="概念，改进和模型"></a>概念，改进和模型</h3><ul>
<li><p>STL有若干个用C++语言无法表达的特性，例如迭代器种类。因此，虽然可以设计具有正向迭代器特征的类，但不能让编译器将算法限制为只使用这个类。</p>
</li>
<li><p>原因在于，正向迭代器是一系列要求，而不是类型。所设计的迭代器类可以满足这种要求，常规指针也能满足这种要求。</p>
</li>
<li><p>STL算法可以使用任何满足其要求的迭代器实现。STL文献使用术语概念(concept)来描述一系列的要求。因此，存在输入迭代器概念，正向迭代器概念等。</p>
</li>
<li><p><strong>概念，可以具有类似继承的关系</strong>。例如，双向迭代器继承了正向迭代器的功能。然而，不能将C++继承机制用于迭代器。例如，可以将正向迭代器实现为一个类，而将双向迭代器实现为一个常规指针。</p>
</li>
<li><p>因此，对C++而言，这种双向迭代器是一种内置类型，不能从类派生而来。然而，从概念上看，它确实能够继承。有些<code>STL</code>文献使用术语**改进(refinement)**来表示这种概念上的继承，因此，双向迭代器是对正向迭代器概念的一种改进。</p>
</li>
<li><p>**概念的具体实现被称为模型(model)**。因此，指向int的常规指针是一个随机访问迭代器模型，也是一个正向迭代器模型，因为它满足该概念的所有要求。</p>
</li>
</ul>
<hr>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><ul>
<li><p>关联容器(associative container)是对容器概念的另一个改进。关联容器将值与键关联在一起，并使用键来查找值。</p>
</li>
<li><p>关联容器的优点在于，它提供了对元素的快速访问。与序列相似，关联容器也允许插入新元素，但不能指定元素的插入位置。原因是关联容器通常有用于确定数据放置位置的算法，以便能够快速检索信息。</p>
</li>
<li><p>关联容器通常是使用某种树实现的。</p>
</li>
<li><p>STL提供了四种关联容器：<code>set, multiset, map, multimap</code>。前两种是在头文件<code>set</code>中定义的，后两种是在头文件<code>map</code>中定义的</p>
</li>
</ul>
<hr>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><ul>
<li>很多<code>STL</code>算法都是用函数对象 – 也叫函数符(functor)。函数符是可以以函数方式与<code>()</code>结合使用的任意对象。这包括函数名，指向函数的指针和重载了<code>()</code>运算符的类对象(即定义了函数<code>operator()</code>的类)</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>C++提供了一组功能强大的库，这些库提供了很多常见编程问题的解决方案以及简化其他问题的工具。<code>string</code>类为将字符串作为对象来处理提供了一种方便的方法。<code>string</code>类提供了自动内存管理功能以及众多处理字符串的方法和函数</p>
</li>
<li><p>STL是一个容器类模板，迭代器类模板，函数对象模板和算法函数模板的集合，它们的设计是一致的，都是基于泛型编程原则的。算法通过使用模板，从而独立于所存储的对象的类型：通过使用迭代器接口，从而独立于容器的类型。迭代器是广义指针</p>
</li>
<li><p><strong>STL使用术语概念来描述一组要求</strong></p>
</li>
<li><p>有些算法被表示为容器类方法，但大量算法都被表示为通用的，非成员函数，这是通过将迭代器作为容器和算法之间的接口得以实现的</p>
</li>
<li><p>容器和算法都是由其提供或需要的迭代器类型表征的。</p>
</li>
</ul>
<h2 id="第十七章-输入，-输出和文件"><a href="#第十七章-输入，-输出和文件" class="headerlink" title="第十七章 输入， 输出和文件"></a>第十七章 输入， 输出和文件</h2><ul>
<li><p>多数计算机语言的输入和输出是以语言本身为基础实现的。但是C和C++都没有将输入和输出建立在语言中。这两种语言的关键字包括for和if，但不包括与I&#x2F;O有关的内容。C语言最初把I&#x2F;O留给了编译器实现人员。这样做的一个原因是为了让实现人员能够自由的设计I&#x2F;O函数，使之最适合于目标计算机的硬件要求。实际上，多数实现人员都把I&#x2F;O建立在最初为UNIX环境开发的库函数的基础之上。ANSI C 正式承认这个I&#x2F;O软件包时，将其称为标准输入&#x2F;输出包，并将其作为标准C库不可或缺的组成部分。C++也认可这个软件包，因此如果熟悉<code>stdio.h</code>文件中声明的C函数系列，则可以在C++程序中使用它们，较新的实现使用头文件<code>cstdio</code>来支持这些函数。</p>
</li>
<li><p>C++依赖于C++的I&#x2F;O解决方案，而不是C语言的I&#x2F;O解决方案，前者是在头文件<code>iostream</code>中定义一组类</p>
</li>
</ul>
<h3 id="流和缓冲区"><a href="#流和缓冲区" class="headerlink" title="流和缓冲区"></a>流和缓冲区</h3><ul>
<li><p>C++程序把输入和输出看作字节流。输入时，程序从输入流中抽取字节；输出时，程序将字节插入到输出流中。对于面向文本的程序，每个字节代表一个字符，更通俗地说，字节可以构成字符或数值数据的二进制表示。</p>
</li>
<li><p>输入流中的字节可能来自键盘，也可能来自存储设备（例如硬盘）或其他程序。同样，输出流中的字节可以流向屏幕，打印机，存储设备或者其他程序。<strong>流充当了程序和流源或流目标之间的桥梁</strong>。</p>
</li>
<li><p>这使得C++程序可以以相同的方式对待来自键盘的输入和来自文件的输入。C++程序只是检查字节流，而不需要知道字节来自何方。同理，通过使用流，C++程序处理输出的方式将独立于其去向。因此管理输入包含两部：</p>
<ul>
<li>将流和输入去向的程序关联起来</li>
<li>将流和文件连接起来</li>
</ul>
</li>
<li><p>换句话说，输入流需要两个连接，每端各一个。文件端部连接提供了流的来源，程序端连接将流的流出部分转储到程序中（文件端连接可以是文件，也可以是设备）。同样，对输出的管理包括将输出流连接到程序以及将输出目标与流关联起来。</p>
</li>
<li><p>通常，通过使用缓冲区可以更高效地处理输入和输出。</p>
</li>
<li><p>缓冲区，<strong>是用作中介的内存块，它是将信息从设备传输到程序或从程序传输给设备的临时存储工具</strong>。</p>
</li>
<li><p>缓冲区帮忙匹配两种不同的信息传输速率。</p>
</li>
<li><p>输出时，程序首先填满缓冲区，然后把整块数据传输给硬盘，并清空缓冲区，以备下一批输出使用，这被称为刷新缓冲区(flushing the buffer)</p>
</li>
</ul>
<h3 id="文件输入和输出"><a href="#文件输入和输出" class="headerlink" title="文件输入和输出"></a>文件输入和输出</h3><ul>
<li>大多数计算机程序都使用了文件。字处理程序创建文档文件；数据库程序创建和搜索信息文件；编译器读取源代码文件并生成可执行文件。</li>
<li>文件本身是存储在某种设备（磁盘，光盘，软盘或硬盘）上的一系列字节。通常，操作系统管理文件，跟踪它们的位置，大小，创建时间等。</li>
</ul>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><ul>
<li>流，是进出程序的字节流。</li>
<li>缓冲区是内存中的临时存储区域，是程序与文件或其他I&#x2F;O设备之间的桥梁。</li>
<li>信息在缓冲区和文件之间传输时，将使用设备（例如磁盘驱动器）处理效率最高的尺寸以大块数据的方式进行传输。</li>
<li>信息在缓冲区和程序之间传输时，是逐字节传输的。这种方式对于程序中的处理操作更为方便。</li>
<li>C++通过将一个被缓冲流同程序及其输入源相连接来处理输入。同样，C++也通过将一个被缓冲流和程序及其输出目标相连来处理输出。</li>
<li><code>iostream</code>和<code>fstream</code>文件构成了I&#x2F;O类库，该类库定义了大量用于管理流的类。</li>
</ul>
<h2 id="探讨C-新标准"><a href="#探讨C-新标准" class="headerlink" title="探讨C++新标准"></a>探讨C++新标准</h2><ul>
<li><p>如果仔细阅读了本书，则应很好地掌握了C++的规则，然而，这仅仅是学习这种语言的开始，接下来需要学习如何高效地使用该语言，这样的路更长。更好的情况是，工作或学习环境能够接触到优秀的C++代码和程序员。</p>
</li>
<li><p>另外，了解C++后，便可以阅读一些介绍高级主体和面向对象编程的书记，附录H列出了一些这样的资源。</p>
</li>
<li><p>OOP有助于开发大型项目，并提高其可靠性。OOP方法的基本活动之一是发明能够表示正在模拟的情况（被称为问题域(problem domain)）的类。</p>
</li>
<li><p>由于实际问题通常很复杂，因此找到适当的类富有挑战性。创建复杂的系统时，从空白开始通常不可行，最好采用<strong>逐步迭代</strong>的方式。为此，该领域的实践者开发了多种技术和策略。<strong>具体地说，重要的是在分析和设计阶段完成尽可能多的迭代工作，而不要不断地修改实际代码</strong>。</p>
</li>
<li><p>除了加深对C++的总体理解外，还可能需要学习特定的类库</p>
</li>
</ul>
<h2 id="附录H"><a href="#附录H" class="headerlink" title="附录H"></a>附录H</h2><ul>
<li><p>C++常见问题解答，第二版 – Cline, Marshall, Greg Lomow and Mike Girou. C++FAQ, Second Edition</p>
</li>
<li><p>C++标准库教程和参考手册 – Josuttis, Nicolai M. The C++ Standard Library:A Tutorial and Reference</p>
</li>
<li><p>Meyers, Scott. Effective C++:55 Specific Ways to Improve Your Programs and Designs, Third Edition.</p>
<ul>
<li>本书针对的是了解C++的程序员，提供了55条规定和指南。其中一些是技术性的，例如解释何时应该定义复制构造函数和赋值运算符；其他一些更为通用，例如对<code>is-a</code> <code>has-a</code>关系的讨论</li>
</ul>
</li>
<li><p>Stroustrup,Bjarne. The C++ Programming Language. Third Edition. </p>
</li>
<li><p><code>http://webstore.ansi.org</code></p>
</li>
<li><p><code>www.iso.org</code></p>
</li>
<li><p><code>http://www.parashift.com/C++-faq-lite</code></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
