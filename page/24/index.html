<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/24/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/24/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_42_semaphore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_42_semaphore/" class="post-title-link" itemprop="url">C++_10_42_semaphore</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <semaphore>标准库 详解</li>
</ul>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <semaphore>标准库 详解</h2><p>在C++20标准中引入了 <code>&lt;semaphore&gt;</code> 头文件，提供了信号量（Semaphore）的标准库实现。信号量是一种经典的同步原语，用于控制对共享资源的访问。</p>
<h3 id="创建信号量"><a href="#创建信号量" class="headerlink" title="创建信号量"></a>创建信号量</h3><p>使用 <code>std::counting_semaphore</code> 来创建一个计数信号量，或者使用 <code>std::binary_semaphore</code> 来创建一个二进制信号量。计数信号量允许指定一个初始计数值，而二进制信号量的初始状态是锁定的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::counting_semaphore</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::counting_semaphore</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::counting_semaphore</span><br><span class="line"></span><br><span class="line">### 使用计数信号量</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::counting_semaphore&lt;<span class="type">int</span>&gt; <span class="title">mySemaphore</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 创建一个初始计数值为1的计数信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    mySemaphore.<span class="built_in">acquire</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// Simulate some work</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    mySemaphore.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(worker, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用二进制信号量"><a href="#使用二进制信号量" class="headerlink" title="使用二进制信号量"></a>使用二进制信号量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::binary_semaphore <span class="title">mySemaphore</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 创建一个初始状态为1的二进制信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    mySemaphore.<span class="built_in">acquire</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// Simulate some work</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    mySemaphore.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(worker, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两种信号量，一种是计数信号量，另一种是二进制信号量。计数信号量允许多个线程同时访问共享资源，而二进制信号量一次只允许一个线程访问共享资源。</p>
<p>标准库的信号量实现提供了一个简单而强大的工具，用于管理多线程环境中的资源访问。</p>
<h2 id="C-std-semaphore-详解"><a href="#C-std-semaphore-详解" class="headerlink" title="C++ std::semaphore 详解"></a>C++ std::semaphore 详解</h2><p>在C++20中，标准库引入了信号量 (<code>std::semaphore</code>)。信号量是一种经典的同步原语，用于控制多个线程对共享资源的访问。让我们详细了解一下 <code>std::semaphore</code>：</p>
<h3 id="创建信号量-1"><a href="#创建信号量-1" class="headerlink" title="创建信号量"></a>创建信号量</h3><p>你可以使用 <code>std::semaphore</code> 的构造函数来创建一个信号量。构造函数需要一个参数，即初始的信号量计数值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::semaphore <span class="title">mySemaphore</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 创建一个初始计数值为1的信号量</span></span><br></pre></td></tr></table></figure>

<h3 id="P-操作（等待）"><a href="#P-操作（等待）" class="headerlink" title="P 操作（等待）"></a>P 操作（等待）</h3><p>当一个线程想要访问共享资源时，它必须执行 P 操作，也称为等待操作。如果信号量的计数值大于 0，则计数值减 1，线程继续执行。如果计数值为 0，则线程被阻塞，直到有其他线程执行 V 操作（释放）来增加计数值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mySemaphore.<span class="built_in">acquire</span>(); <span class="comment">// 等待（等同于 P 操作）</span></span><br></pre></td></tr></table></figure>

<h3 id="V-操作（释放）"><a href="#V-操作（释放）" class="headerlink" title="V 操作（释放）"></a>V 操作（释放）</h3><p>当一个线程完成对共享资源的访问时，它执行 V 操作，也称为释放操作。这会增加信号量的计数值，并唤醒等待的线程（如果有的话）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mySemaphore.<span class="built_in">release</span>(); <span class="comment">// 释放（等同于 V 操作）</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::semaphore <span class="title">mySemaphore</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 创建一个初始计数值为1的信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    mySemaphore.<span class="built_in">acquire</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// Simulate some work</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    mySemaphore.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(worker, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，两个线程共享一个信号量 <code>mySemaphore</code>。只有一个线程能够获得信号量，另一个线程必须等待，直到第一个线程释放信号量。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>如果信号量的计数值小于0，<code>acquire()</code> 将会阻塞当前线程。</li>
<li><code>release()</code> 会递增信号量的计数值，并唤醒一个等待的线程（如果有）。</li>
<li>使用信号量时，要注意正确地保证计数值的增减，以免造成死锁或者资源泄漏。</li>
</ul>
<p>通过 <code>std::semaphore</code>，C++标准库提供了一种简单而强大的机制来处理多线程间的同步问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_5_string/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_5_string/" class="post-title-link" itemprop="url">C++_10_5_string</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><string>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++  标准库"></a>C++ <string> 标准库</h2><p>C++ 标准库中的 <code>&lt;string&gt;</code> 头文件提供了许多操作字符串的功能，包括创建、操作、处理和管理字符串。使用这个头文件，可以方便地使用字符串并执行各种操作，例如连接字符串、查找子串、截取部分字符串等。</p>
<p>以下是 <code>&lt;string&gt;</code> 标准库中一些常用的类和函数：</p>
<h3 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h3><ul>
<li><strong><code>std::string</code></strong>: 提供了一个可变长度的字符序列，支持字符串的各种操作和方法，如插入、删除、查找、替换等。</li>
</ul>
<h3 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h3><ul>
<li><strong><code>std::to_string()</code></strong>: 将基本数据类型转换为对应的字符串。</li>
<li><strong><code>std::stoi()</code>, <code>std::stol()</code>, <code>std::stoll()</code>, <code>std::stof()</code>, <code>std::stod()</code>, <code>std::stold()</code></strong>: 将字符串转换为对应的数值类型。</li>
<li><strong><code>std::getline()</code></strong>: 从输入流中读取一行数据到字符串中。</li>
</ul>
<h3 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h3><ul>
<li><strong><code>size()</code>, <code>length()</code></strong>: 返回字符串的长度。</li>
<li><strong><code>append()</code>, <code>+=</code></strong>: 在字符串末尾追加内容。</li>
<li><strong><code>insert()</code>, <code>erase()</code>, <code>replace()</code></strong>: 插入、删除、替换子串。</li>
<li><strong><code>substr()</code>, <code>find()</code>, <code>rfind()</code></strong>: 提取子串、查找子串的位置。</li>
</ul>
<h3 id="字符串比较和转换"><a href="#字符串比较和转换" class="headerlink" title="字符串比较和转换"></a>字符串比较和转换</h3><ul>
<li><strong><code>compare()</code></strong>: 比较字符串。</li>
<li><strong><code>toupper()</code>, <code>tolower()</code></strong>: 转换为大写或小写。</li>
</ul>
<h3 id="字符串查询和搜索"><a href="#字符串查询和搜索" class="headerlink" title="字符串查询和搜索"></a>字符串查询和搜索</h3><ul>
<li><strong><code>find()</code>, <code>rfind()</code>, <code>find_first_of()</code>, <code>find_last_of()</code>, <code>find_first_not_of()</code>, <code>find_last_not_of()</code></strong>: 查找字符串中特定子串或字符的位置。</li>
</ul>
<h3 id="其他实用函数"><a href="#其他实用函数" class="headerlink" title="其他实用函数"></a>其他实用函数</h3><ul>
<li><strong><code>c_str()</code>, <code>data()</code></strong>: 返回以 null 结尾的 C 风格字符串的指针。</li>
<li><strong><code>empty()</code>, <code>clear()</code>, <code>reserve()</code>, <code>shrink_to_fit()</code></strong>: 管理字符串的空间和大小。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;world!&quot;</span>; <span class="comment">// 连接字符串</span></span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Length of str: &quot;</span> &lt;&lt; str.<span class="built_in">length</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找子串</span></span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">find</span>(<span class="string">&quot;world&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Substring &#x27;world&#x27; found at position: &quot;</span> &lt;&lt; str.<span class="built_in">find</span>(<span class="string">&quot;world&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取子串</span></span><br><span class="line">    std::string sub = str.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Substring: &quot;</span> &lt;&lt; sub &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码演示了一些常见的字符串操作，包括字符串连接、长度获取、查找子串位置、提取子串等。 <code>&lt;string&gt;</code> 头文件提供了丰富的功能，用于处理字符串以及执行各种字符串操作。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <string>标准库 详解</h2><p>C++ 标准库中的 <code>&lt;string&gt;</code> 头文件提供了丰富的字符串操作功能，使得在程序中处理字符串变得更加方便和灵活。以下是 <code>&lt;string&gt;</code> 标准库中一些常用的类和函数的详细解释：</p>
<h3 id="std-string-类"><a href="#std-string-类" class="headerlink" title="std::string 类"></a><code>std::string</code> 类</h3><p><code>std::string</code> 是 C++ 标准库中表示字符串的类。它提供了一系列的方法来操作和管理字符串。这些方法包括：</p>
<ul>
<li><p><strong>构造函数</strong>：<code>std::string</code> 提供了多种构造函数，允许你用不同的方式初始化字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str1;                 <span class="comment">// 初始化为空字符串</span></span><br><span class="line">std::string str2 = <span class="string">&quot;Hello&quot;</span>;       <span class="comment">// 用 C 风格字符串初始化</span></span><br><span class="line"><span class="function">std::string <span class="title">str3</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;         <span class="comment">// 初始化为重复字符的字符串，&quot;aaaaa&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>size()</code> 和 <code>length()</code>**：返回字符串的长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Length of str: &quot;</span> &lt;&lt; str.<span class="built_in">length</span>() &lt;&lt; std::endl; <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串连接</strong>：可以使用 <code>+</code> 运算符或 <code>append()</code> 方法来连接字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">std::string str2 = <span class="string">&quot;world!&quot;</span>;</span><br><span class="line">std::string result = str1 + str2; <span class="comment">// 使用 + 运算符</span></span><br><span class="line">str<span class="number">1.</span><span class="built_in">append</span>(str2);                <span class="comment">// 使用 append() 方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串比较</strong>：使用 <code>compare()</code> 方法进行字符串的比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">std::string str2 = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line"><span class="type">int</span> result = str<span class="number">1.</span><span class="built_in">compare</span>(str2);  <span class="comment">// 返回值 &lt; 0 表示 str1 小于 str2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提取子串</strong>：使用 <code>substr()</code> 方法提取子串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">std::string sub = str.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">5</span>); <span class="comment">// 提取从位置 7 开始的长度为 5 的子串 &quot;world&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查找子串</strong>：使用 <code>find()</code> 方法查找子串的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">&quot;world&quot;</span>); <span class="comment">// 查找子串 &quot;world&quot; 的位置，返回 7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转换为 C 风格字符串</strong>：可以使用 <code>c_str()</code> 方法将 <code>std::string</code> 转换为以 null 结尾的 C 风格字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>(); <span class="comment">// 返回以 null 结尾的 C 风格字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>其他方法</strong>：还有很多其他方法，如 <code>insert()</code> 插入子串、<code>erase()</code> 删除子串、<code>replace()</code> 替换子串等。</p>
</li>
</ul>
<h3 id="其他函数和功能"><a href="#其他函数和功能" class="headerlink" title="其他函数和功能"></a>其他函数和功能</h3><ul>
<li><p>**<code>std::to_string()</code>**：将数值转换为对应的字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">std::string str = std::<span class="built_in">to_string</span>(num); <span class="comment">// 将整数转换为字符串 &quot;123&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串流</strong>：<code>std::stringstream</code> 可以用于字符串和其他数据类型之间的转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; num;               <span class="comment">// 将整数写入字符串流</span></span><br><span class="line">std::string str = ss.<span class="built_in">str</span>(); <span class="comment">// 从字符串流中获取字符串 &quot;123&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>这些只是 <code>&lt;string&gt;</code> 标准库中一部分功能，该库还提供了更多用于字符串处理和操作的功能。使用这些功能，可以更方便地对字符串进行操作、处理和管理。</p>
<h2 id="C-标准库-常用函数"><a href="#C-标准库-常用函数" class="headerlink" title="C++ 标准库 常用函数"></a>C++ <string>标准库 常用函数</h2><p>C++ 标准库 <code>&lt;string&gt;</code> 中提供了许多常用的函数，用于处理和操作字符串。以下是一些常用的函数及其简要说明：</p>
<h3 id="字符串长度和容量"><a href="#字符串长度和容量" class="headerlink" title="字符串长度和容量"></a>字符串长度和容量</h3><ul>
<li><strong><code>size()</code> 和 <code>length()</code></strong>: 返回字符串的长度。</li>
<li><strong><code>capacity()</code></strong>: 返回字符串当前分配的存储容量。</li>
</ul>
<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><ul>
<li><strong><code>append()</code></strong>: 在字符串末尾添加内容。</li>
<li><strong><code>insert()</code></strong>: 在指定位置插入内容。</li>
<li><strong><code>erase()</code></strong>: 从字符串中删除指定范围的内容。</li>
<li><strong><code>replace()</code></strong>: 替换指定范围的内容为另一个字符串。</li>
<li><strong><code>substr()</code></strong>: 提取子串。</li>
<li><strong><code>swap()</code></strong>: 交换两个字符串的内容。</li>
</ul>
<h3 id="字符串搜索和查找"><a href="#字符串搜索和查找" class="headerlink" title="字符串搜索和查找"></a>字符串搜索和查找</h3><ul>
<li><strong><code>find()</code> 和 <code>rfind()</code></strong>: 查找子串的位置，<code>find()</code> 从前往后找，<code>rfind()</code> 从后往前找。</li>
<li><strong><code>find_first_of()</code> 和 <code>find_last_of()</code></strong>: 在字符串中查找字符序列中任意字符的第一个&#x2F;最后一个匹配位置。</li>
<li><strong><code>find_first_not_of()</code> 和 <code>find_last_not_of()</code></strong>: 查找字符串中第一个&#x2F;最后一个不在指定字符序列中的字符位置。</li>
</ul>
<h3 id="字符串比较和处理"><a href="#字符串比较和处理" class="headerlink" title="字符串比较和处理"></a>字符串比较和处理</h3><ul>
<li><strong><code>compare()</code></strong>: 比较两个字符串的大小。</li>
<li><strong><code>tolower()</code> 和 <code>toupper()</code></strong>: 将字符串转换为小写或大写。</li>
<li><strong><code>std::stoi()</code>, <code>std::stol()</code>, <code>std::stoll()</code>, <code>std::stof()</code>, <code>std::stod()</code>, <code>std::stold()</code></strong>: 将字符串转换为对应的数值类型。</li>
</ul>
<h3 id="C-风格字符串处理"><a href="#C-风格字符串处理" class="headerlink" title="C 风格字符串处理"></a>C 风格字符串处理</h3><ul>
<li><strong><code>c_str()</code></strong>: 返回以 null 结尾的 C 风格字符串的指针。</li>
<li><strong><code>data()</code></strong>: 返回指向字符串缓冲区的指针。</li>
</ul>
<h3 id="字符串空间管理"><a href="#字符串空间管理" class="headerlink" title="字符串空间管理"></a>字符串空间管理</h3><ul>
<li><strong><code>reserve()</code></strong>: 设置字符串的预留空间。</li>
<li><strong><code>shrink_to_fit()</code></strong>: 请求释放未使用的内存空间，将容器的容量减小到与其大小相匹配。</li>
</ul>
<h3 id="其他实用函数-1"><a href="#其他实用函数-1" class="headerlink" title="其他实用函数"></a>其他实用函数</h3><ul>
<li><strong><code>std::getline()</code></strong>: 从输入流中读取一行数据到字符串中。</li>
<li><strong><code>std::to_string()</code></strong>: 将数值转换为对应的字符串。</li>
</ul>
<p>这些函数提供了对字符串进行各种操作和处理的功能，可以轻松地执行字符串的连接、查找、替换、截取等操作，以及对字符串的大小、长度、容量进行管理。</p>
<h2 id="std-string-size"><a href="#std-string-size" class="headerlink" title="std::string::size()"></a>std::string::size()</h2><p><code>std::string::size()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数，用于获取字符串的长度，即字符的个数。</p>
<p>这个函数返回一个 <code>size_t</code> 类型的无符号整数，代表字符串中字符的数量。这个字符数量不包括字符串末尾的 null 终止符。</p>
<p>示例用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> len = str.<span class="built_in">size</span>(); <span class="comment">// 获取字符串的长度</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符串长度为: &quot;</span> &lt;&lt; len &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str.size()</code> 返回的值将是字符串 “Hello, world!” 中字符的总数，包括逗号、空格和感叹号在内。</p>
<h2 id="std-string-length"><a href="#std-string-length" class="headerlink" title="std::string::length()"></a>std::string::length()</h2><p><code>std::string::length()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，与 <code>size()</code> 函数类似，用于获取字符串的长度，即字符的个数。</p>
<p>这两个函数 <code>size()</code> 和 <code>length()</code> 在 <code>std::string</code> 类中是等价的，都用于返回字符串中字符的数量，不包括末尾的空字符（null terminator）。</p>
<p>示例用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> len = str.<span class="built_in">length</span>(); <span class="comment">// 或者使用 str.size() 获取字符串的长度</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符串长度为: &quot;</span> &lt;&lt; len &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str.length()</code> 返回的值将是字符串 “Hello, world!” 中字符的总数，包括逗号、空格和感叹号在内。通常来说，<code>length()</code> 和 <code>size()</code> 都可用于获取字符串的长度，并且在 <code>std::string</code> 类中它们的功能是一样的。</p>
<h2 id="std-string-append"><a href="#std-string-append" class="headerlink" title="std::string::append()"></a>std::string::append()</h2><p><code>std::string::append()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于将指定的内容追加到字符串的末尾。</p>
<p>这个函数可以接受多种类型的参数来追加内容，包括：</p>
<ul>
<li>另一个 <code>std::string</code> 对象</li>
<li>字符串的一部分（通过指定位置和长度）</li>
<li>C 风格的字符串</li>
<li>字符或者重复的字符</li>
</ul>
<p>以下是 <code>std::string::append()</code> 函数的几种重载形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>; <span class="comment">// 将另一个字符串追加到末尾</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> pos, <span class="type">size_t</span> len)</span></span>; <span class="comment">// 将字符串的一部分追加到末尾</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">// 将 C 风格的字符串追加到末尾</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>; <span class="comment">// 将指定长度的 C 风格字符串追加到末尾</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">append</span><span class="params">(<span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>; <span class="comment">// 将字符 c 重复追加 n 次到末尾</span></span><br></pre></td></tr></table></figure>

<p>以下是一个简单的示例演示了如何使用 <code>std::string::append()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 追加另一个字符串到末尾</span></span><br><span class="line">    str.<span class="built_in">append</span>(<span class="string">&quot; world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追加字符串的一部分到末尾</span></span><br><span class="line">    std::string anotherStr = <span class="string">&quot; This is a test.&quot;</span>;</span><br><span class="line">    str.<span class="built_in">append</span>(anotherStr, <span class="number">0</span>, <span class="number">11</span>); <span class="comment">// 从另一个字符串的指定位置追加一部分内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追加重复的字符到末尾</span></span><br><span class="line">    str.<span class="built_in">append</span>(<span class="number">3</span>, <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;结果字符串: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::string::append()</code> 函数被用于将不同类型的内容追加到字符串 <code>str</code> 的末尾，包括另一个字符串、另一个字符串的一部分以及重复的字符。最终输出的字符串将是 “Hello world! This is a test.!!!”。</p>
<h2 id="std-string-insert"><a href="#std-string-insert" class="headerlink" title="std::string::insert()"></a>std::string::insert()</h2><p><code>std::string::insert()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于在指定位置插入内容到字符串中。</p>
<p>这个函数允许在字符串的特定位置插入另一个字符串、子串或字符。它的重载版本可以用于不同的插入操作，可以指定要插入的位置和内容。</p>
<p>以下是 <code>std::string::insert()</code> 函数的几种重载形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> std::string&amp; str)</span></span>; <span class="comment">// 在指定位置插入另一个字符串</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> subpos, <span class="type">size_t</span> sublen)</span></span>; <span class="comment">// 在指定位置插入另一个字符串的一部分</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">// 在指定位置插入 C 风格的字符串</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>; <span class="comment">// 在指定位置插入指定长度的 C 风格字符串</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>; <span class="comment">// 在指定位置插入重复的字符</span></span><br></pre></td></tr></table></figure>

<p>以下是一个简单的示例演示了如何使用 <code>std::string::insert()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在指定位置插入另一个字符串</span></span><br><span class="line">    str.<span class="built_in">insert</span>(<span class="number">5</span>, <span class="string">&quot;beautiful &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在指定位置插入重复的字符</span></span><br><span class="line">    str.<span class="built_in">insert</span>(<span class="number">6</span>, <span class="number">3</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;结果字符串: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::string::insert()</code> 函数被用于在字符串 <code>str</code> 的指定位置进行插入操作。首先，在位置 5 插入了另一个字符串 “beautiful “，然后在位置 6 插入了重复的字符 ‘<em>‘。最终输出的字符串将是 “Hello</em> * * beautiful world!”。</p>
<h2 id="std-string-erase"><a href="#std-string-erase" class="headerlink" title="std::string::erase()"></a>std::string::erase()</h2><p><code>std::string::erase()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于从字符串中删除指定位置的字符或一段子串。</p>
<p>这个函数有多个重载版本，允许你指定要删除的位置和要删除的字符数。你可以删除单个字符、一段字符，或者从指定位置开始一直删除到字符串末尾。</p>
<p>以下是 <code>std::string::erase()</code> 函数的几种重载形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">erase</span><span class="params">(<span class="type">size_t</span> pos = <span class="number">0</span>, <span class="type">size_t</span> len = npos)</span></span>; <span class="comment">// 从指定位置开始删除指定数量的字符</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span>; <span class="comment">// 删除指定位置处的字符</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>; <span class="comment">// 删除指定范围内的字符</span></span><br></pre></td></tr></table></figure>

<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, beautiful world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定位置开始的 7 个字符</span></span><br><span class="line">    str.<span class="built_in">erase</span>(<span class="number">7</span>, <span class="number">7</span>); <span class="comment">// 从位置 7 开始，删除 7 个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从迭代器位置开始删除一段字符</span></span><br><span class="line">    std::string::iterator it = str.<span class="built_in">begin</span>() + <span class="number">13</span>;</span><br><span class="line">    str.<span class="built_in">erase</span>(it, str.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;结果字符串: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，首先使用 <code>erase()</code> 函数从位置 7 开始删除了 7 个字符，然后使用迭代器指定的位置开始删除了一段字符，直到字符串的末尾。最终输出的字符串将是 “Hello, “。</p>
<h2 id="std-string-replace"><a href="#std-string-replace" class="headerlink" title="std::string::replace()"></a>std::string::replace()</h2><p><code>std::string::replace()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于替换字符串中的部分内容。</p>
<p>这个函数允许你用另一个字符串、子串或字符序列替换指定位置和长度的内容。你可以选择性地替换指定位置开始的一定数量的字符，也可以替换整个字符串的一部分。</p>
<p>以下是 <code>std::string::replace()</code> 函数的几种重载形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> std::string&amp; str)</span></span>; <span class="comment">// 用另一个字符串替换指定位置和长度的内容</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">replace</span><span class="params">(iterator i1, iterator i2, <span class="type">const</span> std::string&amp; str)</span></span>; <span class="comment">// 用另一个字符串替换指定范围的内容</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> subpos, <span class="type">size_t</span> sublen)</span></span>; <span class="comment">// 用另一个字符串的一部分替换指定位置和长度的内容</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">// 用 C 风格的字符串替换指定位置和长度的内容</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">replace</span><span class="params">(iterator i1, iterator i2, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>; <span class="comment">// 用指定长度的 C 风格字符串替换指定范围的内容</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>; <span class="comment">// 用重复的字符替换指定位置和长度的内容</span></span><br></pre></td></tr></table></figure>

<p>以下是一个示例演示了如何使用 <code>std::string::replace()</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, beautiful world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用另一个字符串替换指定位置和长度的内容</span></span><br><span class="line">    str.<span class="built_in">replace</span>(<span class="number">7</span>, <span class="number">9</span>, <span class="string">&quot;wonderful&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用重复的字符替换指定位置和长度的内容</span></span><br><span class="line">    str.<span class="built_in">replace</span>(<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;结果字符串: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，首先使用 <code>replace()</code> 函数将字符串中位置 7 开始、长度为 9 的部分替换为另一个字符串 “wonderful”，然后用重复的字符 ‘*’ 替换了字符串的前 7 个字符。最终输出的字符串将是 “*******wonderful world!”。</p>
<h2 id="std-string-substr"><a href="#std-string-substr" class="headerlink" title="std::string::substr()"></a>std::string::substr()</h2><p><code>std::string::substr()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于提取字符串的子串。</p>
<p>这个函数接受两个参数，第一个参数是子串的起始位置（索引），第二个参数是子串的长度。如果只提供一个参数，它将从指定位置开始提取直到字符串末尾的所有字符。</p>
<p>以下是 <code>std::string::substr()</code> 函数的形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">substr</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len = npos)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pos</code> 是子串的起始位置（索引），从 0 开始计数。</li>
<li><code>len</code> 是子串的长度，默认值是 <code>npos</code>，表示提取从 <code>pos</code> 开始到字符串末尾的所有字符。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取从索引为 7 开始的子串</span></span><br><span class="line">    std::string sub1 = str.<span class="built_in">substr</span>(<span class="number">7</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子串1: &quot;</span> &lt;&lt; sub1 &lt;&lt; std::endl; <span class="comment">// 输出 &quot;world!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取从索引为 0 开始，长度为 5 的子串</span></span><br><span class="line">    std::string sub2 = str.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子串2: &quot;</span> &lt;&lt; sub2 &lt;&lt; std::endl; <span class="comment">// 输出 &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str.substr(7)</code> 提取了从索引 7 开始到字符串末尾的子串（”world!”），而 <code>str.substr(0, 5)</code> 提取了从索引 0 开始长度为 5 的子串（”Hello”）。</p>
<h2 id="std-string-swap"><a href="#std-string-swap" class="headerlink" title="std::string::swap()"></a>std::string::swap()</h2><p><code>std::string::swap()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一。它用于交换两个 <code>std::string</code> 对象的内容，但是它的作用并不是直接交换字符串的内容，而是交换它们内部指向字符数据的指针，这样可以在不复制字符串的情况下快速交换它们的内容。</p>
<h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(std::string&amp; str)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>: 另一个 <code>std::string</code> 对象，它的内容将与当前对象的内容进行交换。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;交换前:\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2: &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 swap() 函数交换 str1 和 str2 的内容</span></span><br><span class="line">    str<span class="number">1.</span><span class="built_in">swap</span>(str2);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n交换后:\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2: &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">交换前:</span><br><span class="line">str1: Hello</span><br><span class="line">str2: World</span><br><span class="line"></span><br><span class="line">交换后:</span><br><span class="line">str1: World</span><br><span class="line">str2: Hello</span><br></pre></td></tr></table></figure>

<p><code>str1.swap(str2);</code> 执行后，<code>str1</code> 的内容变为 “World”，<code>str2</code> 的内容变为 “Hello”。这种交换方式使得操作更高效，特别是当处理大量字符数据时。</p>
<h2 id="std-string-find"><a href="#std-string-find" class="headerlink" title="std::string::find()"></a>std::string::find()</h2><p><code>std::string::find()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于在字符串中查找指定子串第一次出现的位置。</p>
<h3 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> count)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要查找的子串。</li>
<li><code>s</code>：要查找的 C 风格字符串（以 null 结尾的字符数组）。</li>
<li><code>count</code>：要查找的 C 风格字符串中的字符数。</li>
<li><code>c</code>：要查找的字符。</li>
<li><code>pos</code>：搜索的起始位置，默认为 0。</li>
</ul>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><p>返回第一次出现子串或字符的位置，如果未找到，则返回 <code>std::string::npos</code>（<code>static const size_t npos = -1;</code>）。</p>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找子串 &quot;World&quot;</span></span><br><span class="line">    <span class="type">size_t</span> found = str.<span class="built_in">find</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;子串 &#x27;World&#x27; 第一次出现的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到子串 &#x27;World&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找字符 &#x27;o&#x27; 第一次出现的位置</span></span><br><span class="line">    found = str.<span class="built_in">find</span>(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;字符 &#x27;o&#x27; 第一次出现的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到字符 &#x27;o&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子串 &#x27;World&#x27; 第一次出现的位置：7</span><br><span class="line">字符 &#x27;o&#x27; 第一次出现的位置：4</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>str.find(&quot;World&quot;)</code> 查找子串 “World” 在 <code>str</code> 中第一次出现的位置，返回 7。而 <code>str.find(&#39;o&#39;)</code> 查找字符 ‘o’ 在 <code>str</code> 中第一次出现的位置，返回 4。</p>
<h2 id="std-string-rfind"><a href="#std-string-rfind" class="headerlink" title="std::string::rfind()"></a>std::string::rfind()</h2><p><code>std::string::rfind()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于在字符串中从末尾开始查找指定子串最后一次出现的位置。</p>
<h3 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> count)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-2"><a href="#参数：-2" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要查找的子串。</li>
<li><code>s</code>：要查找的 C 风格字符串（以 null 结尾的字符数组）。</li>
<li><code>count</code>：要查找的 C 风格字符串中的字符数。</li>
<li><code>c</code>：要查找的字符。</li>
<li><code>pos</code>：搜索的起始位置，默认为 <code>std::string::npos</code>，表示从末尾开始搜索。</li>
</ul>
<h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h3><p>返回最后一次出现子串或字符的位置，如果未找到，则返回 <code>std::string::npos</code>（<code>static const size_t npos = -1;</code>）。</p>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World! Hello again.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从末尾开始查找子串 &quot;Hello&quot;</span></span><br><span class="line">    <span class="type">size_t</span> found = str.<span class="built_in">rfind</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;子串 &#x27;Hello&#x27; 最后一次出现的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到子串 &#x27;Hello&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从末尾开始查找字符 &#x27;o&#x27;</span></span><br><span class="line">    found = str.<span class="built_in">rfind</span>(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;字符 &#x27;o&#x27; 最后一次出现的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到字符 &#x27;o&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子串 &#x27;Hello&#x27; 最后一次出现的位置：14</span><br><span class="line">字符 &#x27;o&#x27; 最后一次出现的位置：24</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>str.rfind(&quot;Hello&quot;)</code> 从末尾开始查找子串 “Hello” 在 <code>str</code> 中最后一次出现的位置，返回 14。而 <code>str.rfind(&#39;o&#39;)</code> 从末尾开始查找字符 ‘o’ 在 <code>str</code> 中最后一次出现的位置，返回 24。</p>
<h2 id="std-string-find-first-of"><a href="#std-string-find-first-of" class="headerlink" title="std::string::find_first_of()"></a>std::string::find_first_of()</h2><p><code>std::string::find_first_of()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于在字符串中查找与给定字符序列中任何字符匹配的第一个位置。</p>
<h3 id="函数原型：-3"><a href="#函数原型：-3" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> count)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-3"><a href="#参数：-3" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要查找的字符序列。</li>
<li><code>s</code>：要查找的 C 风格字符串（以 null 结尾的字符数组）。</li>
<li><code>count</code>：要查找的 C 风格字符串中的字符数。</li>
<li><code>c</code>：要查找的字符。</li>
<li><code>pos</code>：搜索的起始位置，默认为 0。</li>
</ul>
<h3 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h3><p>返回第一个与字符序列中任何字符匹配的位置，如果未找到，则返回 <code>std::string::npos</code>（<code>static const size_t npos = -1;</code>）。</p>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个匹配字符序列中任何字符的位置</span></span><br><span class="line">    <span class="type">size_t</span> found = str.<span class="built_in">find_first_of</span>(<span class="string">&quot;aeiou&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第一个匹配元音字母的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到匹配的元音字母&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个匹配字符 &#x27;o&#x27; 的位置</span></span><br><span class="line">    found = str.<span class="built_in">find_first_of</span>(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第一个匹配字符 &#x27;o&#x27; 的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到字符 &#x27;o&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-3"><a href="#输出：-3" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一个匹配元音字母的位置：1</span><br><span class="line">第一个匹配字符 &#x27;o&#x27; 的位置：4</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>str.find_first_of(&quot;aeiou&quot;)</code> 查找字符序列中任何元音字母（’a’、’e’、’i’、’o’、’u’）第一次出现的位置，返回 1。而 <code>str.find_first_of(&#39;o&#39;)</code> 查找字符 ‘o’ 第一次出现的位置，返回 4。</p>
<h2 id="std-string-find-last-of"><a href="#std-string-find-last-of" class="headerlink" title="std::string::find_last_of()"></a>std::string::find_last_of()</h2><p><code>std::string::find_last_of()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于在字符串中查找与给定字符序列中任何字符匹配的最后一个位置。</p>
<h3 id="函数原型：-4"><a href="#函数原型：-4" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> count)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-4"><a href="#参数：-4" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要查找的字符序列。</li>
<li><code>s</code>：要查找的 C 风格字符串（以 null 结尾的字符数组）。</li>
<li><code>count</code>：要查找的 C 风格字符串中的字符数。</li>
<li><code>c</code>：要查找的字符。</li>
<li><code>pos</code>：搜索的起始位置，默认为 <code>std::string::npos</code>，表示从末尾开始搜索。</li>
</ul>
<h3 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a>返回值：</h3><p>返回最后一个与字符序列中任何字符匹配的位置，如果未找到，则返回 <code>std::string::npos</code>（<code>static const size_t npos = -1;</code>）。</p>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最后一个匹配字符序列中任何字符的位置</span></span><br><span class="line">    <span class="type">size_t</span> found = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;aeiou&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;最后一个匹配元音字母的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到匹配的元音字母&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最后一个匹配字符 &#x27;o&#x27; 的位置</span></span><br><span class="line">    found = str.<span class="built_in">find_last_of</span>(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;最后一个匹配字符 &#x27;o&#x27; 的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到字符 &#x27;o&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-4"><a href="#输出：-4" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最后一个匹配元音字母的位置：9</span><br><span class="line">最后一个匹配字符 &#x27;o&#x27; 的位置：8</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>str.find_last_of(&quot;aeiou&quot;)</code> 查找字符序列中任何元音字母（’a’、’e’、’i’、’o’、’u’）最后一次出现的位置，返回 9。而 <code>str.find_last_of(&#39;o&#39;)</code> 查找字符 ‘o’ 最后一次出现的位置，返回 8。</p>
<h2 id="std-string-find-first-not-of"><a href="#std-string-find-first-not-of" class="headerlink" title="std::string::find_first_not_of()"></a>std::string::find_first_not_of()</h2><p><code>std::string::find_first_not_of()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于在字符串中查找第一个不属于给定字符序列的字符位置。</p>
<h3 id="函数原型：-5"><a href="#函数原型：-5" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> count)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-5"><a href="#参数：-5" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要查找的字符序列。</li>
<li><code>s</code>：要查找的 C 风格字符串（以 null 结尾的字符数组）。</li>
<li><code>count</code>：要查找的 C 风格字符串中的字符数。</li>
<li><code>c</code>：要查找的字符。</li>
<li><code>pos</code>：搜索的起始位置，默认为 0。</li>
</ul>
<h3 id="返回值：-4"><a href="#返回值：-4" class="headerlink" title="返回值："></a>返回值：</h3><p>返回第一个不属于字符序列中任何字符的位置，如果未找到，则返回 <code>std::string::npos</code>（<code>static const size_t npos = -1;</code>）。</p>
<h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;   Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个不属于空格字符的位置</span></span><br><span class="line">    <span class="type">size_t</span> found = str.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; \t\n\v\f\r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第一个不属于空白字符的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到不属于空白字符的位置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个不属于字符 &#x27;H&#x27; 的位置</span></span><br><span class="line">    found = str.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第一个不属于字符 &#x27;H&#x27; 的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到不属于字符 &#x27;H&#x27; 的位置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-5"><a href="#输出：-5" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一个不属于空白字符的位置：3</span><br><span class="line">第一个不属于字符 &#x27;H&#x27; 的位置：0</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>str.find_first_not_of(&quot; \t\n\v\f\r&quot;)</code> 查找第一个不属于空白字符（空格、制表符、换行符等）的位置，返回 3。而 <code>str.find_first_not_of(&#39;H&#39;)</code> 查找第一个不属于字符 ‘H’ 的位置，返回 0。</p>
<h2 id="std-string-find-last-not-of"><a href="#std-string-find-last-not-of" class="headerlink" title="std::string::find_last_not_of()"></a>std::string::find_last_not_of()</h2><p><code>std::string::find_last_not_of()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于在字符串中查找最后一个不属于给定字符序列的字符位置。</p>
<h3 id="函数原型：-6"><a href="#函数原型：-6" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> count)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-6"><a href="#参数：-6" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要查找的字符序列。</li>
<li><code>s</code>：要查找的 C 风格字符串（以 null 结尾的字符数组）。</li>
<li><code>count</code>：要查找的 C 风格字符串中的字符数。</li>
<li><code>c</code>：要查找的字符。</li>
<li><code>pos</code>：搜索的起始位置，默认为 <code>std::string::npos</code>，表示从末尾开始搜索。</li>
</ul>
<h3 id="返回值：-5"><a href="#返回值：-5" class="headerlink" title="返回值："></a>返回值：</h3><p>返回最后一个不属于字符序列中任何字符的位置，如果未找到，则返回 <code>std::string::npos</code>（<code>static const size_t npos = -1;</code>）。</p>
<h3 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;   Hello, World!   &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最后一个不属于空格字符的位置</span></span><br><span class="line">    <span class="type">size_t</span> found = str.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; \t\n\v\f\r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;最后一个不属于空白字符的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到不属于空白字符的位置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最后一个不属于字符 &#x27;!&#x27; 的位置</span></span><br><span class="line">    found = str.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;最后一个不属于字符 &#x27;!&#x27; 的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到不属于字符 &#x27;!&#x27; 的位置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-6"><a href="#输出：-6" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最后一个不属于空白字符的位置：14</span><br><span class="line">最后一个不属于字符 &#x27;!&#x27; 的位置：13</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str.find_last_not_of(&quot; \t\n\v\f\r&quot;)</code> 查找最后一个不属于空白字符（空格、制表符、换行符等）的位置，返回 14。而 <code>str.find_last_not_of(&#39;!&#39;)</code> 查找最后一个不属于字符 ‘!’ 的位置，返回 13。</p>
<h2 id="std-string-compare"><a href="#std-string-compare" class="headerlink" title="std::string::compare()"></a>std::string::compare()</h2><p><code>std::string::compare()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于比较两个字符串的大小关系。</p>
<h3 id="函数原型：-7"><a href="#函数原型：-7" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> std::string&amp; str)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> subpos, <span class="type">size_t</span> sublen)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span>* s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-7"><a href="#参数：-7" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要比较的另一个字符串。</li>
<li><code>s</code>：要比较的 C 风格字符串（以 null 结尾的字符数组）。</li>
<li><code>pos</code>：字符串中的起始位置，默认为 0。</li>
<li><code>len</code>：要比较的字符数，默认为 <code>std::string::npos</code>。</li>
<li><code>subpos</code>：子串的起始位置，默认为 0。</li>
<li><code>sublen</code>：子串的字符数，默认为 <code>std::string::npos</code>。</li>
<li><code>n</code>：要比较的字符数。</li>
</ul>
<h3 id="返回值：-6"><a href="#返回值：-6" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回值为负数：表示调用对象小于参数字符串。</li>
<li>返回值为零：表示调用对象等于参数字符串。</li>
<li>返回值为正数：表示调用对象大于参数字符串。</li>
</ul>
<h3 id="示例：-7"><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    std::string str2 = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个字符串</span></span><br><span class="line">    <span class="type">int</span> result = str<span class="number">1.</span><span class="built_in">compare</span>(str2);</span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 小于 str2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 等于 str2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 大于 str2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-7"><a href="#输出：-7" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1 小于 str2</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str1.compare(str2)</code> 比较了两个字符串 <code>str1</code> 和 <code>str2</code>。由于 “apple” 在字典序中小于 “banana”，所以返回值为负数，输出表明 <code>str1</code> 小于 <code>str2</code>。</p>
<h2 id="std-stoi"><a href="#std-stoi" class="headerlink" title="std::stoi()"></a>std::stoi()</h2><p><code>std::stoi()</code> 是 C++ 标准库中 <code>&lt;string&gt;</code> 头文件中提供的函数之一，用于将字符串转换为整数类型（<code>int</code>）。</p>
<h3 id="函数原型：-8"><a href="#函数原型：-8" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stoi</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span>* pos = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-8"><a href="#参数：-8" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要转换为整数的字符串。</li>
<li><code>pos</code>：指向存储第一个无效字符位置的指针，可选参数，默认为 <code>nullptr</code>。</li>
<li><code>base</code>：进制，默认为 10（十进制）。可以是 0 或者介于 2 到 36 之间的值，表示字符序列的进制基数。</li>
</ul>
<h3 id="返回值：-7"><a href="#返回值：-7" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回转换后的整数值。如果转换过程中出现错误，会抛出 <code>std::invalid_argument</code> 或 <code>std::out_of_range</code> 异常。</li>
</ul>
<h3 id="示例：-8"><a href="#示例：-8" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> num = std::<span class="built_in">stoi</span>(str);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换后的整数为: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-8"><a href="#输出：-8" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换后的整数为: 12345</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::stoi()</code> 将字符串 “12345” 转换为整数类型并输出。如果无法转换字符串为整数，例如，当字符串包含非数字字符时，将抛出异常。</p>
<h2 id="std-stol"><a href="#std-stol" class="headerlink" title="std::stol()"></a>std::stol()</h2><p><code>std::stol()</code> 是 C++ 标准库中 <code>&lt;string&gt;</code> 头文件中提供的函数之一，用于将字符串转换为长整型（<code>long</code>）。</p>
<h3 id="函数原型：-9"><a href="#函数原型：-9" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">stol</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span>* pos = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-9"><a href="#参数：-9" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要转换为长整型的字符串。</li>
<li><code>pos</code>：指向存储第一个无效字符位置的指针，可选参数，默认为 <code>nullptr</code>。</li>
<li><code>base</code>：进制，默认为 10（十进制）。可以是 0 或者介于 2 到 36 之间的值，表示字符序列的进制基数。</li>
</ul>
<h3 id="返回值：-8"><a href="#返回值：-8" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回转换后的长整型值。如果转换过程中出现错误，会抛出 <code>std::invalid_argument</code> 或 <code>std::out_of_range</code> 异常。</li>
</ul>
<h3 id="示例：-9"><a href="#示例：-9" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> num = std::<span class="built_in">stol</span>(str);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换后的长整数为: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-9"><a href="#输出：-9" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换后的长整数为: 123456789</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>std::stol()</code> 将字符串 “123456789” 转换为长整数类型并输出。如果无法转换字符串为长整数，例如，当字符串包含非数字字符时，将抛出异常。</p>
<h2 id="std-stoll"><a href="#std-stoll" class="headerlink" title="std::stoll()"></a>std::stoll()</h2><p><code>std::stoll()</code> 是 C++ 标准库中 <code>&lt;string&gt;</code> 头文件中提供的函数之一，用于将字符串转换为长长整型（<code>long long</code>）。</p>
<h3 id="函数原型：-10"><a href="#函数原型：-10" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">stoll</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span>* pos = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-10"><a href="#参数：-10" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要转换为长长整型的字符串。</li>
<li><code>pos</code>：指向存储第一个无效字符位置的指针，可选参数，默认为 <code>nullptr</code>。</li>
<li><code>base</code>：进制，默认为 10（十进制）。可以是 0 或者介于 2 到 36 之间的值，表示字符序列的进制基数。</li>
</ul>
<h3 id="返回值：-9"><a href="#返回值：-9" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回转换后的长长整型值。如果转换过程中出现错误，会抛出 <code>std::invalid_argument</code> 或 <code>std::out_of_range</code> 异常。</li>
</ul>
<h3 id="示例：-10"><a href="#示例：-10" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;1234567890123456789&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num = std::<span class="built_in">stoll</span>(str);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换后的长长整数为: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-10"><a href="#输出：-10" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换后的长长整数为: 1234567890123456789</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>std::stoll()</code> 将字符串 “1234567890123456789” 转换为长长整数类型并输出。如果无法转换字符串为长长整数，例如，当字符串包含非数字字符时，将抛出异常。</p>
<h2 id="std-stof"><a href="#std-stof" class="headerlink" title="std::stof()"></a>std::stof()</h2><p><code>std::stof()</code> 是 C++ 标准库中 <code>&lt;string&gt;</code> 头文件中提供的函数之一，用于将字符串转换为单精度浮点数（<code>float</code>）。</p>
<h3 id="函数原型：-11"><a href="#函数原型：-11" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">stof</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span>* pos = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-11"><a href="#参数：-11" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要转换为单精度浮点数的字符串。</li>
<li><code>pos</code>：指向存储第一个无效字符位置的指针，可选参数，默认为 <code>nullptr</code>。</li>
</ul>
<h3 id="返回值：-10"><a href="#返回值：-10" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回转换后的单精度浮点数值。如果转换过程中出现错误，会抛出 <code>std::invalid_argument</code> 或 <code>std::out_of_range</code> 异常。</li>
</ul>
<h3 id="示例：-11"><a href="#示例：-11" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;3.14159&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">float</span> num = std::<span class="built_in">stof</span>(str);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换后的单精度浮点数为: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-11"><a href="#输出：-11" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换后的单精度浮点数为: 3.14159</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>std::stof()</code> 将字符串 “3.14159” 转换为单精度浮点数类型并输出。如果无法转换字符串为单精度浮点数，例如，当字符串包含非数字字符时，将抛出异常。</p>
<h2 id="std-stod"><a href="#std-stod" class="headerlink" title="std::stod()"></a>std::stod()</h2><p><code>std::stod()</code> 是 C++ 标准库中 <code>&lt;string&gt;</code> 头文件中提供的函数之一，用于将字符串转换为双精度浮点数（<code>double</code>）。</p>
<h3 id="函数原型：-12"><a href="#函数原型：-12" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">stod</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span>* pos = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-12"><a href="#参数：-12" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要转换为双精度浮点数的字符串。</li>
<li><code>pos</code>：指向存储第一个无效字符位置的指针，可选参数，默认为 <code>nullptr</code>。</li>
</ul>
<h3 id="返回值：-11"><a href="#返回值：-11" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回转换后的双精度浮点数值。如果转换过程中出现错误，会抛出 <code>std::invalid_argument</code> 或 <code>std::out_of_range</code> 异常。</li>
</ul>
<h3 id="示例：-12"><a href="#示例：-12" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;3.14159265359&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">double</span> num = std::<span class="built_in">stod</span>(str);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换后的双精度浮点数为: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-12"><a href="#输出：-12" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换后的双精度浮点数为: 3.14159265359</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>std::stod()</code> 将字符串 “3.14159265359” 转换为双精度浮点数类型并输出。如果无法转换字符串为双精度浮点数，例如，当字符串包含非数字字符时，将抛出异常。</p>
<h2 id="std-stold"><a href="#std-stold" class="headerlink" title="std::stold()"></a>std::stold()</h2><p><code>std::stold()</code> 是 C++ 标准库中 <code>&lt;string&gt;</code> 头文件中提供的函数之一，用于将字符串转换为长双精度浮点数（<code>long double</code>）。</p>
<h3 id="函数原型：-13"><a href="#函数原型：-13" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">stold</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span>* pos = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-13"><a href="#参数：-13" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要转换为长双精度浮点数的字符串。</li>
<li><code>pos</code>：指向存储第一个无效字符位置的指针，可选参数，默认为 <code>nullptr</code>。</li>
</ul>
<h3 id="返回值：-12"><a href="#返回值：-12" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回转换后的长双精度浮点数值。如果转换过程中出现错误，会抛出 <code>std::invalid_argument</code> 或 <code>std::out_of_range</code> 异常。</li>
</ul>
<h3 id="示例：-13"><a href="#示例：-13" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;3.141592653589793238&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">double</span> num = std::<span class="built_in">stold</span>(str);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换后的长双精度浮点数为: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-13"><a href="#输出：-13" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换后的长双精度浮点数为: 3.141592653589793238</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>std::stold()</code> 将字符串 “3.141592653589793238” 转换为长双精度浮点数类型并输出。如果无法转换字符串为长双精度浮点数，例如，当字符串包含非数字字符时，将抛出异常。</p>
<h2 id="std-string-c-str"><a href="#std-string-c-str" class="headerlink" title="std::string::c_str()"></a>std::string::c_str()</h2><p><code>std::string::c_str()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数，用于返回一个指向以 null 结尾的 C 风格字符串（字符数组）的指针，即指向 <code>std::string</code> 对象中存储的字符数据。</p>
<h3 id="函数原型：-14"><a href="#函数原型：-14" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="返回值：-13"><a href="#返回值：-13" class="headerlink" title="返回值："></a>返回值：</h3><p>返回一个指向以 null 结尾的字符数组的指针，该字符数组存储了 <code>std::string</code> 对象中的字符串内容。</p>
<h3 id="示例：-14"><a href="#示例：-14" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;C 风格字符串为: &quot;</span> &lt;&lt; cstr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-14"><a href="#输出：-14" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C 风格字符串为: Hello, World!</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str.c_str()</code> 返回一个指向字符串 “Hello, World!” 的 C 风格字符串的指针，并通过 <code>std::cout</code> 输出该字符串。需要注意的是，<code>c_str()</code> 返回的指针指向的字符数组是以 null 结尾的，因此可以被正常地当做 C 风格字符串处理。</p>
<h2 id="std-string-data"><a href="#std-string-data" class="headerlink" title="std::string::data()"></a>std::string::data()</h2><p><code>std::string::data()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数，用于返回一个指向字符数据的指针，但不一定以 null 结尾。</p>
<h3 id="函数原型：-15"><a href="#函数原型：-15" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">data</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="返回值：-14"><a href="#返回值：-14" class="headerlink" title="返回值："></a>返回值：</h3><p>返回一个指向存储在 <code>std::string</code> 对象中的字符数据的指针。与 <code>c_str()</code> 不同的是，<code>data()</code> 不一定会在字符串的末尾添加 null 终止符。</p>
<h3 id="示例：-15"><a href="#示例：-15" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* strData = str.<span class="built_in">data</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符数据为: &quot;</span> &lt;&lt; strData &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-15"><a href="#输出：-15" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符数据为: Hello, World!</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str.data()</code> 返回一个指向字符串 “Hello, World!” 的字符数据的指针，并通过 <code>std::cout</code> 输出该字符串。需要注意的是，<code>data()</code> 返回的指针可能不以 null 结尾，并且对返回指针所指向的数据进行修改时，需要谨慎处理末尾的 null 终止符。</p>
<h2 id="std-string-reserve"><a href="#std-string-reserve" class="headerlink" title="std::string::reserve()"></a>std::string::reserve()</h2><p><code>std::string::reserve()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于请求字符串预留足够的内存空间，以容纳指定数量的字符，而不会更改字符串的大小。</p>
<h3 id="函数原型：-16"><a href="#函数原型：-16" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-14"><a href="#参数：-14" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>n</code>：要预留的字符数量。</li>
</ul>
<h3 id="返回值：-15"><a href="#返回值：-15" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>无（<code>void</code>）。</li>
</ul>
<h3 id="示例：-16"><a href="#示例：-16" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;初始容量: &quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">reserve</span>(<span class="number">20</span>); <span class="comment">// 预留至少可以容纳 20 个字符的空间</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;预留后的容量: &quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-16"><a href="#输出：-16" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始容量: 5</span><br><span class="line">预留后的容量: 20</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str.reserve(20)</code> 调用了 <code>reserve()</code> 函数来预留至少可以容纳 20 个字符的空间。请注意，<code>reserve()</code> 只是预留了空间，并不改变字符串的长度。这对于在预先知道要存储大量字符的情况下，避免多次重新分配内存而提高性能是很有用的。</p>
<h2 id="std-string-shrink-to-fit"><a href="#std-string-shrink-to-fit" class="headerlink" title="std::string::shrink_to_fit()"></a>std::string::shrink_to_fit()</h2><p><code>std::string::shrink_to_fit()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于要求字符串收缩其容量以适应当前字符串的大小。</p>
<h3 id="函数原型：-17"><a href="#函数原型：-17" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="返回值：-16"><a href="#返回值：-16" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>无（<code>void</code>）。</li>
</ul>
<h3 id="示例：-17"><a href="#示例：-17" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;初始容量: &quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">reserve</span>(<span class="number">100</span>); <span class="comment">// 分配较大的空间</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;扩大容量后的容量: &quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">shrink_to_fit</span>(); <span class="comment">// 收缩容量以适应当前大小</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;收缩容量后的容量: &quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-17"><a href="#输出：-17" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始容量: 5</span><br><span class="line">扩大容量后的容量: 100</span><br><span class="line">收缩容量后的容量: 5</span><br></pre></td></tr></table></figure>

<p>在这个示例中，首先创建了一个字符串 <code>str</code>，然后通过 <code>str.reserve(100)</code> 手动扩大了其容量。随后调用 <code>str.shrink_to_fit()</code> 来收缩字符串的容量以适应当前字符串的大小。这对于释放不再需要的内存空间是有用的，可以减少不必要的内存浪费。</p>
<h2 id="std-string-capacity"><a href="#std-string-capacity" class="headerlink" title="std::string::capacity()"></a>std::string::capacity()</h2><p><code>std::string::capacity()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于返回当前字符串能够容纳的字符数量，即分配给字符串的内存空间大小。</p>
<h3 id="函数原型：-18"><a href="#函数原型：-18" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="返回值：-17"><a href="#返回值：-17" class="headerlink" title="返回值："></a>返回值：</h3><p>返回字符串当前可容纳的字符数量，即字符串所分配的内存空间大小。</p>
<h3 id="示例：-18"><a href="#示例：-18" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符串当前容量: &quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-18"><a href="#输出：-18" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串当前容量: 15</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str.capacity()</code> 返回了字符串 <code>str</code> 当前的容量。需要注意的是，字符串的容量并不等同于字符串的长度（即字符个数），而是指字符串当前已分配的内存大小。容量通常大于或等于字符串的长度，因为字符串预留了额外的空间以便于扩展和操作。</p>
<h2 id="std-getline"><a href="#std-getline" class="headerlink" title="std::getline()"></a>std::getline()</h2><p><code>std::getline()</code> 是 C++ 标准库中 <code>&lt;string&gt;</code> 头文件中提供的函数，用于从输入流中读取一行文本并存储到字符串中。</p>
<h3 id="函数原型：-19"><a href="#函数原型：-19" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::istream&amp; <span class="title">getline</span><span class="params">(std::istream&amp; is, std::string&amp; str, <span class="type">char</span> delim = <span class="string">&#x27;\n&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-15"><a href="#参数：-15" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>is</code>：输入流，例如 <code>std::cin</code>（标准输入）或文件流。</li>
<li><code>str</code>：用于存储输入行的字符串。</li>
<li><code>delim</code>：可选参数，表示行的结束符，默认为换行符 <code>&#39;\n&#39;</code>。</li>
</ul>
<h3 id="返回值：-18"><a href="#返回值：-18" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回输入流 <code>is</code> 的引用，以便进行链式输入。</li>
</ul>
<h3 id="示例：-19"><a href="#示例：-19" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string input;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一行文本：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::<span class="built_in">getline</span>(std::cin, input);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你输入的内容是：&quot;</span> &lt;&lt; input &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-19"><a href="#输出：-19" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入一行文本：</span><br><span class="line">[用户输入]</span><br><span class="line">你输入的内容是：[用户输入的内容]</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>std::getline(std::cin, input)</code> 从标准输入中读取一行用户输入的文本，并将其存储在 <code>input</code> 字符串中。如果输入的行超过了字符串的最大长度，<code>std::getline()</code> 会自动调整字符串的大小以容纳整个输入行。</p>
<h2 id="std-to-string"><a href="#std-to-string" class="headerlink" title="std::to_string()"></a>std::to_string()</h2><p><code>std::to_string()</code> 是 C++ 标准库中 <code>&lt;string&gt;</code> 头文件中提供的函数之一，用于将数值类型转换为对应的字符串形式。</p>
<h3 id="函数原型：-20"><a href="#函数原型：-20" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">long</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">long</span> <span class="type">long</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">float</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">double</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">long</span> <span class="type">double</span> value)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-16"><a href="#参数：-16" class="headerlink" title="参数："></a>参数：</h3><ul>
<li>不同版本的 <code>to_string()</code> 接受不同的数值类型作为参数，并将其转换为对应的字符串形式。</li>
</ul>
<h3 id="返回值：-19"><a href="#返回值：-19" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回包含数值转换后的字符串。</li>
</ul>
<h3 id="示例：-20"><a href="#示例：-20" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> intValue = <span class="number">42</span>;</span><br><span class="line">    <span class="type">float</span> floatValue = <span class="number">3.14159f</span>;</span><br><span class="line"></span><br><span class="line">    std::string strInt = std::<span class="built_in">to_string</span>(intValue);</span><br><span class="line">    std::string strFloat = std::<span class="built_in">to_string</span>(floatValue);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;整数转换后的字符串: &quot;</span> &lt;&lt; strInt &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;浮点数转换后的字符串: &quot;</span> &lt;&lt; strFloat &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-20"><a href="#输出：-20" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">整数转换后的字符串: 42</span><br><span class="line">浮点数转换后的字符串: 3.141590</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::to_string()</code> 将整数和浮点数分别转换为对应的字符串形式，并将其存储在 <code>strInt</code> 和 <code>strFloat</code> 中。这是一个方便的函数，用于将不同类型的数值转换为字符串，以便于输出或字符串处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_9_memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_9_memory/" class="post-title-link" itemprop="url">C++_10_9_memory</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <memory>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <memory>标准库</h2><p><code>&lt;memory&gt;</code> 是 C++ 标准库中的头文件，提供了一些内存管理相关的类和函数，用于帮助管理动态分配的内存和智能指针等。</p>
<p>以下是 <code>&lt;memory&gt;</code> 标准库中一些重要的内容：</p>
<ol>
<li><p><strong>动态内存分配：</strong></p>
<ul>
<li><code>std::allocator</code>：是用于分配和释放内存的默认分配器。</li>
<li><code>std::unique_ptr</code>：一种独占指针，用于管理动态分配的对象，确保内存的释放。</li>
<li><code>std::shared_ptr</code>：一种共享指针，多个指针可以共享对同一个对象的所有权，使用引用计数来管理内存释放。</li>
<li><code>std::weak_ptr</code>：弱引用指针，用于解决 <code>std::shared_ptr</code> 可能导致的循环引用问题。</li>
</ul>
</li>
<li><p><strong>智能指针相关函数和工具：</strong></p>
<ul>
<li><code>std::make_unique</code>：用于创建动态分配的对象并返回一个 <code>std::unique_ptr</code>。</li>
<li><code>std::make_shared</code>：用于创建动态分配的对象并返回一个 <code>std::shared_ptr</code>。</li>
</ul>
</li>
<li><p><strong>内存管理相关工具和函数：</strong></p>
<ul>
<li><code>std::addressof</code>：获取对象的地址。</li>
<li><code>std::pointer_traits</code>：提供了对指针类型的通用操作。</li>
<li><code>std::default_delete</code>：默认删除器，用于指定 <code>std::unique_ptr</code> 的删除策略。</li>
</ul>
</li>
<li><p><strong>特定内存工具和操作：</strong></p>
<ul>
<li><code>std::align</code>：在给定地址处对齐内存。</li>
<li><code>std::allocator_traits</code>：提供了对分配器的通用操作。</li>
</ul>
</li>
</ol>
<p>使用 <code>&lt;memory&gt;</code> 标准库，可以更安全地管理动态分配的内存，避免内存泄漏和悬挂指针等问题。智能指针类能够自动处理内存的释放，大大简化了内存管理的复杂性。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <memory>标准库 详解</h2><p><code>&lt;memory&gt;</code> 标准库提供了许多功能，主要用于在 C++ 中管理内存和智能指针。以下是 <code>&lt;memory&gt;</code> 标准库中的一些重要组件和功能：</p>
<ol>
<li><p><strong>智能指针：</strong></p>
<ul>
<li><code>std::unique_ptr</code>：独占所有权的智能指针，确保只有一个指针可以管理一个对象。当 <code>std::unique_ptr</code> 被销毁时，它所管理的对象也会被自动释放。</li>
<li><code>std::shared_ptr</code>：允许多个指针共享对同一对象的所有权，使用引用计数来管理对象的生命周期。当最后一个 <code>std::shared_ptr</code> 被销毁时，关联的对象才会被释放。</li>
<li><code>std::weak_ptr</code>：弱引用指针，用于打破 <code>std::shared_ptr</code> 可能产生的循环引用问题。</li>
</ul>
</li>
<li><p><strong>内存管理相关工具和函数：</strong></p>
<ul>
<li><code>std::make_unique</code>：用于创建动态分配的对象并返回一个 <code>std::unique_ptr</code>。</li>
<li><code>std::make_shared</code>：用于创建动态分配的对象并返回一个 <code>std::shared_ptr</code>。</li>
<li><code>std::allocator</code>：用于动态内存分配和释放的默认分配器。</li>
<li><code>std::default_delete</code>：默认的删除器，通常与智能指针 <code>std::unique_ptr</code> 结合使用，指定对象的释放方式。</li>
</ul>
</li>
<li><p><strong>工具和类型特征：</strong></p>
<ul>
<li><code>std::addressof</code>：获取对象的地址。</li>
<li><code>std::pointer_traits</code>：提供了对指针类型的通用操作。</li>
<li><code>std::allocator_traits</code>：提供了对分配器的通用操作。</li>
</ul>
</li>
<li><p><strong>内存操作和指针工具：</strong></p>
<ul>
<li><code>std::align</code>：在给定地址处对齐内存。</li>
<li><code>std::memcpy</code> 和 <code>std::memset</code>：用于内存复制和内存设置。</li>
</ul>
</li>
</ol>
<p><code>&lt;memory&gt;</code> 标准库提供了许多工具和类，使得在 C++ 中进行内存管理变得更加安全和方便。智能指针能够避免常见的内存管理问题，如悬挂指针、内存泄漏等，有助于提高代码的健壮性和可靠性。同时，这些功能也让程序员更加轻松地进行动态内存管理。</p>
<h2 id="C-标准库-常用类和函数"><a href="#C-标准库-常用类和函数" class="headerlink" title="C++ 标准库 常用类和函数"></a>C++ <memory>标准库 常用类和函数</h2><p><code>&lt;memory&gt;</code> 标准库中有许多常用的类和函数，主要用于内存管理和智能指针。以下是一些常用的类和函数：</p>
<h3 id="常用类："><a href="#常用类：" class="headerlink" title="常用类："></a>常用类：</h3><ol>
<li><strong>智能指针类：</strong><ul>
<li><code>std::unique_ptr&lt;T&gt;</code>：独占所有权的智能指针，确保只有一个指针可以管理一个对象。</li>
<li><code>std::shared_ptr&lt;T&gt;</code>：允许多个指针共享对同一对象的所有权。</li>
<li><code>std::weak_ptr&lt;T&gt;</code>：弱引用指针，用于打破 <code>std::shared_ptr</code> 可能产生的循环引用问题。</li>
</ul>
</li>
</ol>
<h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><ol>
<li><p><strong>内存管理相关函数：</strong></p>
<ul>
<li><code>std::make_unique&lt;T&gt;()</code>：用于创建动态分配的对象并返回一个 <code>std::unique_ptr&lt;T&gt;</code>。</li>
<li><code>std::make_shared&lt;T&gt;()</code>：用于创建动态分配的对象并返回一个 <code>std::shared_ptr&lt;T&gt;</code>。</li>
<li><code>std::allocate_shared&lt;T&gt;()</code>：分配一个对象的共享内存。</li>
<li><code>std::allocate_shared&lt;T, Args...&gt;()</code>：使用自定义分配器分配一个对象的共享内存。</li>
</ul>
</li>
<li><p><strong>其他函数：</strong></p>
<ul>
<li><code>std::addressof()</code>：获取对象的地址。</li>
<li><code>std::memcpy()</code> 和 <code>std::memset()</code>：用于内存复制和内存设置。</li>
</ul>
</li>
</ol>
<h3 id="类型特征和工具："><a href="#类型特征和工具：" class="headerlink" title="类型特征和工具："></a>类型特征和工具：</h3><ol>
<li><p><strong>指针和分配器相关的类型特征：</strong></p>
<ul>
<li><code>std::pointer_traits&lt;T&gt;</code>：提供了对指针类型 <code>T</code> 的通用操作。</li>
<li><code>std::allocator_traits&lt;Allocator&gt;</code>：提供了对分配器 <code>Allocator</code> 的通用操作。</li>
</ul>
</li>
<li><p><strong>分配器相关类：</strong></p>
<ul>
<li><code>std::allocator&lt;T&gt;</code>：用于动态内存分配和释放的默认分配器。</li>
</ul>
</li>
</ol>
<p><code>&lt;memory&gt;</code> 标准库提供了强大的工具和类来管理动态分配的内存，帮助避免内存泄漏和悬挂指针等问题。智能指针类使得在 C++ 中进行内存管理变得更加方便和安全。</p>
<h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p><code>std::unique_ptr</code> 是 C++ 标准库 <code>&lt;memory&gt;</code> 中定义的智能指针类，用于管理动态分配的对象，并且在其生命周期结束时自动释放所管理的对象。</p>
<p><code>std::unique_ptr</code> 具有独占所有权的特性，即同一时间只能有一个 <code>std::unique_ptr</code> 指向一个对象。当 <code>std::unique_ptr</code> 被销毁时（例如超出作用域、被赋予新值或者显式释放），它所管理的对象也会被自动释放，从而避免内存泄漏。</p>
<p>以下是 <code>std::unique_ptr</code> 的主要特点和用法：</p>
<ul>
<li><p><strong>独占所有权：</strong> 一个 <code>std::unique_ptr</code> 实例是对象的唯一所有者，不能被复制，但可以被移动。</p>
</li>
<li><p><strong>创建 <code>std::unique_ptr</code>：</strong></p>
<ul>
<li>使用 <code>std::make_unique&lt;T&gt;()</code>：用于创建动态分配的对象并返回一个 <code>std::unique_ptr&lt;T&gt;</code>。</li>
<li>直接声明：<code>std::unique_ptr&lt;T&gt; ptr(new T())</code>，但不推荐直接使用 <code>new</code>。</li>
</ul>
</li>
<li><p><strong>移动语义：</strong> <code>std::unique_ptr</code> 支持移动语义，可以使用 <code>std::move</code> 来将所有权从一个 <code>std::unique_ptr</code> 转移到另一个。</p>
</li>
<li><p><strong>释放内存：</strong> 当 <code>std::unique_ptr</code> 超出作用域时，它所管理的对象会被自动释放。</p>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// ptr 在此处超出作用域，触发自动释放所管理的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">someFunction</span>();</span><br><span class="line">    <span class="comment">// 在此处无法访问 ptr，因为它已经超出了作用域</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::make_unique&lt;int&gt;(42)</code> 创建了一个动态分配的整数对象，并将其存储在 <code>std::unique_ptr&lt;int&gt;</code> 中。当 <code>ptr</code> 超出作用域时，所管理的对象会被自动释放。</p>
<h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p><code>std::shared_ptr</code> 是 C++ 标准库 <code>&lt;memory&gt;</code> 中定义的智能指针类，用于管理动态分配的对象，并且可以让多个指针共享对同一对象的所有权。</p>
<p>与 <code>std::unique_ptr</code> 不同，<code>std::shared_ptr</code> 允许多个 <code>std::shared_ptr</code> 实例共享对同一对象的控制权。它使用引用计数机制来管理内存，当最后一个 <code>std::shared_ptr</code> 指向对象时，对象会被销毁。</p>
<p>以下是 <code>std::shared_ptr</code> 的主要特点和用法：</p>
<ul>
<li><p><strong>共享所有权：</strong> 多个 <code>std::shared_ptr</code> 可以指向同一个对象，共享对该对象的所有权。</p>
</li>
<li><p><strong>引用计数：</strong> 使用引用计数来追踪对象的所有权，当最后一个 <code>std::shared_ptr</code> 被销毁时，才会释放对象。</p>
</li>
<li><p><strong>创建 <code>std::shared_ptr</code>：</strong></p>
<ul>
<li>使用 <code>std::make_shared&lt;T&gt;()</code>：用于创建动态分配的对象并返回一个 <code>std::shared_ptr&lt;T&gt;</code>。</li>
<li>直接声明：<code>std::shared_ptr&lt;T&gt; ptr = std::shared_ptr&lt;T&gt;(new T())</code>，但不推荐直接使用 <code>new</code>。</li>
</ul>
</li>
<li><p><strong>复制和移动语义：</strong> <code>std::shared_ptr</code> 支持复制和移动语义。复制 <code>std::shared_ptr</code> 会增加引用计数，移动 <code>std::shared_ptr</code> 会将所有权转移给另一个对象。</p>
</li>
<li><p><strong>释放内存：</strong> 当最后一个 <code>std::shared_ptr</code> 超出作用域时，所管理的对象会被释放。</p>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 共享指针 ptr1 的所有权</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value of ptr1: &quot;</span> &lt;&lt; *ptr1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value of ptr2: &quot;</span> &lt;&lt; *ptr2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// ptr1 和 ptr2 在此处超出作用域，引用计数减少，对象不会被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">someFunction</span>();</span><br><span class="line">    <span class="comment">// 在此处无法访问 ptr1 和 ptr2，因为它们已经超出了作用域</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>ptr1</code> 和 <code>ptr2</code> 都指向同一个动态分配的整数对象。当函数结束时，引用计数减少，但由于 <code>ptr1</code> 和 <code>ptr2</code> 都超出作用域，所管理的对象最终会被释放。</p>
<h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p><code>std::weak_ptr</code> 是 C++ 标准库 <code>&lt;memory&gt;</code> 中定义的智能指针类，用于解决 <code>std::shared_ptr</code> 可能导致的循环引用问题，并且不影响所管理对象的生命周期。</p>
<p><code>std::weak_ptr</code> 是一种弱引用指针，它可以指向由 <code>std::shared_ptr</code> 管理的对象，但并不拥有对象的所有权。它不会增加对象的引用计数，因此也不会阻止对象的销毁。通常用于观察或临时访问由 <code>std::shared_ptr</code> 管理的对象。</p>
<p>以下是 <code>std::weak_ptr</code> 的主要特点和用法：</p>
<ul>
<li><p><strong>弱引用：</strong> 不持有对象的所有权，不会影响对象的生命周期。</p>
</li>
<li><p><strong>与 <code>std::shared_ptr</code> 搭配使用：</strong> <code>std::weak_ptr</code> 可以从 <code>std::shared_ptr</code> 创建，并通过 <code>std::lock()</code> 方法转换为 <code>std::shared_ptr</code>，以临时获取对象的所有权。</p>
</li>
<li><p><strong>检查对象是否存在：</strong> 可以使用 <code>expired()</code> 方法检查与 <code>std::weak_ptr</code> 关联的对象是否被销毁。</p>
</li>
<li><p><strong>安全地访问对象：</strong> 使用 <code>std::lock()</code> 方法可以安全地获取 <code>std::shared_ptr</code>，如果对象存在，则返回 <code>std::shared_ptr</code>，否则返回空的 <code>std::shared_ptr</code>。</p>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">observe</span><span class="params">(std::weak_ptr&lt;<span class="type">int</span>&gt; weakPtr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> sharedPtr = weakPtr.<span class="built_in">lock</span>()) &#123; <span class="comment">// 尝试获取 shared_ptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value observed: &quot;</span> &lt;&lt; *sharedPtr &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object has been destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; weakPtr = sharedPtr; <span class="comment">// 创建 weak_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">observe</span>(weakPtr); <span class="comment">// 观察对象</span></span><br><span class="line"></span><br><span class="line">    sharedPtr.<span class="built_in">reset</span>(); <span class="comment">// 销毁 shared_ptr</span></span><br><span class="line">    <span class="built_in">observe</span>(weakPtr); <span class="comment">// 再次观察对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>weakPtr</code> 弱引用指向 <code>sharedPtr</code> 所管理的整数对象。通过 <code>std::lock()</code> 方法，<code>weakPtr</code> 可以安全地转换为 <code>std::shared_ptr</code>，以临时获取对象的所有权。在 <code>observe()</code> 函数中，可以检查对象是否存在，并安全地访问对象。当 <code>sharedPtr</code> 被销毁后，通过 <code>weakPtr</code> 观察对象时，将得到对象已被销毁的信息。</p>
<h2 id="std-make-unique"><a href="#std-make-unique" class="headerlink" title="std::make_unique"></a>std::make_unique</h2><p><code>std::make_unique</code> 是 C++11 标准引入的一个函数模板，用于创建动态分配的对象并返回一个 <code>std::unique_ptr</code> 智能指针。它是用于创建 <code>std::unique_ptr</code> 的首选方式，具有安全和简洁的特性。</p>
<p>与直接使用 <code>new</code> 来分配内存并创建 <code>std::unique_ptr</code> 不同，<code>std::make_unique</code> 提供了更加安全和简洁的方式，它在分配对象的同时将其封装到 <code>std::unique_ptr</code> 中。</p>
<p>基本用法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::unique_ptr，管理一个动态分配的整数对象</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl; <span class="comment">// 访问所管理的整数对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::make_unique&lt;int&gt;(42)</code> 创建了一个动态分配的整数对象，并将其封装到 <code>std::unique_ptr&lt;int&gt;</code> 中。这种方式简洁、安全，并且避免了手动管理内存，提高了代码的可读性和健壮性。</p>
<p>需要注意的是，<code>std::make_unique</code> 在 C++11 中引入，但用于创建 <code>std::unique_ptr</code>。而对于 <code>std::shared_ptr</code>，C++11 并没有提供 <code>std::make_shared</code>，但在 C++14 中引入了这个功能。所以在 C++14 中，可以使用 <code>std::make_shared</code> 来创建 <code>std::shared_ptr</code>。</p>
<h2 id="std-make-shared"><a href="#std-make-shared" class="headerlink" title="std::make_shared"></a>std::make_shared</h2><p><code>std::make_shared</code> 是 C++11 引入的函数模板，用于创建动态分配的对象并返回一个 <code>std::shared_ptr</code> 智能指针。它是创建 <code>std::shared_ptr</code> 的推荐方式，提供了安全和高效的对象分配和管理。</p>
<p>基本用法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::shared_ptr，管理一个动态分配的整数对象</span></span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl; <span class="comment">// 访问所管理的整数对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::make_shared&lt;int&gt;(42)</code> 创建了一个动态分配的整数对象，并将其封装到 <code>std::shared_ptr&lt;int&gt;</code> 中。<code>std::make_shared</code> 可以接收参数并直接传递给对象的构造函数。</p>
<p>与直接使用 <code>new</code> 来分配内存并创建 <code>std::shared_ptr</code> 不同，<code>std::make_shared</code> 提供了更高效的内存分配，因为它会分配一个单一的内存块用于存储对象和控制块（用于跟踪引用计数等信息）。这种方式可以减少额外的开销，并且可以更有效地使用内存。</p>
<p>需要注意的是，<code>std::make_shared</code> 是 C++11 引入的，在 C++11 之前，可以使用 <code>std::shared_ptr&lt;T&gt;(new T(args))</code> 的方式创建 <code>std::shared_ptr</code>，但这种方式可能导致额外的内存分配和性能损耗。</p>
<h2 id="std-allocate-shared"><a href="#std-allocate-shared" class="headerlink" title="std::allocate_shared"></a>std::allocate_shared</h2><p><code>std::allocate_shared</code> 是 C++11 引入的函数模板，用于创建动态分配的对象并返回一个 <code>std::shared_ptr</code> 智能指针。与 <code>std::make_shared</code> 类似，<code>std::allocate_shared</code> 也用于动态分配对象，但允许指定自定义的分配器。</p>
<p>基本用法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyStruct</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用自定义分配器创建一个 std::shared_ptr，管理一个动态分配的 MyStruct 对象</span></span><br><span class="line">    std::allocator&lt;MyStruct&gt; alloc;</span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">allocate_shared</span>&lt;MyStruct&gt;(alloc, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; ptr-&gt;value &lt;&lt; std::endl; <span class="comment">// 访问所管理的对象的成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::allocate_shared&lt;MyStruct&gt;(alloc, 42)</code> 使用自定义的分配器 <code>std::allocator&lt;MyStruct&gt;</code> 创建了一个动态分配的 <code>MyStruct</code> 对象，并将其封装到 <code>std::shared_ptr&lt;MyStruct&gt;</code> 中。第一个参数是分配器对象，第二个参数是传递给对象构造函数的参数。</p>
<p>相较于 <code>std::shared_ptr</code> 的其他构造函数和 <code>std::make_shared</code>，<code>std::allocate_shared</code> 允许程序员提供自定义的分配器，以满足特定的内存管理需求。这个函数在一些特殊情况下可以提供更大的灵活性。</p>
<h2 id="std-addressof"><a href="#std-addressof" class="headerlink" title="std::addressof"></a>std::addressof</h2><p><code>std::addressof</code> 是 C++ 标准库 <code>&lt;memory&gt;</code> 中定义的函数模板，用于获取对象的地址。</p>
<p>与 C++ 内置的取地址运算符 <code>&amp;</code> 不同，<code>std::addressof</code> 能够确保即使重载了取地址运算符的类，也能获得对象的真实地址。</p>
<p><code>std::addressof</code> 的基本用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = std::<span class="built_in">addressof</span>(num); <span class="comment">// 获取变量 num 的地址</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Address of num: &quot;</span> &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::addressof</code> 获取了变量 <code>num</code> 的地址，并将其存储在指针 <code>ptr</code> 中。使用 <code>std::cout</code> 打印出 <code>num</code> 的地址。</p>
<p>通常情况下，直接使用取地址运算符 <code>&amp;</code> 可以获取对象的地址。但是，如果类重载了取地址运算符（<code>operator&amp;</code>），可能会导致取到重载后的地址。在这种情况下，使用 <code>std::addressof</code> 可以确保获取到对象的真实地址。</p>
<h2 id="std-allocator"><a href="#std-allocator" class="headerlink" title="std::allocator"></a>std::allocator</h2><p><code>std::allocator</code> 是 C++ 标准库 <code>&lt;memory&gt;</code> 头文件中定义的默认分配器类模板。它是 C++ 中动态内存分配和释放的接口之一，用于管理内存的分配和释放。</p>
<p><code>std::allocator</code> 作为内存分配器，提供了用于分配和释放内存的一组操作，其中包括 <code>allocate()</code>、<code>deallocate()</code>、<code>construct()</code> 和 <code>destroy()</code> 等函数。</p>
<p>以下是 <code>std::allocator</code> 的主要操作：</p>
<ul>
<li><code>allocate()</code>：分配指定数量的未初始化内存块。</li>
<li><code>deallocate()</code>：释放之前分配的内存块。</li>
<li><code>construct()</code>：在分配的内存中构造一个对象。</li>
<li><code>destroy()</code>：在分配的内存中销毁一个对象。</li>
</ul>
<p>它是 C++ 标准库提供的默认分配器，并且也是许多容器（如 <code>std::vector</code>、<code>std::list</code> 等）的默认分配器。</p>
<p>通常情况下，如果不提供自定义的分配器，标准库的容器会默认使用 <code>std::allocator</code> 进行内存管理。当然，如果需要更多的定制或特定的内存管理方式，可以通过定义自己的分配器类并符合特定的接口来实现。</p>
<p>以下是一个简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::allocator&lt;<span class="type">int</span>&gt; myAllocator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存来存储 5 个整数</span></span><br><span class="line">    <span class="type">int</span>* ptr = myAllocator.<span class="built_in">allocate</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        myAllocator.<span class="built_in">construct</span>(&amp;ptr[i], i); <span class="comment">// 构造对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出分配的整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; ptr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁对象并释放内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        myAllocator.<span class="built_in">destroy</span>(&amp;ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    myAllocator.<span class="built_in">deallocate</span>(ptr, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::allocator</code> 被用来分配和释放一块存储整数的内存，然后构造并输出这些整数，最后销毁并释放分配的内存。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_6_cctype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_6_cctype/" class="post-title-link" itemprop="url">C++_10_6_cctype</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><cctype> 标准库相关笔记</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <cctype>标准库</h2><p>C++ 标准库 <code>&lt;cctype&gt;</code> 提供了一组用于对字符进行分类和简单字符处理的函数。这些函数在 <code>&lt;cctype&gt;</code> 头文件中声明，并且是 C++ 中处理字符的标准方式。</p>
<p>以下是 <code>&lt;cctype&gt;</code> 头文件中常用的一些函数：</p>
<h3 id="字符分类函数："><a href="#字符分类函数：" class="headerlink" title="字符分类函数："></a>字符分类函数：</h3><ul>
<li><code>std::isalnum(int c)</code>: 检查字符是否是字母或数字。</li>
<li><code>std::isalpha(int c)</code>: 检查字符是否是字母。</li>
<li><code>std::isdigit(int c)</code>: 检查字符是否是十进制数字。</li>
<li><code>std::islower(int c)</code>: 检查字符是否是小写字母。</li>
<li><code>std::isupper(int c)</code>: 检查字符是否是大写字母。</li>
<li><code>std::isspace(int c)</code>: 检查字符是否是空格或类似的空白字符。</li>
<li><code>std::iscntrl(int c)</code>: 检查字符是否是控制字符。</li>
<li><code>std::ispunct(int c)</code>: 检查字符是否是标点符号。</li>
<li><code>std::isprint(int c)</code>: 检查字符是否是可打印字符。</li>
<li><code>std::isxdigit(int c)</code>: 检查字符是否是十六进制数字。</li>
</ul>
<h3 id="字符转换函数："><a href="#字符转换函数：" class="headerlink" title="字符转换函数："></a>字符转换函数：</h3><ul>
<li><code>std::tolower(int c)</code>: 将字符转换为小写形式。</li>
<li><code>std::toupper(int c)</code>: 将字符转换为大写形式。</li>
</ul>
<h3 id="其他函数："><a href="#其他函数：" class="headerlink" title="其他函数："></a>其他函数：</h3><ul>
<li><code>std::tolower()</code> 和 <code>std::toupper()</code> 还有版本可用于处理字符的宽字符版本 <code>wchar_t</code>，其函数名为 <code>std::towlower()</code> 和 <code>std::towupper()</code>。</li>
</ul>
<p>这些函数都接受一个整数参数，通常是 <code>int</code> 类型，表示要检查或转换的字符。函数返回值为 <code>int</code> 类型，通常表示一个非零值（真）或零值（假）来指示检查的条件是否满足。</p>
<p>这些函数通常用于检查或转换字符，例如，检查一个字符是否是字母、数字，或者将字符转换为大写或小写形式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">isupper</span>(ch)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;字符 &quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot; 是大写字母&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> lowercase = std::<span class="built_in">tolower</span>(ch);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;将字符 &quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot; 转换为小写形式为: &quot;</span> &lt;&lt; lowercase &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上示例演示了 <code>std::isupper()</code> 函数检查一个字符是否为大写字母，以及 <code>std::tolower()</code> 函数将一个字符转换为小写形式。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <cctype>标准库 详解</h2><p><code>&lt;cctype&gt;</code> 是 C++ 标准库中的头文件，提供了一系列操作 C 风格字符串中字符的函数，这些函数是字符分类函数（character classification functions），用于检查和操作字符的特性。</p>
<p>以下是 <code>&lt;cctype&gt;</code> 头文件中常见的函数及其功能：</p>
<ol>
<li><p><strong>字符分类函数</strong>：</p>
<ul>
<li><code>isalnum(int c)</code>：检查字符是否是字母或数字。</li>
<li><code>isalpha(int c)</code>：检查字符是否是字母。</li>
<li><code>isdigit(int c)</code>：检查字符是否是十进制数字。</li>
<li><code>isxdigit(int c)</code>：检查字符是否是十六进制数字。</li>
<li><code>islower(int c)</code>：检查字符是否是小写字母。</li>
<li><code>isupper(int c)</code>：检查字符是否是大写字母。</li>
<li><code>isspace(int c)</code>：检查字符是否是空白字符（空格、制表符、换行符等）。</li>
<li><code>iscntrl(int c)</code>：检查字符是否是控制字符。</li>
<li><code>ispunct(int c)</code>：检查字符是否是标点符号。</li>
<li><code>isprint(int c)</code>：检查字符是否是可打印字符（包括空格）。</li>
<li><code>isgraph(int c)</code>：检查字符是否是可打印字符，但不包括空格。</li>
</ul>
</li>
<li><p><strong>字符转换函数</strong>：</p>
<ul>
<li><code>tolower(int c)</code>：将字符转换为小写字母（如果是大写字母的话）。</li>
<li><code>toupper(int c)</code>：将字符转换为大写字母（如果是小写字母的话）。</li>
</ul>
</li>
</ol>
<p>这些函数通常用于对字符进行分类、转换或验证操作。它们的参数一般是一个整数（<code>int</code> 类型），这个整数可以是字符，也可以是 <code>EOF</code>（文件结束符）的值。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>以下是一个简单的示例，展示了 <code>&lt;cctype&gt;</code> 头文件中的一些函数的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">isalnum</span>(ch)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character is alphanumeric.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character is a digit.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lowercase: &quot;</span> &lt;&lt; std::<span class="built_in">tolower</span>(ch) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Uppercase: &quot;</span> &lt;&lt; std::<span class="built_in">toupper</span>(ch) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此示例中，使用了 <code>isalnum()</code>、<code>isdigit()</code>、<code>tolower()</code> 和 <code>toupper()</code> 函数来检查和转换字符的特性。<code>isalnum()</code> 检查字符是否是字母或数字，<code>isdigit()</code> 检查字符是否是数字，<code>tolower()</code> 和 <code>toupper()</code> 分别将字符转换为小写和大写形式。</p>
<h2 id="std-tolower"><a href="#std-tolower" class="headerlink" title="std::tolower()"></a>std::tolower()</h2><p><code>std::tolower()</code> 是 C++ 标准库中 <code>&lt;cctype&gt;</code> 头文件中提供的函数，用于将单个字符转换为小写形式。</p>
<h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tolower</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>c</code>：要转换为小写的字符。</li>
</ul>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果 <code>c</code> 是大写字母，则返回对应的小写字母，否则返回 <code>c</code> 本身。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> uppercase = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> lowercase = std::<span class="built_in">tolower</span>(uppercase);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;大写字母 &quot;</span> &lt;&lt; uppercase &lt;&lt; <span class="string">&quot; 转换为小写字母为: &quot;</span> &lt;&lt; lowercase &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大写字母 A 转换为小写字母为: a</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::tolower(&#39;A&#39;)</code> 将大写字母 ‘A’ 转换为小写字母 ‘a’。</p>
<h2 id="std-toupper"><a href="#std-toupper" class="headerlink" title="std::toupper()"></a>std::toupper()</h2><p><code>std::toupper()</code> 是 C++ 标准库中 <code>&lt;cctype&gt;</code> 头文件中提供的函数之一，用于将字符转换为大写形式。</p>
<h3 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">toupper</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>c</code>：要转换为大写的字符。</li>
</ul>
<h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果 <code>c</code> 是小写字母，则返回对应的大写字母；否则返回 <code>c</code> 本身。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> lowercase = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> uppercase = std::<span class="built_in">toupper</span>(lowercase);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;小写字母 &quot;</span> &lt;&lt; lowercase &lt;&lt; <span class="string">&quot; 转换为大写字母为: &quot;</span> &lt;&lt; uppercase &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小写字母 a 转换为大写字母为: A</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::toupper(&#39;a&#39;)</code> 将小写字母 ‘a’ 转换为大写字母 ‘A’。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_7_array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_7_array/" class="post-title-link" itemprop="url">C++_10_7_array</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <array>标准库笔记</li>
</ul>
<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><ul>
<li>和vector类似，区别在于array的大小是固定的，不能增加或收缩</li>
<li>这个类的目的是让array能分配在栈上，而不是像vector那样总是需要访问自由存储区</li>
<li>对于包含基本类型(整数，浮点数，字符，布尔值等)的array，初始化元素的方式与vector,list等容器的初始化不同，如果在创建array时没有给初始化值，那么array的元素将是未初始化的，即包含垃圾。对于其他容器，例如vector和list，元素总是初始化的，要么是给定值，要么使用零初始化。因此，array的行为实际上与C风格数组相同。</li>
<li>和vector一样，array支持随机访问迭代器，元素都保存在连续内存中。array支持front()，back(),at()和operator[]，还支持使用fill()方法通过特定元素将array填满</li>
<li>与vector相比，array的缺点是，array的swap()方法具有线性时间复杂度，而vector的swap()方法具有常量时间复杂度。array的移动不是常量时间，vector是</li>
<li>array有size()方法，这显然是优于C风格数组。</li>
</ul>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <array>标准库 详解</h2><p><code>&lt;array&gt;</code> 标准库提供了 <code>std::array</code> 类模板，用于表示固定大小的数组。以下是一些关键点：</p>
<ol>
<li><strong>固定大小：</strong> <code>std::array</code> 的大小在创建时确定，并且无法改变。</li>
<li><strong>内存分配：</strong> 与内置数组类似，<code>std::array</code> 在栈上分配内存，因此大小必须在编译时确定。</li>
<li><strong>元素访问：</strong> 与内置数组类似，可以使用下标操作符 <code>[]</code> 来访问元素。也可以使用 <code>at()</code> 函数进行安全的边界检查。</li>
<li><strong>迭代器支持：</strong> 提供迭代器支持，可以使用迭代器来遍历数组。</li>
<li><strong>容器功能：</strong> 支持一些容器方法，如 <code>size()</code>、<code>empty()</code> 等。</li>
<li><strong>数组间的比较：</strong> 支持数组之间的比较操作，可以使用 <code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code> 等运算符进行比较。</li>
<li><strong>类型安全：</strong> 提供了类型安全的数组访问和操作，因此可以更轻松地避免指针错误和越界访问。</li>
</ol>
<p>使用 <code>std::array</code> 可以简化对数组的管理和操作，提供更多的安全性和方便性，是 C++ 中常用的容器之一。</p>
<h2 id="C-标准库常用函数"><a href="#C-标准库常用函数" class="headerlink" title="C++ 标准库常用函数"></a>C++ <array>标准库常用函数</h2><p><code>&lt;array&gt;</code> 标准库中的 <code>std::array</code> 类提供了一些常用的函数和方法，以下是其中一些常见的：</p>
<ol>
<li><p><strong><code>at()</code>：</strong> 以安全的方式访问指定位置的元素，并进行边界检查，如果索引超出范围，则抛出 <code>std::out_of_range</code> 异常。</p>
</li>
<li><p><strong><code>operator[]</code>：</strong> 使用下标操作符 <code>[]</code> 访问数组的特定元素。不进行边界检查，因此需要确保索引在合法范围内。</p>
</li>
<li><p><strong><code>front()</code> 和 <code>back()</code>：</strong> 分别返回数组的第一个元素和最后一个元素。</p>
</li>
<li><p><strong><code>data()</code>：</strong> 返回指向数组第一个元素的指针。</p>
</li>
<li><p><strong><code>fill()</code>：</strong> 将数组中的所有元素设置为特定的值。</p>
</li>
<li><p><strong><code>empty()</code>：</strong> 检查数组是否为空，即大小是否为零。</p>
</li>
<li><p><strong><code>size()</code>：</strong> 返回数组中元素的数量。</p>
</li>
<li><p><strong><code>swap()</code>：</strong> 交换两个数组的内容。</p>
</li>
</ol>
<p>这些函数和方法使得 <code>std::array</code> 更加方便和易于使用，可以轻松地进行数组的访问、操作和管理。</p>
<h2 id="std-array-operator"><a href="#std-array-operator" class="headerlink" title="std::array::operator[]"></a>std::array::operator[]</h2><p><code>std::array::operator[]</code> 是 <code>std::array</code> 类中重载的下标访问操作符。它允许像普通数组一样使用 <code>[]</code> 运算符来访问数组中特定位置的元素，但不进行边界检查。</p>
<p>与 <code>std::array::at()</code> 不同，<code>std::array::operator[]</code> 不会检查索引是否超出数组边界。因此，如果使用 <code>[]</code> 运算符访问超出数组范围的索引，将导致未定义行为，可能会读取到未知的内存或导致程序崩溃。</p>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value = arr[<span class="number">2</span>]; <span class="comment">// 访问数组索引为 2 的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value at index 2: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问超出数组范围的索引，这可能导致未定义行为</span></span><br><span class="line">    <span class="type">int</span> out_of_range_value = arr[<span class="number">7</span>];</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value at index 7: &quot;</span> &lt;&lt; out_of_range_value &lt;&lt; std::endl; <span class="comment">// 可能导致程序崩溃或未定义行为</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>arr[2]</code> 访问了数组索引为 2 的元素，而 <code>arr[7]</code> 尝试访问了超出数组范围的索引。请注意，访问超出范围的索引可能会导致程序运行时的不可预测行为。</p>
<h2 id="std-array-front"><a href="#std-array-front" class="headerlink" title="std::array::front()"></a>std::array::front()</h2><p><code>std::array::front()</code> 是 <code>std::array</code> 类提供的成员函数之一，用于获取数组的第一个元素。</p>
<p>它类似于 <code>std::array</code> 的下标访问方式，但是 <code>front()</code> 更直观和语义化，专门用于访问数组的第一个元素。这个函数对于代码的可读性很有帮助，因为它清晰地表达了获取数组第一个元素的意图。</p>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> first_element = arr.<span class="built_in">front</span>(); <span class="comment">// 获取数组的第一个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The first element is: &quot;</span> &lt;&lt; first_element &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>arr.front()</code> 获取了数组 <code>arr</code> 的第一个元素，并将其存储在 <code>first_element</code> 变量中，然后将其打印输出。</p>
<h2 id="std-array-back"><a href="#std-array-back" class="headerlink" title="std::array::back"></a>std::array::back</h2><p><code>std::array::back()</code> 是 <code>std::array</code> 类提供的成员函数之一，用于获取数组的最后一个元素。</p>
<p>与 <code>std::array::front()</code> 类似，<code>std::array::back()</code> 专门用于获取数组的最后一个元素，这样可以更清晰地表达获取最后一个元素的意图，提高代码的可读性。</p>
<p>以下是一个示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> last_element = arr.<span class="built_in">back</span>(); <span class="comment">// 获取数组的最后一个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The last element is: &quot;</span> &lt;&lt; last_element &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>arr.back()</code> 获取了数组 <code>arr</code> 的最后一个元素，并将其存储在 <code>last_element</code> 变量中，然后将其打印输出。</p>
<h2 id="std-array-data"><a href="#std-array-data" class="headerlink" title="std::array::data()"></a>std::array::data()</h2><p><code>std::array::data()</code> 是 <code>std::array</code> 类提供的成员函数之一，用于获取指向数组首元素的指针。</p>
<p>它返回一个指向数组中第一个元素的指针，允许直接访问数组的底层数据。这个函数在需要以 C 风格的函数或需要传递数组数据的情况下很有用，因为它提供了指向数组数据的指针。</p>
<p>以下是一个示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* ptr = arr.<span class="built_in">data</span>(); <span class="comment">// 获取指向数组首元素的指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First element of the array: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>arr.data()</code> 返回指向数组 <code>arr</code> 第一个元素的指针，并将其存储在 <code>ptr</code> 变量中。然后，<code>*ptr</code> 打印出指针所指向的第一个元素的值。</p>
<h2 id="std-array-fill"><a href="#std-array-fill" class="headerlink" title="std::array::fill()"></a>std::array::fill()</h2><p><code>std::array::fill()</code> 是 <code>std::array</code> 类提供的成员函数之一，用于将数组中的所有元素设置为特定的值。</p>
<p>这个函数接受一个参数，用来指定要填充到数组中的值。调用 <code>fill()</code> 函数会将数组中的所有元素都设置为该指定值。</p>
<p>以下是一个示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    arr.<span class="built_in">fill</span>(<span class="number">0</span>); <span class="comment">// 将数组中的所有元素设置为 0</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array after filling with 0s: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>arr.fill(0)</code> 调用将数组 <code>arr</code> 中的所有元素都设置为 0。然后使用循环遍历数组并打印出填充后的数组元素。</p>
<h2 id="std-array-empty"><a href="#std-array-empty" class="headerlink" title="std::array::empty()"></a>std::array::empty()</h2><p><code>std::array::empty()</code> 是 <code>std::array</code> 类提供的成员函数之一，用于检查数组是否为空。</p>
<p>对于 <code>std::array</code> 类型，它的大小是在编译时确定的，因此不会存在空数组的情况。<code>empty()</code> 函数对于 <code>std::array</code> 始终会返回 <code>false</code>，因为它不具备动态大小调整的能力，数组的大小在创建时已经固定。</p>
<p>下面是一个示例代码，展示了 <code>empty()</code> 函数的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Array is empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Array is not empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管调用 <code>empty()</code> 函数并不会报错，但对于 <code>std::array</code> 类型，它永远返回 <code>false</code>，因为该类型的数组大小在创建时就被确定了，不允许为空。</p>
<h2 id="std-array-size"><a href="#std-array-size" class="headerlink" title="std::array::size()"></a>std::array::size()</h2><p><code>std::array::size()</code> 是 <code>std::array</code> 类提供的成员函数之一，用于获取数组中元素的数量。</p>
<p>它返回 <code>std::array</code> 中的元素个数，这个值是在编译时确定的，因为 <code>std::array</code> 是一个固定大小的数组容器。</p>
<p>以下是一个示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of the array: &quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>arr.size()</code> 返回数组 <code>arr</code> 中元素的数量，即 5。这个函数对于确定数组的大小非常方便，可以在不需要硬编码数组大小的情况下获得数组的实际大小。</p>
<h2 id="std-array-swap"><a href="#std-array-swap" class="headerlink" title="std::array::swap()"></a>std::array::swap()</h2><p><code>std::array::swap()</code> 是 <code>std::array</code> 类提供的成员函数之一，用于交换两个数组的内容。</p>
<p>这个函数接受另一个 <code>std::array</code> 作为参数，并交换调用该函数的数组对象和传入的数组对象的内容。要注意的是，这两个数组必须具有相同的大小和类型。</p>
<p>以下是一个示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr2 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array 1 before swap:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; element;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array 2 before swap:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; element;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    arr<span class="number">1.</span><span class="built_in">swap</span>(arr2); <span class="comment">// 交换两个数组的内容</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array 1 after swap:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; element;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array 2 after swap:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; element;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>arr1</code> 和 <code>arr2</code> 的内容被交换。<code>arr1.swap(arr2)</code> 将数组 <code>arr1</code> 和 <code>arr2</code> 的内容互换，使得 <code>arr1</code> 包含原来的 <code>arr2</code> 内容，<code>arr2</code> 包含原来的 <code>arr1</code> 内容。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_8_exception/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_8_exception/" class="post-title-link" itemprop="url">C++_10_8_exception</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <exception> 标准库</li>
</ul>
<h2 id="c-标准库"><a href="#c-标准库" class="headerlink" title="c++ 标准库"></a>c++ <exception>标准库</h2><p><code>&lt;exception&gt;</code> 标准库提供了异常处理相关的功能，包含了一些用于异常处理的类和函数。在 C++ 中，异常处理允许程序在运行时检测到错误，并且在适当的地方进行处理，而不是导致程序异常终止。</p>
<p>一些 <code>&lt;exception&gt;</code> 标准库中的重要组件包括：</p>
<ol>
<li><p><strong><code>std::exception</code> 类：</strong> 是所有标准异常类的基类。它定义了一些公共成员函数，如 <code>what()</code>，用于返回异常的描述信息。</p>
</li>
<li><p><strong>标准异常类：</strong> 包括 <code>std::bad_alloc</code>、<code>std::bad_cast</code>、<code>std::bad_exception</code>、<code>std::bad_typeid</code>、<code>std::logic_error</code> 和 <code>std::runtime_error</code> 等。这些类继承自 <code>std::exception</code>，用于表示不同类型的异常情况。</p>
</li>
<li><p><strong>异常处理关键字：</strong> <code>try</code>、<code>catch</code> 和 <code>throw</code>。<code>try</code> 用于包裹可能引发异常的代码块，<code>catch</code> 用于捕获并处理异常，<code>throw</code> 用于抛出异常。</p>
</li>
<li><p><strong><code>std::nested_exception</code>：</strong> 这是一个模板类，它允许异常在一个异常处理器中重新抛出。</p>
</li>
</ol>
<p>通过使用 <code>&lt;exception&gt;</code> 标准库，程序员可以更加精细地控制代码中可能出现的异常，并且可以根据情况进行处理或传递异常信息，从而提高程序的健壮性和可靠性。</p>
<h2 id="c-标准库-详解"><a href="#c-标准库-详解" class="headerlink" title="c++ 标准库 详解"></a>c++ <exception>标准库 详解</h2><p><code>&lt;exception&gt;</code> 标准库提供了在 C++ 中处理异常的相关功能。以下是该标准库中的一些重要组件和使用方法的详细解释：</p>
<ol>
<li><p><strong><code>std::exception</code> 类：</strong> 是所有标准异常类的基类。它包含了一个虚拟成员函数 <code>what()</code>，允许派生类提供描述异常的字符串。程序员通常通过继承 <code>std::exception</code> 来创建自定义异常类，并重写 <code>what()</code> 函数以提供特定异常的描述信息。</p>
</li>
<li><p><strong>标准异常类：</strong> <code>std::exception</code> 的派生类包括：</p>
<ul>
<li><code>std::bad_alloc</code>：用于表示动态分配内存失败的情况。</li>
<li><code>std::bad_cast</code>：用于表示类型转换失败的情况。</li>
<li><code>std::bad_exception</code>：用于表示异常规范（exception specifications）未匹配的情况。</li>
<li><code>std::bad_typeid</code>：用于表示 typeid 运算符失败的情况。</li>
<li><code>std::logic_error</code>：用于表示在程序逻辑上可被预见的异常。</li>
<li><code>std::runtime_error</code>：用于表示在运行时可能发生的异常。</li>
</ul>
</li>
<li><p><strong>异常处理关键字：</strong></p>
<ul>
<li><code>try</code>：用于将可能引发异常的代码块包裹起来。</li>
<li><code>catch</code>：用于捕获和处理 <code>try</code> 块中抛出的异常。</li>
<li><code>throw</code>：用于手动抛出异常对象。</li>
</ul>
</li>
<li><p><strong><code>std::nested_exception</code>：</strong> 这个模板类允许异常在一个异常处理器中重新抛出。它允许在捕获异常后保留异常信息，然后在另一个上下文中重新抛出异常。</p>
</li>
</ol>
<p>异常处理是一种用于控制程序在遇到错误时如何处理的机制。通过 <code>&lt;exception&gt;</code> 标准库，程序员可以使用异常来跳出错误的代码块并在适当的地方进行处理，而不是让程序非正常终止。这有助于提高程序的可靠性和健壮性。</p>
<h2 id="c-标准库-常用函数"><a href="#c-标准库-常用函数" class="headerlink" title="c++ 标准库 常用函数"></a>c++ <exception>标准库 常用函数</h2><p><code>&lt;exception&gt;</code> 标准库并未提供太多直接调用的函数，但它定义了一些关键的类和机制来处理异常。以下是一些常用的函数和类：</p>
<ol>
<li><p><strong><code>std::exception</code>：</strong> 是所有标准异常类的基类，它包含了一个虚拟成员函数 <code>what()</code>，用于返回描述异常的字符串。常用于自定义异常类的基类。</p>
</li>
<li><p><strong>标准异常类：</strong> 派生自 <code>std::exception</code>，如 <code>std::bad_alloc</code>、<code>std::bad_cast</code>、<code>std::logic_error</code> 和 <code>std::runtime_error</code> 等。每个异常类都可以通过构造函数接受字符串来描述异常。</p>
</li>
<li><p><strong>异常处理关键字：</strong> <code>try</code>、<code>catch</code> 和 <code>throw</code>。</p>
<ul>
<li><code>try</code> 用于包裹可能引发异常的代码块。</li>
<li><code>catch</code> 用于捕获并处理 <code>try</code> 块中抛出的异常，其语法为 <code>catch (const SomeExceptionType&amp; ex)</code>。</li>
<li><code>throw</code> 用于手动抛出异常对象，可以是标准异常类的实例或者用户自定义的异常类的实例。</li>
</ul>
</li>
<li><p><strong><code>std::nested_exception</code>：</strong> 模板类允许异常在一个异常处理器中重新抛出，以便在另一个上下文中处理异常。</p>
</li>
</ol>
<p>虽然 <code>&lt;exception&gt;</code> 标准库并不包含太多的直接函数，但它提供了一套机制和类，可以帮助程序员在程序执行过程中检测和处理异常，从而提高程序的可靠性和健壮性。</p>
<h2 id="std-exception"><a href="#std-exception" class="headerlink" title="std::exception"></a>std::exception</h2><p><code>std::exception</code> 是 C++ 标准库 <code>&lt;exception&gt;</code> 中的一个类，是所有标准异常类的基类。它被设计为一个抽象基类，用于派生出各种不同类型的异常类，以表示不同的异常情况。</p>
<p><code>std::exception</code> 包含了一个虚拟成员函数 <code>what()</code>，允许派生类提供描述异常的字符串。派生类应该覆盖 <code>what()</code> 函数，并返回一个 C 风格的字符串，描述了异常的信息。</p>
<p>例如，下面是一个简单的例子展示了如何使用 <code>std::exception</code> 的派生类，并重写 <code>what()</code> 函数来提供异常信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This is a custom exception.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>MyException</code> 是一个自定义异常类，它继承自 <code>std::exception</code>。它重写了 <code>what()</code> 函数，返回一个描述异常信息的字符串。在 <code>main()</code> 函数中，<code>throw MyException()</code> 语句抛出一个 <code>MyException</code> 类的实例，然后在 <code>catch</code> 块中捕获并打印异常信息。</p>
<h2 id="std-bad-alloc"><a href="#std-bad-alloc" class="headerlink" title="std::bad_alloc"></a>std::bad_alloc</h2><p><code>std::bad_alloc</code> 是 C++ 标准库 <code>&lt;exception&gt;</code> 中的一个异常类，它是 <code>std::exception</code> 的一个派生类。<code>std::bad_alloc</code> 类通常用于表示动态内存分配失败的情况，比如使用 <code>new</code> 操作符申请内存时，如果内存不足或分配失败，就会抛出这个异常。</p>
<p>这个异常通常在需要动态分配内存（比如使用 <code>new</code>、<code>malloc</code> 或其他动态内存分配方式）的情况下使用。如果动态内存分配失败，比如尝试分配比系统可用内存还多的内存时，就会抛出 <code>std::bad_alloc</code> 异常。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span>* myArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10000000000000000</span>]; <span class="comment">// 尝试分配一个非常大的数组</span></span><br><span class="line">        <span class="keyword">delete</span>[] myArray;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught bad_alloc exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>new int[10000000000000000]</code> 尝试分配一个非常大的数组，可能超出系统可用内存的范围，因此会抛出 <code>std::bad_alloc</code> 异常。<code>catch</code> 块捕获这个异常，并打印出异常信息。</p>
<h2 id="std-bad-cast"><a href="#std-bad-cast" class="headerlink" title="std::bad_cast"></a>std::bad_cast</h2><p><code>std::bad_cast</code> 是 C++ 标准库 <code>&lt;exception&gt;</code> 中的一个异常类，它是 <code>std::exception</code> 的一个派生类。<code>std::bad_cast</code> 类通常用于表示在类型转换失败的情况下抛出的异常。</p>
<p>这个异常通常与 C++ 中的类型转换运算符 <code>dynamic_cast</code> 相关。当使用 <code>dynamic_cast</code> 进行转换时，如果无法将一个指针或引用转换为所需的目标类型，则会抛出 <code>std::bad_cast</code> 异常。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (derivedPtr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Successful dynamic_cast.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">typeid</span>(*basePtr) == <span class="built_in">typeid</span>(Derived)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">bad_cast</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">catch</span>(<span class="type">const</span> std::bad_cast&amp; e) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Caught bad_cast exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Base</code> 和 <code>Derived</code> 是类的继承关系。在 <code>main()</code> 函数中，使用 <code>dynamic_cast</code> 尝试将 <code>Base</code> 指针 <code>basePtr</code> 转换为 <code>Derived</code> 类型的指针 <code>derivedPtr</code>。如果转换失败，<code>dynamic_cast</code> 返回 <code>nullptr</code>。在这种情况下，通过 <code>typeid</code> 运算符检查类型，如果类型不匹配，则手动抛出 <code>std::bad_cast</code> 异常。<code>catch</code> 块捕获这个异常，并打印出异常信息。</p>
<h2 id="std-bad-exception"><a href="#std-bad-exception" class="headerlink" title="std::bad_exception"></a>std::bad_exception</h2><p><code>std::bad_exception</code> 是 C++ 标准库 <code>&lt;exception&gt;</code> 中的一个异常类，它是 <code>std::exception</code> 的一个派生类。<code>std::bad_exception</code> 类通常用于表示异常规范（exception specifications）未匹配的情况。</p>
<p>在 C++ 中，异常规范（exception specifications）被用来指定一个函数可以抛出的异常类型。如果一个函数声明了它可以抛出某种异常类型，但在实际执行中抛出了不属于这个类型的异常，那么就会抛出 <code>std::bad_exception</code> 异常。</p>
<p>需要注意的是，异常规范在 C++ 中并不是强制性的，而且在现代 C++ 中，使用异常规范的做法已经不再推荐，因为它们在实际应用中存在一些问题，例如可能导致程序终止。</p>
<p>以下是一个简单的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">10</span>; <span class="comment">// 抛出一个 int 类型的异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">myFunction</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught bad_exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>myFunction()</code> 声明了它可以抛出异常（使用 <code>noexcept(false)</code>），但实际上抛出了一个 <code>int</code> 类型的异常。由于 <code>std::bad_exception</code> 指示了异常规范不匹配的情况，所以在 <code>catch</code> 块中捕获了 <code>std::bad_exception</code> 并打印出异常信息。</p>
<h2 id="std-bad-typeid"><a href="#std-bad-typeid" class="headerlink" title="std::bad_typeid"></a>std::bad_typeid</h2><p><code>std::bad_typeid</code> 是 C++ 标准库 <code>&lt;exception&gt;</code> 中的一个异常类，它是 <code>std::exception</code> 的一个派生类。<code>std::bad_typeid</code> 类通常用于表示 <code>typeid</code> 运算符失败的情况。</p>
<p>在 C++ 中，<code>typeid</code> 运算符可以用来获取对象的类型信息。如果 <code>typeid</code> 运算符无法识别对象的类型，比如对象为空指针或者对象类型是不可识别的，则会抛出 <code>std::bad_typeid</code> 异常。</p>
<p>以下是一个简单的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">const</span> std::type_info&amp; info = <span class="built_in">typeid</span>(<span class="literal">nullptr</span>); <span class="comment">// typeid 对空指针的运算</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Type info: &quot;</span> &lt;&lt; info.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_typeid&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught bad_typeid: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>typeid(nullptr)</code> 尝试获取空指针的类型信息，由于空指针不引用任何实际对象，因此 <code>typeid</code> 运算符无法获取其类型信息，导致抛出 <code>std::bad_typeid</code> 异常。<code>catch</code> 块捕获这个异常，并打印出异常信息。</p>
<h2 id="std-logic-error"><a href="#std-logic-error" class="headerlink" title="std::logic_error"></a>std::logic_error</h2><p><code>std::logic_error</code> 是 C++ 标准库 <code>&lt;stdexcept&gt;</code> 头文件中的一个异常类，它是 <code>std::exception</code> 的一个派生类。<code>std::logic_error</code> 类通常用于表示在程序逻辑上可被预见的异常情况。</p>
<p><code>std::logic_error</code> 类及其派生类用于表示在程序执行期间由于程序逻辑错误导致的异常，这些错误是可以在代码设计阶段预见到的。例如，当函数接收到不合理的参数时，可能会抛出 <code>std::logic_error</code> 异常。</p>
<p>以下是一个简单的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;Division by zero is not allowed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of division: &quot;</span> &lt;&lt; x / y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>); <span class="comment">// 尝试对 10 进行除以 0 的操作</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::logic_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught logic_error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>divide()</code> 函数用于执行除法操作，但在除数为 0 的情况下会抛出 <code>std::logic_error</code> 异常。在 <code>main()</code> 函数中，<code>divide(10, 0)</code> 尝试对 10 进行除以 0 的操作，触发了异常，并在 <code>catch</code> 块中捕获并打印出异常信息。</p>
<h2 id="std-runtime-error"><a href="#std-runtime-error" class="headerlink" title="std::runtime_error"></a>std::runtime_error</h2><p><code>std::runtime_error</code> 是 C++ 标准库 <code>&lt;stdexcept&gt;</code> 头文件中的一个异常类，它是 <code>std::exception</code> 的一个派生类。<code>std::runtime_error</code> 类通常用于表示在程序运行期间可能发生的异常情况。</p>
<p><code>std::runtime_error</code> 类及其派生类用于表示在程序运行期间由于不可预测的情况导致的异常，例如文件打开失败、内存不足等。与 <code>std::logic_error</code> 不同，<code>std::runtime_error</code> 表示的异常是在运行时才能被检测到的，而不是在程序设计阶段就可以预见到的。</p>
<p>以下是一个简单的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设在打开文件时可能发生异常</span></span><br><span class="line">    <span class="comment">// 这里使用 std::ifstream 模拟文件操作</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to open the file.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他文件操作...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">processFile</span>(<span class="string">&quot;nonexistent_file.txt&quot;</span>); <span class="comment">// 尝试处理一个不存在的文件</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught runtime_error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>processFile()</code> 函数尝试打开一个文件。如果文件打开失败，就会抛出 <code>std::runtime_error</code> 异常。在 <code>main()</code> 函数中，<code>processFile(&quot;nonexistent_file.txt&quot;)</code> 尝试处理一个不存在的文件，触发了异常，并在 <code>catch</code> 块中捕获并打印出异常信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++_%E7%BC%96%E8%AF%91%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++_%E7%BC%96%E8%AF%91%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">C++_编译基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p><code>gcc</code>和<code>g++</code>分别是<code>GNU</code>的C和<code>C++</code>编译器。<code>gcc</code>和<code>g++</code>在执行编译工作的时候，总共四步：</p>
<ul>
<li>预处理，生成<code>.i</code>文件{预处理器  –  <code>cpp</code>}</li>
<li>将预处理后的文件转换成汇编语言，生成文件.s{编译器  –  <code>egcs</code>}</li>
<li>由汇编变为目标代码（机器代码）生成.o的文件{汇编器  –  <code>as</code>}</li>
<li>链接目标代码，生成可执行程序{链接器  –  <code>ld</code>}</li>
</ul>
</li>
<li><p>参数：</p>
<ul>
<li><code>-c</code>：只激活预处理、编译和汇编，生成<code>obj</code>文件<code>.o</code></li>
<li><code>-S</code>：只激活预处理和编译，生成汇编代码</li>
<li><code>-I</code>：指定头文件所在路径</li>
<li><code>-L</code>：指定库文件所在路径</li>
<li><code>-l</code>：指定库的名字</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li><code>GCC</code>是一个驱动式的程序，它调用其他程序来依次进行编译、汇编和链接</li>
<li><code>GCC</code>分析命令行参数，然后决定该调用哪一个子程序，哪些参数应该传递给子程序。所有这些行为都是由<code>SPEC</code>字符串（<code>spec strings</code>）来控制的。</li>
<li>通常情况下，每一个<code>GCC</code>可以调用的子程序都对应着一个<code>SPEC</code>字符串，不过有少数的子程序需要多个<code>SPEC</code>字符串来控制他们的行为。</li>
</ul>
</li>
<li><p>深入理解计算机操作系统 P109</p>
<ul>
<li>试图最大化一段关键代码性能的程序员,通常会尝试源代码的各种形式,每次编译并检查产生的汇编代码,从而了解程序将要运行的效率如何</li>
<li>此外,有些时候,高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行为</li>
</ul>
</li>
</ul>
<h2 id="GCC参数"><a href="#GCC参数" class="headerlink" title="GCC参数"></a>GCC参数</h2><ul>
<li><p><code>-x language filename</code></p>
<ul>
<li>设定文件所使用的语言, 使后缀名无效, 对以后的多个有效。</li>
<li>也就是根据约定 <code>C</code> 语言的后缀名称是 <code>.c</code> 的，而 <code>C++</code> 的后缀名是 <code>.C</code> 或者 <code>.cpp</code></li>
<li>可以使用的参数：<ul>
<li><code>c</code></li>
<li><code>objective-c</code></li>
<li><code>c-header</code></li>
<li><code>c++</code></li>
<li><code>cpp-output</code></li>
<li><code>assembler</code></li>
<li><code>assembler-with-cpp</code></li>
</ul>
</li>
<li>例如：<code>gcc -x c hello.pig</code></li>
</ul>
</li>
<li><p><code>-x none filename</code></p>
<ul>
<li>关掉上一个选项，也就是让gcc根据文件名后缀，自动识别文件类型 。</li>
</ul>
</li>
<li><p><code>-pipe</code></p>
<ul>
<li>使用管道代替编译中临时文件, 在使用非 gnu 汇编工具的时候, 可能有些问题</li>
<li>例如：<code>gcc -pipe -o hello.exe hello.c</code></li>
</ul>
</li>
<li><p><code>-ansi</code></p>
<ul>
<li>关闭 <code>gnu c</code>中与 <code>ansi c</code> 不兼容的特性, 激活 <code>ansi c</code> 的专有特性（包括禁止一些 <code>asm</code> <code>inline</code> <code>typeof</code> 关键字, 以及 <code>UNIX</code>,<code>vax</code> 等预处理宏）</li>
</ul>
</li>
<li><p><code>-fno-asm</code></p>
<ul>
<li>此选项实现 <code>ansi</code> 选项的功能的一部分，它禁止将 <code>asm</code>, <code>inline</code> 和 <code>typeof</code> 用作关键字。</li>
</ul>
</li>
<li><p><code>-fno-strict-prototype</code></p>
<ul>
<li>只对 <code>g++</code> 起作用,</li>
<li>使用这个选项, <code>g++</code> 将对不带参数的函数,都认为是没有显式的对参数的个数和类型说明,而不是没有参数</li>
<li>而 <code>gcc</code> 无论是否使用这个参数, 都将对没有带参数的函数, 认为没有显式说明的类型</li>
</ul>
</li>
<li><p><code>-fthis-is-varialble</code></p>
<ul>
<li>就是向传统 <code>c++</code> 看齐, 可以使用 <code>this</code> 当一般变量使用</li>
</ul>
</li>
<li><p><code>-fcond-mismatch</code></p>
<ul>
<li>允许条件表达式的第二和第三参数类型不匹配, 表达式的值将为 <code>void</code> 类型</li>
</ul>
</li>
<li><p><code>-funsigned-char</code> 、<code>-fno-signed-char</code>、<code>-fsigned-char</code> 、<code>-fno-unsigned-char</code></p>
<ul>
<li>这四个参数是对 <code>char</code> 类型进行设置, 决定将 <code>char</code> 类型设置成 unsigned char(前两个参数)或者 signed char(后两个参数)。</li>
</ul>
</li>
<li><p><code>-include file</code></p>
<ul>
<li>包含某个代码,简单来说,就是便以某个文件,需要另一个文件的时候,就可以用它设定,</li>
<li>功能就相当于在代码中使用 <code>#include&lt;filename&gt;</code></li>
</ul>
</li>
<li><p><code>-imacros file</code></p>
<ul>
<li>将 file 文件的宏, 扩展到 gcc&#x2F;g++ 的输入文件, 宏定义本身并不出现在输入文件中</li>
</ul>
</li>
<li><p><code>-Dmacro</code></p>
<ul>
<li>定义宏<code>macro</code></li>
<li>相当于 <code>C</code> 语言中的 <code>#define macro</code></li>
</ul>
</li>
<li><p><code>-Umacro</code></p>
<ul>
<li>相当于 <code>C</code> 语言中的 <code>#undef macro</code></li>
</ul>
</li>
<li><p><code>-undef</code></p>
<ul>
<li>取消对任何非标准宏的定义</li>
</ul>
</li>
<li><p><code>-Idir</code></p>
<ul>
<li>在你是用 <code>#include &quot;file&quot;</code> 的时候, <code>gcc/g++</code> 会先在当前目录查找你所制定的头文件, 如果没有找到, 他回到默认的头文件目录找, 如果使用 <code>-I</code> 制定了目录,他会先在你所制定的目录查找, 然后再按常规的顺序去找</li>
<li>对于 <code>#include&lt;file&gt;</code>, <code>gcc/g++</code> 会到 <code>-I</code> 制定的目录查找, 查找不到, 然后将到系统的默认的头文件目录查找</li>
</ul>
</li>
<li><p><code>-C</code></p>
<ul>
<li>在预处理的时候, 不删除注释信息, 一般和-E使用, 有时候分析程序，用这个很方便的</li>
</ul>
</li>
<li><p><code>-Wa,option</code></p>
<ul>
<li>此选项传递 <code>option</code> 给汇编程序; 如果 <code>option</code> 中间有逗号, 就将 <code>option</code> 分成多个选项, 然 后传递给会汇编程序</li>
</ul>
</li>
<li><p><code>-Wl.option</code></p>
<ul>
<li>此选项传递 <code>option</code> 给链接程序; 如果 <code>option</code> 中间有逗号, 就将 <code>option</code> 分成多个选项, 然后传递给会链接程序</li>
</ul>
</li>
<li><p><code>-llibrary</code></p>
<ul>
<li>制定编译的时候使用的库</li>
</ul>
</li>
<li><p><code>-Ldir</code></p>
<ul>
<li>制定编译的时候，搜索库的路径。比如你自己的库，可以用它制定目录，不然编译器将只在标准库的目录找。这个<code>dir</code>就是目录的名称</li>
</ul>
</li>
<li><p><code>-O0 、-O1 、-O2 、-O3</code></p>
<ul>
<li>编译器的优化选项的 4 个级别，-O0 表示没有优化, -O1 为默认值，-O3 优化级别最高</li>
</ul>
</li>
<li><p><code>-g</code></p>
<ul>
<li>只是编译器，在编译的时候，产生调试信息</li>
</ul>
</li>
<li><p><code>-ggdb</code></p>
<ul>
<li>此选项将尽可能的生成 <code>gdb</code> 的可以使用的调试信息</li>
</ul>
</li>
<li><p><code>-static</code></p>
<ul>
<li>此选项将禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么动态连接库，就可以运行。</li>
</ul>
</li>
<li><p><code>-share</code></p>
<ul>
<li>此选项将尽量使用动态库，所以生成文件比较小，但是需要系统有动态库。</li>
</ul>
</li>
<li><p><code>-traditional</code></p>
<ul>
<li>试图让编译器支持传统的C语言特性。</li>
<li><code>GCC</code> 是 <code>GNU</code> 的 <code>C</code> 和 <code>C++</code> 编译器。实际上，<code>GCC</code> 能够编译三种语言：<code>C</code>、<code>C++</code> 和 <code>Object C</code>（<code>C</code> 语言的一种面向对象扩展）。</li>
<li>利用 <code>gcc</code> 命令可同时编译并连接 <code>C</code> 和 <code>C++</code> 源程序。</li>
</ul>
</li>
</ul>
<h2 id="编译器的工作过程"><a href="#编译器的工作过程" class="headerlink" title="编译器的工作过程"></a>编译器的工作过程</h2><h3 id="配置-configure"><a href="#配置-configure" class="headerlink" title="配置(configure)"></a>配置(configure)</h3><ul>
<li>编译器在开始工作之前,需要知道当前的系统环境,比如标准库在哪里,软件的安装位置在哪里,需要安装那些组件等等.</li>
<li>这是因为不同计算机的系统环境不一样,通过指定编译参数,编译器就可以灵活适应环境,编译出各种环境都能运行的机器码,<strong>这个确定编译参数的步骤,就叫做”配置(configure)”</strong></li>
<li>这些配置信息保存在一个配置文件中,约定俗成是一个叫做<code>configure</code>的脚本文件.通常它是由<code>autoconf</code>工具生成的.编译器通过运行这个脚本,获得编译参数</li>
</ul>
<h3 id="确定标准库和头文件的位置"><a href="#确定标准库和头文件的位置" class="headerlink" title="确定标准库和头文件的位置"></a>确定标准库和头文件的位置</h3><ul>
<li>源码肯定会用到标准库函数(standard library)和头文件(header).它们可以放在系统的任意目录中,编译器实际上没有办法自动检测它们的位置,只有通过配置文件才能知道</li>
<li>编译的第二步,就是从配置文件中知道标准库和头文件的位置.一般来说,配置文件会给出一个清单,列出几个具体的目录.等到编译时,编译器就按顺序到这几个目录中,寻找目标</li>
</ul>
<h3 id="确定依赖关系"><a href="#确定依赖关系" class="headerlink" title="确定依赖关系"></a>确定依赖关系</h3><ul>
<li>对于大型项目来说,源码之间往往存在依赖关系,编译器需要确定编译的先后顺序.假设A文件依赖于B文件,编译器应该保证做到:<strong>只有在B文件编译完成后,才开始编译A文件;当B文件发生变化时,A文件会被重新编译</strong></li>
<li>编译顺序保存在一个叫做<code>makefile</code>的文件中,里面列出哪个文件先编译,哪个文件后编译.而<code>makefile</code>文件由<code>configure</code>脚本运行生成,这就是<strong>为什么编译时configure必须首先运行的原因</strong></li>
</ul>
<h3 id="头文件的预编译-precompilation"><a href="#头文件的预编译-precompilation" class="headerlink" title="头文件的预编译(precompilation)"></a>头文件的预编译(precompilation)</h3><ul>
<li>不同的源码文件,可能引用同一个头文件,编译的时候,头文件也必须一起编译</li>
<li>为了节省时间,编译器会在编译源码之前,先编译头文件.这保证了头文件只需编译一次,不必每次用到的时候都需要重新编译</li>
<li>不过,并不是头文件的所有内容都会被预编译,用来声明宏的<code>#define</code>命令,就不会被预编译</li>
</ul>
<h3 id="预处理-preprocessing"><a href="#预处理-preprocessing" class="headerlink" title="预处理(preprocessing)"></a>预处理(preprocessing)</h3><ul>
<li>预编译完成后,编译器就开始替换掉源码中bash的头文件和宏,编译器在这一步还会移除注释</li>
</ul>
<h3 id="编译-Compilation"><a href="#编译-Compilation" class="headerlink" title="编译(Compilation)"></a>编译(Compilation)</h3><ul>
<li>预处理之后,编译器就开始生成机器码.</li>
<li>对于某些编译器来说,还存在一个中间步骤,会先把源码转为汇编码(<code>assembly</code>),然后再把汇编码转为机器码</li>
<li>这种转码后的文件称为对象文件(<code>object file</code>)</li>
</ul>
<h3 id="连接-Linking"><a href="#连接-Linking" class="headerlink" title="连接(Linking)"></a>连接(Linking)</h3><ul>
<li>把外部函数的代码(通常是后缀名为<code>.lib</code>和<code>.a</code>的文件),添加到可执行文件中,这就叫做连接(linking).</li>
<li>这种通过拷贝,将外部函数库添加到可执行文件的方式,叫做静态连接(static linking)</li>
<li><code>make</code>命令的作用,就是<strong>从第四步头文件预编译开始,一直到做完这一步.</strong></li>
</ul>
<h3 id="安装-Installation"><a href="#安装-Installation" class="headerlink" title="安装(Installation)"></a>安装(Installation)</h3><ul>
<li>上一步的连接是在<strong>内存</strong>中进行的,即编译器在内存中生成了可执行文件.下一步,必须将可执行文件保存到用户事先指定的安装目录</li>
<li>表面上,这一步就是将可执行文件(连带相关的数据文件)拷贝过去,但是实际上,这一步还必须完成创建目录,保存文件,设置权限等步骤,这整个的过程就称为”安装(Installation)”</li>
</ul>
<h3 id="操作系统连接"><a href="#操作系统连接" class="headerlink" title="操作系统连接"></a>操作系统连接</h3><ul>
<li>可执行文件安装后,必须以某种方式通知操作系统,让其知道可以使用这个程序了</li>
<li>这就要求在操作系统中,登记这个程序的元数据:文件名,文件描述,关联后缀名等等.linux系统中,这些信息通常保存在<code>/usr/share/applications/</code>目录下的<code>.desktop</code>文件中.另外在windows操作系统中,还需要在start启动菜单中,建立一个快捷方式</li>
<li>这些事情就叫做”操作系统连接”.<code>make install</code>命令,就用来完成”安装”和”操作系统连接”这两步</li>
</ul>
<h3 id="生成安装包"><a href="#生成安装包" class="headerlink" title="生成安装包"></a>生成安装包</h3><ul>
<li>到这一步,源码编译的整个过程就基本完成了,但是事实上,如果只有源码可以交给用户,是不可行的,大部分用户要的是一个二进制的可执行程序,立刻就能运行.这就要求开发者,将上一步生成的可执行文件,做成可以分发的安装包</li>
<li>所以,编译器还必须有生成安装包的功能,通常是将可执行文件(连带相关的数据文件),以某种目录结构,保存成压缩文件包,交给用户</li>
</ul>
<h3 id="动态连接-Dynamic-linking"><a href="#动态连接-Dynamic-linking" class="headerlink" title="动态连接(Dynamic linking)"></a>动态连接(Dynamic linking)</h3><ul>
<li>静态连接就是把外部函数库,拷贝到可执行文件中,这样做的好处是:适用范围较广,不用担心用户机器缺少某个库文件;缺点是:安装包会比较大,而且多个应用程序之间,无法共享文件.</li>
<li>动态连接的做法正好相反,外部函数库不进入安装包,只在运行时动态引用.这样做的好处是:安装包比较小,多个应用程序可以共享文件;缺点是:用户必须事先安装好库文件,而且版本和安装位置都必须符合要求,否则就不能正常运行</li>
</ul>
<h2 id="ld-–-GNU-linker（连接器）"><a href="#ld-–-GNU-linker（连接器）" class="headerlink" title="ld – GNU linker（连接器）"></a>ld – GNU linker（连接器）</h2><ul>
<li>概述：<ul>
<li>ld 合并一组目标文件(<code>object</code>)和库文件(<code>archive</code>),重定位数据部分,构建符号引用(<code>symbolreference</code>).</li>
<li>一般说来,编译生成可执行文件的最后步骤就是调用<code>ld</code></li>
</ul>
</li>
</ul>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul>
<li><p><code>-rpath directory</code></p>
<ul>
<li>增加一条对运行时(<code>runtime</code>)库的搜索路径. 这个选项用于连接<code>ELF</code>可执行文件和共享目标库</li>
<li>所有<code>-rpath</code>选项的参数被合并,然后一起传递给运行时<code>linker</code>,运行时<code>linker</code>在运行的时候使用这些路径寻找共享目标库. </li>
<li>如果连接<code>ELF</code>可执行文件时没有指定<code>-rpath</code>选项,<code>linker</code>就使用环境变量<code>LD_RUN_PATH</code>的内容,只要这个环境变量存在.</li>
</ul>
</li>
<li><p><code>-Wl</code></p>
<ul>
<li>如果通过编译器驱动程序（例如 <code>gcc</code>）间接调用链接器，则所有链接器命令行选项都应以<code>-Wl</code>为前缀</li>
<li>这很重要，因为否则编译器驱动程序可能会默默地删除链接器选项，从而导致链接错误</li>
</ul>
</li>
<li><p><code>-s</code></p>
<ul>
<li>去掉输出文件中的全部符号信息</li>
</ul>
</li>
<li><p><code>-g</code></p>
<ul>
<li>虚设项;用于兼容其他工具</li>
</ul>
</li>
</ul>
<h2 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h2><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><ul>
<li><p><code>-fPIC</code></p>
<ul>
<li>如果目标机器支持，则发出与位置无关的代码，适用于动态链接并避免对全局偏移表大小的任何限制</li>
<li>与位置无关的代码需要特殊支持，因此仅适用于某些机器</li>
<li>设置此标志时，宏“__pic__”和“__PIC__”被定义为 2</li>
</ul>
</li>
<li><p><code>-Wno-unused-variable</code></p>
<ul>
<li>不显示未使用的变量告警</li>
</ul>
</li>
<li><p><code>-Wno-unused-result</code></p>
<ul>
<li>不要警告标记了属性的函数的调用者是否使用它的返回值<code>warn_unused_result</code>（请参阅函数属性）。默认是<code>-Wunused-</code>结果</li>
</ul>
</li>
<li><p><code>-Wno-deprecated-declarations</code></p>
<ul>
<li>不要警告使用属性标记为弃用的函数（请参阅函数属性），变量（请参阅变量属性）和类型（请参阅类型属性）<code>deprecated</code></li>
</ul>
</li>
<li><p><code>-DMACRO</code></p>
<ul>
<li>以字符串”1”定义 <code>MACRO</code> 宏</li>
</ul>
</li>
<li><p><code>-DMACRO=DEFN</code></p>
<ul>
<li>以字符串”DEFN”定义 <code>MACRO</code> 宏。</li>
</ul>
</li>
<li><p><code>-DVERSION_MAJOR=$&#123;VERSION_MAJOR&#125;</code></p>
<ul>
<li>以变量 <code>VERSION_MAJOR</code> 定义 <code>VERSION_MAJOR</code> 宏</li>
</ul>
</li>
<li><p><code>-funroll-loops</code></p>
<ul>
<li>循环展开，可以减少循环的次数，对程序的性能带了两方面的提高</li>
<li>一是，减少了对循环没有直接贡献的计算，比如循环计数变量的计算，分支跳转指令的执行等</li>
<li>二是，提供了进一步利用机器特性进行的优化的机会</li>
</ul>
</li>
<li><p><code>-march=cpu-type</code></p>
<ul>
<li>优化选项。指定目标架构的名字，以及（可选的）一个或多个功能修饰符。 </li>
<li>此选项的格式为: <code>-march = arch &#123;+ [no] feature&#125; *</code></li>
</ul>
</li>
</ul>
<h2 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul>
<li><p>从运行时的依赖关系来看 ： </p>
<ul>
<li>对性能有较大影响的组件有 kernel 和 glibc ，虽然这严格说来这不属于本文的话题，但是经过精心选择、精心配置、精心编译的内核与C库将对提高系统的运行速度起着基础性的作用</li>
</ul>
</li>
<li><p>从被编译的软件包来看 ： </p>
<ul>
<li>每个软件包的 configure 脚本都提供了许多配置选项，其中有许多选项是与性能息息相关的。比如，对于 Apache-2.2.6 而言，你可以使用 –enable-MODULE&#x3D;static 将模块静态编译进核心，使用 –disable-MODULE 禁用不需要的模块，使用 –with-mpm&#x3D;MPM 选择一个高效的多路处理模块，在不需要IPv6的情况下使用 –disable-ipv6 禁用IPv6支持，在不使用线程化的MPM时使用 –disable-threads 禁用线程支持，等等……这部分内容显然不可能在本文中进行完整的讲述，本文只能讲述与优化相关的通用选项。针对特定的软件包，请在编译前使用 configure –help 查看所有选项，并精心选择。</li>
</ul>
</li>
<li><p>从编译过程自身来看 ： </p>
<ul>
<li>将源代码编译为二进制文件是在 Makefile 文件的指导下，由 make 程序调用一条条编译命令完成的。而将源代码编译为二进制文件又需要经过以下四个步骤：预处理(cpp) → 编译(gcc或g++) → 汇编(as) → 连接(ld) ；括号中表示每个阶段所使用的程序，它们分别属于 GCC 和 Binutils 软件包。显然的，优化应当从编译工具自身的选择以及控制编译工具的行为入手</li>
</ul>
</li>
</ul>
<h3 id="编译工具的选择"><a href="#编译工具的选择" class="headerlink" title="编译工具的选择"></a>编译工具的选择</h3><ul>
<li>对于编译工具自身的选择，在假定使用 Binutils 和 GCC 以及 Make 的前提下，没什么好说的，基本上新版本都能带来性能提升，同时比老版本对新硬件的支持更好，所以应当尽量选用新版本。不过追新也可能带来系统的不稳定，这 就要针对实际情况进行权衡了</li>
</ul>
<h3 id="CC和CXX"><a href="#CC和CXX" class="headerlink" title="CC和CXX"></a>CC和CXX</h3><ul>
<li>这是 C 与 C++ 编译器命令。默认值一般是 “gcc” 与 “g++”</li>
</ul>
<h3 id="CPPFLAGS"><a href="#CPPFLAGS" class="headerlink" title="CPPFLAGS"></a>CPPFLAGS</h3><ul>
<li><p>这是用于预处理阶段的选项。不过能够用于此变量的选项，看不出有哪个与优化相关。如果你实在想设一个，那就使用下面这两个吧：</p>
</li>
<li><p><code>-DNDEBUG</code></p>
<ul>
<li>“NDEBUG”是一个标准的 ANSI 宏，表示不进行调试编译。</li>
</ul>
</li>
<li><p><code>-D_FILE_OFFSET_BITS=64</code></p>
<ul>
<li>大多数包使用这个来提供大文件(&gt;2G)支持。</li>
</ul>
</li>
</ul>
<h3 id="CFLAGS-与-CXXFLAGS"><a href="#CFLAGS-与-CXXFLAGS" class="headerlink" title="CFLAGS 与 CXXFLAGS"></a>CFLAGS 与 CXXFLAGS</h3><ul>
<li><p>CFLAGS 表示用于 C 编译器的选项；CXXFLAGS 表示用于 C++ 编译器的选项。这两个变量实际上涵盖了编译和汇编两个步骤</p>
</li>
<li><p>大多数程序和库在编译时默认的优化级别是”2”(使用”-O2”选项)并且带有调试符号来编译，也就是 CFLAGS&#x3D;”-O2 -g”, CXXFLAGS&#x3D;$CFLAGS 。</p>
</li>
<li><p>事实上，”-O2”已经启用绝大多数安全的优化选项了。另一方面，由于大部分选项可以同时用于这两个变量，所以仅在最后讲述只能用于其中一个变量的选 项。提醒：下面所列选项皆为非默认选项，你只要按需添加即可。</p>
</li>
<li><p>先说说”-O3”在”-O2”基础上增加的几项：</p>
<ul>
<li><code>-finline-functions</code> : 允许编译器选择某些简单的函数在其被调用处展开，比较安全的选项，特别是在CPU二级缓存较大时建议使用。</li>
<li><code>-funswitch-loops</code> : 将循环体中不改变值的变量移动到循环体之外</li>
<li><code>-fgcse-after-reload</code> : 为了清除多余的溢出，在重载之后执行一个额外的载入消除步骤。</li>
</ul>
</li>
<li><p>参考链接：<code>https://sites.google.com/site/polarisnotme/linux/gcc</code></p>
</li>
</ul>
<h3 id="LDFLAGS"><a href="#LDFLAGS" class="headerlink" title="LDFLAGS"></a>LDFLAGS</h3><ul>
<li><p>LDFLAGS 是传递给连接器的选项。这是一个常被忽视的变量，事实上它对优化的影响也是很明显的。</p>
</li>
<li><p><code>-s</code> : 删除可执行程序中的所有符号表和所有重定位信息。其结果与运行命令 strip 所达到的效果相同，这个选项是比较安全的。</p>
</li>
<li><p><code>-Wl,options</code> : options是由一个或多个逗号分隔的传递给链接器的选项列表。其中的每一个选项均会作为命令行选项提供给链接器。</p>
</li>
<li><p><code>-Wl,-On</code> : 当n&gt;0时将会优化输出，但是会明显增加连接操作的时间，这个选项是比较安全的。</p>
</li>
<li><p><code>-Wl,--exclude-libs=ALL</code> : 不自动导出库中的符号，也就是默认将库中的符号隐藏。</p>
</li>
<li><p><code>-Wl,-m&lt;emulation&gt;</code> : 仿真<code>&lt;emulation&gt;</code>连接器，当前ld所有可用的仿真可以通过”ld -V”命令获取。默认值取决于ld的编译时配置</p>
</li>
<li><p><code>-Wl,--sort-common</code> : 把全局公共符号按照大小排序后放到适当的输出节，以防止符号间因为排布限制而出现间隙。</p>
</li>
<li><p><code>-Wl,-x</code> : 删除所有的本地符号。</p>
</li>
<li><p><code>-Wl,-X</code> : 删除所有的临时本地符号。对于大多数目标平台，就是所有的名字以’L’开头的本地符号。</p>
</li>
<li><p><code>-Wl,-zcomberloc</code> : 组合多个重定位节并重新排布它们，以便让动态符号可以被缓存。</p>
</li>
<li><p><code>-Wl,--enable-new-dtags</code> : 在ELF中创建新式的”dynamic tags”，但在老式的ELF系统上无法识别。</p>
</li>
<li><p><code>-Wl,--as-needed</code> : 移除不必要的符号引用，仅在实际需要的时候才连接，可以生成更高效的代码。</p>
</li>
<li><p><code>-Wl,--no-define-common</code> : 限制对普通符号的地址分配。该选项允许那些从共享库中引用的普通符号只在主程序中被分配地址。这会消除在共享库中的无用的副本的空间，同时也防止了在有多个指定了搜索路径的动态模块在进行运行时符号解析时引起的混乱。</p>
</li>
<li><p><code>-Wl,--hash-style=gnu</code> : 使用gnu风格的符号散列表格式。它的动态链接性能比传统的sysv风格(默认)有较大提升，但是它生成的可执行程序和库与旧的Glibc以及动态链接器不兼容。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++_%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++_%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">C++_智能指针</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>C&#x2F;C++ 语言最为人所诟病的特性之一就是存在内存泄露问题，因此后来的大多数语言都提供了内置内存分配与释放功能，有的甚至干脆对语言的使用者屏蔽了内存指针这一概念。这里不置贬褒，手动分配内存与手动释放内存有利也有弊，自动分配内存和自动释放内存亦如此，这是两种不同的设计哲学。有人认为，内存如此重要的东西怎么能放心交给用户去管理呢？而另外一些人则认为，内存如此重要的东西怎么能放心交给系统去管理呢？在 C&#x2F;C++ 语言中，内存泄露的问题一直困扰着广大的开发者，因此各类库和工具的一直在努力尝试各种方法去检测和避免内存泄露，如 boost，智能指针技术应运而生。</p>
</li>
<li><p>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。简要的说，智能指针利用了 C++ 的 RAII 机制，在智能指针对象作用域结束后，会自动做内存释放的相关操作，不需要我们再手动去操作内存。但是智能指针也不只是说的简简单单的自动释放内存这么简单，在使用上有一些坑需要注意，将会在下文中提到</p>
</li>
<li><p>C++ 中有四种智能指针：<code>auto_pt、unique_ptr、shared_ptr、weak_ptr</code> 其中后三个是 C++11 支持，第一个已经被 C++11 弃用且被 unique_prt 代替，不推荐使用。下文将对其逐个说明</p>
</li>
</ul>
<hr>
<h2 id="std-auto-ptr"><a href="#std-auto-ptr" class="headerlink" title="std::auto_ptr"></a>std::auto_ptr</h2><ul>
<li><p>在这个年代讨论 std::auto_ptr 不免有点让人怀疑是不是有点过时了，确实如此，随着 C++11 标准的出现（最新标准是 C++20），std::auto_ptr 已经被彻底放弃，取而代之是 std::unique_ptr。然而，之所以还向介绍一下 std::auto_ptr 的用法以及它的设计不足之处是想更多了解 C++ 语言中智能指针的发展过程，一项技术如果我们了解它过去的样子和发展的轨迹，我们就能更好地掌握它</p>
</li>
<li><p>std::auto_ptr 的基本用法如下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //初始化方式1</span><br><span class="line">    std::auto_ptr&lt;int&gt; ap1(new int(8));</span><br><span class="line">    //初始化方式2</span><br><span class="line">    std::auto_ptr&lt;int&gt; ap2;</span><br><span class="line">    ap2.reset(new int(8));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>智能指针对象 ap1 和 ap2 均持有一个在堆上分配 int 对象，其值均是 8，这两块堆内存均可以在 ap1 和 ap2 释放时得到释放。这是 std::auto_ptr 的基本用法</p>
</li>
</ul>
<hr>
<ul>
<li><p>std::auto_ptr 真正让人容易误用的地方是其不常用的复制语义，即当复制一个 std::auto_ptr 对象时（拷贝复制或 operator&#x3D; 复制），原对象所持有的堆内存对象也会转移给复制出来的对象</p>
</li>
<li><p>利用拷贝构造（ap1 &#x3D;&gt; ap2）和 赋值构造（ap3 &#x3D;&gt; ap4）来创建新的 std::auto_ptr 对象，因此 ap1 持有的堆对象被转移给 ap2，ap3 持有的堆对象被转移给 ap4。而 ap1 和 ap2 已经指向 NULL，若现在再对 ap1 和 ap2 进行访问并操作，将会出现内存错误问题</p>
</li>
<li><p>由于 std::auto_ptr 这种不常用的复制语义，我们应该避免在 stl 容器中使用 std::auto_ptr，例如我们绝不应该写出如下代码：</p>
<ul>
<li><code>std::vector&lt;std::auto_ptr&lt;int&gt;&gt; myvectors;</code></li>
<li>当用算法对容器操作的时候（如最常见的容器元素遍历），很难避免不对容器中的元素实现赋值传递，这样便会使容器中多个元素被置为空指针，这不是我们想看到的，会造成很多意想不到的错误</li>
</ul>
</li>
<li><p>正因为 std::auto_ptr 的设计存在如此重大缺陷，C++11 标准在充分借鉴和吸收了 boost 库中智能指针的设计思想，引入了三种类型的智能指针，即 std::unique_ptr、std::shared_ptr 和 std::weak_ptr。</p>
</li>
<li><p>boost 还有 scoped_ptr，C++11 并没有全部照搬，而是选择了三个最实用的指针类型。在 C++11 中可以通过 std::unique_ptr 达到与 boost::scoped_ptr 一样的效果。</p>
</li>
<li><p>所有的智能指针类（包括 std::unique_ptr）均包含于头文件 <code>&lt;memory&gt;</code> 中。</p>
</li>
</ul>
<hr>
<h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><ul>
<li><p>作为对 std::auto_ptr 的改进，std::unique_ptr 对其持有的堆内存具有唯一拥有权，也就是 std::unique_ptr 不可以拷贝或赋值给其他对象，其拥有的堆内存仅自己独占，std::unique_ptr 对象销毁时会释放其持有的堆内存</p>
</li>
<li><p>可以使用以下方式初始化一个 std::unique_ptr 对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化方式1</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">123</span>))</span></span>;</span><br><span class="line">    <span class="comment">//初始化方式2</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; up2;</span><br><span class="line">    up<span class="number">2.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">123</span>));</span><br><span class="line">    <span class="comment">//初始化方式3 (-std=c++14)</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; up3 = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>应该尽量使用初始化方式 3 的方式去创建一个 std::unique_ptr 而不是方式 1 和 2，因为形式 3 更安全，原因 Scott Meyers 在其《Effective Modern C++》中已经解释过了，有兴趣的可以阅读此书相关章节</p>
</li>
<li><p>令很多人对 C++11 规范不满的地方是，C++11 新增了 std::make_shared() 方法创建一个 std::shared_ptr 对象，却没有提供相应的 std::make_unique() 方法创建一个 std::unique_ptr 对象，这个方法直到 C++14 才被添加进来。当然，在 C++11 中你很容易实现出这样一个方法来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename... Ts&gt;</span><br><span class="line">std::unique_ptr&lt;T&gt; make_unique(Ts &amp;&amp;...params)</span><br><span class="line">&#123;</span><br><span class="line">    return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>鉴于 std::auto_ptr 的前车之鉴，std::unique_ptr 禁止复制语义，为了达到这个效果，std::unique_ptr 类的拷贝构造函数和赋值运算符（operator &#x3D;）被标记为 delete</p>
</li>
</ul>
<hr>
<ul>
<li><p>禁止复制语义也存在特例，即可以通过一个函数返回一个 std::unique_ptr：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">func</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(val))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> up;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; up1 = <span class="built_in">func</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>上述代码从 func 函数中得到一个 std::unique_ptr 对象，然后返回给 up1</p>
</li>
<li><p>既然 std::unique_ptr 不能复制，那么如何将一个 std::unique_ptr 对象持有的堆内存转移给另外一个呢？答案是使用移动构造，示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up1</span><span class="params">(std::make_unique&lt;<span class="type">int</span>&gt;(<span class="number">123</span>))</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">up2</span><span class="params">(std::move(up1))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; ((up<span class="number">1.</span><span class="built_in">get</span>() == <span class="literal">nullptr</span>) ? <span class="string">&quot;up1 is NULL&quot;</span> : <span class="string">&quot;up1 is not NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; up3;</span><br><span class="line">    up3 = std::<span class="built_in">move</span>(up2);</span><br><span class="line">    std::cout &lt;&lt; ((up<span class="number">2.</span><span class="built_in">get</span>() == <span class="literal">nullptr</span>) ? <span class="string">&quot;up2 is NULL&quot;</span> : <span class="string">&quot;up2 is not NULL&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>以上代码利用 std::move 将 up1 持有的堆内存（值为 123）转移给 up2，再把 up2 转移给 up3。最后，up1 和 up2 不再持有堆内存的引用，变成一个空的智能指针对象</p>
</li>
<li><p>并不是所有的对象的 std::move 操作都有意义，只有实现了移动构造函数或移动赋值运算符的类才行，而 std::unique_ptr 正好实现了这二者</p>
</li>
</ul>
<hr>
<ul>
<li>std::unique_ptr 不仅可以持有一个堆对象，也可以持有一组堆对象，示例如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建10个int类型的堆对象</span></span><br><span class="line">    <span class="comment">//形式1</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line">    <span class="comment">//形式2</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>[]&gt; up2;</span><br><span class="line">    up<span class="number">2.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]);</span><br><span class="line">    <span class="comment">//形式3</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">up3</span><span class="params">(std::make_unique&lt;<span class="type">int</span>[]&gt;(<span class="number">10</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        up1[i] = i;</span><br><span class="line">        up2[i] = i;</span><br><span class="line">        up3[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; up1[i] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; up2[i] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; up3[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>std::shared_ptr 和 std::weak_ptr 也可以持有一组堆对象，用法与 std::unique_ptr 相同，下文不再赘述</li>
</ul>
<hr>
<ul>
<li>另外，std::unique_ptr 有几个常用函数如下：<ul>
<li><code>void reset(pointer p = pointer())</code><ul>
<li>释放当前由 unique_ptr（如果有）管理的指针并获得参数 p（参数 p 默认为 NULL）的所有权。如果 p 是空指针（例如默认初始化的指针），则 unique_ptr 变为空，调用后不管理任何对象。</li>
</ul>
</li>
<li><code>pointer release()</code><ul>
<li>返回管理的指针并将其替换为空指针， 释放其管理指针的所有权。这个调用并不会销毁托管对象，但是将 unique_ptr 对象管理的指针解脱出来。如果要强制销毁所指向的对象，请调用 reset 函数或对其执行赋值操作</li>
</ul>
</li>
<li><code>element_type* get()</code><ul>
<li>返回存储的指针，不会使 unique_ptr 释放指针的所有权。因此，该函数返回的值不能于构造新的托管指针，如果为了获得存储的指针并释放其所有权，请调用 release。</li>
</ul>
</li>
<li><code>void swap (unique_ptr&amp; x)</code><ul>
<li>将 unique_ptr 对象的内容与对象 x 进行交换，在它们两者之间转移管理指针的所有权而不破坏二者。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>自定义智能指针对象持有的资源的释放函数<ul>
<li>默认情况下，智能指针对象在析构时只会释放其持有的堆内存（调用 delete 或者 delete[]），但是假设这块堆内存代表的对象还对应一种需要回收的资源（如操作系统的套接字句柄、文件句柄等），我们可以通过自定义智能指针的资源释放函数。假设现在有一个 Socket 类，对应着操作系统的套接字句柄，在回收时需要关闭该对象，我们可以如下自定义智能指针对象的资源析构函数，这里以 std::unique_ptr 为例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Socket</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Socket</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Socket</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭资源句柄</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> deletor = [](Socket *pSocket)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//关闭句柄</span></span><br><span class="line">        pSocket-&gt;<span class="built_in">close</span>();</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 你甚至可以在这里打印一行日志...</span></span><br><span class="line">        <span class="keyword">delete</span> pSocket;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Socket, <span class="title">void</span> <span class="params">(*)</span><span class="params">(Socket * pSocket)</span>&gt; <span class="title">upSocket</span><span class="params">(<span class="keyword">new</span> Socket(), deletor)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>自定义 std::unique_ptr 的资源释放函数其规则是：<ul>
<li><code>std::unique_ptr&lt;T, DeletorFuncPtr&gt;</code> </li>
<li>其中 T 是你要释放的对象类型，DeletorPtr 是一个自定义函数指针。</li>
<li>上述代码 28 行表示 DeletorPtr 有点复杂（是 C++11 中的 Lambda 函数），我们可以使用 decltype(deletor) 让编译器自己推导 deletor 的类型，因此可以将 28 行代码修改为：<ul>
<li><code>std::unique_ptr&lt;Socket, decltype(deletor)&gt; upSocket(new Socket(), deletor);</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><ul>
<li>std::unique_ptr 对其持有的资源具有独占性，而 std::shared_ptr 持有的资源可以在多个 std::shared_ptr 之间共享，每多一个 std::shared_ptr 对资源的引用，资源引用计数将增加 1，每一个指向该资源的 std::shared_ptr 对象析构时，资源引用计数减 1，最后一个 std::shared_ptr 对象析构时，发现资源计数为 0，将释放其持有的资源。多个线程之间，递增和减少资源的引用计数是安全的。（注意：这不意味着多个线程同时操作 std::shared_ptr 引用的对象是安全的）。std::shared_ptr 提供了一个 use_count() 方法来获取当前持有资源的引用计数。除了上面描述的，std::shared_ptr 用法和 std::unique_ptr 基本相同</li>
<li>下面是一个初始化 std::shared_ptr 的示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化方式1</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">123</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化方式2</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sp2;</span><br><span class="line">    sp<span class="number">2.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">123</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化方式3</span></span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sp3;</span><br><span class="line">    sp3 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>和 std::unique_ptr 一样，你应该优先使用 std::make_shared 去初始化一个 std::shared_ptr 对象</li>
</ul>
<hr>
<ul>
<li>std::shared_ptr 有几个常用函数如下：<ul>
<li><code>void swap (unique_ptr&amp; x)</code><ul>
<li>将 shared_ptr 对象的内容与对象 x 进行交换，在它们两者之间转移管理指针的所有权而不破坏或改变二者的引用计数</li>
</ul>
</li>
<li><code>void reset()</code></li>
<li><code>void reset (ponit p)</code><ul>
<li>没有参数时，先将管理的计数器引用计数减一并将管理的指针和计数器置清零。有参数 p 时，先做面前没有参数的操作，再管理 p 的所有权和设置计数器</li>
</ul>
</li>
<li><code>element_type* get()</code><ul>
<li>得到其管理的指针。</li>
</ul>
</li>
<li><code>long int use_count()</code><ul>
<li>返回与当前智能指针对象在同一指针上共享所有权的 shared_ptr 对象的数量，如果这是一个空的 shared_ptr，则该函数返回 0。如果要用来检查 use_count 是否为 1，可以改用成员函数 unique 会更快。</li>
</ul>
</li>
<li><code>bool unique()</code><ul>
<li>返回当前 shared_ptr 对象是否不和其他智能指针对象共享指针的所有权，如果这是一个空的 shared_ptr，则该函数返回 false</li>
</ul>
</li>
<li><code>element_type&amp; operator\*()</code><ul>
<li>重载指针的 * 运算符，返回管理的指针指向的地址的引用。</li>
</ul>
</li>
<li><code>element_type* operator-&gt;()</code><ul>
<li>重载指针的 -&gt; 运算符，返回管理的指针，可以访问其成员</li>
</ul>
</li>
<li><code>explicit operator bool()</code><ul>
<li>返回存储的指针是否已经是空指针，返回的结果与 get() !&#x3D; 0 相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><code>std::enable_shared_from_this</code><ul>
<li>实际开发中，有时候需要在类中返回包裹当前对象（this）的一个 std::shared_ptr 对象给外部使用，C++ 新标准也为我们考虑到了这一点，有如此需求的类只要继承自 std::enable_shared_from_this 模板对象即可。用法如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;A&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">getSelf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;A&gt; sp2 = sp1-&gt;<span class="built_in">getSelf</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>上述代码中，类 A 的继承 std::enable_shared_from_this 并提供一个 getSelf() 方法返回自身的 std::shared_ptr 对象，在 getSelf() 中调用 shared_from_this() 即可</li>
</ul>
</li>
<li>std::enable_shared_from_this 用起来比较方便，但是也存在很多不易察觉的陷阱<ul>
<li>陷阱一：不应该共享栈对象的 this 给智能指针对象<ul>
<li>假设我们将上面代码 main 函数 25 行生成 A 对象的方式改成一个栈变量，即：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他相同代码省略...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;A&gt; sp2 = a.<span class="built_in">getSelf</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>运行修改后的代码会发现程序在 std::shared_ptr sp2 &#x3D; a.getSelf() 产生崩溃。这是因为，智能指针管理的是堆对象，栈对象会在函数调用结束后自行销毁，因此不能通过 shared_from_this() 将该对象交由智能指针对象管理。</li>
<li><strong>切记：</strong> 智能指针最初设计的目的就是为了管理堆对象的（即那些不会自动释放的资源）</li>
</ul>
</li>
<li>陷阱二：避免 std::enable_shared_from_this 的循环引用问题<ul>
<li>再来看另外一段代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;A&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_i = <span class="number">9</span>;</span><br><span class="line">        <span class="comment">//注意:</span></span><br><span class="line">        <span class="comment">//比较好的做法是在构造函数里面调用shared_from_this()给m_SelfPtr赋值</span></span><br><span class="line">        <span class="comment">//但是很遗憾不能这么做,如果写在构造函数里面程序会直接崩溃</span></span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_SelfPtr = <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    std::shared_ptr&lt;A&gt; m_SelfPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;A&gt; <span class="title">spa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">        spa-&gt;<span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>乍一看上面的代码好像看不出什么问题，让我们来实际运行一下看看输出结果：<ul>
<li><code>A constructor</code></li>
</ul>
</li>
<li>我们发现在程序的整个生命周期内，只有 A 类构造函数的调用输出，没有 A 类析构函数的调用输出，这意味着 new 出来的 A 对象产生了内存泄漏！</li>
<li>我们来分析一下为什么 new 出来的 A 对象得不到释放。当程序执行到 39 行后，spa 出了其作用域准备析构，在析构时其发现仍然有另外的一个 std::shared_ptr 对象即 A::m_SelfPtr 引用了 A，因此 spa 只会将 A 的引用计数递减为 1，然后就销毁自身了。现在留下一个矛盾的处境：必须销毁 A 才能销毁其成员变量 m_SelfPtr，而销毁 m_SelfPtr 必须先销毁 A。这就是所谓的 std::enable_shared_from_this 的循环引用问题。我们在实际开发中应该避免做出这样的逻辑设计，这种情形下即使使用了智能指针也会造成内存泄漏。</li>
<li>也就是说: <strong>一个资源的生命周期可以交给一个智能指针对象，但是该智能指针的生命周期不可以再交给整个资源来管理</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><ul>
<li>std::weak_ptr 是一个不控制资源生命周期的智能指针，是对对象的一种弱引用，只是提供了对其管理的资源的一个访问手段，引入它的目的为协助 std::shared_ptr 工作</li>
<li>std::weak_ptr 可以从一个 std::shared_ptr 或另一个 std::weak_ptr 对象构造，std::shared_ptr 可以直接赋值给 std::weak_ptr ，也可以通过 std::weak_ptr 的 lock() 函数来获得 std::shared_ptr。它的构造和析构不会引起引用计数的增加或减少。std::weak_ptr 可用来解决 std::shared_ptr 相互引用时的死锁问题（即两个std::shared_ptr 相互引用，那么这两个指针的引用计数永远不可能下降为 0， 资源永远不会释放）</li>
<li>示例代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个std::shared_ptr对象</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">123</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造函数得到一个std::weak_ptr对象</span></span><br><span class="line">    <span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过赋值运算符得到一个std::weak_ptr对象</span></span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; sp3 = sp1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过一个std::weak_ptr对象得到另外一个std::weak_ptr对象</span></span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; sp4 = sp2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use count: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>运行结果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use count: 1</span><br><span class="line">use count: 1</span><br><span class="line">use count: 1</span><br><span class="line">use count: 1</span><br></pre></td></tr></table></figure></li>
<li>无论通过何种方式创建 std::weak_ptr 都不会增加资源的引用计数，因此每次输出引用计数的值都是 1。</li>
</ul>
<hr>
<ul>
<li>既然，std::weak_ptr 不管理对象的生命周期，那么其引用的对象可能在某个时刻被销毁了，如何得知呢？std::weak_ptr 提供了一个 expired() 方法来做这一项检测，返回 true，说明其引用的资源已经不存在了；返回 false，说明该资源仍然存在，这个时候可以使用 std::weak_ptr 的 lock() 方法得到一个 std::shared_ptr 对象然后继续操作资源，以下代码演示了该用法：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tmpConn_ 是一个 std::weak_ptr&lt;TcpConnection&gt; 对象</span></span><br><span class="line"><span class="comment">// tmpConn_ 引用的TcpConnection已经销毁，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (tmpConn_.<span class="built_in">expired</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;TcpConnection&gt; conn = tmpConn_.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (conn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对conn进行操作，省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>有读者可能对上述代码产生疑问，既然使用了 std::weak_ptr 的 expired() 方法判断了对象是否存在，为什么不直接使用 std::weak_ptr 对象对引用资源进行操作呢？实际上这是行不通的，std::weak_ptr 类没有重写 operator-&gt; 和 operator* 方法，因此不能像 std::shared_ptr 或 std::unique_ptr 一样直接操作对象，同时 std::weak_ptr 类也没有重写 operator! 操作，因此也不能通过 std::weak_ptr 对象直接判断其引用的资源是否存在：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;A&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::weak_ptr&lt;A&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确代码</span></span><br><span class="line">    <span class="keyword">if</span> (sp1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//正确代码</span></span><br><span class="line">        sp1-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line">        (*sp1).<span class="built_in">doSomething</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确代码</span></span><br><span class="line">    <span class="keyword">if</span> (!sp1)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误代码，无法编译通过</span></span><br><span class="line">    <span class="comment">//if (sp2)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    //错误代码，无法编译通过</span></span><br><span class="line">    <span class="comment">//    sp2-&gt;doSomething();</span></span><br><span class="line">    <span class="comment">//    (*sp2).doSomething();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误代码，无法编译通过</span></span><br><span class="line">    <span class="comment">//if (!sp2)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>之所以 std::weak_ptr 不增加引用资源的引用计数不管理资源的生命周期，是因为，即使它实现了以上说的几个方法，调用它们也是不安全的，因为在调用期间，引用的资源可能恰好被销毁了，这会造成棘手的错误和麻烦</li>
</ul>
<hr>
<ul>
<li><p>因此，std::weak_ptr 的正确使用场景是那些资源如果可能就使用，如果不可使用则不用的场景，它不参与资源的生命周期管理。例如，网络分层结构中，Session 对象（会话对象）利用 Connection 对象（连接对象）提供的服务工作，但是 Session 对象不管理 Connection 对象的生命周期，Session 管理 Connection 的生命周期是不合理的，因为网络底层出错会导致 Connection 对象被销毁，此时 Session 对象如果强行持有 Connection 对象与事实矛盾</p>
</li>
<li><p>std::weak_ptr 的应用场景，经典的例子是订阅者模式或者观察者模式中。这里以订阅者为例来说明，消息发布器只有在某个订阅者存在的情况下才会向其发布消息，而不能管理订阅者的生命周期</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubscribeManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publish</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;iter : m_subscribers)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!iter.<span class="built_in">expired</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//TODO：给订阅者发送消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::weak_ptr&lt;Subscriber&gt;&gt; m_subscribers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li>另外，std::weak_ptr 有几个常用函数如下<ul>
<li><code>void swap (weak_ptr&amp; x)</code><ul>
<li>将当前 weak_ptr 对象的内容与 x 的内容交换</li>
</ul>
</li>
<li><code>void reset()</code><ul>
<li>将当前 weak_ptr 对象管理的指针和计数器变成空的，就像默认构造的一样。</li>
</ul>
</li>
<li><code>long int use_count()</code><ul>
<li>返回与当前 weak_ptr 对象在同一指针上共享所有权的 shared_ptr 对象的数量。</li>
</ul>
</li>
<li><code>bool expired()</code><ul>
<li>检查是否过期，返回 weak_ptr 对象管理的指针为空，或者和他所属共享的没有更多 shared_ptr。lock 函数一般需要先调用 expired 判断，如果已经过期，就不能通过 weak_ptr 恢复拥有的 shared_ptr。此函数应返回与（use_count() &#x3D;&#x3D; 0）相同的值，但是它可能以更有效的方式执行此操作。</li>
</ul>
</li>
<li><code>shared_ptr&lt;element_type&gt; lock()</code><ul>
<li>如果它没有过期，则返回一个 shared_ptr，其中包含由 weak_ptr 对象保留的信息。如果 weak_ptr 对象已经过期，则该函数返回一个空的 shared_ptr（默认构造一样）。因为返回的 shared_ptr 对象也算作一个所有者，所以这个函数锁定了拥有的指针，防止它被释放（至少在返回的对象没有释放它的情况下）。 此操作以原子方式执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="智能指针使用注意事项"><a href="#智能指针使用注意事项" class="headerlink" title="智能指针使用注意事项"></a>智能指针使用注意事项</h2><ul>
<li>C++ 新标准提倡的理念之一是不应该再手动调用 delete 或者 free 函数去释放内存了，而应该把它们交给新标准提供的各种智能指针对象。C++ 新标准中的各种智能指针是如此的实用与强大，在现代 C++ 项目开发中，我们应该尽量去使用它们。</li>
<li>智能指针虽然好用，但稍不注意，也可能存在许多难以发现的 bug，这里我根据经验总结了几条</li>
</ul>
<hr>
<ul>
<li><p>一旦一个对象使用智能指针管理后，就不该再使用原始裸指针去操作</p>
</li>
<li><p>一段代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subscriber</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Subscriber *pSubscriber = <span class="keyword">new</span> <span class="built_in">Subscriber</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Subscriber&gt; <span class="title">spSubscriber</span><span class="params">(pSubscriber)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pSubscriber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这段代码利用创建了一个堆对象 Subscriber，然后利用智能指针 spSubscriber 去管理之，可以却私下利用原始指针销毁了该对象，这让智能指针对象 spSubscriber 情何以堪啊？</p>
</li>
<li><p>记住，一旦智能指针对象接管了你的资源，所有对资源的操作都应该通过智能指针对象进行，不建议再通过原始指针进行操作了。</p>
</li>
<li><p>当然，除了 std::weak_ptr 之外，std::unique_ptr 和 std::shared_ptr 都提供了获取原始指针的方法——get() 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Subscriber *pSubscriber = <span class="keyword">new</span> <span class="built_in">Subscriber</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Subscriber&gt; <span class="title">spSubscriber</span><span class="params">(pSubscriber)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pTheSameSubscriber和pSubscriber指向同一个对象</span></span><br><span class="line">    Subscriber *pTheSameSubscriber = spSubscriber.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li>分清楚场合应该使用哪种类型的智能指针</li>
<li>通常情况下，如果你的资源不需要在其他地方共享，那么应该优先使用 std::unique_ptr，反之使用 std::shared_ptr，当然这是在该智能指针需要管理资源的生命周期的情况下；如果不需要管理对象的生命周期，请使用 std::weak_ptr</li>
</ul>
<hr>
<ul>
<li>认真考虑，避免操作某个引用资源已经释放的智能指针</li>
<li>前面的例子，一定让你觉得非常容易知道一个智能指针的持有的资源是否还有效，但是还是建议在不同场景谨慎一点，有些场景是很容易造成误判。例如下面的代码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;T do something...&quot;</span> &lt;&lt; m_i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> T())</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> &amp;sp2 = sp1;</span><br><span class="line"></span><br><span class="line">    sp<span class="number">1.</span><span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于sp2已经不再持有对象的引用，程序会在这里出现意外的行为</span></span><br><span class="line">    sp2-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>上述代码中，sp2 是 sp1 的引用，sp1 被置空后，sp2 也一同为空。这时候调用 sp2-&gt;doSomething()，sp2-&gt;（即 operator-&gt;）在内部会调用 get() 方法获取原始指针对象，这时会得到一个空指针（地址为 0），继续调用 doSomething() 导致程序崩溃</li>
<li>你一定仍然觉得这个例子也能很明显地看出问题，ok，让我们把这个例子放到实际开发中再来看一下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接断开</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MonitorServer::OnClose</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;TcpConnection&gt; &amp;conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m_sessionMutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = m_sessions.<span class="built_in">begin</span>(); iter != m_sessions.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//通过比对connection对象找到对应的session</span></span><br><span class="line">        <span class="keyword">if</span> ((*iter)-&gt;<span class="built_in">GetConnectionPtr</span>() == conn)</span><br><span class="line">        &#123;</span><br><span class="line">            m_sessions.<span class="built_in">erase</span>(iter);</span><br><span class="line">            <span class="comment">//注意这里：程序在此处崩溃</span></span><br><span class="line">            <span class="built_in">LOGI</span>(<span class="string">&quot;monitor client disconnected: %s&quot;</span>, conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>该段程序会在代码 12 行处崩溃，崩溃原因是调用了 conn-&gt;peerAddress() 方法</li>
<li>崩溃原因是传入的 conn 对象和上一个例子中的 sp2 一样都是另外一个 std::shared_ptr 的引用，当连接断开时，对应的 TcpConnection 对象可能早已被销毁，而 conn 引用就会变成空指针（严格来说是不再拥有一个 TcpConnection 对象），此时调用 TcpConnection 的 peerAddress() 方法就会产生和上一个示例一样的错误</li>
</ul>
<hr>
<ul>
<li>作为类成员变量时，应该优先使用前置声明（forward declarations）</li>
<li>我们知道，为了减小编译依赖加快编译速度和生成二进制文件的大小，C&#x2F;C++ 项目中一般在 *.h 文件对于指针类型尽量使用前置声明，而不是直接包含对应类的头文件</li>
<li>示例<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test.h</span></span><br><span class="line"><span class="comment">//在这里使用A的前置声明，而不是直接包含A.h文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    ~<span class="built_in">Test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A *m_pA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>同样的道理，在头文件中当使用智能指针对象作为类成员变量时，也应该优先使用前置声明去引用智能指针对象的包裹类，而不是直接包含包含类的头文件<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//智能指针包裹类A，这里优先使用A的前置声明，而不是直接包含A.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    ~<span class="built_in">Test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;A&gt; m_spA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>Modern C&#x2F;C++ 已经变为 C&#x2F;C++ 开发的趋势，希望能善用和熟练这些智能指针对象</li>
</ul>
<hr>
<h2 id="智能指针的简单实现"><a href="#智能指针的简单实现" class="headerlink" title="智能指针的简单实现"></a>智能指针的简单实现</h2><ul>
<li><p>最后，给出智能指针的简单实现，因为 weak_ptr 作为弱引用指针，其实现依赖于 Counter 计数器类和 shared_ptr 的赋值，所以先进行 Counter 计数器类和 share_ptr 的简单实现</p>
</li>
<li><p>Counter的简单实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 计数器</span></span><br><span class="line"><span class="comment"> * Counter对象就是用来申请一块内存存储引用计数</span></span><br><span class="line"><span class="comment"> * m_refCount是SharedPtr的引用计数</span></span><br><span class="line"><span class="comment"> * m_weakCount是WeakPtr的引用计数</span></span><br><span class="line"><span class="comment"> * 当m_weakCount为0时删除Counter对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">SharedPtr</span>&lt;T&gt;;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">WeakPtr</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>() : <span class="built_in">m_refCount</span>(<span class="number">0</span>), <span class="built_in">m_weakCount</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Counter</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">const</span> Counter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Counter &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Counter &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    atomic_uint m_refCount;  <span class="comment">// #shared,原子操作</span></span><br><span class="line">    atomic_uint m_weakCount; <span class="comment">// #weak,原子操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>shared_ptr的简单实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SharedPtr的简单实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedPtr</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">WeakPtr</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 构造函数，用原生指针构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">SharedPtr</span>(T *ptr) : <span class="built_in">m_ptr</span>(ptr), <span class="built_in">m_cnt</span>(<span class="keyword">new</span> Counter&lt;T&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            m_cnt-&gt;m_refCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Ptr Construct S.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SharedPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 拷贝构造函数，用另一个SharedPtr对象构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">SharedPtr</span>(<span class="type">const</span> SharedPtr &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ptr = s.m_ptr;</span><br><span class="line">        s.m_cnt-&gt;m_refCount++;</span><br><span class="line">        m_cnt = s.m_cnt;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;S Copy Construct S.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 拷贝构造函数，用另一个WeakPtr对象构造</span></span><br><span class="line"><span class="comment">     * 为了WeakPtr对象调用自己的lock()方法将自己传进来构造一个SharedPtr返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">SharedPtr</span>(<span class="type">const</span> WeakPtr&lt;T&gt; &amp;w)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ptr = w.m_ptr;</span><br><span class="line">        w.m_cnt-&gt;m_refCount++;</span><br><span class="line">        m_cnt = w.m_cnt;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;W Copy Construct S.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 赋值构造函数，用另一个SharedPtr对象构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SharedPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(<span class="type">const</span> SharedPtr&lt;T&gt; &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">release</span>();</span><br><span class="line">            m_ptr = s.m_ptr;</span><br><span class="line">            s.m_cnt-&gt;m_refCount++;</span><br><span class="line">            m_cnt = s.m_cnt;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;S Assign Construct S.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_cnt-&gt;m_refCount--;</span><br><span class="line">        <span class="keyword">if</span> (m_cnt-&gt;m_refCount &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_ptr;</span><br><span class="line">            m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;SharedPtr Delete Ptr.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">if</span> (m_cnt-&gt;m_weakCount &lt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> m_cnt;</span><br><span class="line">                m_cnt = <span class="literal">nullptr</span>;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;SharedPtr Delete Cnt.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;SharedPtr Release.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *m_ptr;</span><br><span class="line">    Counter&lt;T&gt; *m_cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>weak_ptr的简单实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeakPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 构造函数，用SharedPtr对象构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">WeakPtr</span>(SharedPtr&lt;T&gt; &amp;s) : <span class="built_in">m_ptr</span>(s.m_ptr), <span class="built_in">m_cnt</span>(s.m_cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        m_cnt-&gt;m_weakCount++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;S Construct W.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 构造函数，用WeakPtr对象构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">WeakPtr</span>(WeakPtr&lt;T&gt; &amp;w) : <span class="built_in">m_ptr</span>(w.m_ptr), <span class="built_in">m_cnt</span>(w.m_cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        m_cnt-&gt;m_weakCount++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;W Construct W.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">WeakPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 赋值构造函数，用另一个SharedPtr对象构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WeakPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(SharedPtr&lt;T&gt; &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">        m_cnt = s.m_cnt;</span><br><span class="line">        m_cnt-&gt;m_weakCount++;</span><br><span class="line">        m_ptr = s.m_ptr;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;S Assign Construct W.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 赋值构造函数，用另一个WeakPtr对象构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WeakPtr&lt;T&gt; &amp;<span class="keyword">operator</span>=(WeakPtr&lt;T&gt; &amp;w)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;w)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            m_cnt = w.m_cnt;</span><br><span class="line">            m_cnt-&gt;m_weakCount++;</span><br><span class="line">            m_ptr = w-&gt;m_ptr;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;W Assign Construct W.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * WeakPtr通过lock函数获得SharedPtr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">SharedPtr&lt;T&gt; &amp;<span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SharedPtr</span>&lt;T&gt;(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 检查SharedPtr是否已过期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">expired</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_cnt-&gt;m_refCount &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">WeakPtr</span>() = <span class="keyword">delete</span>;       WeakPtr禁止默认构造，只能从SharedPtr或者WeakPtr构造</span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() = <span class="keyword">delete</span>;  <span class="comment">//WeakPtr禁止*</span></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() = <span class="keyword">delete</span>; <span class="comment">//WeakPtr禁止-&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            m_cnt-&gt;m_weakCount--;</span><br><span class="line">            <span class="keyword">if</span> (m_cnt-&gt;m_weakCount &lt; <span class="number">1</span> &amp;&amp; m_cnt-&gt;m_refCount &lt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> m_cnt;</span><br><span class="line">                m_cnt = <span class="literal">nullptr</span>;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Delete Cnt.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;WeakPtr Release.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *m_ptr;</span><br><span class="line">    Counter&lt;T&gt; *m_cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><code>https://blog.csdn.net/code_peak/article/details/119722167</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++_%E6%83%AF%E7%94%A8%E5%86%99%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++_%E6%83%AF%E7%94%A8%E5%86%99%E6%B3%95/" class="post-title-link" itemprop="url">C++_惯用写法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ 惯用写法</li>
</ul>
<h2 id="以良好的方式编写-C-class"><a href="#以良好的方式编写-C-class" class="headerlink" title="以良好的方式编写 C++ class"></a>以良好的方式编写 C++ class</h2><ul>
<li><p>假设现在我们要实现一个复数类complex，在类的实现过程中探索良好的编程习惯</p>
</li>
<li><p>Header(头文件)中的防卫式声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">complex.h:</span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span>  __COMPLEX__</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>防止头文件的内容被多次包含</p>
</li>
<li><p>把数据放在 private 声明下，提供接口访问数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">ifndef</span>  __COMPLEX__</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> re;&#125;</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> im;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        doubel re,im;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不会改变类属性(数据成员)的成员函数，全部加上 const 声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">real</span> <span class="params">()</span> `<span class="type">const</span>` </span>&#123;<span class="keyword">return</span> re;&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">imag</span><span class="params">()</span> `<span class="type">const</span>` </span>&#123;<span class="keyword">return</span> im;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>既然函数不会改变对象，那么就如实说明，编译器能帮你确保函数的const属性，阅读代码的人也明确你的意图</p>
</li>
<li><p>而且，const 对象才可以调用这些函数 – const 对象不能调用非const成员函数</p>
</li>
<li><p>使用构造函数初始值列表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">complex</span>(<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i =<span class="number">0</span>)</span><br><span class="line">            : <span class="built_in">re</span>(r), <span class="built_in">im</span>(i)  &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        doubel re,im;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在初始值列表中，才是初始化。在构造函数体内的，叫做赋值</p>
</li>
<li><p>如果可以，参数尽量使用 reference to const </p>
</li>
<li><p>为complex类添加一个+&#x3D;操作符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        complex&amp; <span class="keyword">operator</span> += (<span class="type">const</span> complex &amp;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用引用避免类对象构造与析构的开销，使用const确保参数不会被改变。内置类型的值传递与引用传递效率没有多大差别，甚至值传递效率会更高</p>
</li>
<li><p>例如，传递char类型时，值传递只需要传递一个字节；引用实际上是指针实现，需要四个字节(32位机)的传递开销。但是为了一致，不妨统一使用引用。</p>
</li>
<li><p>如果可以，函数返回值也尽量使用引用</p>
</li>
<li><p>以引用方式返回函数局部变量会引发程序为定义行为，离开函数作用域的局部变量被销毁，引用该变量没有意义。但是我要说的是，如果可以，函数应该返回引用。</p>
</li>
<li><p>当然，要放回的变量要有一定限制：改变量必须自进入函数之前，已经被分配了内存。以此条件来考量，很容易决定是否要放回引用。而在函数被调用时才创建出来的对象，一定不能返回引用。</p>
</li>
<li><p>说回 operator+&#x3D;，其返回值就是引用，原因在于，执行a +&#x3D; b时，a已经在内存上存在了。</p>
</li>
<li><p>而 operator+，其返回值不能时引用，因为 a+b 的值，在调用 operator+ 的时候才产生</p>
</li>
<li><p>下面是 operator+&#x3D;与operator+的实现:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex &amp; complex :: <span class="keyword">operator</span> += (<span class="type">const</span> complex &amp; r)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; re+= r-&gt;re;</span><br><span class="line">        <span class="keyword">this</span> -&gt; im+= r-&gt;im;</span><br><span class="line">        <span class="keyword">return</span> * <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span> + (<span class="type">const</span> complex &amp; x , <span class="type">const</span> complex &amp; y)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">complex</span> ( <span class="built_in">real</span> (x)+ <span class="built_in">real</span> (y), <span class="comment">//新创建的对象，不能返回引用</span></span><br><span class="line">                         <span class="built_in">imag</span>(x)+ <span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在operator+&#x3D; 中返回引用还是必要的，这样可以使用连续的操作</p>
</li>
<li><p>c3 +&#x3D; c2 +&#x3D; c1;</p>
</li>
<li><p>如果重载了操作符，就考虑是否需要多个重载</p>
</li>
<li><p>就我们的复数来说，+可以有多种使用方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">complex c2;</span><br><span class="line">c2 = c1+ c2;</span><br><span class="line">c2 = c1 + <span class="number">5</span>;</span><br><span class="line">c2 = <span class="number">7</span> + c1;</span><br></pre></td></tr></table></figure></li>
<li><p>为了应付多种加法，+需要有如下三种重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span>+ (<span class="type">const</span> complex &amp; x ,<span class="type">const</span> complex &amp; y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span> (<span class="built_in">real</span>(x)+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(x+<span class="built_in">imag</span>(y)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span> + (<span class="type">const</span> complex &amp; x, <span class="type">double</span> y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span> (<span class="built_in">real</span>(x)+y,<span class="built_in">imag</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex <span class="keyword">operator</span> + (<span class="type">double</span> x，<span class="type">const</span> complex &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span> (x+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供给外界使用的接口，放在类声明的最前面</p>
<ul>
<li>这是某次面试中，面试官大哥告诉我的。想想确实是有道理，类的用户用起来也舒服，一眼就能看见接口</li>
</ul>
</li>
</ul>
<h2 id="Class-with-pointer-member-s-记得写Big-Tree"><a href="#Class-with-pointer-member-s-记得写Big-Tree" class="headerlink" title="Class with pointer member(s): 记得写Big Tree"></a>Class with pointer member(s): 记得写Big Tree</h2><ul>
<li><p>C++的类可以分为带指针数据成员与不带指针数据成员两类,complex 就属于不带指针成员的。而这里要说的字符串类String，一般的实现会带有一个 char * 指针。带指针数据成员的类需要自己实现class三大件: 拷贝构造函数，拷贝赋值函数，析构函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">String</span> (<span class="type">const</span> <span class="type">char</span> * cstr = <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">String</span> (<span class="type">const</span> String &amp; str);</span><br><span class="line">        String &amp; <span class="keyword">operator</span> = (<span class="type">const</span> String &amp; str);</span><br><span class="line">        ~<span class="built_in">String</span>();</span><br><span class="line">        <span class="function"><span class="type">char</span> * <span class="title">get_c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_data&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span> * m_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果没有写拷贝构造函数，赋值构造函数，析构函数，编译器默认会给我们写一套。然而带指针的类不能依赖编译器的默认实现–这涉及到资源的释放，深拷贝与浅拷贝的问题。在实现String类的过程中我们来阐述这些问题。</p>
</li>
<li><p>析构函数释放动态分配的内存资源</p>
</li>
<li><p>如果class里有指针，多半是需要进行内存动态分配(例如String)，析构函数必须负责在对象生命结束时释放掉动态申请来的内存，否则就造成了内存泄漏。</p>
</li>
<li><p>局部对象在离开函数作用域时，对象析构函数被自动调用，而使用new动态分配的对象，也需要显式的使用delete来删除对象。而delete实际上会调用对象的析构函数，我们必须在析构函数中完成释放指针m_data所申请的内存。下面是一个构造函数，体现了m_data的动态内存申请:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*String的构造函数*/</span></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String ::<span class="built_in">String</span> (<span class="type">const</span> <span class="type">char</span> *cstr = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cstr)</span><br><span class="line">    &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cstr)<span class="number">+1</span>];   <span class="comment">// 这里，m_data申请了内存</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m_data,cstr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_data= <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">        *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这个构造函数以C风格字符串为参数，当执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String *p = <span class="keyword">new</span> <span class="built_in">String</span> (<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>m_data 向系统申请了一块内存存放字符串hello</p>
</li>
<li><p>析构函数必须负责把这段动态申请来的内存释放掉:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line">String ::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[]m_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>赋值构造函数与复制构造函数负责进行深拷贝</p>
</li>
<li><p>来看看如果使用编译器为String默认生成的拷贝构造函数与赋值操作符会发生什么事情。默认的复制构造函数或赋值操作符所做的事情是对类的内存进行按位的拷贝，也成为浅拷贝。他们只是把对象内存上的每一个bit复制到另一个对象上去，在String中就只是复制了指针，而不复制指针所指内容。</p>
</li>
<li><p>来看看我们自己实现的构造函数是如何解决这个问题的，它复制的是指针所指的内存内容，这称为深拷贝</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*拷贝赋值函数*/</span></span><br><span class="line"><span class="keyword">inline</span> String &amp;String ::<span class="keyword">operator</span>= (<span class="type">const</span> String &amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)           <span class="comment">//①</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;        <span class="comment">//②</span></span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.m_data)<span class="number">+1</span>];        <span class="comment">//③</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_data,str.m_data);            <span class="comment">//④</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这是拷贝赋值函数的经典实现，要点在于：</p>
<ul>
<li>处理自我赋值，如果不存在自我赋值问题，继续下列步骤</li>
<li>释放自身已经申请的内存</li>
<li>申请一块大小与目标字符串一样大的内存</li>
<li>进行字符串的拷贝</li>
</ul>
</li>
<li><p>同样的，复制构造函数也是一个深拷贝的过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> String ::<span class="built_in">String</span>(<span class="type">const</span> String &amp; str )</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">strlen</span> (str) <span class="number">+1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data,str.m_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>另外，一定要在 operator&#x3D; 中检查是否 self assignment 。假设这时候确实执行了对象的自我赋值，左右pointers指向同一个内存块，前面的步骤2 delete 该内存块造成的结果是：当企图对内存进行访问时，结果是未定义的</p>
</li>
</ul>
<h2 id="static-与类"><a href="#static-与类" class="headerlink" title="static 与类"></a>static 与类</h2><ul>
<li><p>不和对象直接相关的数据，声明为 static </p>
<ul>
<li>想象有一个银行账户的类，每个人都可以开银行账户。存在银行利率这个成员变量，它不应该属于对象，而应该属于银行这个类，由所有的用户来共享。</li>
<li>static 修饰成员变量时，该成员变量放在程序的全局区中，整个程序运行过程中只有该成员变量的一个副本。而普通的成员变量存在每个对象的内存中，如果把银行利率放在每个对象中，是浪费了内存。</li>
</ul>
</li>
<li><p>static 成员函数没有this指针</p>
<ul>
<li>static 成员函数与普通函数一样，都是只有一份函数的副本，存储在进程的代码段上。不一样的是staic 成员函数没有this指针，所以它不能够调用普通的成员变量，只能调用static成员变量。普通成员函数的调用需要通过对象来调用，编译器会把对象取地址，作为this指针的实参传递给成员函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="built_in">func</span>() ---&gt; Class :: <span class="built_in">fun</span>(&amp;obj);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>而 static 成员函数即可以通过对象来调用，也可以通过类名称来调用。</p>
</li>
<li><p>在类的外部定义 static 成员变量</p>
<ul>
<li>另一个问题是 static 成员变量的定义。static 成员变量必须在类外部进行定义:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> a; <span class="comment">//①</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> A::a = <span class="number">10</span>;  <span class="comment">//②</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>注意①是声明，②才是定义，定义为变量分配了内存。</p>
</li>
<li><p>static 与类的一些小应用</p>
<ul>
<li>这些可以用来应付一下面试，在实现单例模式的时候，static 成员函数与 static 成员变量得到了使用，下面是一种称为 饿汉式 的单例模式的实现：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">            <span class="built_in">setup</span>()&#123;...&#125;;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">A</span>();</span><br><span class="line">            <span class="built_in">A</span>(<span class="type">const</span> A &amp; rhs);</span><br><span class="line">            <span class="type">static</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这里把class A的构造函数都设置为私有，不允许用户代码创建对象。要获取对象实例需要通过接口getInstance。饿汉式 缺点在于无论有没有代码需要a，a都被创建出来。下面是改进的单例模式，称为懒汉式:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span>  A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="built_in">setup</span>()&#123;....&#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">A</span>();</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">const</span> A&amp; rsh);</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">static</span> A a;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>“懒汉式”只有在真正需要a时，调用getInstance才创建出唯一实例。这可以看成一个具有拖延症的单例模式，不到最后关头不干活。很多设计都体现了这种拖延的思想，比如string的写时复制，真正需要的时候才分配内存给string对象管理的字符串。</li>
</ul>
</li>
</ul>
<h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><ul>
<li><p>RAII可能是C++中最常用的编程技法.他的思想是把资源映射到对象,根据这些对象的作用域自动管理它们的生命周期</p>
</li>
<li><p>例如，如果在堆上打开一个文件句柄，那么一旦我们从函数返回（或循环，或任何它在内部声明的作用域）时，它都应该被隐式关闭。</p>
</li>
<li><p>如果类的成员中有动态内存分配，那么当该类实例被销毁时，相关内存应该被隐式释放。</p>
</li>
<li><p>每一种资源-内存分配,文件句柄,数据库连接,套接字和任何其他需要获取和释放的资源  都应该包装在这样一个RAII类中,其声明周期由它的对象所在的作用域决定,和RAII类对象绑定.</p>
</li>
<li><p>C++语言会保证,当对象超出作用域时,析构函数被调用,不管对象如何离开该作用域.即使抛出异常,所有相关对象也将超出作用域,所以他们的相关资源都会被释放.</p>
</li>
<li><p>C++很多地方都用到了RAII特性,例如lock_guard, 智能指针等.</p>
</li>
</ul>
<h2 id="使用enum-class-而非-enum"><a href="#使用enum-class-而非-enum" class="headerlink" title="使用enum class 而非 enum"></a>使用enum class 而非 enum</h2><ul>
<li>enum class 最重要的好处是: 防止隐式转换</li>
</ul>
<h2 id="Copy-and-swap"><a href="#Copy-and-swap" class="headerlink" title="Copy-and-swap"></a>Copy-and-swap</h2><ul>
<li><p>copy-and-swap 技法保证了强异常安全的保证,它可以非常方便的实现operator&#x3D;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    String &amp; <span class="keyword">operator</span> = (String s) <span class="comment">// the pass-by-value parameter serves as a temporary</span></span><br><span class="line">    &#123;</span><br><span class="line">       s.<span class="built_in">swap</span> (*<span class="keyword">this</span>); <span class="comment">// Non-throwing swap</span></span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;<span class="comment">// Old resources released when destructor of s is called.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(String &amp; s)</span> <span class="keyword">noexcept</span> <span class="comment">// Also see non-throwing swap idiom</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;str, s.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>补充知识点,异常安全的四种保证</p>
<ul>
<li>Nothrow(或者nofail)异常保证: 该函数永远不会抛出异常.对于可能在堆栈展开期间被调用的析构函数和其他函数,期望它们不会抛出异常(错误通过其他方式报告或隐藏).析构函数默认情况下是noexcept的(自C++11起).Nofail(函数总是成功执行)的要求适用于交换(swaps),移动构造函数和其他被那些提供强异常保证的函数所使用的函数.</li>
<li>强异常保证: 如果该函数抛出异常,程序的状态将回滚到函数调用之前的状态(例如 std::vector::push_back).即使抛出异常,程序仍然处于有效状态.</li>
<li>基本异常保证: 如果该函数抛出异常,程序仍然处于有效状态,没有资源泄漏,所有对象的不变性仍然保持完整.</li>
<li>无异常保证: 如果该函数抛出异常,程序可能处于无效状态,可能会发生资源泄漏,内存损坏或其他破坏不变性的错误.</li>
</ul>
</li>
</ul>
<h2 id="CRTP-Curiously-Recurring-Template-Pattern"><a href="#CRTP-Curiously-Recurring-Template-Pattern" class="headerlink" title="CRTP: Curiously Recurring Template Pattern"></a>CRTP: Curiously Recurring Template Pattern</h2><ul>
<li><p>CRTP 是指将一个类作为模板参数传递给其基类的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Derived</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BaseCRTP</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Example</span> : BaseCRTP&lt;Example&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在基类中,通过进行类型转换(可以使用static_cast或dynamic_cast)可以获取派生类实例,包括派生类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Derived</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BaseCRTP</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">call_foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived&amp; self = *<span class="built_in">static_cast</span>&lt;Derived*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    self.<span class="built_in">foo</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Example</span> : BaseCRTP&lt;Example&gt; &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;foo()\\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="PIMPL-模式"><a href="#PIMPL-模式" class="headerlink" title="PIMPL 模式"></a>PIMPL 模式</h2><ul>
<li><p>简介</p>
<ul>
<li>很实用的一种基础模式</li>
</ul>
</li>
<li><p>PIMPL 解释：</p>
<ul>
<li>PIMPL（Private Implementation 或 Pointer to Implementation）是通过一个私有的成员指针，将指针所指向的类的内部实现数据进行隐藏。</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i; <span class="comment">//add int i;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    X x; <span class="comment">//与X的强耦合</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PIMPL做法：</span><br><span class="line"><span class="comment">//c.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>; <span class="comment">//代替#include &lt;x.h&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    X *pImpl; <span class="comment">//pimpl</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>降低模块的耦合。因为隐藏了类的实现，被隐藏的类相当于原类不可见，对隐藏的类进行修改，不需要重新编译原类。</p>
</li>
<li><p>降低编译依赖，提高编译速度。指针的大小为（32位）或8（64位），X发生变化，指针大小却不会改变，文件c.h也不需要重编+ </p>
</li>
<li><p>接口与实现分离，提高接口的稳定性。</p>
<ul>
<li>通过指针封装，当定义“new C”或”C c1”时 ,编译器生成的代码中不会掺杂X的任何信息。</li>
<li>当使用C时，使用的是C的接口（C接口里面操作的类其实是pImpl成员指向的X对象），与X无关，X被通过指针封装彻底的与实现分离。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c.cpp</span></span><br><span class="line">C::<span class="built_in">C</span>()<span class="built_in">pImpl</span>(<span class="keyword">new</span> <span class="built_in">X</span>())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C::~<span class="built_in">C</span>()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">delete</span> pImpl;</span><br><span class="line">     pImpl = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C::Fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pImpl-&gt;<span class="built_in">Fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;c.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c1;</span><br><span class="line">    c<span class="number">1.F</span>un();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++_%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++_%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">C++_服务器开发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++服务器开发相关笔记</li>
</ul>
<h2 id="C-服务器开发-github推荐开源项目"><a href="#C-服务器开发-github推荐开源项目" class="headerlink" title="C++ 服务器开发 github推荐开源项目"></a>C++ 服务器开发 github推荐开源项目</h2><p>以下是一些在 GitHub 上受欢迎且有用的 C++ 服务器开发的开源项目，它们可用于构建各种类型的服务器应用程序。请注意，GitHub 上的项目可能会不断更新，因此建议查看其最新状态和文档：</p>
<ol>
<li><p><strong>Boost.Asio</strong>：<br>Boost.Asio 是一个 C++ 网络库，提供异步事件处理和网络通信的功能。它可以用于构建高性能的网络服务器和客户端应用程序。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/boostorg/asio">https://github.com/boostorg/asio</a></p>
</li>
<li><p><strong>cpp-netlib</strong>：<br>cpp-netlib 是一个现代的 C++ 网络库，提供 HTTP、HTTPS、HTTP client 等功能。它提供了易于使用的 API 来处理网络通信。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/cpp-netlib/cpp-netlib">https://github.com/cpp-netlib/cpp-netlib</a></p>
</li>
<li><p><strong>Crow</strong>：<br>Crow 是一个 C++ 微型 Web 框架，可用于构建高性能的 Web 服务器。它具有简单的 API 和支持 WebSocket 等功能。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/ipkn/crow">https://github.com/ipkn/crow</a></p>
</li>
<li><p><strong>Pistache</strong>：<br>Pistache 是一个 C++ RESTful Web 服务器框架，它具有异步处理和路由功能。它适用于构建 REST API 服务器。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/oktal/pistache">https://github.com/oktal/pistache</a></p>
</li>
<li><p><strong>Civetweb</strong>：<br>Civetweb 是一个轻量级的嵌入式 HTTP&#x2F;WebSocket 服务器，适用于嵌入式系统和小型应用程序。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/civetweb/civetweb">https://github.com/civetweb/civetweb</a></p>
</li>
<li><p><strong>uWebSockets</strong>：<br>uWebSockets 是一个高性能的 WebSocket 库，用于构建 WebSocket 服务器和客户端。它具有低延迟和高吞吐量的特性。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/uNetworking/uWebSockets">https://github.com/uNetworking/uWebSockets</a></p>
</li>
<li><p><strong>Restbed</strong>：<br>Restbed 是一个 C++11 Web 服务框架，支持 HTTP 和 HTTPS，并提供异步事件处理和路由功能。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/corvusoft/restbed">https://github.com/corvusoft/restbed</a></p>
</li>
<li><p><strong>Drogon</strong>：<br>Drogon 是一个高性能的 C++ Web 服务器框架，支持 HTTP&#x2F;1.1 和 HTTP&#x2F;2，提供异步和多线程支持。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/an-tao/drogon">https://github.com/an-tao/drogon</a></p>
</li>
<li><p><strong>Seastar</strong>：<br>Seastar 是一个高性能的 C++ 框架，用于构建分布式系统和高性能的服务器应用程序。它采用异步编程模型。<br>GitHub 地址：<a target="_blank" rel="noopener" href="https://github.com/scylladb/seastar">https://github.com/scylladb/seastar</a></p>
</li>
</ol>
<p>请注意，选择适合你的项目需求和技术栈的开源项目非常重要。这些项目在不同的场景和用例中具有不同的优势，因此建议根据你的具体需求来评估这些项目。同时，查看每个项目的文档和社区支持，以确保你能够成功地使用它们。</p>
<h2 id="从零设计跨平台C-C-服务器框架"><a href="#从零设计跨平台C-C-服务器框架" class="headerlink" title="从零设计跨平台C&#x2F;C++服务器框架"></a>从零设计跨平台C&#x2F;C++服务器框架</h2><h3 id="1-1-基础"><a href="#1-1-基础" class="headerlink" title="1.1 基础"></a>1.1 基础</h3><ul>
<li><p>技术框架，其实质就是建立一种标准的工作流，让更多的人参与，更低成本地实现目标。</p>
</li>
<li><p>目前我们所规定的标准：</p>
<ul>
<li>使用CMake管理项目，以Linux开源系统为标准，如果在windows上缺少的库，就模仿Linux造一个，实现一份代码跑全部平台</li>
<li>采用utf8字符编码，调用win32接口，需要把unicode转utf8。</li>
<li>采用骆驼峰形式代码风格<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DemoClass</span> <span class="comment">//类名首字母大写，骆驼峰</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> parramArg_;           <span class="comment">// 变量名末尾有_，非静态变量首字母小写</span></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> ParramArg_;    <span class="comment">// 变量名末尾有_，静态变量首字母大写</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FuncA</span><span class="params">()</span></span>&#123;&#125;     <span class="comment">// 函数名末尾无有_，静态函数首字母大写</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123;&#125;            <span class="comment">// 函数名末尾无有_，非静态函数首字母小写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>设计模式众多，选择人脑比较容易接受的设计模式：面向对象、状态机和组件设计等。模块用组件实现，可达到组件通用化，避免重复造轮子</li>
</ul>
</li>
</ul>
<h4 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h4><ul>
<li>面向对象设计，把业务逻辑封装类似实物世界，以一种人脑熟悉的方式，让人脑更容易接受和使用。制作工具一定要符合用户习惯</li>
<li>我们设计的服务器框架，服务器主要功能是加工数据、提供数据和数据通讯，就像一座数据工厂，里面有各种各样的数据加工机器人。我们用变量记录和描述属性，用函数描述行为</li>
<li>面向对象只是一种逻辑，跟编程语言无关，我们可以用C语言和C++语言各自实现一个对象。但是C++编译器对面向对象提供了更好的语法便利，这就是C++语法的优点，代价就是损失一些性能，好处就是提高写代码效率，代码更少，更容易维护</li>
</ul>
<h4 id="状态机设计"><a href="#状态机设计" class="headerlink" title="状态机设计"></a>状态机设计</h4><ul>
<li>计算机可以算是一种状态机：通过输入设备输入操作，就会改变状态</li>
<li>例如HTTP服务器的状态：<ul>
<li>监听到客户端连接，执行accept，建立链接状态；</li>
<li>解析HTTP头状态；</li>
<li>解析Cookie，处理session状态</li>
<li>验证modify和etag缓存状态</li>
<li>路由到具体url业务状态</li>
<li>获取到数据进行文件渲染状态</li>
<li>向客户端发送数据状态</li>
<li>最后关闭连接状态</li>
</ul>
</li>
<li>上述把HTTP服务器复杂的请求过程，细分成各种具体的状态，大幅降低了问题的复杂度，转换人脑更加容易熟悉的状态。</li>
<li>程序发生bug，可以快速定位；对性能调优，监测每个状态的消耗时间，带来极大便利性</li>
</ul>
<h4 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h4><ul>
<li><p>我们的机器人需要接收消息，接收到消息以后，需要进行加工，然后把加工的数据，通过消息发出去。我们有成千上万种数据加工业务，我们需要设计各种各样的机器人。</p>
</li>
<li><p>如果按照继承的方式，robot作为父类，需要实现各种各样的子类，这种方式虽然也可以做到业务分离，但是复用和共享很困难。</p>
</li>
<li><p>我们希望像汽车一样，标准化各种零部件，想要什么价位和性能的汽车，就选择组装什么样的零件。这个就是组件设计。</p>
</li>
<li><p>设计一个类Com，作为组件基类，把单一功能的逻辑，作为一个组件。Robot作为集合类，需要什么样的Robot，就组装什么样的组件。</p>
</li>
<li><p>我们通过CMake建立跨平台工程，以Linux做标准库，让我们的程序可以移植在任何操作系统上。</p>
</li>
<li><p>我们也希望写的代码可以轻松地移植在任意一个项目中，甚至发到网上，轻松导入即可使用。</p>
</li>
<li><p>我们也希望可视化操作，人脑更容易接受的方式去开发程序</p>
</li>
<li><p>这就是组件设计。我们设计组件的核心目标是可视化操作，通过可视化方式组装我们的业务。</p>
</li>
</ul>
<h2 id="C-高性能服务器网络框架设计细节"><a href="#C-高性能服务器网络框架设计细节" class="headerlink" title="C++ 高性能服务器网络框架设计细节"></a>C++ 高性能服务器网络框架设计细节</h2><h3 id="1-1-基础-1"><a href="#1-1-基础-1" class="headerlink" title="1.1 基础"></a>1.1 基础</h3><ul>
<li>这篇文章我们将介绍服务器的开发，并从多个方面探究如何开发一款高性能高并发的服务器程序。需要注意的是一般大型服务器，其复杂程度在于其业务，而不是在于其代码工程的基本框架。</li>
<li>大型服务器一般有多个服务组成，可能会支持CDN，或者支持所谓的“分布式”等，这篇文章不会介绍这些东西，因为不管结构多么复杂的服务器，都是由单个服务器组成的。所以这篇文章的侧重点是讨论单个服务程序的结构，而且这里的结构指的也是单个服务器的网络通信层结构，如果你能真正地理解了我所说的，那么在这个基础的结构上面开展任何业务都是可以的，也可以将这种结构扩展成复杂的多个服务器组，例如“分布式”服务。</li>
<li>文中的代码示例虽然是以C++为例，但同样适合Java（我本人也是Java开发者），原理都是一样的，只不过Java可能在基本的操作系统网络通信API的基础上用虚拟机包裹了一层接口而已（Java甚至可能基于一些常用的网络通信框架思想提供了一些现成的API，例如NIO）。有鉴于此，这篇文章不讨论那些大而空、泛泛而谈的技术术语，而是讲的是实实在在的能指导读者在实际工作中实践的编码方案或优化已有编码的方法。另外这里讨论的技术同时涉及windows和linux两个平台。</li>
</ul>
<hr>
<ul>
<li>所谓高性能就是服务器能流畅地处理各个客户端的连接并尽量低延迟地应答客户端的请求；</li>
<li>所谓高并发，不仅指的是服务器可以同时支持多的客户端连接，而且这些客户端在连接期间内会不断与服务器有数据来往。</li>
<li>网络上经常有各种网络库号称单个服务能同时支持百万甚至千万的并发，然后我实际去看了下，结果发现只是能同时支持很多的连接而已。如果一个服务器能单纯地接受ｎ个连接（ｎ可能很大），但是不能有条不紊地处理与这些连接之间的数据来往也没有任何意义，这种服务器框架只是“玩具型”的，对实际生产和应用没有任何意义。</li>
<li>这篇文章将从两个方面来介绍：<ul>
<li>一个是服务器中的基础的网络通信部件；</li>
<li>另外一个是，如何利用这些基础通信部件整合成一个完整的高效的服务器框架。</li>
</ul>
</li>
</ul>
<h3 id="1-2-网络通信部件"><a href="#1-2-网络通信部件" class="headerlink" title="1.2 网络通信部件"></a>1.2 网络通信部件</h3><h4 id="1-1-需要解决的问题："><a href="#1-1-需要解决的问题：" class="headerlink" title="1.1 需要解决的问题："></a>1.1 需要解决的问题：</h4><ul>
<li><p>既然是服务器程序肯定会涉及到网络通信部分，那么服务器程序的网络通信模块要解决哪些问题？</p>
</li>
<li><p>目前，网络上有很多网络通信框架，如libevent、boost asio、ACE，但都网络通信的常见的技术手段都大同小异，至少要解决以下问题：</p>
<ul>
<li>如何检测有新客户端连接？</li>
<li>如何接受客户端连接？</li>
<li>如何检测客户端是否有数据发来？</li>
<li>如何收取客户端发来的数据？</li>
<li>如何检测连接异常？发现连接异常之后，如何处理？</li>
<li>如何给客户端发送数据？</li>
<li>如何在给客户端发完数据后关闭连接？</li>
</ul>
</li>
<li><p>稍微有点网络基础的人，都能回答上面说的其中几个问题，比如接收客户端连接用socket API的accept函数，收取客户端数据用recv函数，给客户端发送数据用send函数，检测客户端是否有新连接和客户端是否有新数据可以用IO multiplexing技术（IO复用）的select、poll、epoll等socket API</p>
</li>
<li><p>确实是这样的，这些基础的socket API构成了服务器网络通信的地基，不管网络通信框架设计的如何巧妙，都是在这些基础的socket API的基础上构建的。但是如何巧妙地组织这些基础的socket API，才是问题的关键</p>
</li>
<li><p>我们说服务器很高效，支持高并发，实际上只是一个技术实现手段，不管怎样，从软件开发的角度来讲无非就是一个程序而已，所以，只要程序能最大可能地满足“尽量减少等待或者不等待”这一原则就是高效的，也就是说高效不是“忙的忙死，闲的闲死”，而是大家都可以闲着，但是如果有活要干，大家尽量一起干，而不是一部分忙着依次做事情，另外一部分闲在那里无所事事</p>
</li>
</ul>
<hr>
<ul>
<li>我们来举一些例子具体来说明一下。 例如：<ul>
<li>默认情况下，recv函数如果没有数据的时候，线程就会阻塞在那里；</li>
<li>默认情况下，send函数，如果tcp窗口不是足够大，数据发不出去也会阻塞在那里；</li>
<li>connect函数默认连接另外一端的时候，也会阻塞在那里；</li>
<li>又或者是给对端发送一份数据，需要等待对端回答，如果对方一直不应答，当前线程就阻塞在这里。</li>
</ul>
</li>
<li>以上都不是高效服务器的开发思维方式，因为上面的例子都不满足“尽量减少等待”的原则，为什么一定要等待呢？有没用一种方法，这些过程不需要等待，最好是不仅不需要等待，而且这些事情完成之后能通知我。这样在这些本来用于等待的cpu时间片内，我就可以做一些其他的事情。有，也就是我们下文要讨论的IO Multiplexing技术（IO复用技术）</li>
</ul>
<h4 id="1-2-几种IO服用机制的比较"><a href="#1-2-几种IO服用机制的比较" class="headerlink" title="1.2 几种IO服用机制的比较"></a>1.2 几种IO服用机制的比较</h4><ul>
<li><p>目前：</p>
<ul>
<li>windows系统支持select、WSAAsyncSelect、WSAEventSelect、完成端口（IOCP）</li>
<li>linux系统支持select、poll、epoll。</li>
</ul>
</li>
<li><p>以上列举的API函数可以分为两个层次：</p>
<ul>
<li>层次一 select和poll</li>
<li>层次二 WSAAsyncSelect、WSAEventSelect、完成端口（IOCP）、epoll</li>
</ul>
</li>
<li><p>为什么这么分呢？</p>
</li>
<li><p>先来介绍第一层次</p>
<ul>
<li>select和poll函数本质上还是在一定时间内主动去查询socket句柄（可能是一个也可能是多个）上是否有事件，比如可读事件，可写事件或者出错事件，也就是说我们还是需要每隔一段时间内去主动去做这些检测，如果在这段时间内检测出一些事件来，我们这段时间就算没白花，但是倘若这段时间内没有事件呢？我们只能是做无用功了，说白了，还是在浪费时间，因为假如一个服务器有多个连接，在cpu时间片有限的情况下，我们花费了一定的时间检测了一部分socket连接，却发现它们什么事件都没有，而在这段时间内我们却有一些事情需要处理，那我们为什么要花时间去做这个检测呢？把这个时间用在做我们需要做的事情不好吗？</li>
<li>所以对于服务器程序来说，要想高效，我们应该尽量避免花费时间主动去查询一些socket是否有事件，而是等这些socket有事件的时候告诉我们去处理。</li>
</ul>
</li>
<li><p>这也就是层次二的各个函数做的事情</p>
<ul>
<li>它们实际相当于变主动查询是否有事件为当有事件时，系统会告诉我们，此时我们再去处理，也就是“好钢用在刀刃”上了。只不过层次二的函数通知我们的方式是各不相同，</li>
<li>比如WSAAsyncSelect是利用windows窗口消息队列的事件机制来通知我们设定的窗口过程函数，IOCP是利用GetQueuedCompletionStatus返回正确的状态，epoll是epoll_wait函数返回而已</li>
</ul>
</li>
<li><p>例如，connect函数连接另外一端，如果用于连接socket是非阻塞的，那么connect虽然不能立刻连接完成，但是也是会立刻返回，无需等待，等连接完成之后，WSAAsyncSelect会返回FD_CONNECT事件告诉我们连接成功，epoll会产生EPOLLOUT事件，我们也能知道连接完成。甚至socket有数据可读时，WSAAsyncSelect产生FD_READ事件，epoll产生EPOLLIN事件，等等。所以有了上面的讨论，我们就可以得到网络通信检测可读可写或者出错事件的正确姿势。这是我这里提出的第二个原则：尽量减少做无用功的时间。这个在服务程序资源够用的情况下可能体现不出来什么优势，但是如果有大量的任务要处理，这里就成了性能的一个瓶颈。</p>
</li>
</ul>
<h4 id="1-3-检测网络时间的正确姿势"><a href="#1-3-检测网络时间的正确姿势" class="headerlink" title="1.3 检测网络时间的正确姿势"></a>1.3 检测网络时间的正确姿势</h4><ul>
<li><p>第一，为了避免无意义的等待时间</p>
</li>
<li><p>第二，不采用主动查询各个socket的事件，而是采用等待操作系统通知我们有事件的状态的策略。</p>
</li>
<li><p>我们的socket都要设置成非阻塞的。在此基础上我们回到栏目（一）中提到的七个问题：</p>
<ul>
<li>如何检测有新客户端连接？</li>
<li>如何接受客户端连接？ 默认accept函数会阻塞在那里，如果epoll检测到侦听socket上有EPOLLIN事件，或者WSAAsyncSelect检测到有FD_ACCEPT事件，那么就表明此时有新连接到来，这个时候调用accept函数，就不会阻塞了。当然产生的新socket你应该也设置成非阻塞的。这样我们就能在新socket上收发数据了。</li>
<li>如何检测客户端是否有数据发来？</li>
<li>如何收取客户端发来的数据？ 同理，我们也应该在socket上有可读事件的时候才去收取数据，这样我们调用recv或者read函数时不用等待，至于一次性收多少数据好呢？我们可以根据自己的需求来决定，甚至你可以在一个循环里面反复recv或者read，对于非阻塞模式的socket，如果没有数据了，recv或者read也会立刻返回，错误码EWOULDBLOCK会表明当前已经没有数据了</li>
<li>如何检测连接异常？发现连接异常之后，如何处理？ 同样当我们收到异常事件后例如EPOLLERR或关闭事件FD_CLOSE，我们就知道了有异常产生，我们对异常的处理一般就是关闭对应的socket。另外，如果send&#x2F;recv或者read&#x2F;write函数对一个socket进行操作时，如果返回0，那说明对端已经关闭了socket，此时这路连接也没必要存在了，我们也可以关闭对应的socket。</li>
<li>如何给客户端发送数据？ 这也是一道常见的网络通信面试题，某一年的腾讯后台开发职位就问到过这样的问题。给客户端发送数据，比收数据要稍微麻烦一点，也是需要讲点技巧的。<ul>
<li>首先我们不能像注册检测数据可读事件一样一开始就注册检测数据可写事件，因为如果检测可写的话，一般情况下只要对端正常收取数据，我们的socket就都是可写的，如果我们设置监听可写事件，会导致频繁地触发可写事件，但是我们此时并不一定有数据需要发送。</li>
<li>所以正确的做法是：<ul>
<li>如果有数据要发送，则先尝试着去发送，如果发送不了或者只发送出去部分，剩下的我们需要将其缓存起来，然后再设置检测该socket上可写事件，下次可写事件产生时，再继续发送，如果还是不能完全发出去，则继续设置侦听可写事件，如此往复，一直到所有数据都发出去为止。</li>
<li>一旦所有数据都发出去以后，我们要移除侦听可写事件，避免无用的可写事件通知。</li>
</ul>
</li>
<li>不知道你注意到没有，如果某次只发出去部分数据，剩下的数据应该暂且存起来，这个时候我们就需要一个缓冲区来存放这部分数据，这个缓冲区我们称为“发送缓冲区”。</li>
<li>发送缓冲区不仅存放本次没有发完的数据，还用来存放在发送过程中，上层又传来的新的需要发送的数据。</li>
<li>为了保证顺序，新的数据应该追加在当前剩下的数据的后面，发送的时候从发送缓冲区的头部开始发送。也就是说先来的先发送，后来的后发送。</li>
</ul>
<p> 　　</p>
</li>
<li>如何在给客户端发完数据后关闭连接？ 这个问题比较难处理，因为这里的“发送完”不一定是真正的发送完，我们调用send或者write函数即使成功，也只是向操作系统的协议栈里面成功写入数据，至于能否被发出去、何时被发出去很难判断，发出去对方是否收到就更难判断了。所以，我们目前只能简单地认为send或者write返回我们发出数据的字节数大小，我们就认为“发完数据”了。然后调用close等socket API关闭连接。当然，你也可以调用shutdown函数来实现所谓的“半关闭”。</li>
</ul>
</li>
</ul>
<h4 id="1-4-被动关闭连接和主动关闭连接"><a href="#1-4-被动关闭连接和主动关闭连接" class="headerlink" title="1.4 被动关闭连接和主动关闭连接"></a>1.4 被动关闭连接和主动关闭连接</h4><ul>
<li>在实际的应用中，被动关闭连接是由于我们检测到了连接的异常事件，比如EPOLLERR，或者对端关闭连接，send或recv返回0，这个时候这路连接已经没有存在必要的意义了，我们被迫关闭连接</li>
<li>而主动关闭连接，是我们主动调用close&#x2F;closesocket来关闭连接。比如客户端给我们发送非法的数据，比如一些网络攻击的尝试性数据包。这个时候出于安全考虑，我们关闭socket连接。</li>
</ul>
<h4 id="1-5-发送缓冲区和接收缓冲区"><a href="#1-5-发送缓冲区和接收缓冲区" class="headerlink" title="1.5 发送缓冲区和接收缓冲区"></a>1.5 发送缓冲区和接收缓冲区</h4><ul>
<li><p>接收缓冲区也是一样的道理，当收到数据以后，我们可以直接进行解包，但是这样并不好，</p>
<ul>
<li>理由一：除非一些约定俗称的协议格式，比如http协议，大多数服务器的业务的协议都是不同的，也就是说一个数据包里面的数据格式的解读应该是业务层的事情，和网络通信层应该解耦，为了网络层更加通用，我们无法知道上层协议长成什么样子，因为不同的协议格式是不一样的，它们与具体的业务有关。</li>
<li>理由二：即使知道协议格式，我们在网络层进行解包处理对应的业务，如果这个业务处理比较耗时，比如需要进行复杂的运算，或者连接数据库进行账号密码验证，那么我们的网络线程会需要大量时间来处理这些任务，这样其它网络事件可能没法及时处理。</li>
</ul>
</li>
<li><p>鉴于以上二点，我们确实需要一个接收缓冲区，将收取到的数据放到该缓冲区里面去，并由专门的业务线程或者业务逻辑去从接收缓冲区中取出数据，并解包处理业务。</p>
</li>
<li><p>说了这么多，那发送缓冲区和接收缓冲区该设计成多大的容量？这是一个老生常谈的问题了，因为我们经常遇到这样的问题：预分配的内存太小不够用，太大的话可能会造成浪费。怎么办呢？答案就是像string、vector一样，设计出一个可以动态增长的缓冲区，按需分配，不够还可以扩展。</p>
</li>
<li><p>需要特别注意的是，这里说的发送缓冲区和接收缓冲区是每一个socket连接都存在一个。这是我们最常见的设计方案。</p>
</li>
</ul>
<h4 id="1-6-协议的设计"><a href="#1-6-协议的设计" class="headerlink" title="1.6 协议的设计"></a>1.6 协议的设计</h4><ul>
<li><p>除了一些通用的协议，如http、ftp协议以外，大多数服务器协议都是根据业务制定的。协议设计好了，数据包的格式就根据协议来设置。</p>
</li>
<li><p>我们知道tcp&#x2F;ip协议是流式数据，所以流式数据就是像流水一样，数据包与数据包之间没有明显的界限</p>
</li>
<li><p>比如A端给B端连续发了三个数据包，每个数据包都是50个字节，</p>
<ul>
<li>B端可能先收到10个字节，再收到140个字节；</li>
<li>或者先收到20个字节，再收到20个字节，再收到110个字节；</li>
<li>也可能一次性收到150个字节。</li>
<li>这150个字节可以以任何字节数目组合和次数被B收到。</li>
</ul>
</li>
<li><p>所以我们讨论协议的设计第一个问题就是如何界定包的界限，也就是接收端如何知道每个包数据的大小</p>
</li>
<li><p>目前常用有如下三种方法</p>
<ul>
<li>固定大小，这种方法就是假定每一个包的大小都是固定字节数目，例如上文中讨论的每个包大小都是50个字节，接收端每收气50个字节就当成一个包</li>
<li>指定包结束符，例如以一个\r\n(换行符和回车符)结束，这样对端只要收到这样的结束符，就可以认为收到了一个包，接下来的数据是下一个包的内容。</li>
<li>指定包的大小，这种方法结合了上述两种方法，一般包头是固定大小，包头中有一个字段指定包体或者整个大的大小，对端收到数据以后先解析包头中的字段得到包体或者整个包的大小，然后根据这个大小去界定数据的界线。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>协议要讨论的第二个问题是，设计协议的时候要尽量方便解包，也就是说协议的格式字段应该尽量清晰明了。</li>
<li>协议要讨论的第三个问题是，根据协议组装的单个数据包应该尽量小，注意这里指的是单个数据包，这样有如下好处<ul>
<li>第一、对于一些移动端设备来说，其数据处理能力和带宽能力有限，小的数据不仅能加快处理速度，同时节省大量流量费用；</li>
<li>第二、如果单个数据包足够小的话，对频繁进行网络通信的服务器端来说，可以大大减小其带宽压力，其所在的系统也能使用更少的内存。</li>
</ul>
</li>
<li>协议要讨论的第四个问题是，对于数值类型，我们应该显式地指定数值的长度<ul>
<li>比如long型，在32位机器上是32位4个字节，但是如果在64位机器上，就变成了64位8个字节了。</li>
<li>这样同样是一个long型，发送方和接收方可能因为机器位数的不同会用不同的长度去解码。所以建议最好，在涉及到跨平台使用的协议最好显式地指定协议中整型字段的长度，比如int32、int64等等。</li>
</ul>
</li>
</ul>
<h3 id="1-3-服务器程序结构的组织"><a href="#1-3-服务器程序结构的组织" class="headerlink" title="1.3 服务器程序结构的组织"></a>1.3 服务器程序结构的组织</h3><ul>
<li>上面的六个标题，我们讨论了很多具体的细节问题，现在是时候讨论将这些细节组织起来了。</li>
<li>根据我的个人经验，目前主流的思想是<code>one thread one loop+reactor</code>模式（也有proactor模式）的策略。通俗点说就是一个线程一个循环，即在一个线程的函数里面不断地循环依次做一些事情，这些事情包括检测网络事件、解包数据产生业务逻辑</li>
<li>我们先从最简单地来说，设定一些线程在一个循环里面做网络通信相关的事情。另外设定一些线程去处理接收到的数据，并解包处理业务逻辑，这些线程可以认为是业务线程了，</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++%E6%9C%AA%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++%E6%9C%AA%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">C++未整理笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>记录一些C++零乱的知识点</li>
</ul>
<h2 id="微信文章-–"><a href="#微信文章-–" class="headerlink" title="微信文章 –"></a>微信文章 –</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><ul>
<li>与进程相关的两个指标：VIRT Virtual Memory, 虚拟内存 和 RES Resident Memory，常驻内存，通常称为物理内存<ul>
<li>虚拟内存，是指整个进程申请的内存，包括程序本身占用的内存，new或者malloc分配的内存等</li>
<li>物理内存，就是这个进程在主板上内存条中占用的内存</li>
</ul>
</li>
<li>所以，通过top查看进程内存时，如果发现VIRT占用很大，说明这个程序用new或者malloc等分配了很多内存，但如果RES不是很大，那就不要慌，可能这只是程序的一个缓存优化，实际程序占用的物理内存并不大，但如果RES也很高，那可能就有点慌了</li>
</ul>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ul>
<li><p>内存泄漏是导致进程内存持续上涨最常见的原因，而这是C++中常见但不好处理的问题。</p>
</li>
<li><p>解决这个问题没有什么通用的快捷的办法，只能根据实际业务处理</p>
</li>
<li><p>第一，从业务上，能不能重现内存泄漏。</p>
<ul>
<li>例如，做游戏，加入玩家不停地登录，就会导致内存不断上涨，那就说明问题就在登录游戏，把整个流程拆分，一个个屏蔽测试，最终找出问题</li>
</ul>
</li>
<li><p>第二，从部署上，能不能定位内存泄漏。</p>
<ul>
<li>例如，最近更新了一个版本，发现内存占用变得很高，那就可以确定，是这个版本的修改出现了问题，一个版本的代码量终究是有限的，查找起来也比较容易</li>
</ul>
</li>
<li><p>第三，使用valgrind memcheck。如果能够复现内存泄漏，但无法定位是哪个逻辑，那就可以用valgrind memcheck。复现内存泄漏，这个通常比较难实现，一般是线下测试无法复现，线上用户量大，运行久了才会复现，而valgrind会导致程序运行很慢，无法支撑线上测试，因此这个选项不太适用于线上</p>
</li>
<li><p>第四，使用Visual Leak Detector.valgrind使linux下的，如果程序可以跨平台，或者只在windows下，可以试试这个</p>
</li>
<li><p>第五，重载new,delete。</p>
<ul>
<li>可以简单加个计数，用于平时预防泄漏，也可更深入一些，记录内存的分配，得到内存泄漏的堆栈，但是这个是否能够支撑线上debug，不一定</li>
</ul>
</li>
<li><p>第六，使用自己的内存分配函数，每一个内存分配，都是用自己的函数，每一个STL的容器，都传入自己的分配器，然后分别记录这些内存分配的大小。</p>
<ul>
<li>这个方法看起来很不现实，但如果能够使用并实现，对内存统计，查找有很大的帮助，而且支持线上debug。</li>
<li>查找内存，只需要打印每个分配器分配的内存大小基本上可以得到结论是哪个分配器除了问题。</li>
<li>唯一的问题是它增加了开发难度，而且不能像valgrind那样不需要修改程序即可使用</li>
</ul>
</li>
<li><p>第七，使用valgrind massif。valgrind memcheck需要复现内存泄漏，所以不容易找出问题。它会定时记录分配内存的各个堆栈以及分配内存的量，当出现内存泄漏时，根据分配内存的量检查各个堆栈，应该可以找到问题的。</p>
<ul>
<li>massif也会导致程序运行满，但比memcheck要快，能不能线上debug，这个依然需要看具体情况</li>
</ul>
</li>
<li><p>第八，使用第三方内存分配器，例如jemalloc。并不是说使用第三方内存分配器就解决问题了，而是jemalloc自带了一大堆工具，其中jeprof可以得到内存的大小以及堆栈等信息，对查找内存泄漏有很大帮助</p>
<ul>
<li>不过开启prof后，效率如何，能不能在线上使用，不一定</li>
</ul>
</li>
</ul>
<h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><ul>
<li>加入找不到内存泄漏，也许本来就没有内存泄漏，这时不妨考虑内存碎片的问题</li>
<li>以linux下的ptmalloc为例</li>
</ul>
<h3 id="内存利用率"><a href="#内存利用率" class="headerlink" title="内存利用率"></a>内存利用率</h3><ul>
<li>如果一个进程占用的内存远高于预期，但没有持续上涨，还需要考虑下是不是内存使用率的问题。</li>
<li>当使用new分配一块内存时，系统需要为这次分配记录大小，地址，分配的内存也需要对其。</li>
<li>加入分配的内存很小，例如1b，那系统最终需要消耗的内存是远大于1b的</li>
</ul>
<h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++编译器</li>
</ul>
<h2 id="g-Werror-type-limits是什么"><a href="#g-Werror-type-limits是什么" class="headerlink" title="g++ -Werror&#x3D;type-limits是什么"></a>g++ -Werror&#x3D;type-limits是什么</h2><p><code>g++ -Werror=type-limits</code> 是 GCC 编译器的一个编译选项，用于将与类型限制相关的警告转换为错误。这个选项告诉编译器将类型限制的警告视为编译错误，即在出现此类警告时，编译过程将中断，并生成一个错误，而不是继续生成可执行文件。</p>
<p>具体而言，<code>-Werror=type-limits</code> 用于处理与类型限制（type limits）相关的警告。例如，在比较有符号和无符号整数时，或者在进行其他可能导致溢出或意外行为的操作时，编译器可能会发出此类警告。通过将这些警告视为错误，开发者可以更加强制执行对于类型安全性的规则，从而避免一些潜在的运行时错误。</p>
<p>在实际的编译过程中，使用 <code>-Werror=type-limits</code> 可能会使得编译时更加严格，但也需要确保代码中不存在不希望的类型限制问题，否则编译将失败。</p>
<p>以下是使用这个编译选项的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -Werror=type-limits -o my_program my_program.cpp</span><br></pre></td></tr></table></figure>

<p>这将编译名为 <code>my_program.cpp</code> 的源文件，并在编译时将类型限制的警告转换为错误。</p>
<h2 id="为什么要用内存池？"><a href="#为什么要用内存池？" class="headerlink" title="为什么要用内存池？"></a>为什么要用内存池？</h2><ul>
<li>首先,在7 * 24h的服务器中如果不使用内存池,而使用malloc和free,那么就非常容易产生内存碎片,早晚都会申请内存失败,并且在比较复杂的代码中,非常容易出现内存泄漏</li>
<li>为了解决这两个问题,内存池就应运而生了.内存池预先分配一大块内存用来做一个内存池,业务中的内存分配和释放都由这个内存池来管理,内存池内的内存不足时其内部会自己申请.所以,内存碎片的问题就交由内存池的算法来优化,而内存泄漏的问题只需要遵守内存池提供的api,就非常容易避免内存泄漏了.</li>
<li>而且即使出现了内存泄漏,排查的思路也很清晰:<ul>
<li>检查是不是内存池的问题</li>
<li>如果不是内存池的问题,就检查是不是第三方库的内存泄漏</li>
</ul>
</li>
</ul>
<h2 id="内存池的使用场景"><a href="#内存池的使用场景" class="headerlink" title="内存池的使用场景:"></a>内存池的使用场景:</h2><ul>
<li>全局内存池,</li>
<li>一个连接一个内存池</li>
</ul>
<h2 id="设计一个内存池"><a href="#设计一个内存池" class="headerlink" title="设计一个内存池"></a>设计一个内存池</h2><ul>
<li>以4k为分界线,大于4k的认为是大块内存;小于4k的认为是小块内存;并且这里的4k,并不是严格遵照4096,而是在描述上,用4k比较好描述</li>
<li>在真正使用内存之前,内存池提前分配一定数量且大小相等的内存块以作备用,当真正被用户调用api分配内存的时候,直接从内存块中获取内存(指小块内存),当内存块不够用了,再由内存池去申请新的内存块;而如果是需要大块内存,则内存池直接申请大块内存再返回给用户.</li>
<li><strong>内存池</strong>:就是将这些提前申请的内存块组织管理起来的数据结构. 内存池实现原理主要分为:分配,回收,扩容三个部分.</li>
<li>内存池原理之小块内存:<ul>
<li>分配:<ul>
<li>内存池预申请一块4k的内存块,这里称为<strong>block</strong>,即block&#x3D;4k内存块.当用户向内存池申请内存的size小于4k时,内存池从block的空间中划分出去size空间,当再有新的申请时,再划分出去</li>
</ul>
</li>
<li>扩容:<ul>
<li>直到block中的剩余空间不足以分配size大小,那么此时内存池会再次申请一块block,再从新的block中划分size空间给用户</li>
</ul>
</li>
<li>回收:<ul>
<li>每一次申请小块内存,都会在对应的block中引用计数加1,每一次释放小块内存时,都会在block中引用计数减1,只有当引用计数为0的时候,才会回收block使他重新成为空闲空间,以便重复利用空间资源.</li>
</ul>
</li>
<li>这样,内存池避免频繁向内核申请&#x2F;释放内存,从而提高系统性能</li>
</ul>
</li>
<li>内存池原理之大块内存:<ul>
<li>分配:<ul>
<li>因为大块内存是大于4k的,所以内存池不预先申请内存,也就是用户申请的时候,内存池再申请内存,然后响应用户申请的时候,将申请的内存资源返回给用户</li>
</ul>
</li>
<li>扩容:<ul>
<li>大块内存不存在扩容</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++适用的应用领域</li>
</ul>
<h2 id="实时数据处理"><a href="#实时数据处理" class="headerlink" title="实时数据处理"></a>实时数据处理</h2><ul>
<li>实时数据处理是指在数据流入时对其进行处理的数据处理方法。实时数据处理通常用于处理高速、大量数据，例如实时监控、社交媒体分析等。实时数据处理的主要优点是低延迟、高吞吐量，但缺点是系统复杂度较高。</li>
</ul>
<h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><ul>
<li>整理自己的技术栈</li>
<li>C++是一门讲究深度的语言，其深度不是体现在会多少C++语法，而是能够洞察所写的C++代码背后的系统原理，这是需要长期不断的积累的，没有</li>
</ul>
<h2 id="常见知识点"><a href="#常见知识点" class="headerlink" title="常见知识点"></a>常见知识点</h2><ul>
<li>auto 关键字</li>
<li>for-each 循环</li>
<li>右值及移动构造函数，std::forward,std::move,stl容器</li>
<li>std::thread库</li>
<li>std::chrono库</li>
<li>智能指针系列(std::shared_ptr&#x2F;std::unique_ptr&#x2F;std::weak_ptr)，智能指针的实现原理</li>
<li>线程库std::thread + 线程同步技术库std::mutex&#x2F;std::condition_variable&#x2F;std::lock_guard等</li>
<li>Lambda表达式</li>
<li>std::bind&#x2F;std::function库</li>
<li>关键字的用法(override, final, delete)</li>
</ul>
<h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ 机器人控制系统相关笔记</li>
</ul>
<h2 id="C-机器人控制系统相关的C-库和框架"><a href="#C-机器人控制系统相关的C-库和框架" class="headerlink" title="C++ 机器人控制系统相关的C++库和框架"></a>C++ 机器人控制系统相关的C++库和框架</h2><p>C++ 是一种通用编程语言，可以用于编写各种类型的应用程序，包括机器人控制系统。</p>
<p>机器人控制系统通常涉及硬件控制和数据处理两个方面。在 C++ 中，您可以使用特定的库和框架来实现这些功能。</p>
<p>以下是一些与机器人控制相关的 C++ 库和框架：</p>
<p>Robot Operating System (ROS)：ROS 是一个用于构建机器人软件的开源框架。它提供了用于硬件抽象、设备驱动程序、库、可视化工具、消息传递和软件包管理的工具。</p>
<p>Robotics Library (RL)：RL 是一个用于机器人控制和仿真的 C++ 库。它提供了用于运动规划、动力学仿真、机器人建模和感知的工具。</p>
<p>OpenCV：OpenCV 是一个开源的计算机视觉库，可用于机器人的视觉感知和图像处理。</p>
<p>Boost C++ 库：Boost 是一个 C++ 库集合，其中包括许多常用的数据结构、算法和工具，可用于机器人控制系统中的各种任务。</p>
<p>如果您想开始使用 C++ 开发机器人控制系统，建议您首先了解 C++ 的基础知识，然后学习上述库和框架的用法。这些库和框架都有详细的文档和示例代码可供参考。通过练习和实践，您可以逐步提高您的技能，并开发出更高级的机器人控制系统。</p>
<h2 id="C-机器人控制系统相关的C-库和框架-详解"><a href="#C-机器人控制系统相关的C-库和框架-详解" class="headerlink" title="C++ 机器人控制系统相关的C++库和框架 详解"></a>C++ 机器人控制系统相关的C++库和框架 详解</h2><p>在机器人控制系统中，有许多C++库和框架可用于不同的任务，包括运动规划、传感器融合、模拟和仿真等。以下是一些常见的C++库和框架，它们在机器人控制领域具有广泛的应用：</p>
<ol>
<li><p><strong>ROS (Robot Operating System)</strong>:</p>
<ul>
<li><strong>简介</strong>: ROS是一个用于构建机器人软件的开源框架。它提供了一系列工具和库，用于传感器数据的处理、运动规划、通信和控制等方面。</li>
<li><strong>特点</strong>: 灵活、模块化，支持多语言（包括C++）。</li>
</ul>
</li>
<li><p><strong>Robotics Library (RL) - formerly known as SL</strong>:</p>
<ul>
<li><strong>简介</strong>: Robotics Library是一个用于机器人控制和仿真的C++库。它包括运动学、动力学、传感器处理和运动规划等功能。</li>
<li><strong>特点</strong>: 面向多关节机器人，提供强大的建模和仿真工具。</li>
</ul>
</li>
<li><p><strong>Orocos (Open Robot Control Software)</strong>:</p>
<ul>
<li><strong>简介</strong>: Orocos是一个用于实时控制系统的框架，支持多种硬件平台。它包括组件化的体系结构，适用于工业和研究用途。</li>
<li><strong>特点</strong>: 实时性能好，支持硬实时和软实时操作系统。</li>
</ul>
</li>
<li><p><strong>MoveIt!</strong>:</p>
<ul>
<li><strong>简介</strong>: MoveIt!是一个用于运动规划的库，特别适用于机器人操作系统（ROS）环境。它支持各种运动规划算法和机器人硬件。</li>
<li><strong>特点</strong>: 高度集成于ROS，易于使用，支持运动学和动力学规划。</li>
</ul>
</li>
<li><p><strong>Eigen</strong>:</p>
<ul>
<li><strong>简介</strong>: Eigen是一个C++模板库，用于线性代数运算。在机器人控制中，它经常用于进行矩阵和向量运算，例如在运动学和动力学计算中。</li>
<li><strong>特点</strong>: 高性能，使用模板元编程提高运行时性能。</li>
</ul>
</li>
<li><p><strong>Gazebo</strong>:</p>
<ul>
<li><strong>简介</strong>: Gazebo是一个开源的机器人仿真器，用于模拟机器人在不同环境中的行为。它可以与ROS集成，提供真实感的物理仿真。</li>
<li><strong>特点</strong>: 适用于仿真和测试，支持多种机器人模型。</li>
</ul>
</li>
</ol>
<p>这些库和框架在不同的方面提供了丰富的功能，选择取决于你的具体需求和项目要求。在使用这些工具时，请务必查看它们的文档以获取详细的信息和使用说明。</p>
<h2 id="C-机器人仿真"><a href="#C-机器人仿真" class="headerlink" title="C++ 机器人仿真"></a>C++ 机器人仿真</h2><p>在C++中进行机器人仿真涉及到使用适当的库和工具，以模拟机器人在虚拟环境中的行为。以下是一些用于C++机器人仿真的常见库和框架：</p>
<ol>
<li><p><strong>Gazebo</strong>:</p>
<ul>
<li><strong>简介</strong>: Gazebo是一个功能强大的开源机器人仿真器，它可以用于模拟机器人的行为、传感器和环境。它提供了高度可定制的物理引擎，支持ROS集成。</li>
<li><strong>特点</strong>: 物理精确度高，支持多机器人模型，提供多种传感器模拟。</li>
</ul>
</li>
<li><p><strong>Webots</strong>:</p>
<ul>
<li><strong>简介</strong>: Webots是一个通用的机器人仿真平台，支持C++编程语言。它可以用于模拟各种机器人，包括地面和飞行器。</li>
<li><strong>特点</strong>: 提供易于使用的用户界面，支持多种编程语言，有广泛的机器人模型和环境。</li>
</ul>
</li>
<li><p><strong>V-REP (CoppeliaSim)</strong>:</p>
<ul>
<li><strong>简介</strong>: V-REP（现在称为CoppeliaSim）是一个跨平台的仿真工具，支持C++编程。它提供了丰富的机器人模型、物理引擎和传感器模拟。</li>
<li><strong>特点</strong>: 易于集成到自动化系统中，支持远程API调用，适用于各种机器人应用。</li>
</ul>
</li>
<li><p><strong>Stage</strong>:</p>
<ul>
<li><strong>简介</strong>: Stage是ROS的一部分，是一个轻量级的2D机器人仿真器。它使用C++进行开发，适用于模拟地面机器人。</li>
<li><strong>特点</strong>: 简单易用，适用于快速原型设计，支持多机器人仿真。</li>
</ul>
</li>
<li><p><strong>Microsoft AirSim</strong>:</p>
<ul>
<li><strong>简介</strong>: AirSim是一个由Microsoft开发的开源机器人仿真工具，支持C++和其他编程语言。它专注于模拟无人机和汽车的行为。</li>
<li><strong>特点</strong>: 高度可定制，支持多种传感器，包括RGB相机和深度相机。</li>
</ul>
</li>
</ol>
<p>在选择机器人仿真工具时，需要考虑仿真的准确性、易用性、物理引擎质量以及与其他工具和库的集成能力。具体的选择将取决于项目的需求和目标。</p>
<h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ 线程池的应用</li>
</ul>
<h2 id="boost-asio"><a href="#boost-asio" class="headerlink" title="boost.asio"></a>boost.asio</h2><ul>
<li>boost::asio::thread_pool类</li>
<li>结合mongoose，搭建异步http服务器，示例代码如下:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">http_server_with_mongoose</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">HttpMessage</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::string path;</span><br><span class="line">        std::string method;</span><br><span class="line">        std::string body;</span><br><span class="line"></span><br><span class="line">        std::string response_type;</span><br><span class="line">        std::string response_body;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">HttpWithMongoose</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">mg_mgr</span> mgr;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">mg_connection</span> *connect;</span><br><span class="line">        boost::asio::thread_pool tp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">HttpWithMongoose</span>() : <span class="built_in">tp</span>(<span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">mg_mgr_init</span>(&amp;mgr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">HttpWithMongoose</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">mg_mgr_free</span>(&amp;mgr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            connect = <span class="built_in">mg_http_listen</span>(&amp;mgr, <span class="string">&quot;0.0.0.0:9999&quot;</span>, handle_event, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">mg_mgr_poll</span>(&amp;mgr, <span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Dispath</span><span class="params">(HttpMessage&amp; http_message)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;path: &quot;</span> &lt;&lt; http_message.path &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                      &lt;&lt; <span class="string">&quot;method: &quot;</span> &lt;&lt; http_message.method &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                      &lt;&lt; <span class="string">&quot;body: &quot;</span> &lt;&lt; http_message.body &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            http_message.response_type = <span class="string">&quot;Content-type: application/json&quot;</span>;</span><br><span class="line"></span><br><span class="line">            nlohmann::json reply_data;</span><br><span class="line">            reply_data[<span class="string">&quot;hello&quot;</span>] = <span class="string">&quot;http with mongoose!&quot;</span>;</span><br><span class="line">            http_message.response_body = reply_data.<span class="built_in">dump</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handle_event</span><span class="params">(mg_connection *connect, <span class="type">int</span> ev, <span class="type">void</span> *ev_data, <span class="type">void</span> *fn_data)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            HttpWithMongoose* this_ptr = <span class="built_in">static_cast</span>&lt;HttpWithMongoose *&gt;(fn_data);</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">mg_http_message</span>* hm = <span class="built_in">static_cast</span>&lt;<span class="keyword">struct</span> mg_http_message*&gt;(ev_data);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (ev)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> MG_EV_HTTP_MSG:</span><br><span class="line">                &#123;</span><br><span class="line">                    HttpMessage http_message;</span><br><span class="line"></span><br><span class="line">                    http_message.path = std::<span class="built_in">string</span>(hm-&gt;uri.ptr, hm-&gt;uri.len);</span><br><span class="line">                    http_message.method = std::<span class="built_in">string</span>(hm-&gt;method.ptr, hm-&gt;method.len);</span><br><span class="line">                    http_message.body = std::<span class="built_in">string</span>(hm-&gt;body.ptr, hm-&gt;body.len);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// std::thread tmp_thread = std::thread([](HttpMessage http_message, HttpWithMongoose* this_ptr, struct mg_connection* connect)</span></span><br><span class="line">                    <span class="comment">// &#123;</span></span><br><span class="line">                    <span class="comment">//     this_ptr-&gt;Dispath(http_message);</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//     mg_http_reply(connect, 200, http_message.response_type.c_str(), http_message.response_body.c_str());</span></span><br><span class="line">                    <span class="comment">//     connect-&gt;is_draining = 1;</span></span><br><span class="line">                    <span class="comment">// &#125;, http_message, this_ptr, connect);</span></span><br><span class="line">                    <span class="comment">// tmp_thread.detach();</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">auto</span> dpcp = [](HttpMessage http_message, HttpWithMongoose* this_ptr, <span class="keyword">struct</span> mg_connection* connect)</span><br><span class="line">                    &#123;</span><br><span class="line">                        this_ptr-&gt;<span class="built_in">Dispath</span>(http_message);</span><br><span class="line"></span><br><span class="line">                        <span class="built_in">mg_http_reply</span>(connect, <span class="number">200</span>, http_message.response_type.<span class="built_in">c_str</span>(), http_message.response_body.<span class="built_in">c_str</span>());</span><br><span class="line">                        connect-&gt;is_draining = <span class="number">1</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    boost::asio::<span class="built_in">post</span>(this_ptr-&gt;tp, std::<span class="built_in">bind</span>(dpcp, http_message, this_ptr, connect));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    HttpWithMongoose http_server;</span><br><span class="line"></span><br><span class="line">    http_server.<span class="built_in">Start</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">C++抽象机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>C++类是创建新类型的工具，创建出的新类型可以像内置类型一样方便地使用。而且派生类和模板允许程序员表达类之间的（层次和参数化）关系并且利用这种关系。</p>
</li>
<li><p>一个类型就是一个概念（一个思想，一个观念等）的具体表示。</p>
</li>
<li><p><strong>类是用户自定义类型。如果一个概念没有与之直接对应的内置类型，我们就定义一个新类型来表示它。</strong></p>
</li>
<li><p>定义新类型的基本思想是将实现的细节（例如，某种类型对象的数据存储布局）与正确使用它的必要属性（例如，可访问数据的函数的完整列表）分离。这种分离的最佳表达方式是：通过一个专用接口引导数据结构及其内部辅助例程的使用</p>
</li>
</ul>
<h3 id="类基础"><a href="#类基础" class="headerlink" title="类基础"></a>类基础</h3><ul>
<li><p>类的简要概括：</p>
<ul>
<li>一个类就是一个用户自定义类型</li>
<li>一个类由一组成员构成。最常见的成员类别是数据成员和成员函数</li>
<li>成员函数可定义初始化（创建），拷贝，移动和清理（析构）等语义</li>
<li>可以为类定义运算符，如+， ！和[]</li>
<li>一个类就是一个包含其成员的名字空间</li>
<li>对对象使用<code>.（点）</code>访问成员，对指针使用<code>-&gt;（箭头）</code>访问成员</li>
<li><strong>public成员提供类的接口，private成员提供实现细节。</strong></li>
<li>struct是成员默认为public的class</li>
</ul>
</li>
<li><p>声明于类定义内的函数称为成员函数(member function)，对恰当类型的特定变量使用结构成员访问语法才能调用这种函数。</p>
</li>
<li><p>由于不同结构可能有同名成员函数，在定义成员函数时必须指定结构名。</p>
</li>
</ul>
<h3 id="类内函数定义"><a href="#类内函数定义" class="headerlink" title="类内函数定义"></a>类内函数定义</h3><ul>
<li>如果一个函数不仅在类中声明，还在类中定义，那么它就被当作内联函数处理，即很少修改且频繁使用的小函数适合类内定义。</li>
</ul>
<h3 id="自引用"><a href="#自引用" class="headerlink" title="自引用"></a>自引用</h3><ul>
<li>在非static成员函数中，关键字this是指向调用它的对象的指针</li>
</ul>
<h3 id="成员和基类初始化"><a href="#成员和基类初始化" class="headerlink" title="成员和基类初始化"></a>成员和基类初始化</h3><ul>
<li>类自身的构造函数在其函数体执行之前会先调用成员的构造函数</li>
<li>成员的构造函数按成员在类中声明的顺序调用，而不是按成员在初始化器列表中出现的顺序。</li>
</ul>
<h3 id="不变式"><a href="#不变式" class="headerlink" title="不变式"></a>不变式</h3><ul>
<li><p>一个类通常都会有一个不变式。如果是这样，我们希望拷贝和移动操作能够保持此不变式，而析构函数能释放任何用到的资源。</p>
</li>
<li><p>不幸的是，编译器不可能在任何情况下都能了解程序员所考虑的不变式是什么。只要可能，我们就应该：</p>
<ul>
<li>在构造函数中建立不变式（包括可能的资源获取）</li>
<li>在拷贝和移动操作中保持不变式（利用常用名字和类型）</li>
<li>在析构函数中做任何需要的清理工作（包括可能的资源释放）</li>
</ul>
</li>
<li><p>不变式很多最关键，最明显的应用都与资源管理相关。</p>
</li>
<li><p>简单的句柄Handle，其思想是，给定一个用new分配的对象的指针，创建一个Handle。这个Handle提供对象访问功能，并负责最终delete对象</p>
</li>
</ul>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><ul>
<li>应该将构造函数，赋值操作以及析构函数设计为一组匹配的操作</li>
<li>使用构造函数为类建立不变式</li>
<li>如果一个构造函数获取了资源，那么这个类就需要一个析构函数释放该资源</li>
<li><strong>如果一个类有虚函数，它就需要一个虚析构函数。</strong></li>
<li>如果一个类没有构造函数，它可以进行逐成员初始化</li>
<li>优先选择使用<code>&#123;&#125;</code>初始化而不是<code>=</code>和<code>()</code>初始化</li>
<li>如果一个类是一个容器，为它定义一个初始化器列表构造函数</li>
<li>按声明顺序初始化成员和基类</li>
<li>在构造函数中优先选择成员初始化而不是赋值操作</li>
<li>使用类内初始化器来提供默认值</li>
<li>如果一个类是一个资源句柄，它可能需要拷贝和移动操作</li>
<li>一个拷贝操作应该提供等价性和独立性</li>
<li>如果一个类被用作基类，防止切片现象</li>
<li>如果一个类需要一个拷贝操作或者一个析构函数，它可能需要一个构造函数，一个析构函数，一个拷贝赋值操作以及一个拷贝构造函数。</li>
<li>如果一个类是一个资源句柄，它需要一个构造函数，一个析构函数和非默认拷贝操作</li>
<li>显式说明你的不变式；用构造函数建立不变式，用赋值操作保持不变式</li>
</ul>
<h2 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h2><ul>
<li><p>C++从Simula借鉴了类和类层次的思想。而且，C++还借鉴了一个重要的设计思想：<strong>类应该用来建模程序员和应用程序世界中的思想</strong></p>
</li>
<li><p>任何一个概念都不是孤立存在的，都有与之共存的相关概念，而且其强大能力中的大部分都源于与其它概念的关联。</p>
</li>
<li><p>C++提供了派生类的概念及相关的语言机制来表达层次关系，即，<strong>表达类之间的共性</strong></p>
</li>
<li><p>C++语言特性支持从已有类构建新的类：</p>
<ul>
<li>实现继承(implementation inheritance):通过共享基类所提供的特性来减少实现工作量</li>
<li>接口继承(interface inheritance):通过一个公共基类提供的接口允许不同派生类互换使用。</li>
</ul>
</li>
<li><p>接口继承常被称为<strong>运行时多态(run-time polymorphism, 或动态多态, dynamic polymorphism)</strong></p>
</li>
<li><p>相反，模板所提供的类的通用性与继承无关，常被称为<strong>编译时多态(compile-time polymorphism， 或静态多态, static polymorphism)</strong></p>
</li>
<li><p>我们常常称一个派生类继承了来自基类的属性，因此这种关系也称为继承(inheritance)</p>
</li>
<li><p>派生类的成员可以使用基类的公有和保护成员，就好像它们声明在派生类中一样，但是派生类不能访问基类的私有成员</p>
</li>
</ul>
<h2 id="类层次"><a href="#类层次" class="headerlink" title="类层次"></a>类层次</h2><ul>
<li>一个派生类自身也可以作为其他类的基类，我们习惯称这样的一组相关的类为类层次(class hierarchy)。</li>
<li>这种层次结构大多数情况下是一棵树，但也可能是更一般的图结构</li>
</ul>
<h3 id="类型域"><a href="#类型域" class="headerlink" title="类型域"></a>类型域</h3><ul>
<li>为了使派生类不至于成为仅仅是一种方便的声明简写方式，我们必须解决一个问题：给定一个Base* 类型的指针，它指向的对象的真正派生类型是什么?</li>
<li>C++提供了四种基本解决方法：<ol>
<li>保证指针只能指向单一类型的对象</li>
<li>在基类中放置一个类型域，供函数查看</li>
<li>使用dynamic_cast</li>
<li>使用虚函数</li>
</ol>
</li>
<li>除非使用final，否则方法1依赖于所使用类型的很多值是，比编译器所能掌握的更多。一般而言，不要试图比类型系统更聪明。但是方法1可用来（特别是与模板组合使用）实现同构容器（如标准库vector和map），以获得非常好的性能</li>
<li>方法2，3和4可用来实现异构列表，即，多种不同类型对象（指针）的列表。</li>
<li>方法3是方法2的一种语言支持的变体，</li>
<li>方法4是方法2的一种特殊的类型安全的变体</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul>
<li><p><strong>虚函数机制允许程序员在基类中声明函数，然后在每个派生类中重新的定义这些函数，从而解决了类型域方法的固有问题</strong>。编译器和链接器会保证对象和施用于对象之上的函数之间的正确关联。</p>
</li>
<li><p>为了允许一个虚函数声明能作为派生类中定义的函数的接口，派生类中函数的参数类型必须与基类中声明的参数类型完全一致，返回类型也只允许细微改变。虚成员函数有时也称为方法(method)</p>
</li>
<li><p>如果派生类中的一个函数的<strong>名字</strong>和<strong>参数类型</strong>与基类中的一个虚函数完全相同，则称它**覆盖(override)**了虚函数的基类版本。此外，我们也可以用一个派生层次更深的返回类型覆盖基类中的虚函数</p>
</li>
<li><p>除了我们显式说明调用虚函数的哪个版本之外，覆盖版本会作为最恰当的选择应用于调用它的对象。无论用哪个基类（接口）访问对象，虚函数调用机制都会保证我们总是得到相同的函数</p>
</li>
<li><p>无论真正使用的确切<code>Employee</code>类型是什么，都能令<code>Employee</code>的函数表现出“正确的”行为，这称为<strong>多态性(polymorphism)<strong>。具有虚函数的类型称为</strong>多态类型(polymorphic type)<strong>或（更精确的）</strong>运行时多态类型(run-time polymorphic type)</strong></p>
</li>
<li><p><strong>在C++中为了获得运行时多态行为，必须调用virtual成员函数，对象必须通过指针或引用进行访问</strong>。当直接操作一个对象时（而不是通过指针或引用）编译器了解其确切类型，从而就不需要运行时多肽了。</p>
</li>
<li><p>默认情况下，覆盖虚函数的函数自身也变为virtual的。我们在派生类宗可以重复关键字virtual，但是这不是必需的。建议不重复virtual。如果希望明确标记覆盖版本，可以使用<code>override</code>。</p>
</li>
<li><p>显然，为了实现多态性，编译器必须在每个Employee类的对象中保存某种类型信息，并利用它选择虚函数的正确版本。在一个典型的C++实现中，这只会占用一个指针大小的空间：常用的编译器实现技术是将虚函数名转换为函数指针表中的一个索引。这个表通常称为**虚函数表(the virtual function table)**或者简称为vbtl。每个具有虚函数的类都有自己的vbtl,用来标识它的虚函数。</p>
</li>
<li><p><strong>显式限定</strong>，使用作用域解析运算符<code>::</code>调用函数<code>(Manager::print())</code>能够保证不是用virtual机制</p>
</li>
<li><p>如果一个虚函数也是一个inline，对于使用<code>::</code>限定的调用就可以进行内联替换。这给程序员提供了一种方法高效处理某些重要的特殊情形：一个虚函数对相同对象调用另一个虚函数。</p>
</li>
</ul>
<h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><ul>
<li>override不是一个关键字，它是所谓的上下文关键字(contextual keyword)。即，override在某些上下文中有特殊含义，但是在其他地方可用作标识符</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul>
<li><p>具有一个或者多个纯虚函数的类称为抽象类(abstract class)，我们无法创建抽象类的对象</p>
</li>
<li><p>抽象类就是要作为<strong>通用指针</strong>和<strong>引用访问</strong>的对象的接口（为了保持多态行为）</p>
</li>
<li><p>因此，对于一个抽象类来说，定义一个虚析构函数通常很重要。由于抽象类提供的接口不能用来创建对象，因此抽象类通常没有构造函数。</p>
</li>
<li><p>如果纯虚函数在派生类中未被定义，那么它仍保持是纯虚函数，因此派生类也是一个抽象类。这令我们可以阶段性地构建具体实现</p>
</li>
<li><p>抽象类提供接口，但是不暴露实现细节。</p>
</li>
<li><p>抽象类所支持的设计风格称为接口继承(interface inheritance)，它与实现继承(implementation inheritance)相对，后者是由带状态或定义了成员函数的基类所支撑的。两种风格组合使用是有可能的。即，我们可以定义并使用即带状态又有纯虚函数的基类。但是，这种混合风格会令人迷惑，也需要特别小心。</p>
</li>
</ul>
<h2 id="基类和派生类成员"><a href="#基类和派生类成员" class="headerlink" title="基类和派生类成员"></a>基类和派生类成员</h2><ul>
<li>一个派生类至少包含从基类那里继承来的成员，通常还包含其他成员。这意味着我们可以安全地将一个基类成员指针赋予一个派生类成员指针，但是反方向赋值则不行，这一特性常被称为逆变性(contravariance)</li>
<li>这一逆变规则看起来与另一规则是相反的：我们可以将一个派生类指针赋予其基类的指针。</li>
<li>实际上，两个规则都是为了提供基本保障：<strong>一个指针永远不应该指向这样的对象–不能提供指针所承诺的最基本的属性。</strong></li>
</ul>
<h2 id="类层次-1"><a href="#类层次-1" class="headerlink" title="类层次"></a>类层次</h2><ul>
<li>一个系统应该用抽象类层次表示，而用传统的层次体系实现。换句话说：<ul>
<li>用抽象类支持接口继承</li>
<li>用带有虚函数实现的基类支持实现继承</li>
</ul>
</li>
</ul>
<h3 id="多重继承-multiple-inheritance"><a href="#多重继承-multiple-inheritance" class="headerlink" title="多重继承(multiple inheritance)"></a>多重继承(multiple inheritance)</h3><ul>
<li><p>直接从多个类中派生称为多重继承</p>
</li>
<li><p>用一个基类表示实现细节，用另一个基类表示接口（抽象类）的做法对于所有支持继承和编译时接口检查的编程语言来说都是非常常见的。</p>
</li>
<li><p>“我个人习惯于使用一个实现层次体系，再（在必要时）辅以几个提供接口的抽象类。这种方式比较灵活，也易于系统的演化。但是我们未必总能如愿，尤其是当需要使用现有的类，有不想对它作出任何修改时更时如此（比如，这些类属于别人的库）”</p>
</li>
</ul>
<h3 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h3><ul>
<li>两个基类的成员函数可能具有相同的名字，产生歧义。具体做法是为成员名字加一个类限定符。</li>
<li>然而，显式消除二义性比较繁琐，解决此类问题的最佳方式是在派生类中定义一个新函数。在派生类中声明的函数会覆盖基类中所有同名及同类型的函数。通常情况下，这种效果就是我们需要的，因为在同一个类中的同一个名字不宜有多重含义。<strong>virtual的目标是对于一个调用来说，不管我们是通过哪个接口找到函数的，它的执行效果都应该保持一致。</strong></li>
</ul>
<h2 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h2><ul>
<li><p>如果每个类只有一个直接基类，则类层次表现为一棵树，并且每个类在树中只能出现一次。如果每个类可以有多个基类，则在层次体系中每个类可能出现多次。</p>
</li>
<li><p>重复基类的虚函数可以在派生类中被一个（单独的）函数覆盖。通常情况下，这个覆盖的函数先调用其基类的版本，然后执行派生类自己的操作。</p>
</li>
<li><p>每个被指定为virtual的基类只用该类的一个单独的对象表示。另一个方面，非virtual基类由其子对象表示。</p>
</li>
<li><p><strong>派生类可以覆盖其直接或者间接虚基类的虚函数。尤其是，两个不同的类可能会覆盖虚基类的不同的虚函数。通过这种方式，几个派生类就能共同为一个虚基类表示的接口提供实现了。</strong></p>
</li>
</ul>
<h3 id="建议-1"><a href="#建议-1" class="headerlink" title="建议"></a>建议</h3><ul>
<li>不要在作为接口的基类中放置数据成员</li>
<li>用抽象类表示接口</li>
<li>为抽象基类定义一个虚析构函数确保其正确地清理资源</li>
<li>用抽象类支持接口继承</li>
<li>用含有数据成员的基类支持实现继承</li>
<li>用普通的多重继承表示特征的组合</li>
<li>用多重继承把实现的接口分离开来</li>
<li>用虚基类表示层次中一部分（而非全部）类公有的内容</li>
</ul>
<h2 id="运行时类型信息"><a href="#运行时类型信息" class="headerlink" title="运行时类型信息"></a>运行时类型信息</h2><ul>
<li>一般来说，类是从基类的框架中构造出来的。这种类框架(class lattice)通常被称为类层次(class hierarchy)</li>
<li>在运行时使用类型信息通常被称为“运行时类型信息”，简写为RTTI(Run-Time Type Information)</li>
<li>从基类到派生类的转换通常称为向下转换(downcast),从派生类到基类的转换称为向上转换(upcast),从基类到兄弟类的转换，称为交叉转换(crosscast)</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/" class="post-title-link" itemprop="url">C++常见错误</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C&#x2F;C++程序编译或者运行常见错误</li>
</ul>
<h2 id="error-C2061-语法错误-标识符"><a href="#error-C2061-语法错误-标识符" class="headerlink" title="error C2061: 语法错误 标识符"></a>error C2061: 语法错误 标识符</h2><ul>
<li>错误原因： 重复包含，即A包含了B，B又包含了A</li>
<li>解决办法：头文件class cpp文件include。就是在A.h中，声明B类；在A.cpp中 #include”B.h”</li>
</ul>
<h2 id="windows下C-程序运行出错-Access-violation-reading-location"><a href="#windows下C-程序运行出错-Access-violation-reading-location" class="headerlink" title="windows下C++程序运行出错: Access violation reading location"></a>windows下C++程序运行出错: Access violation reading location</h2><ul>
<li><p>在Visual Studio 2019的Ｃ++工程，编译是没有问题的，但是在程序调试运行时经常会出现’Access violation reading location’的问题，经过调试跟踪后，发现是由于变量被多个代码段访问到，可能出现了空指针的情况。这种错误也不是每次都发生，所以比较难找到原因和追踪到。具体原因可能是所访问的变量已经被其它部分代码改动了，具体建议如下：<br>Then verify that the values are not being unintentionally changed somewhere in the program by creating a Data Breakpoint for the pointer in question to make sure it isn’t being modified elsewhere in the program.</p>
</li>
<li><p>使用以下两个办法可以大大减少此类问题的发生。  </p>
<ul>
<li>在有可能发生变量使用冲突的地方加上 try {…} catch (std::exception ex) {} 来捕捉这个异常，异常被捕捉到后程序时可以接着运行的</li>
<li>减少多段代码访问同一个变量的情况。</li>
</ul>
</li>
</ul>
<h2 id="warning-C4819-该文件包含不能在当前代码页-936-中表示的字符。请将该文件保存为-Unicode-格式以防止数据丢失"><a href="#warning-C4819-该文件包含不能在当前代码页-936-中表示的字符。请将该文件保存为-Unicode-格式以防止数据丢失" class="headerlink" title="warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失"></a>warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失</h2><ul>
<li>使用vs编译时遇到这个错误,正常情况下写的文件是没有问题的，只要用其它编辑器修改过后再保存,再用vs编译就会出现这个问题。</li>
<li>解决方法<ul>
<li>在VS IDE中将文件另存为，在保存中选择高级保存选项，选择 Unicode (UTF-8 带签名) - 代码页65001</li>
</ul>
</li>
</ul>
<h2 id="C-to-‘const-std-mutex’-discards-qualifiers-错误"><a href="#C-to-‘const-std-mutex’-discards-qualifiers-错误" class="headerlink" title="C++ to ‘const std::mutex’ discards qualifiers 错误"></a>C++ to ‘const std::mutex’ discards qualifiers 错误</h2><p>这个错误通常是因为你在尝试将一个非 const 的 <code>std::mutex</code> 对象赋值给一个 <code>const std::mutex</code> 对象，或者你在一个 const 成员函数中尝试对一个非 const 的 <code>std::mutex</code> 对象进行操作。这违反了 C++ 的 const-correctness 原则，即 const 对象只能调用 const 成员函数，并且不能被修改。</p>
<p>以下是一个示例，展示了可能导致这个错误的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 错误！const 成员函数中尝试对非 const 的 mutex 进行操作</span></span><br><span class="line">        mutex.<span class="built_in">lock</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing something...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mutex; <span class="comment">// 使用 mutable 关键字标记 mutex 可以在 const 成员函数中修改</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> MyClass obj;</span><br><span class="line">    obj.<span class="built_in">doSomething</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要解决这个问题，你需要确保在 const 成员函数中只能对 <code>std::mutex</code> 对象调用 <code>const</code> 成员函数，或者使用 <code>mutable</code> 关键字标记 <code>std::mutex</code>，以便在 const 成员函数中修改它。</p>
<h2 id="C-as-‘this’-argument-discards-qualifiers-fpermissive-错误"><a href="#C-as-‘this’-argument-discards-qualifiers-fpermissive-错误" class="headerlink" title="C++ as ‘this’ argument discards qualifiers [-fpermissive] 错误"></a>C++ as ‘this’ argument discards qualifiers [-fpermissive] 错误</h2><p>这个错误通常是由于在常量成员函数中试图修改成员变量引起的。C++ 中的常量成员函数是指在函数声明和定义中使用 <code>const</code> 修饰的成员函数，表示该函数不会修改调用对象的成员变量。</p>
<p>错误信息 “‘this’ argument discards qualifiers” 意味着你在常量成员函数中试图修改 <code>this</code> 指针所指向的对象。这是不允许的，因为常量成员函数被设计为不修改对象的状态。</p>
<p>以下是一个简单的例子，展示了可能导致这个错误的情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量成员函数，试图修改成员变量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modifyData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 错误：试图在常量成员函数中修改成员变量</span></span><br><span class="line">        <span class="comment">// data = 42;</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> MyClass obj;</span><br><span class="line">    obj.<span class="built_in">modifyData</span>();  <span class="comment">// 调用常量成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>modifyData</code> 是一个常量成员函数，但它试图修改 <code>data</code> 成员变量，这将导致上述错误。</p>
<p>要解决这个问题，你应该确保在常量成员函数中不修改成员变量。如果你需要在常量对象上调用一个能够修改成员变量的函数，该函数应该被声明为非常量成员函数。如果你确实需要在常量对象上进行某些修改，你可能需要使用 <code>mutable</code> 关键字来声明一个可变的成员变量。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> data; <span class="comment">// 使用 mutable 关键字声明可变成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modifyData</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        data = <span class="number">42</span>; <span class="comment">// 合法：在常量成员函数中修改可变成员变量</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>请根据你的需求选择适当的解决方案。</p>
<h2 id="C-编译错误-error-prototype-for"><a href="#C-编译错误-error-prototype-for" class="headerlink" title="C++ 编译错误 error: prototype for"></a>C++ 编译错误 error: prototype for</h2><p>看起来你遇到了一个编译错误，错误信息中包含了 “error: prototype for”。这通常是因为函数的声明和定义之间存在不一致，导致编译器无法匹配它们。</p>
<p>常见的情况包括：</p>
<ol>
<li>函数声明和函数定义之间的参数不匹配。</li>
<li>函数声明和函数定义之间的返回类型不匹配。</li>
</ol>
<p>要解决这个问题，你需要确保函数的声明和定义在参数和返回类型等方面保持一致。以下是一些可能导致这个错误的情况以及解决方法：</p>
<p><strong>情况1：参数不匹配</strong></p>
<p>假设你有以下的函数声明和定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，声明和定义中的参数名称不一致（x、y 和 a、b）。编译器会认为这是两个不同的函数，因此会产生错误。解决方法是保持参数名称一致：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明和定义都使用相同的参数名称</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>情况2：返回类型不匹配</strong></p>
<p>另一个可能的情况是函数的声明和定义之间的返回类型不匹配：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，声明指定了函数返回类型为 <code>int</code>，但定义实际上是一个无返回值的函数（返回类型为 <code>void</code>）。要解决这个问题，保持返回类型一致：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明和定义都使用相同的返回类型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请检查你的代码，确保函数的声明和定义在参数和返回类型等方面保持一致，这样编译器就不会报 “error: prototype for” 错误了。如果问题仍然存在，你可以提供更多的代码片段和错误信息，我将尽力帮助你找到解决方案。</p>
<h2 id="C-编译错误-error-candidate-is"><a href="#C-编译错误-error-candidate-is" class="headerlink" title="C++ 编译错误 error: candidate is"></a>C++ 编译错误 error: candidate is</h2><p>你好！你提供的信息有点有限，我需要更多的上下文来帮助你解决这个问题。”error: candidate is” 是一个编译错误的提示信息，通常出现在 C++ 代码中。这个错误提示通常是由于在某个上下文中找到了多个可能匹配的候选项，编译器无法确定要选择哪个。</p>
<p>为了更好地帮助你，可以提供以下信息：</p>
<ol>
<li>完整的错误提示信息，包括错误的文件路径、行号和列号。</li>
<li>引发错误的代码片段，尤其是错误所在的代码行附近的代码。</li>
<li>你正在尝试进行的操作，以及你的预期结果。</li>
</ol>
<p>这些信息将有助于我更准确地理解问题，并为你提供更具体的帮助。</p>
<h2 id="没有命名类型-declare-class-does-not-name-type"><a href="#没有命名类型-declare-class-does-not-name-type" class="headerlink" title="没有命名类型: declare class does not name type"></a>没有命名类型: <code>declare class does not name type</code></h2><ul>
<li><p>出现这个编译错误主要有四个可能原因，现总结如下：</p>
<ul>
<li>引用的类命名空间未包含</li>
<li>引用的类头文件未包含</li>
<li>包含了头文件，或者已经前置声明了，则说明所引用的类名写错了</li>
<li><strong>循环引用头文件</strong></li>
<li>定义或声明的语句，第一个词一定是类型</li>
</ul>
</li>
<li><p>前置声明要素：</p>
<ul>
<li>前置声明需要注意以上提到的几点</li>
<li>尽可能的采用前置声明，做到只有包含继承类的头文件</li>
<li>使用前置声明时，CPP文件中include头文件次序必须先包含前置声明的类定义头文件，再包含本类头文件。否则会出现错误：<ul>
<li><code>(expected constructor, destructor, or type conversion before ‘typedef&#39;)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>前置声明</p>
<ul>
<li><code>XXX</code>应该是一种用户定义的数据类型，而由于没有声明或者拼写错误或者与关键词重名，导致编译有错，出现类型错误</li>
<li>在一个源文件中，要声明或定义一个类的指针时，必须在使用前声明或定义该类</li>
</ul>
</li>
<li><p>使用前置声明：</p>
<ul>
<li><code>class Base;</code></li>
</ul>
</li>
</ul>
<h2 id="未声明的引用"><a href="#未声明的引用" class="headerlink" title="未声明的引用"></a>未声明的引用</h2><ul>
<li><p>如果错误是未声明的引用，那就是找不到函数的原型</p>
</li>
<li><p>解决办法，通常是相关的头文件未包含</p>
</li>
</ul>
<h2 id="未定义引用-undefined-reference-to-xxx"><a href="#未定义引用-undefined-reference-to-xxx" class="headerlink" title="未定义引用:undefined reference to &#39;xxx&#39;"></a>未定义引用:<code>undefined reference to &#39;xxx&#39;</code></h2><ul>
<li><p>未定义引用的问题是：编译之后，链接阶段出现的</p>
</li>
<li><p>未定义引用产生的原因：</p>
<ul>
<li>一个是，生成库文件的时候，某个源文件(cpp)路径不正确</li>
<li>另一个是，有函数声明，但是没有函数定义</li>
</ul>
</li>
<li><p>出现未定义引用的错误原因，主要是C&#x2F;C++编译为object文件的时候，并不需要函数的具体实现，只要有函数的原型即可，但是在链接可执行文件的时候就必须要具体的实现了。</p>
</li>
<li><p>一般的原因：</p>
<ul>
<li>gcc依赖顺序问题</li>
<li>库文件找不到</li>
<li>库文件损坏</li>
<li>C++编译时会修改函数名，CPP文件引用C文件中的函数，混编时很可能报未定义的错误，需要使用<code>extern &quot;C&quot;</code>包裹起来</li>
</ul>
</li>
</ul>
<h2 id="段错误-Segmentation-fault"><a href="#段错误-Segmentation-fault" class="headerlink" title="段错误:Segmentation fault"></a>段错误:<code>Segmentation fault</code></h2><ul>
<li><p>段错误是什么？</p>
<ul>
<li>段错误是指访问的内存超出了系统给这个程序所设定的内存空间。</li>
</ul>
</li>
<li><p>段错误产生的原因</p>
<ol>
<li>访问不存在的内存地址</li>
<li>访问系统保护的内存地址</li>
<li>访问制度的内存地址</li>
<li>栈溢出</li>
<li>delete使用错误</li>
</ol>
</li>
</ul>
<h2 id="corrupted-size-vs-prev-size-问题-内存越界"><a href="#corrupted-size-vs-prev-size-问题-内存越界" class="headerlink" title="corrupted size vs. prev_size 问题 内存越界"></a><code>corrupted size vs. prev_size</code> 问题 内存越界</h2><ul>
<li><p>在C++中我们时常会遇见<code>corrupted size vs. prev_size</code>的报错，它的原因在于<strong>内存越界</strong></p>
</li>
<li><p>其实解决这个问题的办法在于使用<code>vector</code>来代替自己申请内存，并且使用以下两种方法来访问元素：</p>
<ul>
<li>使用迭代器</li>
<li>使用<code>at</code></li>
</ul>
</li>
<li><p>尽量要避免使用<code>[]</code>来访问<code>vector</code>，越界的时候很难找到错误的地方，使用<code>at</code>带有越界的检查，更为安全。</p>
</li>
</ul>
<h2 id="memory-corruption-内存泄漏"><a href="#memory-corruption-内存泄漏" class="headerlink" title="memory corruption  内存泄漏"></a><code>memory corruption</code>  内存泄漏</h2><h2 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h2><ul>
<li><p>内存问题始终是C++程序员需要去面对的问题，这也是C++语言门槛高的原因之一</p>
</li>
<li><p>常见的内存问题：</p>
<ol>
<li>内存重复释放，出现<code>double free</code>时，通常是由于这种情况导致的</li>
<li>内存泄漏，分配的内存忘记释放</li>
<li>内存越界使用，使用了不该使用的内存</li>
<li>使用了无效指针</li>
<li>空指针，对一个空指针进行操作</li>
</ol>
</li>
<li><p>内存越界，引起的问题有极大的不确定性，有时大，有时小，有时可能不会对程序的运行产生影响，正是这种不易复现的错误，才是最致命的。</p>
</li>
<li><p>内存越界，通常可能会造成如下几种情况：</p>
<ol>
<li>破坏了堆中的内存分配信息数据，特别是动态分配的内存块的内存信息数据。因为操作系统在分配和释放内存块时需要访问该数据，一旦该数据被破坏，可能会出现一下几种情况：   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">        *** glibcdetected *** free(): invalid pointer:</span><br><span class="line">        *** glibcdetected *** malloc(): memory corruption:</span><br><span class="line">        *** glibcdetected *** double free or corruption (out): 0x00000000005c18a0 ***</span><br><span class="line">        *** glibcdetected *** corrupted double-linked list: 0x00000000005ab150***</span><br><span class="line">        ```    </span><br><span class="line">  2. 破坏了程序自己的其他对象的内存空间，这种破坏会影响程序执行的不正确性，当然也会诱发`coredump`，如破坏了指针数据</span><br><span class="line">  3. 破坏了空闲内存块</span><br><span class="line">  4. 通常，代码错误被激发是偶然的，也就是说之前的程序一切正常，可能由于为类增加了两个成员变量，或者改变了某一部分代码，`coredump`就频繁发生，而增加的代码绝不会有任何问题，这时应该考虑**是否是某些内存被破坏了**。</span><br><span class="line"></span><br><span class="line">+ 注意事项：</span><br><span class="line">  1. **出现段错误时**，首先应该想到段错误的定义，从它出发考虑引发错误的原因</span><br><span class="line">  2. **在使用指针时**，定义了指针后记得初始化指针，在使用的时候记得判断是否为NULL</span><br><span class="line">  3. **在使用数组时**，注意数组是否被初始化，数组下标是否越界，数组元素是否存在等</span><br><span class="line">  4. **在访问变量时**，注意变量所占地址空间是否已经被程序释放</span><br><span class="line">  5. **在处理变量时**，注意变量的格式控制是否合理等</span><br><span class="line"></span><br><span class="line">## 核心转储:`core dumped`</span><br><span class="line"></span><br><span class="line">+ 当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的**内存状态**记录下来，保存在一个文件中，这种行为就叫做`Core Dump`（中文有的翻译成 核心转储）</span><br><span class="line">+ 可以认为`core dump`是内存快照，但实际上，除了内存信息之外，还有一些关键的程序运行状态也会同时`dump`下来，例如寄存器信息（包括程序指针，栈指针），内存管理信息，其他处理器和操作系统状态和信息。</span><br><span class="line">+ `Segmentation fault (core dumped)`通常是内存未正常操作造成。空指针，野指针的读写操作，数组越界访问，破坏常量等。</span><br><span class="line"></span><br><span class="line">+ 打开`core dump`功能</span><br><span class="line">  1. 在终端输入命令`ulimit -c`，输出结果为0，表示关闭`core dump`，即当程序异常终止时，也不会生成`core dump`文件</span><br><span class="line">  2. 可以使用命令`ulimit -c unlimited`来开启`core dump`功能，并且不限制`core dump`文件的大小；如果需要限制文件的大小，将`unlimited`换成想生成文件的存储上限，单位为blocks(KB)</span><br><span class="line">  3. 用上面命令只会对当前终端环境有效，如果想要永久生效，需要设置文件`/etc/security/limits.conf`文件</span><br><span class="line">  4. 默认生成的`core`文件保存在可执行文件所在的目录下，文件名就为`core`</span><br><span class="line">  5. 修改文件`/proc/sys/kernel/core_uses_pid`文件可以让生成`core`文件名自动加上pid号</span><br><span class="line">  6. 修改文件`/proc/sys/kernel/core_pattern`控制生成`core`文件保存的位置以及文件名格式</span><br><span class="line"></span><br><span class="line">## Linux下C/C++程序内存泄露检查工具</span><br><span class="line"></span><br><span class="line">+ valgrind:强大开源的程序检测工具</span><br><span class="line">+ mtrace:GNU扩展,用来跟踪malloc</span><br><span class="line">+ dmalloc:用于检查C/C++内存泄露的工具,即是检查是否在程序运行结束还没有释放的内存,以一个运行库发布</span><br><span class="line">+ memwatch:和dmalloc一样,能够检测未释放的内存,同一段内存被释放多次,位地址取错误及不当使用未分配的内存区域</span><br><span class="line">+ mpatrol:一个跨平台的C++内存泄露检测器</span><br><span class="line">+ dbgmem:是一个动态库发布的形式,有点类似于dmalloc</span><br><span class="line"></span><br><span class="line">### Valgrind详解</span><br><span class="line"></span><br><span class="line">+ `Valgrind`包含以下一些工具:</span><br><span class="line">  1. `Memcheck`:这是`valgrind`应用最广泛的工具,一个重量级的内存检查器,能够发现 开发中绝大不多述的内存错误使用的情况,比如:使用未初始化</span><br><span class="line">  2. `callgrind`:主要用来检查程序中函数调用过程中出现的问题</span><br><span class="line">  3. `cachegrind`:主要用来检查程序中缓存使用出现的问题</span><br><span class="line">  4. `Helgrind`:主要用来检查多线程中出现的竞争问题</span><br><span class="line">  5. `Massif`:主要用来检查程序中堆栈使用中出现的问题</span><br><span class="line">  6. `Extension`:可以使用core提供的功能,自己编写特定的内存调试工具</span><br><span class="line"></span><br><span class="line">+ 内存检查原理:</span><br><span class="line">  1. `Valid-value`表:对于进程的整个地址空间中的每一个字节(byte),都有与之对应的8个bits,对于CPU的每个寄存器,也有一个与之对应的bit向量,这些bits负责记录该字节或者寄存器值是否具有有效的,已经初始化的值</span><br><span class="line">  2. `Valid-Address`表:对于进程整个地址空间中的一个字节(byte),还有与之对应的1bit,负责记录改地址是否能够被读写</span><br><span class="line">  3. 检测原理:</span><br><span class="line">     + 当要读写内存中的某个字节时,首先检查这个字节对应的A bit, 如果该A bit显示该位置是无效位置,memcheck则报告读写错误</span><br><span class="line">     + 内核(core)类似于一个虚拟的CPU环境,这样当内存中的某个字节被加载到真实的CPU中时,该字节对应的V bit也被加载到虚拟的CPU环境中,一旦寄存器中的值,被用来产生内存地址,或者该值能够影响程序的输出,则memcheck会检查对应的vbits,如果该值尚未初始化,则会报告使用未初始化内存错误</span><br><span class="line"></span><br><span class="line">+ `Valgrind`的安装</span><br><span class="line">  1. 解压安装包:`tar -jxvf valgrind-3.11.0.tar.bz2 -C /usr/local/src`</span><br><span class="line">  2. 进入目录安装:`cd /usr/local/src/valgrind-3.11.0`</span><br><span class="line">  3. 运行 `./autogen.sh` 设置环境(需要标准的`autoconf`工具):`./autogen.sh`</span><br><span class="line">  4. 配置`Valgrind`,生成Makefile文件:`./configure --prefix=/usr/local`</span><br><span class="line">  5. 编译和安装`valgrind`:`make &amp;&amp; make install`</span><br><span class="line"></span><br><span class="line">+ `Valgrind`的使用 </span><br><span class="line">  + 为了`valgrind`发现的错误更精确,如能够定位到源代码的行,建议在编译时加上-g参数,编译优化选项选择O0(不要优化)</span><br><span class="line">  + 利用`valgrind`调试内存问题,不需要重新编译源程序,它的输入就是二进制的可执行程序</span><br><span class="line">  + 调用`valgrind`的通用格式:valgrind [valgrind-options] your-program [your-program-options]</span><br><span class="line">  + `Valgrind`的参数分为两类</span><br><span class="line">      + 一类是core的参数,它对所有的工具都适用</span><br><span class="line">      + 另一类就是具体某个工具,如memcheck的参数.</span><br><span class="line">  + `Valgrind`默认的工具就是memcheck,也可以通过 `-tool=toolname` 指定其他的工具</span><br><span class="line"></span><br><span class="line">+ `Memcheck`将内存泄露分为两种:</span><br><span class="line">  1. `Possibly lost`:可能的内存泄露</span><br><span class="line">        + `Possibly lost`是指仍然存在某个指针能够访问某块内存,但是该指针指向的已经不是该内存的首地址</span><br><span class="line">  2. `Definitely lost`:确定的内存泄漏</span><br><span class="line">        + 确定的内存泄露是指已经不能够访问这块内存</span><br><span class="line">        + `Definitely lost`又分为两种:</span><br><span class="line">            1. `direct`:直接,直接是没有任何指针指向该内存</span><br><span class="line">            2. `indirect`:间接,指向该内存的指针都位于内存泄露处</span><br><span class="line"></span><br><span class="line">+ `Valgrind`常用命令</span><br><span class="line">  + `-log-file=valReport` :指定生成分析日志文件到当前执行目录,文件名为 `valReport`</span><br><span class="line">  + `-leak-check=full` :显示每个泄露的详细信息</span><br><span class="line">  + `-show-reachable=yes` :是否检测控制范围之外的泄露,比如全局指针,`static`指针等,显示所有的内存泄露类型</span><br><span class="line">  + `-leak-resolution=low` :内存泄露报告合并等级</span><br><span class="line"></span><br><span class="line">+ `Valgrind`输出内容:</span><br><span class="line">  + `==98725==` :进程号,如果程序使用了多进程的方式来执行,就会显示多个进程的内容</span><br><span class="line">  + 第一段是`valgrind`的基本信息</span><br><span class="line">  + 第二段是对堆内存分配的总结信息,</span><br><span class="line">  + 第三段的内容描述了内存泄露的具体信息</span><br><span class="line">  + 最后一段是总结,4字节为一块的内存泄露</span><br><span class="line"></span><br><span class="line">## C++ 编译： crosses initialization of ...</span><br><span class="line"></span><br><span class="line">+ 在switch-case中定义变量，编译时出现异常：crosses initialization of......，</span><br><span class="line">+ 异常代码如下:</span><br><span class="line">```cpp</span><br><span class="line">switch (ev)</span><br><span class="line">&#123;</span><br><span class="line">    case MG_EV_HTTP_MSG:</span><br><span class="line">        std::thread tmp(EventHandler, connect, hm);</span><br><span class="line">        tmp.detach();</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>出现异常的原因是：</p>
<ul>
<li>C&#x2F;C++中变量的生命周期问题，在case MG_EV_HTTP_MSG中定义了变量tmp，在default中也能够使用，但是如果在程序运行中直接跳入default分支，就会出现没有初始化的异常。</li>
<li>程序编译时为了防止出现上述情况，就会报编译失败，不是证明程序有异常，只是编译器担心程序有异常。</li>
</ul>
</li>
<li><p>解决方法有两个</p>
<ul>
<li>在switch-case外进行定义:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">tmp</span><span class="params">(EventHandler, connect, hm)</span></span>;</span><br><span class="line"><span class="keyword">switch</span> (ev)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> MG_EV_HTTP_MSG:</span><br><span class="line">        tmp.<span class="built_in">detach</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在case中加花括号<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ev)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> MG_EV_HTTP_MSG:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::thread <span class="title">tmp</span><span class="params">(EventHandler, connect, hm)</span></span>;</span><br><span class="line">        tmp.<span class="built_in">detach</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2024-05-22-C++%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/" class="post-title-link" itemprop="url">C++极客时间</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>内存管理的基本概念，大致的学习路径是：<ul>
<li>先讲堆和栈，</li>
<li>然后讨论C++的特色功能RAII</li>
</ul>
</li>
</ul>
<h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><ul>
<li><p>堆，英文是heap，在内存管理的语境下，指的是动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手动释放，否则就会造成内存泄漏。</p>
</li>
<li><p>C++标准里有一个相关概念是自由存储区，英文是 free store，特指使用 new 和 delete 来分配和释放内存的区域。一般而言，这是堆的一个子集：</p>
<ul>
<li>new 和 delete 操作的区域是 free store</li>
<li>malloc 和 free 操作的区域是 heap</li>
</ul>
</li>
<li><p>但 new 和 delete通常底层使用malloc和free来实现，所以free store也是heap。</p>
</li>
<li><p>栈，英文是stack，在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈高度相似，都满足“后进先出”(last-in-first-out 或 LIFO)</p>
</li>
<li><p>RAII, 完整的英文是 Resource Acquisition Is Initialization，是C++所特有的资源管理方式。由少量其他语言，例如D，Ada和Rust也采纳了RAII，但主流的编程语言中，C++是唯一一个依赖RAII来做资源管理的</p>
</li>
<li><p>RAII依托栈和析构函数，来对所有的资源–包括堆内存在内–进行管理。对RAII的使用，使得C++不需要类似于Java那样的垃圾收集方法，也能有效地对内存进行管理。RAII的存在，也是垃圾收集虽然理论上可以在C++使用，但从来没有真正流行过的主要原因。</p>
</li>
</ul>
<h3 id="1-2-深入探讨-–-堆"><a href="#1-2-深入探讨-–-堆" class="headerlink" title="1.2 深入探讨 – 堆"></a>1.2 深入探讨 – 堆</h3><ul>
<li><p>从现代编程的角度来看，使用堆，或者说使用动态内存分配，是一件再自然不过的事情。</p>
</li>
<li><p>从历史的角度，动态内存分配实际上是较晚出现的。由于动态内存带来的不确定性 –  内存分配耗时需要多久？失败了怎么办？等等。至今仍有很多场合会禁用动态内存，尤其是在实时性要求比较高的场合，例如飞行控制器和电信设备。</p>
</li>
<li><p>在堆上分配内存，有些语言可能使用new这样的关键字，有些语言则是在对象的构造时隐式分配，不需要特殊关键字。</p>
</li>
<li><p>不管哪种情况，程序通常需要牵涉到三个可能的内存管理器的操作</p>
<ul>
<li>让内存管理器分配一个某个大小的内存块</li>
<li>让内存管理器释放一个之前分配的内存款</li>
<li>让内存管理器进行垃圾收集操作，寻找不再使用的内存块并予以释放</li>
</ul>
</li>
<li><p>C++通常会做上面的操作1和2</p>
</li>
<li><p>Java会做上面的操作1和3</p>
</li>
<li><p>Python会做上面的操作1，2，3</p>
</li>
<li><p>这是语言的特性和实现方式决定的。</p>
</li>
<li><p>需要略加说明的是，上面的三个操作都不简单，并且彼此之间是相关的。</p>
</li>
<li><p>幸运的是，内存分配和释放的管理，是内存管理器的任务。一般情况下我们不需要介入。我们只需要正确地使用new和delete。每个new出来的对象都应该用delete来释放。</p>
</li>
</ul>
<h3 id="1-3-深入探讨-–-栈"><a href="#1-3-深入探讨-–-栈" class="headerlink" title="1.3 深入探讨 – 栈"></a>1.3 深入探讨 – 栈</h3><ul>
<li><p>函数调用，本地变量使用栈。这一过程取决于计算机的实际架构，具体细节可能有所不同，但原理上都是相通的，都会使用一个后进先出的结构。</p>
</li>
<li><p>栈是向上增长的。在包括x86在内的大部分计算机体系架构中，栈的增长方向是低地址，因而上方意味着低地址。任何一个函数，根据架构的约定，只能使用进入函数时栈指针向上部分的栈空间。</p>
</li>
<li><p>当函数调用另外一个函数时，会把参数也压入栈里（我们此处忽略使用寄存器传递参数的情况），然后把下一行汇编指令的地址压入栈，并跳转到新的函数。新的函数进入后，首先做一些必须的保存功能，然后会调用栈指针，分配出本地变量所需要的空间，随后执行函数中的代码，并在执行完毕之后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。</p>
</li>
<li><p>注意到了吗：本地变量所需要的内存就在栈上，跟函数执行所需要的其他数据在一起。当函数执行完成之后，这些内存也就自然而然释放掉了。</p>
</li>
<li><p>我们可以看到：</p>
<ul>
<li>栈上的分配极为简单，移动一下栈指针而已</li>
<li>栈上的释放也极为简单，函数执行结束时移动一下栈指针即可</li>
<li>由于后进先出的执行过程，不可能出现内存碎片。</li>
</ul>
</li>
<li><p>顺便说一句，（图2）每种颜色都表示某个函数占用的栈空间。这部分空间有个特定的术语，叫做栈帧(stack frame)。</p>
</li>
<li><p>GCC 和 Clang 的命令行参数中提到 frame 的，例如<code>-fomit-frame-pointer</code>，一般就是指栈帧。</p>
</li>
</ul>
<hr>
<ul>
<li><p>前面例子的本地变量是简单类型，C++里称之为POD类型(Plain Old Data)。</p>
</li>
<li><p>对于有构造和析构函数的非POD类型，栈上的内存分配也同样有效，只不过C++编译器会在生成代码的合适位置，插入对构造和析构函数的调用。</p>
</li>
<li><p>这里尤其重要的是：编译器会自动调用析构函数，包括在函数执行发生异常的情况。</p>
</li>
<li><p>在发生异常时对析构函数的调用，还有一个专门的术语，叫做栈展开(stack unwinding)。</p>
</li>
<li><p>在C++里，所有的变量缺省都是值语义 –  如果不使用 * 和 &amp; 的话，变量不会像Java或Python一样引用一个堆上的对象。对于像智能指针这样的类型，写<code>ptr-&gt;call()</code>和<code>ptr.get()</code>，语法上都是对的，并且<code>-&gt;</code>和<code>.</code>有着不同的语法作用。而在大部分其他语言中，访问成员只有<code>.</code>，但在作用上实际等价于C++的<code>-&gt;</code>。</p>
</li>
<li><p>这种值语义和引用语义的区别，是C++的特点，也是它的复杂性的一个来源。要用好C++，就需要理解它的值语义的特点。</p>
</li>
</ul>
<h3 id="1-4-深入探讨-–-RAII"><a href="#1-4-深入探讨-–-RAII" class="headerlink" title="1.4 深入探讨 – RAII"></a>1.4 深入探讨 – RAII</h3><ul>
<li><p>C++支持将对象存储在栈上面。但是，在很多情况下，对象不能，或者不应该，存储在栈上。例如：</p>
<ul>
<li>对象很大</li>
<li>对象的大小在编译时不能确定</li>
<li>对象是函数的返回值，但由于特殊的原因，不应该使用对象的值返回。</li>
</ul>
</li>
<li><p>常见情况之一是：在工厂方法或其他面向对象编程的情况下，返回值类型是基类（的指针或引用）。</p>
</li>
<li><p>举例：—。 这个create_shape方法会返回一个shape对象，对象的实际类型是某个shape的子类。这种情况下，函数的返回值只能是指针或其变体形式。如果返回类型是shape，实际却返回一个circle，编译器不会报错，但结果多半是错的。这种现象叫做对象切片(object slicing)，是C++特有的一种编码错误。这种错误不是语法错误，而是一个对象复制相关的语义错误，也算是C++的一个陷阱</p>
</li>
<li><p>那么，我们怎样才能确保，在使用create_shape的返回值时不会发生内存泄漏呢？</p>
</li>
<li><p>答案就是：在析构函数和它的栈展开行为上。我们只需要把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可。</p>
</li>
<li><p>如果好奇delete空指针会发生什么的话，那答案是，这是一个合法的空操作。在new一个对象和delete一个指针时编译器需要干不少活的</p>
<ul>
<li>也就是说，new的时候先分配内存（失败时整个操作失败并向外抛出异常，通常使bad_alloc），然后在这个结果指针上构造对象；</li>
<li>构造成功则new操作整体完成，否则释放刚分配的内存并继续向外抛构造函数产生的异常。</li>
<li>delete时则判断指针是否为空，在指针不为空时调用析构函数并释放之前分配的内存</li>
</ul>
</li>
<li><p>在析构函数里做必要的清理工作，这就是RAII的基本用法。</p>
</li>
<li><p>这种清理并不限于释放内存，也可以是：</p>
<ul>
<li>关闭文件（fstream的析构就会这么做）</li>
<li>释放同步锁</li>
<li>释放其他重要的系统资源</li>
</ul>
</li>
</ul>
<h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><ul>
<li>讨论了C++里内存管理的一些基本概念，强调栈是C++里最自然的内存使用方式，并且，使用基于栈和析构函数的RAII，可以有效地对包括内存在内的系统资源进行统一管理。</li>
</ul>
<h2 id="C-的智能指针"><a href="#C-的智能指针" class="headerlink" title="C++的智能指针"></a>C++的智能指针</h2><ul>
<li>使用智能指针，可以简化资源的管理，从根本上消除资源（包括内存）泄漏的可能性。</li>
<li>智能指针本质上并不神秘，其实就是RAII资源管理功能的自然展现而已。</li>
</ul>
<h3 id="1-1-模板化和易用性"><a href="#1-1-模板化和易用性" class="headerlink" title="1.1 模板化和易用性"></a>1.1 模板化和易用性</h3><ul>
<li>要让某一个类能够包装任意类型的指针，我们需要把它变成一个类模板。</li>
<li>在示例中，和shape_wrapper比较一下，我们就是在开头增加模板声明<code>template &lt;typename T&gt;</code>，然后把代码中的shape替换成模板参数T而已。</li>
</ul>
<h3 id="1-2-拷贝构造和赋值"><a href="#1-2-拷贝构造和赋值" class="headerlink" title="1.2 拷贝构造和赋值"></a>1.2 拷贝构造和赋值</h3><ul>
<li><p>拷贝构造和赋值，我们暂且简称为拷贝，这是个比较复杂的问题了。关键它还不是实现问题，而是我们该如何定义其行为。</p>
</li>
<li><p>使用智能指针的目的就是要减少对象的拷贝。</p>
</li>
<li><p>一般而言，并没有通用的方法可以通过基类的指针来构造出一个子类的对象来。</p>
</li>
<li><p>方法一：</p>
<ul>
<li>在拷贝时转移指针的所有权。在赋值函数中，通过拷贝构造产生一个临时对象并调用swap来交换指针的所有权。这种惯用法保证了强异常安全性：赋值分为拷贝构造和交换两步，异常只可能在第一步发生；二第一步如果发生异常的话，this对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景。</li>
<li>这个语义本质上就是C++98的auto_ptr的定义。但是auto_ptr在C++17时已经被正式从C++标准中删除了</li>
</ul>
</li>
</ul>
<h3 id="1-3-移动指针"><a href="#1-3-移动指针" class="headerlink" title="1.3 移动指针"></a>1.3 移动指针</h3><ul>
<li><p>把拷贝构造函数中的参数类型<code>smart_ptr*</code>改成了<code>smart_ptr&amp;&amp;</code>，现在它成了移动构造函数</p>
</li>
<li><p>把赋值函数中的参数类型<code>smart_ptr&amp;</code>改成了<code>smart_ptr</code>，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为时移动还是拷贝，完全依赖于构造函数时走的是移动构造还是拷贝构造。</p>
</li>
<li><p>根据C++的规则，如果我们提供了移动构造函数，而没有手动提供拷贝构造函数，那么后者自动被禁用</p>
</li>
<li><p>记住，C++里哪些复杂的规则也是为方便编程而设立的。</p>
</li>
<li><p>这也是C++11的unique_ptr的基本行为。</p>
</li>
</ul>
<h3 id="1-4-子类指针向基类指针的转换"><a href="#1-4-子类指针向基类指针的转换" class="headerlink" title="1.4 子类指针向基类指针的转换"></a>1.4 子类指针向基类指针的转换</h3><h3 id="1-5-引用计数"><a href="#1-5-引用计数" class="headerlink" title="1.5 引用计数"></a>1.5 引用计数</h3><ul>
<li><p>unique_ptr 算是一种较为安全的智能指针了。但是，一个对象只能被单个 unique_ptr 所拥有，这显然不能满足所有使用场合的需求。</p>
</li>
<li><p>一种常见的情况是：多个智能指针同时拥有一个对象；当他们全部都失效时，这个对象也同时会被删除。这也就是<code>shared_ptr</code>了</p>
</li>
<li><p>多个不同的<code>shared_ptr</code>不仅可以共享一个对象，在共享同一对象时也需要同时共享一个计数。</p>
</li>
<li><p>当最后一个指向对象（和共享计数）的shared_ptr析构时，它需要删除对象和共享计数。</p>
</li>
</ul>
<h3 id="1-6-指针类型转换"><a href="#1-6-指针类型转换" class="headerlink" title="1.6 指针类型转换"></a>1.6 指针类型转换</h3><ul>
<li><p>对应于C++里的不同的类型强制转换：</p>
<ul>
<li><code>static_cast</code></li>
<li><code>reinterpret_cast</code></li>
<li><code>const_cast</code></li>
<li><code>dynamic_cast</code></li>
</ul>
</li>
<li><p>只能指针需要实现类似的函数模板。实现本身并不复杂，但为了实现这些转换，我们需要添加构造函数，允许在对智能指针内部的指针对象赋值时，使用一个现有的智能指针的共享计数。</p>
</li>
</ul>
<h2 id="右值和移动-究竟解决了什么问题？"><a href="#右值和移动-究竟解决了什么问题？" class="headerlink" title="右值和移动 究竟解决了什么问题？"></a>右值和移动 究竟解决了什么问题？</h2><ul>
<li>移动语义是C++11里引入的一个重要概念；理解这个概念，是理解很多现代C++里的优化的基础。</li>
</ul>
<h3 id="1-1-值分左右"><a href="#1-1-值分左右" class="headerlink" title="1.1 值分左右"></a>1.1 值分左右</h3><ul>
<li><p>我们常常会说，C++里有左值和右值。标准里的定义实际更加复杂，规定了下面这些值类别(value categories)</p>
<ul>
<li>一个 lvalue 是通常可以放在等号左边的表达式，左值</li>
<li>一个 rvalue 是通常只能放在等号右边的表达式，右值</li>
<li>一个 glvalue 是 generalized lvalue， 广义左值</li>
<li>一个 xvalue 是 expiring value， 将亡值</li>
<li>一个 prvalue 是 pure rvalue， 纯右值</li>
</ul>
</li>
<li><p>我们暂且抛开这些概念，只看其中两个：lvalue 和 prvalue</p>
</li>
<li><p>左值 lvalue 是有标识符，可以取地址的表达式，最常见的情况有：</p>
<ul>
<li>变量，函数或数据成员的名字</li>
<li>返回左值引用的表达式，例如<code>++x, x = 1, cout &lt;&lt; &#39; &#39;</code></li>
<li>字符串字面量，例如<code>&quot;hello world&quot;</code></li>
</ul>
</li>
<li><p>在函数调用时，左值可以绑定到左值引用的参数，例如<code>T&amp;</code>。一个常量只能绑定到常左值引用，例如<code>const T&amp;</code></p>
</li>
<li><p>反之，纯右值 prvalue 是没有标识符，不可以取地址的表达式，一般也称之为 临时对象。最常见的情况有：</p>
<ul>
<li>返回非引用类型的表达式，例如<code>x++</code>, <code>x+1</code>, <code>make_shared&lt;int&gt;(42)</code></li>
<li>除字符串字面量之外的字面量，例如<code>42</code>, <code>true</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>在C++11之前，右值可以绑定到常左值引用(const lvalue reference)的参数，例如<code>const T&amp;</code>，但不可以绑定到非常左值引用(non-const lvalue reference)，例如<code>T&amp;</code></p>
</li>
<li><p>从C++11开始，C++语言里多了一种引用类型 –  右值引用。右值引用的形式是<code>T&amp;&amp;</code>，比左值引用多了一个<code>&amp;</code>符号。跟左值引用一样，我们可以使用 const 和 volatile 来修饰，但最常见的情况是，我们不会用 const 和 volatile 来修饰右值。</p>
</li>
<li><p>引入一种额外的引用类型当然增加了语言的复杂性，但也带来了很多优化的可能。</p>
</li>
<li><p>由于C++有重载，我们就可以根据不同的引用类型，来选择不同的重载函数，来完成不同的行为。</p>
</li>
<li><p>对于指针，我们通常使用值传递，并不关心它是左值还是右值</p>
</li>
<li><p><code>std::move(ptr)</code>，它的作用是把一个左值引用强制转换成一个右值引用，而并不改变其内容。从实用的角度，在这里<code>std::move(ptr1)</code>等价于<code>static_cast&lt;smart_ptr&lt;shape&gt;&amp;&amp;&gt;(ptr1)</code>。因此，<code>std::move(ptr1)</code>的结果是指向ptr1的一个右值引用，这样构造ptr2时就会选择上面第二个重载。</p>
</li>
<li><p>我们可以把<code>std::move(ptr1)</code>看作是一个有名字的右值。为了跟无名的纯右值prvalue相区别，C++里目前就把这种表达式叫做xvalue。跟左值lvalue不同，xvalue仍然是不能取地址的–这点上，xvalue和prvalue相同。所以，xvalue和prvalue都被归为右值rvalue。</p>
</li>
</ul>
<hr>
<ul>
<li>另外，需要注意的是：值类别(value category) 和 值类型(value type)， 是两个看似相似，却毫不相干的术语。<ul>
<li>前者指的是上面这些左值，右值相关的概念</li>
<li>后者则是与引用类型(reference type)相对而言，表明一个变量是代表实际数值，还是引用另外一个数值。</li>
</ul>
</li>
<li>在C++里，所有的原生类型，枚举，结构，联合，类都代表值类型，只有引用<code>&amp;</code>和指针<code>*</code>才是引用类型。（在Java里，数字等原生类型是值类型，类则属于引用类型。在Python里，一切类型都是引用类型。）</li>
</ul>
<h3 id="1-2-生命周期和表达式类型"><a href="#1-2-生命周期和表达式类型" class="headerlink" title="1.2 生命周期和表达式类型"></a>1.2 生命周期和表达式类型</h3><ul>
<li><p>一个变量的生命周期在超出作用域时结束。如果一个变量代表一个对象，当然这个对象的生命周期也在那时结束。</p>
</li>
<li><p>那么临时对象(prvalue)呢？</p>
</li>
<li><p>在这儿，C++的规则是：</p>
<ul>
<li>一个临时对象会在包含这个临时对象的完整表达式估值完成后，按生成顺序的逆序被销毁，除非有生命周期延长发生。</li>
</ul>
</li>
<li><p>临时对象最后生成，最先析构</p>
</li>
<li><p>为了方便对临时对象的使用，C++对临时对象有特殊的生命周期延长规则，这条规则是：</p>
<ul>
<li>如果一个prvalue被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样长</li>
</ul>
</li>
</ul>
<h3 id="1-3-移动的意义"><a href="#1-3-移动的意义" class="headerlink" title="1.3 移动的意义"></a>1.3 移动的意义</h3><ul>
<li><p>上面谈了一些语法知识。就跟学外语的语法一样，这些内容是比较枯燥的。虽然这些知识有时有用，但往往要回过头来看的时候才觉得。初学之时，更重要的是理解为什么，和熟练掌握基本的用法。</p>
</li>
<li><p>对于smart_ptr，我们使用右值引用的目的是实现移动，而实现移动的意义是减少运行的开销：在引用计数指针的场景下，这个开销并不大。</p>
</li>
<li><p>移动构造和拷贝构造的差异仅在于：</p>
<ul>
<li>少了一次<code>other.shared_count_-&gt;add_count()</code>的调用</li>
<li>被移动的指针被清空，因而析构时也少了一次<code>shared_count_-&gt;reduce_count()</code>的调用</li>
</ul>
</li>
<li><p>在使用容器类的情况下，移动更有意义。</p>
</li>
<li><p><code>string result = string(&quot;Hello, &quot;) + name + &quot;.&quot;;</code></p>
<ul>
<li>在C++11之前的年代里，这种写法是绝对不推荐的。因为它会引入很多额外的开销</li>
<li>既然C++是一门追求性能的语言，一个合格的C++程序员会写：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string result = &quot;Hello, &quot;;</span><br><span class="line">result += name;</span><br><span class="line">result += &quot;.&quot;;</span><br></pre></td></tr></table></figure></li>
<li>这样的话，只会调用构造函数一次和<code>string::operator+=</code>两次，没有任何临时对象需要生成和析构，所有的字符串都只复制了一次。</li>
<li>但是，从C++11开始，这就不再是必须的。同样上面那个单行的语句，性能上，所有的字符串只复制了一次；虽然比啰嗦的写法仍然要增加临时对象的构造和析构，但由于这些操作不牵涉到额外的内存分配和释放，是相当廉价的。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>此外，很关键的额一点是，C++里的对象缺省都是值语义。在下面这样的代码里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  B b_;</span><br><span class="line">  C c_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>从实际内存布局的角度，很多语言：例如Java和Python，会在A对象里放B和C的指针（虽然这些语言里本身没有指针的概念）。而C++则会直接把B和C对象放在A的内存空间里。</p>
</li>
<li><p>这种行为既是优点也是缺点：</p>
<ul>
<li>优点：是因为它保证了内存访问的局域性，而局域型在现在处理器架构上是聚堆具有性能优势的</li>
<li>缺点：是因为复制对象的开销大大增加，在Java类语言里复制的是指针，在C++里是完整的对象。这就是为什么C++需要移动语义这一优化，而Java类语言里则根本不需要这个概念。</li>
</ul>
</li>
<li><p>一句话总结：</p>
<ul>
<li>移动语义使得在C++里返回大对象（如容器）的函数和运算符称为现实，因而可以提高代码的简洁性和可读性，提高程序员的生产率。</li>
<li>所有的现代C++的标准容器都针对移动进行了优化。</li>
</ul>
</li>
</ul>
<h3 id="1-4-如何实现移动"><a href="#1-4-如何实现移动" class="headerlink" title="1.4 如何实现移动"></a>1.4 如何实现移动</h3><ul>
<li>要让你设计的对象支持移动的话，通常需要下面几步：<ul>
<li>你的对象应该有分开的拷贝构造和移动构造函数（除非你只打算支持移动，不支持拷贝，例如unique_ptr）</li>
<li>你的对象应该有swap成员函数，支持和另外一个对象快速交换成员</li>
<li>在你的对象的名空间下，应当有一个全局的swap函数，调用成员函数swap来实现交换。支持这种用法会方便别人（包括你自己在将来）在其他对象里包含你的对象，并快速实现它们的swap函数</li>
<li>实现通用的<code>operator=</code></li>
<li>上面各个函数如果不抛异常的化，应当标为<code>noexcept</code>。这对移动构造函数尤为重要。</li>
</ul>
</li>
</ul>
<h3 id="1-5-不要返回本地变量的引用"><a href="#1-5-不要返回本地变量的引用" class="headerlink" title="1.5 不要返回本地变量的引用"></a>1.5 不要返回本地变量的引用</h3><ul>
<li><p>有一种常见的C++编程错误，是在函数里返回一个本地对象的引用。由于在函数结束时本地对象即被销毁，返回一个指向本地对象的引用属于未定义行为。理论上来说，程序出现任何奇怪的行为都是正常的。</p>
</li>
<li><p>在C++11之前，返回一个本地对象意味着这个对象会被拷贝，除非编译器发现可以做返回值优化(named return value optimization, 或NRVO)能把对象直接构造到调用者的栈上。</p>
</li>
<li><p>从C++11开始，返回值优化仍可以发生，但在没有返回值优化的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。这一行为不需要程序员手工用<code>std::move</code>进行干预：使用<code>std::move</code>对于移动行为没有帮助，反而会影响返回值优化</p>
</li>
</ul>
<h3 id="1-6-引用坍缩和完美转发"><a href="#1-6-引用坍缩和完美转发" class="headerlink" title="1.6 引用坍缩和完美转发"></a>1.6 引用坍缩和完美转发</h3><ul>
<li><p>引用坍缩（又称 引用折叠）。这个概念在泛型编程中是一定会碰到的</p>
</li>
<li><p>对于一个实际的类型T，它的左值引用是<code>T&amp;</code>，右值引用是<code>T&amp;&amp;</code>，那么</p>
<ul>
<li>是不是看到<code>T&amp;</code>，就一定是一个左值引用？</li>
<li>是不是看到<code>T&amp;&amp;</code>，就一定是一个右值引用？</li>
</ul>
</li>
<li><p>对于前者的回答为：是；对于后者的回答为：否</p>
</li>
<li><p>关键在于，在有模板的代码里，对于类型参数的推到结果可能是引用。我们可以略过一些繁复的语法规则，要点是：</p>
<ul>
<li>对于<code>template &lt;typename T&gt; foo(T&amp;&amp;)</code>这样的代码，如果传递过去的参数是左值，T的推到结果是左值引用；如果传递过去的参数是右值，T的推到结果是参数的类型本身</li>
<li>如果T是左值引用，那T&amp;&amp;的结果仍然是左值引用：即<code>type&amp; &amp;&amp;</code>坍缩成了<code>type&amp;</code></li>
<li>如果T是一个实际类型，那<code>T&amp;&amp;</code>的结果自然就是一个右值引用</li>
</ul>
</li>
<li><p>我们之前提到过，右值引用变量仍然会匹配到左值引用上去</p>
</li>
<li><p>事实上，很多标准库里的函数，连目标的参数类型都不知道，但我们仍然需要能够保持参数的值类别：左值的仍然是左值，右值的仍然是右值。</p>
</li>
<li><p>这个功能在C++标准库中已经提供了，叫<code>std::forward</code>。它和<code>std::move</code>一样都是利用引用坍缩机制来实现。</p>
</li>
<li><p>此处，我们不介绍其实现细节，而是重点展示其用法。我们可以把我们的两个bar函数简化成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void var(T&amp;&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">  foo(std::forward&lt;T&gt;(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于下面这样的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">circle temp;</span><br><span class="line">bar(temp);</span><br><span class="line">bar(circle());</span><br></pre></td></tr></table></figure></li>
<li><p>现在的输出是：</p>
<ul>
<li><code>foo(const shape&amp;)</code></li>
<li><code>foo(shape&amp;&amp;)</code></li>
</ul>
</li>
<li><p>因为在T是模板参数时，<code>T&amp;&amp;</code>的作用主要是保持值类别进行转换，它有个名字就叫做 转发引用(forwarding reference)。因为既可以是左值引用，也可以是右值引用，它也曾经被称为 万能引用(universal reference)</p>
</li>
</ul>
<h3 id="1-7-小结"><a href="#1-7-小结" class="headerlink" title="1.7 小结"></a>1.7 小结</h3><ul>
<li>介绍了C++里的值类别，重点介绍了临时变量，右值引用，移动语义和实际的编程用法</li>
<li>由于这是C++11里的重点功能，对于其基本用法需要牢牢掌握</li>
</ul>
<h2 id="容器汇编一：比较简单的若干容器"><a href="#容器汇编一：比较简单的若干容器" class="headerlink" title="容器汇编一：比较简单的若干容器"></a>容器汇编一：比较简单的若干容器</h2><ul>
<li>对于容器，学习上的一个麻烦点是你无法直接输出容器的内容<ul>
<li>如果定义了一个<code>vector&lt;int&gt; v</code>，是没有办法简单输出v的内容的</li>
</ul>
</li>
<li>我们需要一个更好用的工具。在此，我向你大力推荐 <code>xeus-cling</code>。它的便利性无与伦比——你可以直接在浏览器里以交互的方式运行代码，不需要本机安装任何编译器</li>
</ul>
<h3 id="1-1-string"><a href="#1-1-string" class="headerlink" title="1.1 string"></a>1.1 string</h3><ul>
<li><p>string 一般并不被认为是一个 C++ 的容器。但鉴于其和容器有很多共同点，我们先拿 string 类来开说</p>
</li>
<li><p>string 是模板 basic_string 对于 char 类型的特化，可以认为是一个只存放字符 char 类型数据的容器。“真正”的容器类与 string 的最大不同点是里面可以存放任意类型的对象。</p>
</li>
<li><p>跟其他大部分容器一样， string 具有下列成员函数：</p>
<ul>
<li>begin 可以得到对象起始点</li>
<li>end 可以得到对象的结束点</li>
<li>empty 可以得到容器是否为空</li>
<li>size 可以得到容器的大小</li>
<li>swap 可以和另外一个容器交换其内容</li>
</ul>
</li>
<li><p>对于不那么熟悉容器的人，需要知道 C++ 的 begin 和 end 是半开半闭区间：</p>
<ul>
<li>在容器非空时，begin 指向第一个元素，而 end 指向最后一个元素后面的位置</li>
<li>在容器为空时，begin 等于 end。</li>
</ul>
</li>
<li><p>在 string 的情况下，由于考虑到和 C 字符串的兼容，end 指向代表字符串结尾的 \0 字符。</p>
</li>
<li><p>上面就几乎是所有容器的共同点了。也就是说：</p>
<ul>
<li>容器都有开始和结束点</li>
<li>容器会记录其状态是否非空</li>
<li>容器有大小</li>
<li>容器支持交换</li>
</ul>
</li>
<li><p>当然，这只是容器的“共同点”而已。每个容器都有其特殊的用途。</p>
</li>
<li><p>下面你会看到，不管是内存布局，还是成员函数，string 和 vector 是非常相似的。</p>
</li>
<li><p>string 当然是为了存放字符串。和简单的 C 字符串不同：</p>
<ul>
<li>string 负责自动维护字符串的生命周期</li>
<li>string 支持字符串的拼接操作（如之前说过的 + 和 +&#x3D;）</li>
<li>string 支持字符串的查找操作（如 find 和 rfind）</li>
<li>string 支持从 istream 安全地读入字符串（使用 getline）</li>
<li>string 支持给期待 const char* 的接口传递字符串内容（使用 c_str）</li>
<li>string 支持到数字的互转（stoi 系列函数和 to_string）</li>
<li>等等</li>
</ul>
</li>
<li><p>推荐你在代码中尽量使用 string 来管理字符串</p>
</li>
<li><p>不过，对于对外暴露的接口，情况有一点复杂。我一般不建议在接口中使用 const string&amp;，除非确知调用者已经持有 string：</p>
<ul>
<li>如果函数里不对字符串做复杂处理的话，使用 const char* 可以避免在调用者只有 C 字符串时编译器自动构造 string，这种额外的构造和析构代价并不低</li>
</ul>
</li>
<li><p>反过来，如果实现较为复杂、希望使用 string 的成员函数的话，那就应该考虑下面的策略：</p>
<ul>
<li>如果不修改字符串的内容，使用 const string&amp; 或 C++17 的 string_view 作为参数类型。后者是最理想的情况，因为即使在只有 C 字符串的情况，也不会引发不必要的内存复制。</li>
<li>如果需要在函数内修改字符串内容、但不影响调用者的该字符串，使用 string 作为参数类型（自动拷贝）。</li>
<li>如果需要改变调用者的字符串内容，使用 string&amp; 作为参数类型（通常不推荐）</li>
</ul>
</li>
</ul>
<h3 id="1-2-vector"><a href="#1-2-vector" class="headerlink" title="1.2 vector"></a>1.2 vector</h3><ul>
<li><p>vector 应该是最常用的容器了。它的名字“向量”来源于数学术语，但在实际应用中，我们把它当成动态数组更为合适。它基本相当于 Java 的 ArrayList 和 Python 的 list。</p>
</li>
<li><p>和 string 相似，vector 的成员在内存里连续存放，同时 begin、end、front、back 成员函数指向的位置也和 string 一样</p>
</li>
<li><p>除了容器类的共同点，vector 允许下面的操作（不完全列表）：</p>
<ul>
<li>可以使用中括号的下标来访问其成员（同 string）</li>
<li>可以使用 data 来获得指向其内容的裸指针（同 string）</li>
<li>可以使用 capacity 来获得当前分配的存储空间的大小，以元素数量计（同 string）</li>
<li>可以使用 reserve 来改变所需的存储空间的大小，成功后 capacity() 会改变（同 string）</li>
<li>可以使用 resize 来改变其大小，成功后 size() 会改变（同 string）</li>
<li>可以使用 pop_back 来删除最后一个元素（同 string）</li>
<li>可以使用 push_back 在尾部插入一个元素（同 string）</li>
<li>可以使用 insert 在指定位置前插入一个元素（同 string）</li>
<li>可以使用 erase 在指定位置删除一个元素（同 string）</li>
<li>可以使用 emplace 在指定位置构造一个元素</li>
<li>可以使用 emplace_back 在尾部新构造一个元素</li>
</ul>
</li>
<li><p>大家可以留意一下 push_… 和 pop_… 成员函数。它们存在时，说明容器对指定位置的删除和插入性能较高。</p>
</li>
<li><p>vector 适合在尾部操作，这是它的内存布局决定的。只有在尾部插入和删除时，其他元素才会不需要移动，除非内存空间不足导致需要重新分配内存空间。</p>
</li>
<li><p>当 push_back、insert、reserve、resize 等函数导致内存重分配时，或当 insert、erase 导致元素位置移动时，vector 会试图把元素“移动”到新的内存区域。vector 通常保证强异常安全性，如果元素类型没有提供一个保证不抛异常的移动构造函数，vector 通常会使用拷贝构造函数。因此，对于拷贝代价较高的自定义元素类型，我们应当定义移动构造函数，并标其为 noexcept，或只在容器中放置对象的智能指针。这就是为什么我之前需要在 smart_ptr 的实现中标上 noexcept 的原因。</p>
</li>
<li><p>C++11 开始提供的 emplace… 系列函数是为了提升容器的性能而设计的。你可以试试把 v1.emplace_back() 改成 v1.push_back(Obj1())。对于 vector 里的内容，结果是一样的；但使用 push_back 会额外生成临时对象，多一次（移动或拷贝）构造和析构。如果是移动的情况，那会有小幅性能损失；如果对象没有实现移动的话，那性能差异就可能比较大了。</p>
</li>
<li><p>现代处理器的体系架构使得对连续内存访问的速度比不连续的内存要快得多。因而，vector 的连续内存使用是它的一大优势所在。当你不知道该用什么容器时，缺省就使用 vector 吧。</p>
</li>
<li><p>vector 的一个主要缺陷是大小增长时导致的元素移动。如果可能，尽早使用 reserve 函数为 vector 保留所需的内存，这在 vector 预期会增长很大时能带来很大的性能提升。</p>
</li>
</ul>
<h3 id="1-3-deque"><a href="#1-3-deque" class="headerlink" title="1.3 deque"></a>1.3 deque</h3><ul>
<li><p>deque 的意思是 double-ended queue，双端队列。它主要是用来满足下面这个需求：</p>
<ul>
<li>容器不仅可以从尾部自由地添加和删除元素，也可以从头部自由地添加和删除。</li>
</ul>
</li>
<li><p>deque 的接口和 vector 相比，有如下的区别：</p>
<ul>
<li>deque 提供 push_front、emplace_front 和 pop_front 成员函数。</li>
<li>deque 不提供 data、capacity 和 reserve 成员函数。</li>
</ul>
</li>
<li><p>deque 的内存布局，可以看到：</p>
<ul>
<li>如果只从头、尾两个位置对 deque 进行增删操作的话，容器里的对象永远不需要移动。</li>
<li>容器里的元素只是部分连续的（因而没法提供 data 成员函数）。</li>
<li>由于元素的存储大部分仍然连续，它的遍历性能是比较高的。</li>
<li>由于每一段存储大小相等，deque 支持使用下标访问容器元素，大致相当于 <code>index[i / chunk_size][i % chunk_size]</code>，也保持高效。</li>
</ul>
</li>
<li><p>如果你需要一个经常在头尾增删元素的容器，那 deque 会是个合适的选择。</p>
</li>
</ul>
<h3 id="1-4-list"><a href="#1-4-list" class="headerlink" title="1.4 list"></a>1.4 list</h3><ul>
<li><p>list 在 C++ 里代表双向链表。和 vector 相比，它优化了在容器中间的插入和删除：</p>
<ul>
<li>list 提供高效的、O(1) 复杂度的任意位置的插入和删除操作。</li>
<li>list 不提供使用下标访问其元素。</li>
<li>list 提供 push_front、emplace_front 和 pop_front 成员函数（和 deque 相同）。</li>
<li>list 不提供 data、capacity 和 reserve 成员函数（和 deque 相同）。</li>
</ul>
</li>
<li><p>需要指出的是，虽然 list 提供了任意位置插入新元素的灵活性，但由于每个元素的内存空间都是单独分配、不连续，它的遍历性能比 vector 和 deque 都要低</p>
</li>
<li><p>这在很大程度上抵消了它在插入和删除操作时不需要移动元素的理论性能优势。如果你不太需要遍历容器、又需要在中间频繁插入或删除元素，可以考虑使用 list。</p>
</li>
<li><p>另外一个需要注意的地方是，因为某些标准算法在 list 上会导致问题，list 提供了成员函数作为替代，包括下面几个：</p>
<ul>
<li>merge</li>
<li>remove</li>
<li>remove_if</li>
<li>reverse</li>
<li>sort</li>
<li>unique</li>
</ul>
</li>
</ul>
<h3 id="1-5-forward-list"><a href="#1-5-forward-list" class="headerlink" title="1.5 forward_list"></a>1.5 forward_list</h3><ul>
<li><p>既然 list 是双向链表，那么 C++ 里有没有单向链表呢？答案是肯定的。从 C++11 开始，前向列表 forward_list 成了标准的一部分。</p>
</li>
<li><p>大部分 C++ 容器都支持 insert 成员函数，语义是从指定的位置之前插入一个元素。对于 forward_list，这不是一件容易做到的事情（想一想，为什么？）。标准库提供了一个 insert_after 作为替代。此外，它跟 list 相比还缺了下面这些成员函数：</p>
<ul>
<li>back</li>
<li>size</li>
<li>push_back</li>
<li>emplace_back</li>
<li>pop_back</li>
</ul>
</li>
<li><p>为什么会需要这么一个阉割版的 list 呢？</p>
</li>
<li><p>原因是，在元素大小较小的情况下，forward_list 能节约的内存是非常可观的；在列表不长的情况下，不能反向查找也不是个大问题。提高内存利用率，往往就能提高程序性能，更不用说在内存可能不足时的情况了。</p>
</li>
<li><p>目前你只需要知道这个东西的存在就可以了。如果你觉得不需要用到它的话，也许你真的不需要它。</p>
</li>
</ul>
<h3 id="1-6-queue"><a href="#1-6-queue" class="headerlink" title="1.6 queue"></a>1.6 queue</h3><ul>
<li><p>在结束本讲之前，我们再快速讲两个类容器。它们的特别点在于它们都不是完整的实现，而是依赖于某个现有的容器，因而被称为容器适配器（container adaptor）。</p>
</li>
<li><p>我们先看一下队列 queue，先进先出（FIFO）的数据结构。</p>
</li>
<li><p>queue 缺省用 deque 来实现。它的接口跟 deque 比，有如下改变：</p>
<ul>
<li>不能按下标访问元素</li>
<li>没有 begin、end 成员函数</li>
<li>用 emplace 替代了 emplace_back，用 push 替代了 push_back，用 pop 替代了 pop_front；没有其他的 push_…、pop_…、emplace…、insert、erase 函数</li>
</ul>
</li>
<li><p>它的实际内存布局当然是随底层的容器而定的。</p>
</li>
</ul>
<h3 id="1-7-stack"><a href="#1-7-stack" class="headerlink" title="1.7 stack"></a>1.7 stack</h3><ul>
<li><p>类似地，栈 stack 是后进先出（LIFO）的数据结构。</p>
</li>
<li><p>stack 缺省也是用 deque 来实现，但它的概念和 vector 更相似。它的接口跟 vector 比，有如下改变：</p>
<ul>
<li>不能按下标访问元素</li>
<li>没有 begin、end 成员函数</li>
<li>back 成了 top，没有 front</li>
<li>用 emplace 替代了 emplace_back，用 push 替代了 push_back，用 pop 替代了 pop_back；没有其他的 push_…、pop_…、emplace…、insert、erase 函数</li>
</ul>
</li>
<li><p>一般图形表示法会把 stack 表示成一个竖起的 vector：</p>
</li>
<li><p>这里有一个小细节需要注意。stack 跟我们前面讨论内存管理时的栈有一个区别：</p>
<ul>
<li>在这里下面是低地址，向上则地址增大；而我们讨论内存管理时，高地址在下面，向上则地址减小，方向正好相反</li>
</ul>
</li>
<li><p>提这一点，是希望你在有需要检查栈结构时不会因此而发生混淆；在使用 stack 时，这个区别通常无关紧要。</p>
</li>
</ul>
<h2 id="容器汇编二：需要函数对象的容器"><a href="#容器汇编二：需要函数对象的容器" class="headerlink" title="容器汇编二：需要函数对象的容器"></a>容器汇编二：需要函数对象的容器</h2><h3 id="1-1-函数对象及其特化"><a href="#1-1-函数对象及其特化" class="headerlink" title="1.1 函数对象及其特化"></a>1.1 函数对象及其特化</h3><ul>
<li><p>在讲容器之前，我们需要首先来讨论一下两个重要的函数对象，less 和 hash。</p>
</li>
<li><p>我们先看一下 less，小于关系。在标准库里，通用的 less 大致是这样定义的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">struct less</span><br><span class="line">  : binary_function&lt;T, T, bool&gt; &#123;</span><br><span class="line">  bool operator()(const T&amp; x,</span><br><span class="line">                  const T&amp; y) const</span><br><span class="line">  &#123;</span><br><span class="line">    return x &lt; y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>也就是说，less 是一个函数对象，并且是个二元函数，执行对任意类型的值的比较，返回布尔类型。</p>
</li>
<li><p>作为函数对象，它定义了函数调用运算符（operator()），并且缺省行为是对指定类型的对象进行 &lt; 的比较操作。</p>
</li>
<li><p>有点平淡无奇，是吧？原因是因为这个缺省实现在大部分情况下已经够用，我们不太需要去碰它。在需要大小比较的场合，C++ 通常默认会使用 less，包括我们今天会讲到的若干容器和排序算法 sort。如果我们需要产生相反的顺序的话，则可以使用 greater，大于关系。</p>
</li>
<li><p>计算哈希值的函数对象 hash 就不一样了。它的目的是把一个某种类型的值转换成一个无符号整数哈希值，类型为 size_t。它没有一个可用的默认实现。对于常用的类型，系统提供了需要的特化</p>
</li>
<li><p>这当然是一个极其简单的例子。更复杂的类型，如指针或者 string 的特化，都会更复杂。要点是，对于每个类，类的作者都可以提供 hash 的特化，使得对于不同的对象值，函数调用运算符都能得到尽可能均匀分布的不同数值。</p>
</li>
<li><p>对于容器也是如此，函数对象的类型确定了容器的行为。</p>
</li>
</ul>
<h3 id="1-2-priority-queue"><a href="#1-2-priority-queue" class="headerlink" title="1.2 priority_queue"></a>1.2 priority_queue</h3><ul>
<li>priority_queue 也是一个容器适配器。上一讲没有和其他容器适配器一起讲的原因就在于它用到了比较函数对象（默认是 less）。</li>
<li>和 stack 相似，支持 push、pop、top 等有限的操作，但容器内的顺序既不是后进先出，也不是先进先出，而是（部分）排序的结果。</li>
<li>在使用缺省的 less 作为其 Compare 模板参数时，最大的数值会出现在容器的“顶部”。如果需要最小的数值出现在容器顶部，则可以传递 greater 作为其 Compare 模板参数。</li>
</ul>
<h3 id="1-3-关联容器"><a href="#1-3-关联容器" class="headerlink" title="1.3 关联容器"></a>1.3 关联容器</h3><ul>
<li><p>关联容器有 set（集合）、map（映射）、multiset（多重集）和 multimap（多重映射）。</p>
</li>
<li><p>跳出 C++ 的语境，map（映射）的更常见的名字是关联数组和字典，而在 JSON 里直接被称为对象（object）。</p>
</li>
<li><p>在 C++ 外这些容器常常是无序的；在 C++ 里关联容器则被认为是有序的。</p>
</li>
<li><p>关联容器是一种有序的容器。名字带“multi”的允许键重复，不带的不允许键重复。set 和 multiset 只能用来存放键，而 map 和 multimap 则存放一个个键值对</p>
</li>
<li><p>与序列容器相比，关联容器没有前、后的概念及相关的成员函数，但同样提供 insert、emplace 等成员函数。此外，关联容器都有 find、lower_bound、upper_bound 等查找函数，结果是一个迭代器：</p>
<ul>
<li>find(k) 可以找到任何一个等价于查找键 k 的元素（!(x &lt; k || k &lt; x)）</li>
<li>lower_bound(k) 找到第一个不小于查找键 k 的元素（!(x &lt; k)）</li>
<li>upper_bound(k) 找到第一个大于查找键 k 的元素（k &lt; x）</li>
</ul>
</li>
<li><p>如果你需要在 multimap 里精确查找满足某个键的区间的话，建议使用 equal_range，可以一次性取得上下界（半开半闭）</p>
</li>
<li><p>如果在声明关联容器时没有提供比较类型的参数，缺省使用 less 来进行排序。如果键的类型提供了比较算符 &lt; 的重载，我们不需要做任何额外的工作。否则，我们就需要对键类型进行 less 的特化，或者提供一个其他的函数对象类型。</p>
</li>
<li><p>对于自定义类型，我推荐尽量使用标准的 less 实现，通过重载 &lt;（及其他标准比较运算符）对该类型的对象进行排序。存储在关联容器中的键一般应满足严格弱序关系（strict weak ordering；）即：</p>
<ul>
<li>对于任何该类型的对象 x：!(x &lt; x)（非自反）</li>
<li>对于任何该类型的对象 x 和 y：如果 x &lt; y，则 !(y &lt; x)（非对称）</li>
<li>对于任何该类型的对象 x、y 和 z：如果 x &lt; y 并且 y &lt; z，则 x &lt; z（传递性）</li>
<li>对于任何该类型的对象 x、y 和 z：如果 x 和 y 不可比（!(x &lt; y) 并且 !(y &lt; x)）并且 y 和 z 不可比，则 x 和 z 不可比（不可比的传递性）</li>
</ul>
</li>
<li><p>大部分情况下，类型是可以满足这些条件的，不过：</p>
<ul>
<li>如果类型没有一般意义上的大小关系（如复数），我们一定要别扭地定义一个大小关系吗？</li>
<li>通过比较来进行查找、插入和删除，复杂度为对数 O(log(n))，有没有达到更好的性能的方法？</li>
</ul>
</li>
</ul>
<h3 id="1-4-无序关联容器"><a href="#1-4-无序关联容器" class="headerlink" title="1.4 无序关联容器"></a>1.4 无序关联容器</h3><ul>
<li><p>从 C++11 开始，每一个关联容器都有一个对应的无序关联容器，它们是：</p>
<ul>
<li>unordered_set</li>
<li>unordered_map</li>
<li>unordered_multiset</li>
<li>unordered_multimap</li>
</ul>
</li>
<li><p>这些容器和关联容器非常相似，主要的区别就在于它们是“无序”的。这些容器不要求提供一个排序的函数对象，而要求一个可以计算哈希值的函数对象。</p>
</li>
<li><p>你当然可以在声明容器对象时手动提供这样一个函数对象类型，但更常见的情况是，我们使用标准的 hash 函数对象及其特化。</p>
</li>
<li><p>正常情况下，向 std 名空间添加声明或定义是禁止的，属于未定义行为。</p>
</li>
<li><p>从实际的工程角度，无序关联容器的主要优点在于其性能。</p>
<ul>
<li>关联容器和 priority_queue 的插入和删除操作，以及关联容器的查找操作，其复杂度都是 O(log(n))，而无序关联容器的实现使用哈希表 ，可以达到平均 O(1)！</li>
<li>但这取决于我们是否使用了一个好的哈希函数：在哈希函数选择不当的情况下，无序关联容器的插入、删除、查找性能可能成为最差情况的 O(n)，那就比关联容器糟糕得多了。</li>
</ul>
</li>
</ul>
<h3 id="1-5-array"><a href="#1-5-array" class="headerlink" title="1.5 array"></a>1.5 array</h3><ul>
<li><p>我们讲的最后一个容器是 C 数组的替代品。C 数组在 C++ 里继续存在，主要是为了保留和 C 的向后兼容性。C 数组本身和 C++ 的容器相差是非常大的：</p>
<ul>
<li>C 数组没有 begin 和 end 成员函数（虽然可以使用全局的 begin 和 end 函数）</li>
<li>C 数组没有 size 成员函数（得用一些模板技巧来获取其长度）</li>
<li>C 数组作为参数有退化行为，传递给另外一个函数后那个函数不再能获得 C 数组的长度和结束位置</li>
</ul>
</li>
<li><p>在 C 的年代，大家有时候会定义这样一个宏来获得数组的长度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define ARRAY_LEN(a) \</span><br><span class="line">  (sizeof(a) / sizeof((a)[0]))</span><br></pre></td></tr></table></figure></li>
<li><p>如果在一个函数内部对数组参数使用这个宏，结果肯定是错的。</p>
</li>
<li><p>C++17 直接提供了一个 size 方法，可以用于提供数组长度，并且在数组退化成指针的情况下会直接失败：</p>
</li>
<li><p>此外，C 数组也没有良好的复制行为。你无法用 C 数组作为 map 或 unordered_map 的键类型</p>
</li>
</ul>
<hr>
<ul>
<li>如果不用 C 数组的话，我们该用什么来替代呢？我们有三个可以考虑的选项：<ul>
<li>如果数组较大的话，应该考虑 vector。vector 有最大的灵活性和不错的性能。</li>
<li>对于字符串数组，当然应该考虑 string。</li>
<li>如果数组大小固定（C 的数组在 C++ 里本来就是大小固定的）并且较小的话，应该考虑 array。array 保留了 C 数组在栈上分配的特点，同时，提供了 begin、end、size 等通用成员函数。</li>
</ul>
</li>
<li>array 可以避免 C 数组的种种怪异行径</li>
</ul>
<h2 id="异常：用还是不用，这是个问题"><a href="#异常：用还是不用，这是个问题" class="headerlink" title="异常：用还是不用，这是个问题"></a>异常：用还是不用，这是个问题</h2><ul>
<li>首先，开宗明义，如果你不知道到底该不该用异常的话，那答案就是该用。如果你需要避免使用异常，原因必须是你有明确的需要避免使用异常的理由。</li>
</ul>
<h3 id="1-1-没有异常的世界"><a href="#1-1-没有异常的世界" class="headerlink" title="1.1 没有异常的世界"></a>1.1 没有异常的世界</h3><ul>
<li>我们先来看看没有异常的世界是什么样子的。最典型的情况就是 C 了。</li>
<li>我们有大量需要判断错误的代码，零散分布在代码各处。可这是 C 啊。我们用 C++、不用异常可以吗？</li>
<li>当然可以，但你会发现结果好不了多少。毕竟，C++ 的构造函数是不能返回错误码的，所以你根本不能用构造函数来做可能出错的事情。你不得不定义一个只能清零的构造函数，再使用一个 init 函数来做真正的构造操作。C++ 虽然支持运算符重载，可你也不能使用，因为你没法返回一个新矩阵……</li>
<li>我上面还只展示了单层的函数调用。事实上，如果出错位置离处理错误的位置相差很远的话，每一层的函数调用里都得有判断错误码的代码，这就既对写代码的人提出了严格要求，也对读代码的人造成了视觉上的干扰……</li>
</ul>
<h3 id="1-2-使用异常"><a href="#1-2-使用异常" class="headerlink" title="1.2 使用异常"></a>1.2 使用异常</h3><ul>
<li><p>如果使用异常的话，我们就可以在构造函数里做真正的初始化工作了。</p>
</li>
<li><p>假设我们的矩阵类有下列的数据成员：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class matrix &#123;</span><br><span class="line">  …</span><br><span class="line">private:</span><br><span class="line">  float* data_;</span><br><span class="line">  size_t nrows_;</span><br><span class="line">  size_t ncols_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>构造函数我们可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">matrix::matrix(size_t nrows,</span><br><span class="line">               size_t ncols)</span><br><span class="line">&#123;</span><br><span class="line">  data_  = new float[nrows * ncols];</span><br><span class="line">  nrows_ = nrows;</span><br><span class="line">  ncols_ = ncols;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>析构非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">matrix::~matrix()</span><br><span class="line">&#123;</span><br><span class="line">  delete[] data_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>乘法函数可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class matrix &#123;</span><br><span class="line">  …</span><br><span class="line">  friend matrix</span><br><span class="line">  operator*(const matrix&amp;,</span><br><span class="line">            const matrix&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">matrix operator*(const matrix&amp; lhs,</span><br><span class="line">                 const matrix&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  if (lhs.ncols != rhs.nrows) &#123;</span><br><span class="line">    throw std::runtime_error(</span><br><span class="line">      &quot;matrix sizes mismatch&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  matrix result(lhs.nrows, rhs.ncols);</span><br><span class="line">  // 进行矩阵乘法运算</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用乘法的代码则更是简单：</p>
<ul>
<li><code>matrix c = a * b;</code></li>
</ul>
</li>
<li><p>你可能已经非常疑惑了：错误处理在哪儿呢？只有一个 throw，跟前面的 C 代码能等价吗？</p>
</li>
<li><p>异常处理并不意味着需要写显式的 try 和 catch。异常安全的代码，可以没有任何 try 和 catch。</p>
</li>
<li><p>如果你不确定什么是“异常安全”，我们先来温习一下概念：</p>
<ul>
<li><strong>异常安全是指当异常发生时，既不会发生资源泄漏，系统也不会处于一个不一致的状态。</strong></li>
</ul>
</li>
<li><p>我们看看可能会出现错误 &#x2F; 异常的地方：</p>
<ul>
<li>首先是内存分配。如果 new 出错，按照 C++ 的规则，一般会得到异常 bad_alloc，对象的构造也就失败了。这种情况下，在 catch 捕捉到这个异常之前，所有的栈上对象会全部被析构，资源全部被自动清理。</li>
<li>如果是矩阵的长宽不合适不能做乘法呢？我们同样会得到一个异常，这样，在使用乘法的地方，对象 c 根本不会被构造出来。</li>
<li>如果在乘法函数里内存分配失败呢？一样，result 对象根本没有构造出来，也就没有 c 对象了。还是一切正常。</li>
<li>如果 a、b 是本地变量，然后乘法失败了呢？析构函数会自动释放其空间，我们同样不会有任何资源泄漏。</li>
</ul>
</li>
<li><p>总而言之，只要我们适当地组织好代码、利用好 RAII，实现矩阵的代码和使用矩阵的代码都可以更短、更清晰。我们可以统一在外层某个地方处理异常——通常会记日志、或在界面上向用户报告错误了。</p>
</li>
</ul>
<h3 id="1-3-避免异常的风格指南？"><a href="#1-3-避免异常的风格指南？" class="headerlink" title="1.3 避免异常的风格指南？"></a>1.3 避免异常的风格指南？</h3><ul>
<li>一些游戏项目为了追求高性能，也禁用异常。这个实际上也有一定的历史原因，因为今天的主流 C++ 编译器，在异常关闭和开启时应该已经能够产生性能差不多的代码（在异常未抛出时）。</li>
<li>代价是产生的二进制文件大小的增加，因为异常产生的位置决定了需要如何做栈展开，这些数据需要存储在表里。典型情况，使用异常和不使用异常比，二进制文件大小会有约百分之十到二十的上升。LLVM 项目的编码规范里就明确指出这是不使用 RTTI 和异常的原因</li>
</ul>
<h3 id="1-4-异常的问题"><a href="#1-4-异常的问题" class="headerlink" title="1.4 异常的问题"></a>1.4 异常的问题</h3><ul>
<li><p>异常当然不是一个完美的特性，否则也不会招来这些批评和禁用了。对它的批评主要有两条：</p>
<ul>
<li>异常违反了“你不用就不需要付出代价”的 C++ 原则。只要开启了异常，即使不使用异常你编译出的二进制代码通常也会膨胀。</li>
<li>异常比较隐蔽，不容易看出来哪些地方会发生异常和发生什么异常。</li>
</ul>
</li>
<li><p>对于第一条，开发者没有什么可做的。事实上，这也算是 C++ 实现的一个折中了。目前的主流异常实现中，都倾向于牺牲可执行文件大小、提高主流程（happy path）的性能。只要程序不抛异常，C++ 代码的性能比起完全不做错误检查的代码，都只有几个百分点的性能损失。除了非常有限的一些场景，可执行文件大小通常不会是个问题。</p>
</li>
<li><p>第二条可以算作是一个真正有效的批评。和 Java 不同，C++ 里不会对异常规约进行编译时的检查。从 C++17 开始，C++ 甚至完全禁止了以往的动态异常规约，你不再能在函数声明里写你可能会抛出某某异常。你唯一能声明的，就是某函数不会抛出异常——noexcept、noexcept(true) 或 throw()。这也是 C++ 的运行时唯一会检查的东西了。如果一个函数声明了不会抛出异常、结果却抛出了异常，C++ 运行时会调用 std::terminate 来终止应用程序。不管是程序员的声明，还是编译器的检查，都不会告诉你哪些函数会抛出哪些异常。</p>
</li>
<li><p>当然，不声明异常是有理由的。特别是在泛型编程的代码里，几乎不可能预知会发生些什么异常。我个人对避免异常带来的问题有几点建议：</p>
<ul>
<li>写异常安全的代码，尤其在模板里。可能的话，提供强异常安全保证，在任何第三方代码发生异常的情况下，不改变对象的内容，也不产生任何资源泄漏。</li>
<li>如果你的代码可能抛出异常的话，在文档里明确声明可能发生的异常类型和发生条件。确保使用你的代码的人，能在不检查你的实现的情况下，了解需要准备处理哪些异常。</li>
<li>对于肯定不会抛出异常的代码，将其标为 noexcept。尤其是，移动构造函数、移动赋值运算符和 swap 函数一般需要保证不抛异常并标为 noexcept（析构函数通常不抛异常且自动默认为 noexcept，不需要标）。</li>
</ul>
</li>
</ul>
<h3 id="1-5-使用异常的理由"><a href="#1-5-使用异常的理由" class="headerlink" title="1.5 使用异常的理由"></a>1.5 使用异常的理由</h3><ul>
<li><p>虽然后面我们会描述到一些不使用异常、也不使用错误返回码的错误处理方式，但异常是渗透在 C++ 中的标准错误处理方式。标准库的错误处理方式就是异常。其中不仅包括运行时错误，甚至包括一些逻辑错误</p>
</li>
<li><p>比如，在说容器的时候，有一个我没提的地方是，在能使用 [] 运算符的地方，C++ 的标准容器也提供了 at 成员函数，能够在下标不存在的时候抛出异常，作为一种额外的帮助调试的手段。</p>
</li>
<li><p>C++ 的标准容器在大部分情况下提供了强异常保证，即，一旦异常发生，现场会恢复到调用函数之前的状态，容器的内容不会发生改变，也没有任何资源泄漏。前面提到过，vector 会在元素类型没有提供保证不抛异常的移动构造函数的情况下，在移动元素时会使用拷贝构造函数。这是因为一旦某个操作发生了异常，被移动的元素已经被破坏，处于只能析构的状态，异常安全性就不能得到保证了。</p>
</li>
<li><p>只要你使用了标准容器，不管你自己用不用异常，你都得处理标准容器可能引发的异常——至少有 bad_alloc，除非你明确知道你的目标运行环境不会产生这个异常。这对普通配置的 Linux 环境而言，倒确实是对的……这也算是 Google 这么规定的一个底气吧。</p>
</li>
<li><p>虽然对于运行时错误，开发者并没有什么选择余地；但对于代码中的逻辑错误，开发者则是可以选择不同的处理方式的：你可以使用异常，也可以使用 assert，在调试环境中报告错误并中断程序运行。由于测试通常不能覆盖所有的代码和分支，assert 在发布模式下一般被禁用，两者并不是完全的替代关系。在允许异常的情况下，使用异常可以获得在调试和发布模式下都良好、一致的效果。</p>
</li>
</ul>
<h2 id="迭代器和好用的新for循环"><a href="#迭代器和好用的新for循环" class="headerlink" title="迭代器和好用的新for循环"></a>迭代器和好用的新for循环</h2><h3 id="1-1-什么是迭代器？"><a href="#1-1-什么是迭代器？" class="headerlink" title="1.1 什么是迭代器？"></a>1.1 什么是迭代器？</h3><ul>
<li><p>迭代器是一个很通用的概念，并不是一个特定的类型。它实际上是一组对类型的要求</p>
</li>
<li><p>它的最基本要求就是从一个端点出发，下一步、下一步地到达另一个端点。按照一般的中文习惯，也许“遍历”是比“迭代”更好的用词。我们可以遍历一个字符串的字符，遍历一个文件的内容，遍历目录里的所有文件，等等。这些都可以用迭代器来表达</p>
</li>
<li><p>输入迭代器不要求对同一迭代器可以多次使用 * 运算符，也不要求可以保存迭代器来重新遍历对象，换句话说，只要求可以单次访问。如果取消这些限制、允许多次访问的话，那迭代器同时满足了前向迭代器（forward iterator）。</p>
</li>
<li><p>一个前向迭代器的类型，如果同时支持 –（前置及后置），回到前一个对象，那它就是个双向迭代器（bidirectional iterator）。也就是说，可以正向遍历，也可以反向遍历。</p>
</li>
<li><p>一个双向迭代器，如果额外支持在整数类型上的 +、-、+&#x3D;、-&#x3D;，跳跃式地移动迭代器；支持 []，数组式的下标访问；支持迭代器的大小比较（之前只要求相等比较）；那它就是个随机访问迭代器（random-access iterator）。</p>
</li>
<li><p>一个随机访问迭代器 i 和一个整数 n，在 <code>*i</code> 可解引用且 <code>i + n</code> 是合法迭代器的前提下，如果额外还满足 <code>*(addressdof(*i) + n)</code> 等价于 <code>*(i + n)</code>，即保证迭代器指向的对象在内存里是连续存放的，那它（在 C++20 里）就是个连续迭代器（contiguous iterator）。</p>
</li>
<li><p>以上这些迭代器只考虑了读取。如果一个类型像输入迭代器，但 *i 只能作为左值来写而不能读，那它就是个输出迭代器（output iterator）。</p>
</li>
<li><p>而比输入迭代器和输出迭代器更底层的概念，就是迭代器了。基本要求是：</p>
<ul>
<li>对象可以被拷贝构造、拷贝赋值和析构。</li>
<li>对象支持 * 运算符。</li>
<li>对象支持前置 ++ 运算符。</li>
</ul>
</li>
<li><p>迭代器通常是对象。但需要注意的是，指针可以满足上面所有的迭代器要求，因而也是迭代器。这应该并不让人惊讶，因为本来迭代器就是根据指针的特性，对其进行抽象的结果。事实上，vector 的迭代器，在很多实现里就直接是使用指针的。</p>
</li>
</ul>
<h3 id="1-2-常用迭代器"><a href="#1-2-常用迭代器" class="headerlink" title="1.2 常用迭代器"></a>1.2 常用迭代器</h3><ul>
<li><p>最常用的迭代器就是容器的 iterator 类型了</p>
</li>
<li><p>以我们学过的顺序容器为例，它们都定义了嵌套的 iterator 类型和 const_iterator 类型。</p>
</li>
<li><p>一般而言，iterator 可写入，const_iterator 类型不可写入，但这些迭代器都被定义为输入迭代器或其派生类型：</p>
<ul>
<li>vector::iterator 和 array::iterator 可以满足到连续迭代器。</li>
<li>deque::iterator 可以满足到随机访问迭代器（记得它的内存只有部分连续）</li>
<li>list::iterator 可以满足到双向迭代器（链表不能快速跳转）。</li>
<li>forward_list::iterator 可以满足到前向迭代器（单向链表不能反向遍历）。</li>
</ul>
</li>
<li><p>很常见的一个输出迭代器是 back_inserter 返回的类型 back_inserter_iterator 了；用它我们可以很方便地在容器的尾部进行插入操作</p>
</li>
<li><p>另外一个常见的输出迭代器是 ostream_iterator，方便我们把容器内容“拷贝”到一个输出流</p>
</li>
</ul>
<h3 id="1-3-使用输入行迭代器"><a href="#1-3-使用输入行迭代器" class="headerlink" title="1.3 使用输入行迭代器"></a>1.3 使用输入行迭代器</h3><ul>
<li><p>在此之前，我先解说一下基于范围的 for 循环这个语法。虽然这可以说是个语法糖，但它对提高代码的可读性真的非常重要。如果不用这个语法糖的话，简洁性上的优势就小多了。我们直接把这个循环改写成等价的普通 for 循环的样子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  auto&amp;&amp; r = istream_line_reader(is);</span><br><span class="line">  auto it = r.begin();</span><br><span class="line">  auto end = r.end();</span><br><span class="line">  for (; it != end; ++it) &#123;</span><br><span class="line">    const string&amp; line = *it;</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可以看到，它做的事情也不复杂，就是：</p>
<ul>
<li>获取冒号后边的范围表达式的结果，并隐式产生一个引用，在整个循环期间都有效。注意根据生命期延长规则，表达式结果如果是临时对象的话，这个对象要在循环结束后才被销毁。</li>
<li>自动生成遍历这个范围的迭代器。</li>
<li>循环内自动生成根据冒号左边的声明和 *it 来进行初始化的语句。</li>
<li>下面就是完全正常的循环体。</li>
</ul>
</li>
<li><p>生成迭代器这一步有可能是——但不一定是——调用 r 的 begin 和 end 成员函数。具体规则是：</p>
<ul>
<li>对于 C 数组（必须是没有退化为指针的情况），编译器会自动生成指向数组头尾的指针（相当于自动应用可用于数组的 std::begin 和 std::end 函数）。</li>
<li>对于有 begin 和 end 成员的对象，编译器会调用其 begin 和 end 成员函数（我们目前的情况）。</li>
<li>否则，编译器会尝试在 r 对象所在的名空间寻找可以用于 r 的 begin 和 end 函数，并调用 begin(r) 和 end(r)；找不到的话则失败报错。</li>
</ul>
</li>
</ul>
<h2 id="易用性改进一：自动类型推断和初始化"><a href="#易用性改进一：自动类型推断和初始化" class="headerlink" title="易用性改进一：自动类型推断和初始化"></a>易用性改进一：自动类型推断和初始化</h2><ul>
<li>我们主要是介绍 C++ 里好用的特性，而非让你死记规则</li>
<li>因此，这里讲到的内容，有时是一种简化的说法。对于日常使用，本讲介绍的应该能满足大部分的需求。对于复杂用法和边角情况，你可能还是需要查阅参考资料里的明细规则</li>
</ul>
<h3 id="1-1-自动类型推断"><a href="#1-1-自动类型推断" class="headerlink" title="1.1 自动类型推断"></a>1.1 自动类型推断</h3><ul>
<li><p>如果要挑选 C++11 带来的最重大改变的话，自动类型推断肯定排名前三</p>
</li>
<li><p>auto， 自动类型推断，顾名思义，就是编译器能够根据表达式的类型，自动决定变量的类型（从 C++14 开始，还有函数的返回类型），不再需要程序员手工声明</p>
</li>
<li><p>但需要说明的是，auto 并没有改变 C++ 是静态类型语言这一事实——使用 auto 的变量（或函数返回值）的类型仍然是编译时就确定了，只不过编译器能自动帮你填充而已</p>
</li>
<li><p>auto 实际使用的规则类似于函数模板参数的推导规则。当你写了一个含 auto 的表达式时，相当于把 auto 替换为模板参数的结果。举具体的例子：</p>
<ul>
<li>auto a &#x3D; expr; 意味着用 expr 去匹配一个假想的 template f(T) 函数模板，结果为值类型。</li>
<li>const auto&amp; a &#x3D; expr; 意味着用 expr 去匹配一个假想的 template f(const T&amp;) 函数模板，结果为常左值引用类型。</li>
<li>auto&amp;&amp; a &#x3D; expr; 意味着用 expr 去匹配一个假想的 template f(T&amp;&amp;) 函数模板，根据[第 3 讲] 中我们讨论过的转发引用和引用坍缩规则，结果是一个跟 expr 值类别相同的引用类型。</li>
</ul>
</li>
<li><p>decltype 的用途是获得一个表达式的类型，结果可以跟类型一样使用。它有两个基本用法：</p>
<ul>
<li>decltype(变量名) 可以获得变量的精确类型。</li>
<li>decltype(表达式) （表达式不是变量名，但包括 decltype((变量名)) 的情况）可以获得表达式的引用类型；除非表达式的结果是个纯右值（prvalue），此时结果仍然是值类型。</li>
<li>如果我们有 int a;，那么：<ul>
<li>decltype(a) 会获得 int（因为 a 是 int）。</li>
<li>decltype((a)) 会获得 int&amp;（因为 a 是 lvalue）。</li>
<li>decltype(a + a) 会获得 int（因为 a + a 是 prvalue）。</li>
</ul>
</li>
</ul>
</li>
<li><p>通常情况下，能写 auto 来声明变量肯定是件比较轻松的事。但这儿有个限制，你需要在写下 auto 时就决定你写下的是个引用类型还是值类型</p>
</li>
<li><p>根据类型推导规则，auto 是值类型，auto&amp; 是左值引用类型，auto&amp;&amp; 是转发引用（可以是左值引用，也可以是右值引用）。使用 auto 不能通用地根据表达式类型来决定返回值的类型。不过，decltype(expr) 既可以是值类型，也可以是引用类型。因此，我们可以这么写：</p>
<ul>
<li><code>decltype(expr) a = expr;</code></li>
</ul>
</li>
<li><p>这种写法明显不能让人满意，特别是表达式很长的情况（而且，任何代码重复都是潜在的问题）。为此，C++14 引入了 decltype(auto) 语法。对于上面的情况，我们只需要像下面这样写就行了。</p>
<ul>
<li><code>decltype(auto) a = expr;</code></li>
</ul>
</li>
<li><p>这种代码主要用在通用的转发函数模板中：你可能根本不知道你调用的函数是不是会返回一个引用。这时使用这种语法就会方便很多。</p>
</li>
</ul>
<h3 id="1-2-函数返回值类型推断"><a href="#1-2-函数返回值类型推断" class="headerlink" title="1.2 函数返回值类型推断"></a>1.2 函数返回值类型推断</h3><ul>
<li>从 C++14 开始，函数的返回值也可以用 auto 或 decltype(auto) 来声明了。同样的，用 auto 可以得到值类型，用 auto&amp; 或 auto&amp;&amp; 可以得到引用类型；</li>
<li>而用 decltype(auto) 可以根据返回表达式通用地决定返回的是值类型还是引用类型</li>
<li>和这个形式相关的有另外一个语法，后置返回值类型声明。严格来说，这不算“类型推断”，不过我们也放在一起讲吧。它的形式是这个样子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto foo(参数) -&gt; 返回值类型声明</span><br><span class="line">&#123;</span><br><span class="line">  // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>通常，在返回类型比较复杂、特别是返回类型跟参数类型有某种推导关系时会使用这种语法</li>
</ul>
<h3 id="1-3-类模板的模板参数推导"><a href="#1-3-类模板的模板参数推导" class="headerlink" title="1.3 类模板的模板参数推导"></a>1.3 类模板的模板参数推导</h3><ul>
<li><p>如果你用过 pair 的话，一般都不会使用下面这种形式：<code>pair&lt;int, int&gt; pr&#123;1, 42&#125;;</code></p>
</li>
<li><p>使用 make_pair 显然更容易一些：<code>auto pr = make_pair(1, 42);</code></p>
</li>
<li><p>这是因为函数模板有模板参数推导，使得调用者不必手工指定参数类型；但 C++17 之前的类模板却没有这个功能，也因而催生了像 make_pair 这样的工具函数。</p>
</li>
<li><p>在进入了 C++17 的世界后，这类函数变得不必要了。现在我们可以直接写：<code>pair pr&#123;1, 42&#125;;</code></p>
</li>
<li><p>在初次见到 array 时，我觉得它的主要缺点就是不能像 C 数组一样自动从初始化列表来推断数组的大小了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a1[] = &#123;1, 2, 3&#125;;</span><br><span class="line">array&lt;int, 3&gt; a2&#123;1, 2, 3&#125;; // 啰嗦</span><br><span class="line">// array&lt;int&gt; a3&#123;1, 2, 3&#125;; 不行</span><br></pre></td></tr></table></figure></li>
<li><p>这个问题在 C++17 里也是基本不存在的。虽然不能只提供一个模板参数，但你可以两个参数全都不写</p>
<ul>
<li><code>array a&#123;1, 2, 3&#125;;  // 得到 array&lt;int, 3&gt;</code></li>
</ul>
</li>
<li><p>这种自动推导机制，可以是编译器根据构造函数来自动生成：</p>
</li>
<li><p>也可以是手工提供一个推导向导，达到自己需要的效果：</p>
</li>
</ul>
<h3 id="1-4-结构化绑定"><a href="#1-4-结构化绑定" class="headerlink" title="1.4 结构化绑定"></a>1.4 结构化绑定</h3><ul>
<li>在讲关联容器的时候我们有过这样一个例子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string, int&gt;::iterator</span><br><span class="line">  lower, upper;</span><br><span class="line">std::tie(lower, upper) =</span><br><span class="line">  mmp.equal_range(&quot;four&quot;);</span><br></pre></td></tr></table></figure></li>
<li>这个例子里，返回值是个 pair，我们希望用两个变量来接收数值，就不得不声明了两个变量，然后使用 tie 来接收结果。</li>
<li>在 C++11&#x2F;14 里，这里是没法使用 auto 的。好在 C++17 引入了一个新语法，解决了这个问题。目前，我们可以把上面的代码简化为:<code>auto [lower, upper] = mmp.equal_range(&quot;four&quot;);</code></li>
<li>这个语法使得我们可以用 auto 声明变量来分别获取 pair 或 tuple 返回值里各个子项，可以让代码的可读性更好。</li>
</ul>
<h3 id="1-5-列表初始化"><a href="#1-5-列表初始化" class="headerlink" title="1.5 列表初始化"></a>1.5 列表初始化</h3><ul>
<li><p>在 C++98 里，标准容器比起 C 风格数组至少有一个明显的劣势：不能在代码里方便地初始化容器的内容。比如，对于数组你可以写：</p>
<ul>
<li><code>int a[] = &#123;1, 2, 3, 4, 5&#125;;</code></li>
</ul>
</li>
<li><p>而对于 vector 你却得写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v;</span><br><span class="line">v.push(1);</span><br><span class="line">v.push(2);</span><br><span class="line">v.push(3);</span><br><span class="line">v.push(4);</span><br><span class="line">v.push(5);</span><br></pre></td></tr></table></figure></li>
<li><p>这样真是又啰嗦，性能又差，显然无法让人满意。于是，C++ 标准委员会引入了列表初始化，允许以更简单的方式来初始化对象。现在我们初始化容器也可以和初始化数组一样简单了：</p>
<ul>
<li><code>vector v&#123;1, 2, 3, 4, 5&#125;;</code></li>
</ul>
</li>
<li><p>同样重要的是，这不是对标准库容器的特殊魔法，而是一个通用的、可以用于各种类的方法。</p>
</li>
<li><p>从技术角度，编译器的魔法只是对 {1, 2, 3} 这样的表达式自动生成一个初始化列表，在这个例子里其类型是 initializer_list。程序员只需要声明一个接受 initializer_list 的构造函数即可使用。从效率的角度，至少在动态对象的情况下，容器和数组也并无二致，都是通过拷贝（构造）进行初始化</p>
</li>
</ul>
<h3 id="1-6-统一初始化"><a href="#1-6-统一初始化" class="headerlink" title="1.6 统一初始化"></a>1.6 统一初始化</h3><ul>
<li><p>你可能已经注意到了，我在代码里使用了大括号 {} 来进行对象的初始化。这当然也是 C++11 引入的新语法，能够代替很多小括号 () 在变量初始化时使用。这被称为统一初始化（uniform initialization）。</p>
</li>
<li><p>大括号对于构造一个对象而言，最大的好处是避免了 C++ 里“最令人恼火的语法分析”（the most vexing parse）</p>
</li>
<li><p>你几乎可以在所有初始化对象的地方使用大括号而不是小括号。它还有一个附带的特点：当一个构造函数没有标成 explicit 时，你可以使用大括号不写类名来进行构造，如果调用上下文要求那类对象的话</p>
</li>
<li><p>这个语法主要的限制是，如果一个类既有使用初始化列表的构造函数，又有不使用初始化列表的构造函数，那编译器会千方百计地试图调用使用初始化列表的构造函数，导致各种意外。所以，如果给一个推荐的话，那就是：</p>
<ul>
<li>如果一个类没有使用初始化列表的构造函数时，初始化该类对象可全部使用统一初始化语法。</li>
<li>如果一个类有使用初始化列表的构造函数时，则只应用在初始化列表构造的情况。</li>
</ul>
</li>
</ul>
<h3 id="1-7-类数据成员的默认初始化"><a href="#1-7-类数据成员的默认初始化" class="headerlink" title="1.7 类数据成员的默认初始化"></a>1.7 类数据成员的默认初始化</h3><ul>
<li>按照 C++98 的语法，数据成员可以在构造函数里进行初始化。</li>
<li>这本身不是问题，但实践中，如果数据成员比较多、构造函数又有多个的话，逐个去初始化是个累赘，并且很容易在增加数据成员时漏掉在某个构造函数中进行初始化</li>
<li>为此，C++11 增加了一个语法，允许在声明数据成员时直接给予一个初始化表达式。这样，当且仅当构造函数的初始化列表中不包含该数据成员时，这个数据成员就会自动使用初始化表达式进行初始化。</li>
<li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Complex &#123;</span><br><span class="line">public:</span><br><span class="line">  Complex()</span><br><span class="line">    : re_(0) , im_(0) &#123;&#125;</span><br><span class="line">  Complex(float re)</span><br><span class="line">    : re_(re), im_(0) &#123;&#125;</span><br><span class="line">  Complex(float re, float im)</span><br><span class="line">    : re_(re) , im_(im) &#123;&#125;</span><br><span class="line">  …</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  float re_;</span><br><span class="line">  float im_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>假设由于某种原因，我们不能使用缺省参数来简化构造函数，我们可以用什么方式来优化上面这个代码呢？</li>
<li>使用数据成员的默认初始化的话，我们就可以这么写：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Complex &#123;</span><br><span class="line">public:</span><br><span class="line">  Complex() &#123;&#125;</span><br><span class="line">  Complex(float re) : re_(re) &#123;&#125;</span><br><span class="line">  Complex(float re, float im)</span><br><span class="line">    : re_(re) , im_(im) &#123;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  float re_&#123;0&#125;;</span><br><span class="line">  float im_&#123;0&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>第一个构造函数没有任何初始化列表，所以类数据成员的初始化全部由默认初始化完成，re_ 和 im_ 都是 0。</li>
<li>第二个构造函数提供了 re_ 的初始化，im_ 仍由默认初始化完成。</li>
<li>第三个构造函数则完全不使用默认初始化。</li>
</ul>
<h2 id="易用性改进二：字面量，静态断言和成员函数说明符"><a href="#易用性改进二：字面量，静态断言和成员函数说明符" class="headerlink" title="易用性改进二：字面量，静态断言和成员函数说明符"></a>易用性改进二：字面量，静态断言和成员函数说明符</h2><h3 id="1-1-自定义字面量"><a href="#1-1-自定义字面量" class="headerlink" title="1.1 自定义字面量"></a>1.1 自定义字面量</h3><ul>
<li><p>字面量（literal）是指在源代码中写出的固定常量，它们在 C++98 里只能是原生类型，如：</p>
<ul>
<li>“hello”，字符串字面量，类型是 <code>const char[6]</code></li>
<li>1，整数字面量，类型是 int</li>
<li>0.0，浮点数字面量，类型是 double</li>
<li>3.14f，浮点数字面量，类型是 float</li>
<li>123456789ul，无符号长整数字面量，类型是 unsigned long</li>
</ul>
</li>
<li><p>C++11 引入了自定义字面量，可以使用 operator”” 后缀 来将用户提供的字面量转换成实际的类型。C++14 则在标准库中加入了不少标准字面量。下面这个程序展示了它们的用法：</p>
</li>
</ul>
<h3 id="1-2-二进制字面量"><a href="#1-2-二进制字面量" class="headerlink" title="1.2 二进制字面量"></a>1.2 二进制字面量</h3><ul>
<li><p>你一定知道 C++ 里有 0x 前缀，可以让开发人员直接写出像 0xFF 这样的十六进制字面量</p>
</li>
<li><p>另外一个目前使用得稍少的前缀就是 0 后面直接跟 0–7 的数字，表示八进制的字面量，</p>
</li>
<li><p>在跟文件系统打交道的时候还会经常用到：有经验的 Unix 程序员可能会觉得<code>chmod(path, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)</code> 并不比 <code>chmod(path,0644)</code> 更为直观</p>
</li>
<li><p>从 C++14 开始，我们对于二进制也有了直接的字面量：</p>
<ul>
<li><code>unsigned mask = 0b111000000;</code></li>
</ul>
</li>
<li><p>这在需要比特级操作等场合还是非常有用的。</p>
</li>
<li><p>不过，遗憾的是， I&#x2F;O streams 里只有 dec、hex、oct 三个操纵器（manipulator），而没有 bin，因而输出一个二进制数不能像十进制、十六进制、八进制那么直接。一个间接方式是使用 bitset，但调用者需要手工指定二进制位数：</p>
<ul>
<li><code>#include &lt;bitset&gt;  cout &lt;&lt; bitset&lt;9&gt;(mask) &lt;&lt; endl;</code></li>
</ul>
</li>
</ul>
<h3 id="1-3-数字分隔符"><a href="#1-3-数字分隔符" class="headerlink" title="1.3 数字分隔符"></a>1.3 数字分隔符</h3><ul>
<li>数字长了之后，看清位数就变得麻烦了。有了二进制字面量，这个问题变得分外明显。</li>
<li>C++14 开始，允许在数字型字面量中任意添加 <code>&#39;</code> 来使其更可读。</li>
<li>具体怎么添加，完全由程序员根据实际情况进行约定。某些常见的情况可能会是：<ul>
<li>十进制数字使用三位的分隔，对应英文习惯的 thousand、million 等单位。</li>
<li>十进制数字使用四位的分隔，对应中文习惯的万、亿等单位。</li>
<li>十六进制数字使用两位或四位的分隔，对应字节或双字节。</li>
<li>二进制数字使用三位的分隔，对应文件系统的权限分组。</li>
</ul>
</li>
<li>一些实际例子如下：<pre><code>  unsigned mask = 0b111&#39;000&#39;000;
  long r_earth_equatorial = 6&#39;378&#39;137;
  double pi = 3.14159&#39;26535&#39;89793;
  const unsigned magic = 0x44&#39;42&#39;47&#39;4E;
</code></pre>
</li>
</ul>
<h3 id="1-4-静态断言"><a href="#1-4-静态断言" class="headerlink" title="1.4 静态断言"></a>1.4 静态断言</h3><ul>
<li><p>C++98 的 assert 允许在运行时检查一个函数的前置条件是否成立。</p>
</li>
<li><p>没有一种方法允许开发人员在编译的时候检查假设是否成立。比如，如果模板有个参数 alignment，表示对齐，那我们最好在编译时就检查 alignment 是不是二的整数次幂。之前人们用了一些模板技巧来达到这个目的，但输出的信息并不那么友善。</p>
</li>
<li><p>C++11 直接从语言层面提供了静态断言机制，不仅能输出更好的信息，而且适用性也更好，可以直接放在类的定义中，而不像之前用的特殊技巧只能放在函数体里</p>
</li>
<li><p>静态断言语法上非常简单，就是：</p>
<ul>
<li><code>static_assert(编译期条件表达式， 可选输出信息);</code></li>
</ul>
</li>
<li><p>产生上面的示例错误信息的代码是：</p>
<ul>
<li><code>static_assert((alignment &amp; (alignment - 1)) == 0,&quot;Alignment must be power of two&quot;);</code></li>
</ul>
</li>
</ul>
<h3 id="1-5-default-和-delete-成员函数"><a href="#1-5-default-和-delete-成员函数" class="headerlink" title="1.5 default 和 delete 成员函数"></a>1.5 default 和 delete 成员函数</h3><ul>
<li><p>在类的定义时，C++ 有一些规则决定是否生成默认的特殊成员函数。这些特殊成员函数可能包括：</p>
<ul>
<li>默认构造函数</li>
<li>析构函数</li>
<li>拷贝构造函数</li>
<li>拷贝赋值函数</li>
<li>移动构造函数</li>
<li>移动赋值函数</li>
</ul>
</li>
<li><p>生成这些特殊成员函数（或不生成）的规则比较复杂，每个特殊成员函数有几种不同的状态：</p>
<ul>
<li>隐式声明还是用户声明</li>
<li>默认提供还是用户提供</li>
<li>正常状态还是删除状态</li>
</ul>
</li>
<li><p>这三个状态是可组合的，虽然不是所有的组合都有效。隐式声明的必然是默认提供的；默认提供的才可能被删除；用户提供的也必然是用户声明的。</p>
</li>
<li><p>如果成员和父类没有特殊原因导致对象不可拷贝或移动，在用户不声明这些成员函数的情况下，编译器会自动产生这些成员函数，即隐式声明、默认提供、正常状态。有特殊成员、用户声明的话，情况就非常复杂了：</p>
<ul>
<li>没有初始化的非静态 const 数据成员和引用类型数据成员会导致默认提供的默认构造函数被删除。</li>
<li>非静态的 const 数据成员和引用类型数据成员会导致默认提供的拷贝构造函数、拷贝赋值函数、移动构造函数和移动赋值函数被删除。</li>
<li>用户如果没有自己提供一个拷贝构造函数（必须形如 Obj(Obj&amp;) 或 Obj(constObj&amp;)；不是模板），编译器会隐式声明一个</li>
<li>用户如果没有自己提供一个拷贝赋值函数（必须形如 Obj&amp; operator&#x3D;(Obj&amp;) 或Obj&amp; operator&#x3D;(const Obj&amp;)；不是模板），编译器会隐式声明一个。</li>
<li>用户如果自己声明了一个移动构造函数或移动赋值函数，则默认提供的拷贝构造函数和拷贝赋值函数被删除。</li>
<li>用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动赋值函数和析构函数，编译器会隐式声明一个移动构造函数</li>
<li>用户如果没有自己声明拷贝构造函数、拷贝赋值函数、移动构造函数和析构函数，编译器会隐式声明一个移动赋值函数。</li>
</ul>
</li>
<li><p>我不鼓励你去死记硬背这些规则，而是希望你在项目和测试中体会其缘由。我认为这些规则还相当合理，虽然有略偏保守之嫌。尤其是关于移动构造和赋值：只要用户声明了另外的特殊成员函数中的任何一个，编译器就不默认提供了。不过嘛，缺省慢点总比缺省不安全要好……</p>
</li>
<li><p>我们这儿主要要说的是：</p>
<ul>
<li>我们可以改变缺省行为，在编译器能默认提供特殊成员函数时将其删除，或在编译器不默认提供特殊成员函数时明确声明其需要默认提供</li>
<li>（不过，要注意，即使用户要求默认提供，编译器也可能根据其他规则将特殊成员函数标为删除）。</li>
</ul>
</li>
</ul>
<h3 id="1-6-override-和-final-说明符"><a href="#1-6-override-和-final-说明符" class="headerlink" title="1.6 override 和 final 说明符"></a>1.6 override 和 final 说明符</h3><ul>
<li><p>override 和 final 是两个 C++11 引入的新说明符。</p>
</li>
<li><p>它们不是关键词，仅在出现在函数声明尾部时起作用，不影响我们使用这两个词作变量名等其他用途。这两个说明符可以单个或组合使用，都是加在类成员函数声明的尾部。</p>
</li>
<li><p>override 显式声明了成员函数是一个虚函数且覆盖了基类中的该函数。如果有override 声明的函数不是虚函数，或基类中不存在这个虚函数，编译器会报告错误。</p>
</li>
<li><p>这个说明符的主要作用有两个：</p>
<ul>
<li>给开发人员更明确的提示，这个函数覆写了基类的成员函数；</li>
<li>让编译器进行额外的检查，防止程序员由于拼写错误或代码改动没有让基类和派生类中的成员函数名称完全一致。</li>
</ul>
</li>
<li><p>final 则声明了成员函数是一个虚函数，且该虚函数不可在派生类中被覆盖。如果有一点没有得到满足的话，编译器就会报错。</p>
</li>
<li><p>final 还有一个作用是标志某个类或结构不可被派生。同样，这时应将其放在被定义的类或结构名后面。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_09_%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/2024-05-22-C++_09_%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_09_%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/2024-05-22-C++_09_%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">C++_09_后台开发理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++服务器开发，后台开发基本理论知识</li>
</ul>
<h2 id="静态文件托管-是什么"><a href="#静态文件托管-是什么" class="headerlink" title="静态文件托管 是什么"></a>静态文件托管 是什么</h2><p>在服务器环境中，静态文件托管指的是将静态文件（例如HTML、CSS、JavaScript、图像、视频等）通过HTTP协议提供给客户端。这意味着服务器会接收来自客户端的请求，并将请求的静态文件发送回客户端，使其能够在浏览器中进行显示或使用。</p>
<p>静态文件托管是一种简单有效的方式来提供网站或应用程序的静态内容，因为这些文件通常不需要在每次请求时进行处理或生成动态内容。</p>
<p>通常情况下，服务器会配置一个目录，称为静态文件目录（或文档根目录），该目录包含要提供给客户端的静态文件。当收到针对这些静态文件的HTTP请求时，服务器会检查请求的文件路径，并将相应的文件内容发送回客户端。</p>
<p>例如，如果您的服务器上的静态文件目录是<code>/var/www/html</code>，并且有一个名为<code>index.html</code>的文件，当用户在浏览器中访问您的服务器时，可以通过URL <code>http://yourdomain.com/index.html</code> 来请求该文件。服务器会将<code>/var/www/html/index.html</code>的内容发送回浏览器，使其能够显示该网页。</p>
<p>静态文件托管常用于简单的网站、单页应用程序（SPA）和服务端渲染的应用程序等场景。相比于动态内容生成，静态文件托管可以提供更快的响应速度，减轻服务器的负载，并且不需要在每个请求上进行处理。</p>
<p>对于静态文件托管，您可以使用各种服务器软件，如Apache、Nginx等，通过配置服务器软件的相关选项来指定静态文件目录和其他细节。</p>
<h2 id="C-传输二进制数据"><a href="#C-传输二进制数据" class="headerlink" title="C++ 传输二进制数据"></a>C++ 传输二进制数据</h2><ul>
<li><p>二进制数据传输的本质</p>
<ul>
<li>首先明确，数据在计算机内存中的存储方式是二进制的，在进行数据传输的时候，从内存中读取出来的数据就是二进制的数据。</li>
<li>因此，如果能够保证数据存储上的连续性的话，我们只需要告诉httplib，传输数据的指针地址是什么，传输数据的长度是多少即可。</li>
</ul>
</li>
<li><p>指针相关概念</p>
<ul>
<li>C里面关于内存数据的操作需要两个条件，一个是指针，一个是长度</li>
<li>针对连续的内存，可以通过指针+长度的方式来操作内存</li>
</ul>
</li>
<li><p>float* 和 char* 类型的指针有什么区别</p>
<ul>
<li>本质上都是指向数据的存储地址，区别在于指针类型，以及读出数据时候的格式转换</li>
<li>float* 类型的指针，指针运算的时候，因为float是4个字节，需要转换成1个字节，因此需要size * 4</li>
<li>char* 类型的指针，指针运算的时候，因为char是1个字节，因此直接获取size即可</li>
</ul>
</li>
</ul>
<h2 id="理解字节本质和二进制"><a href="#理解字节本质和二进制" class="headerlink" title="理解字节本质和二进制"></a>理解字节本质和二进制</h2><ul>
<li><p>无论是互联网应用还是物联网应用，在网络传输层传输的其是都是二进制数据。因为现代通讯设备对信号处理都是用的数字电路，数字电路的输入输出只有两种状态，那就是高电平或者低电平，也就是对应二进制数据的1和0。</p>
</li>
<li><p>按照一定的时序和时钟基准，就可以代表了不同的信息。</p>
</li>
<li><p>网络传输中是按照字节传输的，而每个字节通常是按照8位二进制组成的。</p>
</li>
<li><p>一个字节由8个二进制位组成，通常标准是高位在前，最低位序号是0，最高位序号是7。</p>
</li>
<li><p>为什么叫二进制？</p>
<ul>
<li>生活中使用的数字计数是10进制的，因逢10进1而得名。那二进制也是因为逢2进1而得名的。</li>
<li>一个字节的8位二进制实际就是一个计数标记，由8个位组合在一起表示。因为每个位只能有0和1两种变化，所以要计数到2的时候就得进位了。</li>
</ul>
</li>
</ul>
<h2 id="理解十六进制"><a href="#理解十六进制" class="headerlink" title="理解十六进制"></a>理解十六进制</h2><ul>
<li><p>二进制的写法，一个字节要写8次，显然很不方便，也不好读，口算成十进制数有很大难度。那么十六进制标准书写是两个字符表示一个字节，等宽制的，便于编辑和浏览。</p>
</li>
<li><p>更重要的是与二进制的换算刚好将8位分成两部分，每四位对应一个字符，两个字符拼在一起代表了完整的8位</p>
</li>
<li><p>十六进制，顾名思义应该是逢十六进一，但是阿拉伯数字只有0-9，那么逢十六进一至少要能表示到15才可以。因此十六进制在0-9的基础上又增加了A-F六个字母分别代表10-15。对应十进制值</p>
<ul>
<li>00 表示 0</li>
<li>0A 表示 10</li>
<li>0F 表示 15</li>
<li>10 表示 16(因为满16就进位了)</li>
</ul>
</li>
<li><p>一个字节的8个位四四分开，分别对应前后两个16进制字符，就很快可以换算出来</p>
</li>
</ul>
<h2 id="HTTP-文件上传"><a href="#HTTP-文件上传" class="headerlink" title="HTTP 文件上传"></a>HTTP 文件上传</h2><ul>
<li>在HTTP中，我们要上传文件的时候一般都是通过Form实现的，对于Form有个属性可以用于定义提交的编码方式: enctype，它的可选值有<ul>
<li>application&#x2F;x-www-form-urlencoded： 默认的类型</li>
<li>multipart&#x2F;form-data : 允许通过file类型的<input>用于上传文件</li>
<li>text&#x2F;plain : 不常用的方式，直接将数据传输到后端</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_11_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2024-05-22-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_11_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2024-05-22-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">装饰者模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>Decorator(装饰者)模式</li>
</ul>
<h2 id="C-Decorator-模式-详解"><a href="#C-Decorator-模式-详解" class="headerlink" title="C++ Decorator 模式 详解"></a>C++ Decorator 模式 详解</h2><p>Decorator（装饰者）模式是一种结构型设计模式，它允许向一个对象动态地添加功能，而无需通过子类继承的方式。这种模式是通过将对象包装在一个装饰器类的实例中来实现的，这样就可以动态地添加新的行为和责任。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>Decorator模式包含以下几个关键角色：</p>
<ol>
<li><p><strong>Component（组件）</strong>：是一个抽象类或接口，定义了被装饰的对象的接口。它可以是一个具体的类或接口，定义了一些基本的行为。</p>
</li>
<li><p><strong>ConcreteComponent（具体组件）</strong>：是实现Component接口的具体类，它是被装饰的对象。</p>
</li>
<li><p><strong>Decorator（装饰器）</strong>：也是一个抽象类或接口，它继承了Component，并持有一个Component对象的引用。这个类的主要作用是为了动态地添加额外的功能。</p>
</li>
<li><p><strong>ConcreteDecorator（具体装饰器）</strong>：是实现Decorator接口的具体类，它包含了要添加的额外功能。它可以包装具体组件对象并调用其原始的操作，然后再添加额外的功能。</p>
</li>
</ol>
<h3 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h3><p>下面是一个简单的Decorator模式的实现示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">serve</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteComponent</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleCoffee</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">serve</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Simple coffee&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeDecorator</span> : <span class="keyword">public</span> Coffee &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Coffee* coffee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CoffeeDecorator</span>(Coffee* coffee) : <span class="built_in">coffee</span>(coffee) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">serve</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        coffee-&gt;<span class="built_in">serve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcreteDecorator</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MilkDecorator</span> : <span class="keyword">public</span> CoffeeDecorator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MilkDecorator</span>(Coffee* coffee) : <span class="built_in">CoffeeDecorator</span>(coffee) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">serve</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        CoffeeDecorator::<span class="built_in">serve</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; + milk&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Coffee* coffee = <span class="keyword">new</span> <span class="built_in">SimpleCoffee</span>();</span><br><span class="line">    coffee-&gt;<span class="built_in">serve</span>();  <span class="comment">// Output: Simple coffee</span></span><br><span class="line"></span><br><span class="line">    Coffee* coffeeWithMilk = <span class="keyword">new</span> <span class="built_in">MilkDecorator</span>(coffee);</span><br><span class="line">    coffeeWithMilk-&gt;<span class="built_in">serve</span>();  <span class="comment">// Output: Simple coffee + milk</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> coffee;</span><br><span class="line">    <span class="keyword">delete</span> coffeeWithMilk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>Coffee</code>是组件，<code>SimpleCoffee</code>是具体组件。<code>CoffeeDecorator</code>是装饰器，<code>MilkDecorator</code>是具体装饰器。</p>
<p>使用装饰器模式，我们可以在运行时动态地向<code>SimpleCoffee</code>对象添加额外的功能，而无需修改其原始类的代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_11_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2024-05-22-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_11_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2024-05-22-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/" class="post-title-link" itemprop="url">抽象工厂</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>抽象工厂模式</li>
</ul>
<h2 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h2><ul>
<li>抽象工厂模式(Abstract factory pattern)是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。抽象工厂模式将一组对象的实现细节与它们的一般使用分离开来。</li>
<li>一个工厂中创建的每个对象都是同一个主题(fancy | modern)</li>
<li>工厂，是创建产品(对象)的地方，其目的是将产品的创建与产品的使用分离。抽象工厂模式的目的，是将若干抽象产品的接口与不同主题产品的具体实现分离开。这样就能够在增加新的具体工厂的时候，不用修改抽象工厂的客户端代码。</li>
<li>使用抽象工厂模式，能够在具体工厂变化的时候，不用修改使用工厂的客户端代码，甚至是在运行时。然而，使用这种模式或者相似的设计模式，可能给编写代码带来不必要的复杂性和额外的工作。正确使用设计模式能够低效这样的额外工作。</li>
</ul>
<h2 id="抽象工厂模式的定义"><a href="#抽象工厂模式的定义" class="headerlink" title="抽象工厂模式的定义"></a>抽象工厂模式的定义</h2><ul>
<li>抽象工厂模式的实质是提供接口，创建一系列相关或者独立的对象，而不指定这些对象的具体类。</li>
</ul>
<h2 id="抽象工厂模式的使用"><a href="#抽象工厂模式的使用" class="headerlink" title="抽象工厂模式的使用"></a>抽象工厂模式的使用</h2><ul>
<li>具体的工厂决定了创建对象的具体类型，而且工厂就是对象实际创建的地方(例如在C++中，用new操作符创建对象)。然而，抽象工厂只返回一个指向创建的对象的抽象引用(或指针)</li>
<li>这样，客户端程序调用抽象工厂引用的方法，由具体工厂完成对象创建，然后客户端程序得到的是抽象产品的引用。如此使客户端代码与对象的创建分离开来</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_08_%E5%B8%B8%E7%94%A8%E7%B1%BB/2024-05-22-C++_08_%E5%B8%B8%E7%94%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_08_%E5%B8%B8%E7%94%A8%E7%B1%BB/2024-05-22-C++_08_%E5%B8%B8%E7%94%A8%E7%B1%BB/" class="post-title-link" itemprop="url">C++_08_常用类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++中常用到的类</li>
</ul>
<h3 id="std-enable-shared-from-this"><a href="#std-enable-shared-from-this" class="headerlink" title="std::enable_shared_from_this"></a>std::enable_shared_from_this</h3><p>在 C++ 中，<code>std::enable_shared_from_this</code> 是一个模板类，位于 <code>&lt;memory&gt;</code> 头文件中，它用于在共享所有权的智能指针（<code>std::shared_ptr</code>）对象中获取指向该对象的 <code>std::shared_ptr</code>。</p>
<p>当一个类继承自 <code>std::enable_shared_from_this</code> 并且其对象被一个 <code>std::shared_ptr</code> 管理时，可以使用 <code>shared_from_this()</code> 成员函数来获取一个指向当前对象的 <code>std::shared_ptr</code>。</p>
<p>以下是 <code>std::enable_shared_from_this</code> 的一些重要特点和使用方法：</p>
<ol>
<li><p><strong>必须使用 <code>std::shared_ptr</code> 管理对象</strong>：<code>std::enable_shared_from_this</code> 只能与 <code>std::shared_ptr</code> 一起使用。使用其他类型的智能指针或裸指针将导致未定义行为。</p>
</li>
<li><p>**继承 <code>std::enable_shared_from_this</code>**：要使用 <code>std::enable_shared_from_this</code>，你的类必须继承自它，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;MyClass&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取 <code>std::shared_ptr</code> 的方法</strong>：通过调用 <code>shared_from_this()</code> 成员函数，可以获取指向当前对象的 <code>std::shared_ptr</code>，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;MyClass&gt; ptr = obj.<span class="built_in">shared_from_this</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li><code>shared_from_this()</code> 只能在由 <code>std::shared_ptr</code> 管理的对象中调用。在构造函数期间或通过裸指针调用会导致未定义行为。</li>
<li>必须先创建 <code>std::shared_ptr</code> 对象，然后才能调用 <code>shared_from_this()</code>。否则，将返回一个空的 <code>std::shared_ptr</code>。</li>
</ul>
</li>
</ol>
<p>使用 <code>std::enable_shared_from_this</code> 可以方便地获取指向当前对象的 <code>std::shared_ptr</code>，以便与其他共享该对象所有权的智能指针一起使用。这在实现资源共享和对象生命周期管理时非常有用，特别是在涉及对象自引用的情况下。</p>
<h2 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h2><p><code>std::thread</code>是C++标准库提供的用于创建和管理线程的类。它位于<code>&lt;thread&gt;</code>头文件中，并定义在<code>std</code>命名空间中。</p>
<p><code>std::thread</code>类提供了以下主要功能和成员函数：</p>
<ol>
<li><p>构造函数：</p>
<ul>
<li><code>explicit thread() noexcept;</code></li>
<li><code>template &lt;class Function, class... Args&gt; explicit thread(Function&amp;&amp; f, Args&amp;&amp;... args);</code></li>
<li><code>thread(const thread&amp;) = delete;</code>（复制构造函数被禁用）</li>
<li><code>thread(thread&amp;&amp; other) noexcept;</code>（移动构造函数）</li>
</ul>
</li>
<li><p>成员函数：</p>
<ul>
<li><code>operator=</code>: 赋值运算符，用于将一个线程对象赋值给另一个线程对象。</li>
<li><code>join()</code>: 阻塞调用线程，直到该线程执行完成。</li>
<li><code>detach()</code>: 将线程分离，使其在后台运行，不再与调用线程同步。</li>
<li><code>swap()</code>: 交换两个线程对象的内容。</li>
<li><code>get_id()</code>: 返回线程的唯一标识符。</li>
<li><code>joinable()</code>: 检查线程是否可加入或分离。</li>
<li><code>native_handle()</code>: 返回底层操作系统的线程句柄。</li>
<li><code>hardware_concurrency()</code>: 返回支持并发执行的线程数量。</li>
</ul>
</li>
<li><p>静态成员函数：</p>
<ul>
<li><code>std::thread::id</code>: 表示线程的唯一标识符的类型。</li>
<li><code>std::thread::native_handle_type</code>: 表示底层操作系统线程句柄的类型。</li>
<li><code>std::thread::hardware_concurrency()</code>: 返回支持并发执行的线程数量。</li>
</ul>
</li>
</ol>
<p>使用<code>std::thread</code>类创建线程的一般步骤如下：</p>
<ol>
<li>定义一个可调用的函数或函数对象，作为线程的执行逻辑。</li>
<li>创建<code>std::thread</code>对象，并将可调用的函数或函数对象作为参数传递给构造函数。</li>
<li>通过调用<code>join()</code>等待线程执行完成，或使用<code>detach()</code>分离线程并允许其在后台运行。</li>
</ol>
<p>以下是一个简单的示例，演示如何使用<code>std::thread</code>类创建和管理线程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可调用的函数作为线程执行逻辑</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; started.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 执行一些任务</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程对象，并指定可调用的函数及其参数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadFunction, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(threadFunction, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完成</span></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，使用<code>std::thread</code>类创建线程时，需要确保线程的执行完成或分离，否则会导致程序异常退出或资源泄漏。</p>
<p>这是对<code>std::thread</code>类的简要解释，您可以查阅C++标准库的文档以获取更详细的信息和用法示例。</p>
<hr>
<h2 id="std-fstream"><a href="#std-fstream" class="headerlink" title="std::fstream"></a>std::fstream</h2><p><code>std::fstream</code> 是 C++ 标准库中用于文件输入输出的类，它是 <code>std::ifstream</code>（文件输入流）和 <code>std::ofstream</code>（文件输出流）的基类，并结合了它们的功能，使得在同一个对象中可以实现文件的读取和写入。</p>
<p>要使用 <code>std::fstream</code> 类，需要包含 <code>&lt;fstream&gt;</code> 头文件。</p>
<p>下面是 <code>std::fstream</code> 类的详细解释：</p>
<h2 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h2><ul>
<li><code>explicit fstream(const char* filename, ios_base::openmode mode = ios_base::in | ios_base::out);</code></li>
<li><code>explicit fstream(const std::string&amp; filename, ios_base::openmode mode = ios_base::in | ios_base::out);</code></li>
</ul>
<p>构造函数用于创建 <code>std::fstream</code> 对象并打开文件。参数 <code>filename</code> 是要打开的文件名，参数 <code>mode</code> 是打开文件的模式，可以使用 <code>ios_base::in</code> 表示读取模式，<code>ios_base::out</code> 表示写入模式，<code>ios_base::app</code> 表示追加写入模式等等。</p>
<h2 id="成员函数："><a href="#成员函数：" class="headerlink" title="成员函数："></a>成员函数：</h2><ul>
<li><code>void open(const char* filename, ios_base::openmode mode = ios_base::in | ios_base::out);</code></li>
<li><code>void open(const std::string&amp; filename, ios_base::openmode mode = ios_base::in | ios_base::out);</code></li>
</ul>
<p><code>open</code> 函数用于打开一个新的文件，并可以指定打开模式。</p>
<ul>
<li><code>void close();</code></li>
</ul>
<p><code>close</code> 函数用于关闭文件。</p>
<ul>
<li><code>bool is_open() const;</code></li>
</ul>
<p><code>is_open</code> 函数用于检查文件是否成功打开，返回 true 表示文件已经成功打开，false 表示文件未打开或者打开失败。</p>
<ul>
<li><code>void clear();</code></li>
</ul>
<p><code>clear</code> 函数用于清除错误状态和结束-of-file标志。</p>
<ul>
<li><code>void seekg(std::streampos pos);</code></li>
<li><code>void seekg(std::streamoff off, std::ios_base::seekdir way);</code></li>
</ul>
<p><code>seekg</code> 函数用于设置输入位置指针的位置。第一种重载接受一个绝对位置 <code>pos</code>，第二种重载接受一个相对位置 <code>off</code> 和一个方向 <code>way</code>，方向可以是 <code>std::ios_base::beg</code>（从开头计算位置），<code>std::ios_base::cur</code>（从当前位置计算位置），或者 <code>std::ios_base::end</code>（从文件末尾计算位置）。</p>
<ul>
<li><code>std::streampos tellg();</code></li>
</ul>
<p><code>tellg</code> 函数用于获取当前输入位置指针的位置。</p>
<ul>
<li><code>void seekp(std::streampos pos);</code></li>
<li><code>void seekp(std::streamoff off, std::ios_base::seekdir way);</code></li>
</ul>
<p><code>seekp</code> 函数用于设置输出位置指针的位置，用法与 <code>seekg</code> 类似。</p>
<ul>
<li><code>std::streampos tellp();</code></li>
</ul>
<p><code>tellp</code> 函数用于获取当前输出位置指针的位置。</p>
<ul>
<li><code>std::fstream&amp; operator&lt;&lt;(T val);</code></li>
<li><code>std::fstream&amp; operator&gt;&gt;(T&amp; val);</code></li>
</ul>
<p>这些重载的运算符用于将数据写入文件（<code>operator&lt;&lt;</code>）或从文件读取数据（<code>operator&gt;&gt;</code>）。T 是要写入或读取的数据类型。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::fstream <span class="title">file</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>, std::ios::out | std::ios::in)</span></span>; <span class="comment">// 打开文件用于读写</span></span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        file &lt;&lt; <span class="string">&quot;Hello, World!\n&quot;</span>; <span class="comment">// 写入数据到文件</span></span><br><span class="line">        file.<span class="built_in">seekg</span>(<span class="number">0</span>); <span class="comment">// 定位输入位置指针到文件开头</span></span><br><span class="line">        std::string line;</span><br><span class="line">        std::<span class="built_in">getline</span>(file, line); <span class="comment">// 从文件读取一行数据</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data read from file: &quot;</span> &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">        file.<span class="built_in">close</span>(); <span class="comment">// 关闭文件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to open file!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::fstream</code> 类提供了一个灵活而强大的接口来处理文件的读写操作。通过合理使用其成员函数和运算符重载，可以方便地在 C++ 程序中进行文件输入输出的操作。</p>
<hr>
<h2 id="std-ifstream"><a href="#std-ifstream" class="headerlink" title="std::ifstream"></a>std::ifstream</h2><p><code>std::ifstream</code> 是 C++ 标准库中用于文件输入的类，用于从文件中读取数据。它是基于流的输入操作符 <code>&gt;&gt;</code> 实现的，可以通过打开文件并使用 <code>&gt;&gt;</code> 运算符将文件中的数据读取到不同类型的变量中。</p>
<p>以下是 <code>std::ifstream</code> 类的一些常用方法和功能：</p>
<ol>
<li><p>打开文件：可以使用 <code>open()</code> 方法打开文件，指定要读取的文件路径和打开模式。打开模式可以是 <code>std::ios::in</code>（默认）或其他可选模式，如 <code>std::ios::binary</code>、<code>std::ios::ate</code> 等。</p>
</li>
<li><p>关闭文件：使用 <code>close()</code> 方法关闭打开的文件。在读取完文件内容后，应该显式地关闭文件。</p>
</li>
<li><p>读取数据：使用 <code>&gt;&gt;</code> 运算符可以将文件中的数据读取到不同类型的变量中。例如，可以使用 <code>&gt;&gt;</code> 运算符读取整数、浮点数、字符串等数据。</p>
</li>
<li><p>检查文件状态：可以使用 <code>good()</code>、<code>eof()</code>、<code>fail()</code>、<code>bad()</code> 等方法检查文件的状态。例如，<code>good()</code> 方法用于检查文件是否处于可读取状态，<code>eof()</code> 方法用于检查是否已到达文件末尾，<code>fail()</code> 方法用于检查读取操作是否失败。</p>
</li>
<li><p>定位文件指针：可以使用 <code>seekg()</code> 方法定位文件指针到指定位置，从而实现随机读取文件内容。</p>
</li>
<li><p>获取文件大小：可以结合文件指针定位和 <code>tellg()</code> 方法获取文件的大小。</p>
</li>
<li><p>检查文件是否打开：使用 <code>is_open()</code> 方法可以检查文件是否成功打开。</p>
</li>
<li><p>逐行读取文件：可以使用 <code>getline()</code> 方法逐行读取文件内容。</p>
</li>
</ol>
<p>使用 <code>std::ifstream</code> 类可以方便地打开、读取和处理文件内容。在使用完毕后，应该关闭文件以释放资源。</p>
<hr>
<h2 id="std-ofstream"><a href="#std-ofstream" class="headerlink" title="std::ofstream"></a>std::ofstream</h2><p><code>std::ofstream</code> 是 C++ 标准库中用于文件输出的类，用于将数据写入文件中。它是基于流的输出操作符 <code>&lt;&lt;</code> 实现的，可以通过打开文件并使用 <code>&lt;&lt;</code> 运算符将数据写入文件。</p>
<p>以下是 <code>std::ofstream</code> 类的一些常用方法和功能：</p>
<ol>
<li><p>打开文件：可以使用 <code>open()</code> 方法打开文件，指定要写入的文件路径和打开模式。打开模式可以是 <code>std::ios::out</code>（默认）或其他可选模式，如 <code>std::ios::binary</code>、<code>std::ios::app</code> 等。</p>
</li>
<li><p>关闭文件：使用 <code>close()</code> 方法关闭打开的文件。在写入完文件内容后，应该显式地关闭文件。</p>
</li>
<li><p>写入数据：使用 <code>&lt;&lt;</code> 运算符可以将数据写入文件。例如，可以使用 <code>&lt;&lt;</code> 运算符将整数、浮点数、字符串等数据写入文件。</p>
</li>
<li><p>检查文件状态：可以使用 <code>good()</code>、<code>fail()</code>、<code>bad()</code> 方法检查文件的状态。例如，<code>good()</code> 方法用于检查文件是否处于可写入状态，<code>fail()</code> 方法用于检查写入操作是否失败。</p>
</li>
<li><p>定位文件指针：可以使用 <code>seekp()</code> 方法定位文件指针到指定位置，从而实现随机写入文件内容。</p>
</li>
<li><p>检查文件是否打开：使用 <code>is_open()</code> 方法可以检查文件是否成功打开。</p>
</li>
</ol>
<hr>
<p>使用 <code>std::ofstream</code> 类可以方便地打开文件并将数据写入文件。在使用完毕后，应该关闭文件以释放资源。</p>
<ul>
<li><p><code>std::ofstream</code>是C++标准库提供的一个输出文件流类，用于将数据写入到文件中。它是<code>std::ostream</code>的派生类，继承了<code>std::ostream</code>中的输出操作符<code>&lt;&lt;</code>，可以方便地向文件写入各种类型的数据。</p>
</li>
<li><p>使用<code>std::ofstream</code>需要包含头文件<code>&lt;fstream&gt;</code>，并通过构造函数创建一个输出文件流对象，可以指定要打开的文件名和打开模式。常用的打开模式包括：</p>
<ul>
<li><code>std::ios::out</code>：以写入模式打开文件。</li>
<li><code>std::ios::app</code>：在文件末尾追加内容。</li>
<li><code>std::ios::trunc</code>：如果文件存在，删除文件内容并重新创建。</li>
<li><code>std::ios::binary</code>：以二进制模式打开文件。</li>
</ul>
</li>
<li><p>下面是一个示例代码，演示如何使用<code>std::ofstream</code>写入数据到文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string filename = <span class="string">&quot;example.txt&quot;</span>; <span class="comment">// 文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建输出文件流对象并打开文件</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">outputFile</span><span class="params">(filename, std::ios::out)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outputFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="comment">// 向文件写入数据</span></span><br><span class="line">        outputFile &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        outputFile &lt;&lt; <span class="number">42</span> &lt;&lt; std::endl;</span><br><span class="line">        outputFile &lt;&lt; <span class="number">3.14159</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件</span></span><br><span class="line">        outputFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;数据已写入文件&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无法打开文件&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在上述代码中，首先创建一个<code>std::ofstream</code>对象并指定要打开的文件名和打开模式。然后，使用<code>&lt;&lt;</code>操作符向文件中写入数据。最后，使用<code>close</code>方法关闭文件。如果文件无法打开，则输出相应的错误信息。</p>
</li>
<li><p>需要注意的是，<code>std::ofstream</code>对象在销毁时会自动关闭文件，但最好显式调用<code>close</code>方法以确保及时关闭文件。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/test/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/BOOST/test/2024-05-22-1_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">1_1_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>BOOST库中单元测试模块</li>
</ul>
<h2 id="boost-单元测试"><a href="#boost-单元测试" class="headerlink" title="boost 单元测试"></a>boost 单元测试</h2><p>Boost 是一个功能强大的 C++ 库集合，其中包括了许多模块，其中 Boost.Test 是用于单元测试的一个模块。下面是使用 Boost.Test 进行单元测试的一般步骤：</p>
<ol>
<li><p><strong>包含 Boost.Test 头文件</strong>：<br>在你的测试文件中包含 Boost.Test 的头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/test/unit_test.hpp&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编写测试用例</strong>：<br>使用 BOOST_AUTO_TEST_SUITE 和 BOOST_AUTO_TEST_CASE 宏来定义测试套件和测试用例。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOST_AUTO_TEST_SUITE</span>(MyTestSuite)</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOST_AUTO_TEST_CASE</span>(TestCase1)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 测试代码</span></span><br><span class="line">    <span class="built_in">BOOST_CHECK_EQUAL</span>(<span class="number">1</span> + <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOST_AUTO_TEST_SUITE_END</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行测试</strong>：<br>你可以使用 Boost.Test 提供的主函数来运行测试，也可以将测试代码添加到你的项目中并通过你的构建系统运行。如果你使用 CMake，则可以使用 add_executable 来添加测试代码，并且使用 target_link_libraries 来链接 Boost.Test 库。</p>
</li>
<li><p><strong>编写更多的测试用例</strong>：<br>编写多个测试用例来覆盖你的代码的不同情况和边界条件。</p>
</li>
<li><p><strong>检查测试结果</strong>：<br>运行测试并检查测试结果。Boost.Test 会输出详细的测试结果，包括测试通过的用例数、失败的用例数、用时等信息。</p>
</li>
<li><p><strong>高级特性</strong>：<br>Boost.Test 还支持许多高级特性，如测试夹具、参数化测试、自定义测试输出格式等。你可以根据需要使用这些特性来进一步增强你的测试。</p>
</li>
</ol>
<p>总的来说，使用 Boost.Test 进行单元测试与其他单元测试框架类似，但它提供了更多的灵活性和功能，可以满足各种复杂的测试需求。</p>
<h2 id="Boost-Test库-详解"><a href="#Boost-Test库-详解" class="headerlink" title="Boost.Test库 详解"></a>Boost.Test库 详解</h2><p>Boost.Test 是 Boost 库集合中的一个模块，用于 C++ 程序的单元测试。它提供了丰富的功能和工具来编写、组织和运行测试用例，以确保代码的质量和可靠性。</p>
<p>以下是 Boost.Test 的一些主要特性和功能：</p>
<ol>
<li><p><strong>自动化测试</strong>：Boost.Test 提供了一套自动化测试框架，使得可以编写测试用例来验证程序的不同部分的行为是否符合预期。</p>
</li>
<li><p><strong>测试用例和测试套件</strong>：可以使用 BOOST_AUTO_TEST_CASE 和 BOOST_AUTO_TEST_SUITE 宏来定义测试用例和测试套件，以便组织和管理你的测试代码。</p>
</li>
<li><p><strong>丰富的断言</strong>：Boost.Test 提供了丰富的断言宏，用于检查测试结果是否符合预期，如 BOOST_CHECK、BOOST_REQUIRE、BOOST_CHECK_EQUAL、BOOST_CHECK_CLOSE 等。</p>
</li>
<li><p><strong>参数化测试</strong>：支持参数化测试，可以使用 BOOST_DATA_TEST_CASE 宏来定义参数化测试用例，以便在同一个测试用例中使用不同的参数运行多次测试。</p>
</li>
<li><p><strong>测试夹具</strong>：支持测试夹具，可以使用 BOOST_FIXTURE_TEST_CASE 宏定义测试夹具，以在多个测试用例之间共享测试环境的设置和清理代码。</p>
</li>
<li><p><strong>丰富的输出信息</strong>：Boost.Test 输出详细的测试结果信息，包括测试通过的用例数、失败的用例数、用时等，以便于分析和调试测试结果。</p>
</li>
<li><p><strong>异常处理</strong>：可以使用 BOOST_CHECK_THROW 和 BOOST_CHECK_NO_THROW 等宏来测试代码是否产生了预期的异常。</p>
</li>
<li><p><strong>超时测试</strong>：支持超时测试，可以使用 BOOST_TEST_TIMEOUT 宏来指定测试用例的最大执行时间，以确保测试不会无限等待。</p>
</li>
<li><p><strong>测试装置</strong>：提供了测试装置（test tools）来支持高级测试需求，如模拟对象、mocking、性能测试等。</p>
</li>
<li><p><strong>适用性</strong>：Boost.Test 可以用于任何 C++ 项目，无论是使用 Boost 库还是其他库。</p>
</li>
</ol>
<p>总的来说，Boost.Test 是一个功能丰富、灵活易用的 C++ 单元测试框架，适用于各种规模和类型的项目，能够帮助开发者编写高质量、可靠性强的测试代码。</p>
<h2 id="Boost-Test库-cmake配置"><a href="#Boost-Test库-cmake配置" class="headerlink" title="Boost.Test库 cmake配置"></a>Boost.Test库 cmake配置</h2><p>要在 CMake 中配置 Boost.Test 库，你需要遵循以下步骤：</p>
<ol>
<li><p><strong>安装 Boost 库</strong>：首先确保你已经正确地安装了 Boost 库。你可以从 Boost 官方网站下载并安装 Boost 库，或者使用系统包管理器（如 apt、brew、yum 等）来安装 Boost 库。</p>
</li>
<li><p><strong>设置 CMakeLists.txt 文件</strong>：在你的项目根目录下创建一个 <code>CMakeLists.txt</code> 文件，并添加如下内容：</p>
</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(your_project_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找 Boost 库</span></span><br><span class="line"><span class="keyword">find_package</span>(Boost REQUIRED COMPONENTS unit_test_framework)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加你的项目源文件和头文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(your_executable_name your_source_files.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接 Boost.Test 库和你的项目</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(your_executable_name PRIVATE <span class="variable">$&#123;Boost_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(your_executable_name PRIVATE <span class="variable">$&#123;Boost_UNIT_TEST_FRAMEWORK_LIBRARY&#125;</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>配置 CMake 变量</strong>：在配置 CMake 时，你可以指定 Boost 库的安装路径，以便 CMake 能够找到 Boost 库。你可以通过以下方式指定 Boost 库的安装路径：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DBOOST_ROOT=/path/to/boost ..</span><br></pre></td></tr></table></figure>

<p>其中 <code>/path/to/boost</code> 是 Boost 库的安装路径。</p>
<ol start="4">
<li><strong>构建项目</strong>：在你的项目目录下创建一个 build 目录，然后在该目录下运行 CMake 命令进行项目构建：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>编写和运行测试</strong>：编写你的测试代码，并在 <code>your_source_files.cpp</code> 中包含 Boost.Test 的头文件。然后编写测试用例，并运行你的可执行文件进行测试。</li>
</ol>
<p>通过以上步骤，你就可以在你的 CMake 项目中成功配置和使用 Boost.Test 了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/CMake/cmake_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-cmake_1_01_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/CMake/cmake_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/2024-05-22-cmake_1_01_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">cmake_1_01_理论基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CMake/" itemprop="url" rel="index"><span itemprop="name">CMake</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>cmake 理论基础</li>
</ul>
<h2 id="cmake-timing-tools-是什么"><a href="#cmake-timing-tools-是什么" class="headerlink" title="cmake timing tools 是什么"></a>cmake timing tools 是什么</h2><p>CMake Timing Tools 是一组 CMake 工具和选项，用于分析 CMake 配置和构建过程中的时间消耗。这些工具帮助开发者定位构建过程中的瓶颈，进而优化构建时间。主要功能包括记录和显示 CMake 配置过程、构建过程以及不同构建步骤所花费的时间。</p>
<h3 id="CMake-Timing-Tools-主要包含以下几个部分："><a href="#CMake-Timing-Tools-主要包含以下几个部分：" class="headerlink" title="CMake Timing Tools 主要包含以下几个部分："></a>CMake Timing Tools 主要包含以下几个部分：</h3><hr>
<h3 id="1-CMake-Trace-选项"><a href="#1-CMake-Trace-选项" class="headerlink" title="1. CMake Trace 选项"></a>1. <strong>CMake Trace 选项</strong></h3><ul>
<li><p><strong><code>CMake --trace</code></strong><br><code>--trace</code> 选项用于在 CMake 配置过程中输出详细的日志信息，记录每个 CMake 脚本文件的执行情况。通过分析这些信息，可以了解每一步的执行顺序和所花费的时间。</p>
<ul>
<li>使用方式:  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --trace &lt;path-to-your-project&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>CMake --trace-expand</code></strong><br><code>--trace-expand</code> 选项是 <code>--trace</code> 的增强版本，除了输出每个 CMake 脚本的执行过程，还会展开每个变量的值。通过这个选项，你可以更详细地看到变量的变化，帮助分析哪些部分的 CMake 脚本影响了构建时间。</p>
<ul>
<li>使用方式:  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --trace-expand &lt;path-to-your-project&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-CMake-的-build-和-log-level"><a href="#2-CMake-的-build-和-log-level" class="headerlink" title="2. CMake 的 --build 和 --log-level"></a>2. <strong>CMake 的 <code>--build</code> 和 <code>--log-level</code></strong></h3><ul>
<li><p><strong><code>CMake --build</code></strong><br>这个选项允许你使用 CMake 来触发构建。虽然它本身不提供时间分析功能，但它可以与其他工具（如 Ninja）一起使用，配合时间监控。</p>
<ul>
<li>使用方式:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build &lt;path-to-your-project&gt; --verbose</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>CMake --log-level</code></strong><br>这个选项可以让你设置 CMake 输出的日志级别，控制日志的详细程度。通过不同的日志级别，开发者可以更容易定位构建过程中时间消耗较大的部分。</p>
<ul>
<li>使用方式:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --log-level=TRACE</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-使用-Ninja-和-CMake"><a href="#3-使用-Ninja-和-CMake" class="headerlink" title="3. 使用 Ninja 和 CMake"></a>3. <strong>使用 <code>Ninja</code> 和 <code>CMake</code></strong></h3><ul>
<li><p><strong>Ninja 构建系统</strong><br><code>Ninja</code> 是一个高效的构建系统，它与 CMake 配合使用时，能够输出每个构建步骤的详细时间。你可以结合 <code>Ninja</code> 和 CMake 来查看每个构建任务的执行时间，找出耗时长的任务。</p>
<ul>
<li><p>使用方式:</p>
<ol>
<li>首先生成 Ninja 构建文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -G Ninja &lt;path-to-your-project&gt;</span><br></pre></td></tr></table></figure></li>
<li>然后进行构建，查看每个构建步骤的时间：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja -v</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过查看 Ninja 输出的构建日志，你可以找到哪些步骤导致了编译时间的增加。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-CMake-和构建时间统计"><a href="#4-CMake-和构建时间统计" class="headerlink" title="4. CMake 和构建时间统计"></a>4. <strong>CMake 和构建时间统计</strong></h3><ul>
<li><p><strong><code>CMake --build &lt;path-to-your-project&gt; --target &lt;target-name&gt; -- -j</code></strong><br>如果使用的是支持并行构建的构建工具（如 Ninja），可以通过 <code>-j</code> 参数指定并行的线程数。通过查看每个线程的执行时间，你可以判断哪些任务是时间上的瓶颈。</p>
</li>
<li><p><strong>CMake 的 <code>CMAKE_VERBOSE_MAKEFILE</code></strong><br>通过设置 <code>CMAKE_VERBOSE_MAKEFILE</code> 变量为 <code>ON</code>，你可以查看每个 Makefile 生成的详细信息，并监控其执行时间。</p>
</li>
</ul>
<hr>
<h3 id="5-CMake-其他有用的分析工具"><a href="#5-CMake-其他有用的分析工具" class="headerlink" title="5. CMake 其他有用的分析工具"></a>5. <strong>CMake 其他有用的分析工具</strong></h3><ul>
<li>**<code>CMake Analyze</code>**（实验性功能）<br>这是一个实验性的 CMake 功能，旨在提供更高级的构建性能分析。它允许开发者分析项目中的每个目标和构建步骤的时间消耗。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CMake Timing Tools 提供的 <code>--trace</code> 和 <code>--trace-expand</code> 等选项，可以帮助开发者分析 CMake 配置过程中的耗时问题。配合 Ninja 等构建工具使用，还能进一步分析和优化构建过程中的每一步，帮助提升整个构建过程的效率。</p>
<h2 id="cmake-find-package-找到库文件之后-头文件目录和库文件目录存放的变量是什么"><a href="#cmake-find-package-找到库文件之后-头文件目录和库文件目录存放的变量是什么" class="headerlink" title="cmake find_package 找到库文件之后 头文件目录和库文件目录存放的变量是什么"></a>cmake find_package 找到库文件之后 头文件目录和库文件目录存放的变量是什么</h2><p>当使用 <code>find_package</code> 找到库文件之后，CMake 会设置一系列的变量来提供有关找到的库的信息，包括头文件目录和库文件目录。这些变量的具体名称取决于库的名称，因为 <code>find_package</code> 是由各个库的 CMake 模块来实现的。</p>
<p>对于大多数库，通常有以下两个变量：</p>
<ol>
<li><p><strong>变量名：<code>&lt;PackageName&gt;_INCLUDE_DIRS</code></strong></p>
<ul>
<li>描述：包含了找到的库的头文件目录。</li>
<li>示例：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PackageName_INCLUDE_DIRS&#125;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>变量名：<code>&lt;PackageName&gt;_LIBRARIES</code></strong></p>
<ul>
<li>描述：包含了找到的库的链接库的名称。</li>
<li>示例：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(MyExecutable PRIVATE <span class="variable">$&#123;PackageName_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>在这里，<code>&lt;PackageName&gt;</code> 是通过 <code>find_package</code> 指定的库的名称。例如，如果你使用 <code>find_package(gflags REQUIRED)</code>，那么变量名称就是 <code>GFLAGS_INCLUDE_DIRS</code> 和 <code>GFLAGS_LIBRARIES</code>。</p>
<p>另外，一些库还可能设置其他相关的变量，具体取决于库的 CMake 模块是如何实现的。查看相应库的文档或 CMake 模块的源代码以获取详细信息是一个好的实践。</p>
<h2 id="请问你能简单描述一下CMake是什么，以及它通常用来做什么吗？"><a href="#请问你能简单描述一下CMake是什么，以及它通常用来做什么吗？" class="headerlink" title="请问你能简单描述一下CMake是什么，以及它通常用来做什么吗？"></a>请问你能简单描述一下CMake是什么，以及它通常用来做什么吗？</h2><ul>
<li>CMake是一个跨平台的自动化构建系统，主要用来管理软件构建的过程，它使用一个名为CMakeLists.txt的配置文件来指导编译和链接的过程。CMake支持多种编译器和开发环境，可以生成标准的构建文件，如Makefile或者Visual Studio的项目文件。它不仅能够管理C&#x2F;C++项目的构建，还支持多种编程语言和库的集成。</li>
</ul>
<h2 id="CMakeLists-txt文件的基本结构是什么？"><a href="#CMakeLists-txt文件的基本结构是什么？" class="headerlink" title="CMakeLists.txt文件的基本结构是什么？"></a>CMakeLists.txt文件的基本结构是什么？</h2><ul>
<li>cmake_minimum_required(VERSION x.x): 指定项目需要的最低CMake版本。</li>
<li>project(ProjectName): 定义项目的名称和使用的语言。</li>
<li>add_executable(TargetName source1 source2 …): 添加一个可执行目标，并指定其源文件。</li>
<li>add_library(TargetName type source1 source2 …): 添加一个库目标，并指定其类型（静态或动态）和源文件。</li>
<li>find_package(PackageName): 查找并加载外部依赖包。</li>
<li>target_link_libraries(TargetName library1 library2 …): 指定目标链接的库。</li>
<li>这些是最基础和最常用的指令，当然还有更多高级功能和指令可以使用。</li>
</ul>
<h2 id="在C-C-项目中经常会有很多依赖库，你通常是如何使用CMake来管理这些依赖的？"><a href="#在C-C-项目中经常会有很多依赖库，你通常是如何使用CMake来管理这些依赖的？" class="headerlink" title="在C&#x2F;C++项目中经常会有很多依赖库，你通常是如何使用CMake来管理这些依赖的？"></a>在C&#x2F;C++项目中经常会有很多依赖库，你通常是如何使用CMake来管理这些依赖的？</h2><ul>
<li>我通常会使用find_package命令来查找并加载外部依赖包。如果依赖的库是通过CMake构建的，那么它通常会提供CMake的配置文件，使得find_package可以直接找到并加载库。如果库没有提供CMake支持，我可能需要手动设置库的路径和链接库。一旦找到依赖库，我会使用target_link_libraries来链接库，并使用target_include_directories来添加头文件的搜索路径。</li>
</ul>
<h2 id="CMake的一个主要优势是能够生成跨平台的构建文件，你通常是如何确保你的CMake项目在不同平台上都能正确构建的？"><a href="#CMake的一个主要优势是能够生成跨平台的构建文件，你通常是如何确保你的CMake项目在不同平台上都能正确构建的？" class="headerlink" title="CMake的一个主要优势是能够生成跨平台的构建文件，你通常是如何确保你的CMake项目在不同平台上都能正确构建的？"></a>CMake的一个主要优势是能够生成跨平台的构建文件，你通常是如何确保你的CMake项目在不同平台上都能正确构建的？</h2><ul>
<li>为了确保构建的可移植性，我会避免使用平台特定的代码和构建设置。我会使用CMake提供的检查和配置功能来查询平台特性，并根据查询的结果来调整构建设置。例如，我可以使用check_function_exists来检查某个函数是否存在，然后根据结果定义宏来启用或禁用相关的代码。我还会确保使用CMake提供的命令来设置编译器标志和定义，而不是直接写死在CMakeLists.txt文件中</li>
</ul>
<h2 id="对于大型的C-C-项目，构建系统可能会变得非常复杂。你通常是如何组织和管理CMake构建系统的，以保持其可维护性？"><a href="#对于大型的C-C-项目，构建系统可能会变得非常复杂。你通常是如何组织和管理CMake构建系统的，以保持其可维护性？" class="headerlink" title="对于大型的C&#x2F;C++项目，构建系统可能会变得非常复杂。你通常是如何组织和管理CMake构建系统的，以保持其可维护性？"></a>对于大型的C&#x2F;C++项目，构建系统可能会变得非常复杂。你通常是如何组织和管理CMake构建系统的，以保持其可维护性？</h2><ul>
<li>对于大型项目，我会将构建系统分解为多个CMakeLists.txt文件，每个目录一个，以保持组织结构的清晰。我会利用add_subdirectory命令来包含子目录，这样每个子目录可以有其自己的CMakeLists.txt文件来管理其源文件和依赖关系。我还会使用CMake的函数和宏来封装重复的逻辑，以减少重复代码并提高可维护性。通过这种方式，我可以保持构建系统的清晰和可管理，即使项目规模很大。</li>
</ul>
<h2 id="在不同的开发阶段，我们可能需要使用不同的编译选项，比如在开发阶段开启调试信息，在发布阶段进行优化。请问你是如何使用CMake来管理这些编译选项的？"><a href="#在不同的开发阶段，我们可能需要使用不同的编译选项，比如在开发阶段开启调试信息，在发布阶段进行优化。请问你是如何使用CMake来管理这些编译选项的？" class="headerlink" title="在不同的开发阶段，我们可能需要使用不同的编译选项，比如在开发阶段开启调试信息，在发布阶段进行优化。请问你是如何使用CMake来管理这些编译选项的？"></a>在不同的开发阶段，我们可能需要使用不同的编译选项，比如在开发阶段开启调试信息，在发布阶段进行优化。请问你是如何使用CMake来管理这些编译选项的？</h2><ul>
<li>我通常会使用CMake的set命令来设置编译器标志，以及add_compile_options来添加编译选项。为了区分不同的构建类型（如Debug和Release），我会使用CMAKE_BUILD_TYPE变量，并根据这个变量的值来设置不同的编译选项。例如：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;-g&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_RELEASE <span class="string">&quot;-O3&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>这样，在Debug构建中，-g选项会被添加到编译命令中，而在Release构建中，-O3选项会被添加。</li>
</ul>
<h2 id="在项目中，我们经常需要使用第三方库。请问你是如何在CMake中集成第三方库的？"><a href="#在项目中，我们经常需要使用第三方库。请问你是如何在CMake中集成第三方库的？" class="headerlink" title="在项目中，我们经常需要使用第三方库。请问你是如何在CMake中集成第三方库的？"></a>在项目中，我们经常需要使用第三方库。请问你是如何在CMake中集成第三方库的？</h2><ul>
<li>为了集成第三方库，我通常会首先使用find_package命令来查找库是否已经安装在系统中。</li>
<li>如果库提供了CMake配置文件，那么find_package会自动设置所有必要的变量和目标。</li>
<li>如果库没有提供CMake支持，我可能需要手动设置库的路径和链接选项。一旦找到库，我会使用target_link_libraries来链接库，并使用target_include_directories来添加头文件的搜索路径。</li>
<li>如果第三方库没有预先安装，或者我需要使用特定版本的库，我可能会将库的源代码包含在我的项目中，并使用add_subdirectory或ExternalProject_Add来构建和链接库。</li>
</ul>
<h2 id="随着项目规模的增加，构建速度可能会成为一个问题。你通常是如何优化CMake项目的构建速度的？"><a href="#随着项目规模的增加，构建速度可能会成为一个问题。你通常是如何优化CMake项目的构建速度的？" class="headerlink" title="随着项目规模的增加，构建速度可能会成为一个问题。你通常是如何优化CMake项目的构建速度的？"></a>随着项目规模的增加，构建速度可能会成为一个问题。你通常是如何优化CMake项目的构建速度的？</h2><ul>
<li>为了优化构建速度，我会使用一系列的策略：<ul>
<li>分离代码: 将项目分解为多个库和可执行文件，这样只有发生变化的部分需要被重新构建。</li>
<li>预编译头文件: 对于C++项目，使用预编译头文件可以显著减少编译时间。</li>
<li>并行构建: 使用make -j或其他构建工具的并行构建选项来利用多核CPU。</li>
<li>ccache: 使用ccache来缓存编译结果，避免重复编译。</li>
<li>优化编译选项: 谨慎使用编译优化选项，避免使用过度的优化，因为它们可能会增加编译时间。</li>
</ul>
</li>
</ul>
<h2 id="CMake支持跨平台构建，但不同平台上可能有不同的依赖和编译选项。你通常是如何管理这些差异的？"><a href="#CMake支持跨平台构建，但不同平台上可能有不同的依赖和编译选项。你通常是如何管理这些差异的？" class="headerlink" title="CMake支持跨平台构建，但不同平台上可能有不同的依赖和编译选项。你通常是如何管理这些差异的？"></a>CMake支持跨平台构建，但不同平台上可能有不同的依赖和编译选项。你通常是如何管理这些差异的？</h2><ul>
<li>为了管理不同平台上的差异，我会使用CMake的平台检查功能和条件语句。例如，我可以使用if(WIN32)来检查是否在Windows平台上构建，然后根据需要设置不同的编译选项或链接选项。我还可以使用CMAKE_SYSTEM_NAME变量来获取更具体的平台信息，并根据这些信息进行条件判断和配置。</li>
</ul>
<h2 id="在现代软件开发中，测试是非常重要的一部分。请问你是如何使用CMake来构建和运行测试的？"><a href="#在现代软件开发中，测试是非常重要的一部分。请问你是如何使用CMake来构建和运行测试的？" class="headerlink" title="在现代软件开发中，测试是非常重要的一部分。请问你是如何使用CMake来构建和运行测试的？"></a>在现代软件开发中，测试是非常重要的一部分。请问你是如何使用CMake来构建和运行测试的？</h2><ul>
<li>为了确保项目的可测试性，我会使用CMake的enable_testing和add_test命令来添加和管理测试。我会为项目中的每个测试用例创建一个可执行文件，并使用add_test来注册测试。然后，我可以使用ctest命令来运行所有的测试，并获取测试结果。</li>
<li>除了基本的测试注册和运行外，我还可以使用set_tests_properties来设置测试属性，如超时时间、所需的环境变量等。如果我的项目使用了Google Test或者其他测试框架，我还可以集成这些框架的CMake模块，以更方便地添加和运行测试。</li>
</ul>
<h2 id="Modern-CMake推荐使用目标和属性来管理构建设置。请问你是如何在你的项目中使用这些特性的？"><a href="#Modern-CMake推荐使用目标和属性来管理构建设置。请问你是如何在你的项目中使用这些特性的？" class="headerlink" title="Modern CMake推荐使用目标和属性来管理构建设置。请问你是如何在你的项目中使用这些特性的？"></a>Modern CMake推荐使用目标和属性来管理构建设置。请问你是如何在你的项目中使用这些特性的？</h2><ul>
<li>在Modern CMake中，我会尽量使用目标和属性来代替全局变量和目录级的设置。这样可以使构建设置更加清晰和可维护。我会使用add_executable和add_library来创建目标，然后使用target_include_directories, target_compile_definitions, target_compile_options, 和 target_link_libraries来设置目标的包含目录、编译定义、编译选项和链接库。</li>
<li>我还会利用接口库来创建可复用的编译设置和编译定义，这样我就可以通过target_link_libraries来应用这些设置。</li>
</ul>
<h2 id="代码格式化是保持代码一致性和可读性的重要手段。请问你是如何在CMake项目中集成代码格式化工具，如ClangFormat，的？"><a href="#代码格式化是保持代码一致性和可读性的重要手段。请问你是如何在CMake项目中集成代码格式化工具，如ClangFormat，的？" class="headerlink" title="代码格式化是保持代码一致性和可读性的重要手段。请问你是如何在CMake项目中集成代码格式化工具，如ClangFormat，的？"></a>代码格式化是保持代码一致性和可读性的重要手段。请问你是如何在CMake项目中集成代码格式化工具，如ClangFormat，的？</h2><ul>
<li>我通常会使用find_program来查找ClangFormat可执行文件的路径，然后使用add_custom_target或add_custom_command来定义一个自定义目标或命令，用于运行ClangFormat来格式化源代码。例如：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_program</span>(CLANG_FORMAT <span class="string">&quot;clang-format&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(CLANG_FORMAT)</span><br><span class="line">    <span class="keyword">add_custom_target</span>(</span><br><span class="line">        format</span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">$&#123;CLANG_FORMAT&#125;</span></span><br><span class="line">        -i</span><br><span class="line">        <span class="variable">$&#123;SOURCE_FILES&#125;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></li>
<li>这样，我就可以通过运行make format或者cmake –build . –target format来格式化项目中的源代码</li>
</ul>
<h2 id="静态代码分析可以帮助我们发现代码中的潜在问题。请问你是如何在CMake项目中集成静态代码分析工具的？"><a href="#静态代码分析可以帮助我们发现代码中的潜在问题。请问你是如何在CMake项目中集成静态代码分析工具的？" class="headerlink" title="静态代码分析可以帮助我们发现代码中的潜在问题。请问你是如何在CMake项目中集成静态代码分析工具的？"></a>静态代码分析可以帮助我们发现代码中的潜在问题。请问你是如何在CMake项目中集成静态代码分析工具的？</h2><ul>
<li>我通常会使用类似于格式化工具的方法来集成静态代码分析工具。例如，对于Clang Static Analyzer，我可以使用scan-build命令来运行分析器。我会创建一个自定义目标或命令来运行scan-build，并将其配置为在构建过程中运行</li>
<li>对于其他静态代码分析工具，我可能还会设置相应的CMake变量来启用编译器的静态分析功能，或者使用工具提供的CMake模块（如果有的话）。</li>
</ul>
<h2 id="测试覆盖率是衡量测试完整性的一个重要指标。请问你是如何在CMake项目中集成测试覆盖率工具的？"><a href="#测试覆盖率是衡量测试完整性的一个重要指标。请问你是如何在CMake项目中集成测试覆盖率工具的？" class="headerlink" title="测试覆盖率是衡量测试完整性的一个重要指标。请问你是如何在CMake项目中集成测试覆盖率工具的？"></a>测试覆盖率是衡量测试完整性的一个重要指标。请问你是如何在CMake项目中集成测试覆盖率工具的？</h2><ul>
<li>为了集成测试覆盖率工具，我通常会在CMake中设置相应的编译器标志来启用覆盖率数据的生成。对于GCC和Clang，我可以使用–coverage选项。然后，我会创建一个自定义目标或命令来运行测试覆盖率工具，如gcov或llvm-cov，并生成覆盖率报告<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(COVERAGE)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; --coverage&quot;</span>)</span><br><span class="line">    <span class="keyword">add_custom_target</span>(coverage</span><br><span class="line">        <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E env <span class="string">&quot;COVERAGE_FILE=$&#123;PROJECT_BINARY_DIR&#125;/coverage.info&quot;</span></span><br><span class="line">        <span class="variable">$&#123;CMAKE_CTEST_COMMAND&#125;</span> --force-new-ctest-process</span><br><span class="line">        <span class="keyword">COMMAND</span> lcov --capture --directory . --output-<span class="keyword">file</span> coverage.info</span><br><span class="line">        <span class="keyword">COMMAND</span> genhtml coverage.info --output-directory out</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></li>
<li>这样，我就可以通过运行make coverage来运行测试并生成测试覆盖率报告</li>
</ul>
<h2 id="文档是任何项目不可或缺的一部分。请问你是如何在CMake项目中集成文档生成工具，如Doxygen，的？"><a href="#文档是任何项目不可或缺的一部分。请问你是如何在CMake项目中集成文档生成工具，如Doxygen，的？" class="headerlink" title="文档是任何项目不可或缺的一部分。请问你是如何在CMake项目中集成文档生成工具，如Doxygen，的？"></a>文档是任何项目不可或缺的一部分。请问你是如何在CMake项目中集成文档生成工具，如Doxygen，的？</h2><ul>
<li>我会使用find_package来查找Doxygen，并使用doxygen_add_docs来添加一个目标，用于生成文档。例如<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Doxygen)</span><br><span class="line"><span class="keyword">if</span>(DOXYGEN_FOUND)</span><br><span class="line">    doxygen_add_docs(</span><br><span class="line">        docs</span><br><span class="line">        <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span></span><br><span class="line">        <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src</span><br><span class="line">        COMMENT <span class="string">&quot;Generate documentation&quot;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></li>
<li>这样，我就可以通过运行make docs来生成项目的文档。</li>
</ul>
<h2 id="在使用CMake进行项目构建时，我们有时会遇到各种构建错误。请问你通常是如何调试这些构建错误的？"><a href="#在使用CMake进行项目构建时，我们有时会遇到各种构建错误。请问你通常是如何调试这些构建错误的？" class="headerlink" title="在使用CMake进行项目构建时，我们有时会遇到各种构建错误。请问你通常是如何调试这些构建错误的？"></a>在使用CMake进行项目构建时，我们有时会遇到各种构建错误。请问你通常是如何调试这些构建错误的？</h2><ul>
<li>当我遇到CMake构建错误时，我通常会遵循以下步骤进行调试：<ul>
<li>查看错误信息：仔细阅读CMake或编译器提供的错误信息和警告，这通常会指向问题的根源。</li>
<li>增加消息输出：使用message()函数在CMakeLists.txt文件中添加打印语句，以输出变量的值或显示代码执行的流程，帮助定位问题。</li>
<li>检查路径和变量：确保所有的路径、文件名和变量设置都是正确的，特别是在使用相对路径或者环境变量时。</li>
<li>分阶段构建：逐步执行CMake配置和构建过程，尝试定位问题发生的具体阶段。</li>
<li>查阅文档和社区帮助：查阅CMake的官方文档，或者在Stack Overflow等社区寻找类似问题的解决方案。</li>
<li>简化CMakeLists.txt：临时删除或注释掉一部分代码，逐步缩小问题范围，直到找到问题的根源。</li>
</ul>
</li>
<li>通过这些方法，我通常能够有效地定位并解决CMake构建过程中的问题。</li>
</ul>
<h2 id="CMake经常更新，引入新的特性和改进。请问你是如何确保你的CMake项目能够在不同版本的CMake上都能正常工作的？"><a href="#CMake经常更新，引入新的特性和改进。请问你是如何确保你的CMake项目能够在不同版本的CMake上都能正常工作的？" class="headerlink" title="CMake经常更新，引入新的特性和改进。请问你是如何确保你的CMake项目能够在不同版本的CMake上都能正常工作的？"></a>CMake经常更新，引入新的特性和改进。请问你是如何确保你的CMake项目能够在不同版本的CMake上都能正常工作的？</h2><ul>
<li>为了确保CMake项目的跨版本兼容性，我会遵循以下几个原则：<ul>
<li>使用版本检查：在CMakeLists.txt文件的开始使用cmake_minimum_required指令来指定项目所需的最低CMake版本。</li>
<li>避免使用废弃的特性：避免使用在新版本中已被废弃的函数和变量，以防它们在未来版本中被移除。</li>
<li>测试多个CMake版本：在不同版本的CMake上测试项目的构建过程，确保兼容性。</li>
<li>文档说明：在项目文档中明确说明支持的CMake版本范围。</li>
</ul>
</li>
<li>通过这些方法，我可以最大程度地确保项目在不同版本的CMake上都能正常工作。</li>
</ul>
<h2 id="在大型项目中，CMake代码可能会变得非常复杂。请问你是如何管理这些复杂的CMake代码，确保其可维护性的？"><a href="#在大型项目中，CMake代码可能会变得非常复杂。请问你是如何管理这些复杂的CMake代码，确保其可维护性的？" class="headerlink" title="在大型项目中，CMake代码可能会变得非常复杂。请问你是如何管理这些复杂的CMake代码，确保其可维护性的？"></a>在大型项目中，CMake代码可能会变得非常复杂。请问你是如何管理这些复杂的CMake代码，确保其可维护性的？</h2><ul>
<li>为了管理大型项目中的复杂CMake代码并确保其可维护性，我会采取以下策略：<ul>
<li>模块化设计：将CMake代码分解为多个模块，每个模块负责一个特定的功能或组件。</li>
<li>使用函数和宏：将重复的代码封装到函数或宏中，减少代码冗余。</li>
<li>代码注释：在CMake代码中添加充足的注释，解释复杂的逻辑和重要的决策。</li>
<li>遵循编码规范：制定并遵循一套CMake代码的编码规范，确保代码风格的一致性。</li>
<li>定期代码审查：定期进行代码审查，确保代码质量并分享最佳实践。</li>
<li>文档化：创建详细的文档，描述CMake代码的结构、功能和使用方法。</li>
</ul>
</li>
<li>通过这些方法，我可以确保即使在大型项目中，CMake代码也能保持清晰、可维护和易于理解。</li>
</ul>
<h2 id="在软件开发中，确保项目的安全性是非常重要的。请问你是如何确保你的CMake项目的安全性的？"><a href="#在软件开发中，确保项目的安全性是非常重要的。请问你是如何确保你的CMake项目的安全性的？" class="headerlink" title="在软件开发中，确保项目的安全性是非常重要的。请问你是如何确保你的CMake项目的安全性的？"></a>在软件开发中，确保项目的安全性是非常重要的。请问你是如何确保你的CMake项目的安全性的？</h2><ul>
<li>为了确保CMake项目的安全性，我会注意以下几点：<ul>
<li><strong>避免使用不安全的函数和命令</strong>：避免使用可能引入安全漏洞的CMake命令和函数。</li>
<li>检查依赖库的安全性：定期检查项目依赖的第三方库，确保它们是最新的，并且没有已知的安全漏洞。</li>
<li>使用安全的编译选项：使用编译器提供的安全相关编译选项，如栈保护等。</li>
<li>代码审计：定期进行代码审计，检查可能的安全漏洞。</li>
</ul>
</li>
<li>通过这些方法，我可以提高CMake项目的安全性，防范可能的安全威胁。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/23/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/25/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
