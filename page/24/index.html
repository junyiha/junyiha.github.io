<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="工作学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="junyi&#39;s blog">
<meta property="og:url" content="https://junyiha.github.io/page/24/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="工作学习笔记">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhang junyi">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/page/24/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_30_set/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_30_set/" class="post-title-link" itemprop="url">C++_10_30_set</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <set>标准库</li>
</ul>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul>
<li>set容器定义在<set>头文件中，和map非常相似。</li>
<li>区别在于set保存的不是键值对，在set中本身就是键。如果信息没有显式的键，且希望进行排序(不包含重复)以便快速的执行插入，查找和删除，就可以考虑使用set容器存储此类信息。</li>
<li>不能修改set中元素的键值，因为修改容器中的set元素会破坏顺序。</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <set>标准库</h2><p><code>&lt;set&gt;</code> 是 C++ 标准库中的头文件，定义了一组容器类模板，用于实现集合（Set）和关联容器的功能。</p>
<h3 id="std-set："><a href="#std-set：" class="headerlink" title="std::set："></a>std::set：</h3><ul>
<li><code>std::set</code> 是一个关联容器，用于存储一组唯一的、已排序的元素。</li>
<li>内部元素按照某个严格弱顺序排列（默认是升序），并且元素值是唯一的。</li>
<li>主要特点：<ul>
<li>自动排序：元素按照某个严格弱顺序（由比较函数或默认的 <code>&lt;</code> 运算符决定）自动排序。</li>
<li>唯一性：不允许重复的元素存在。</li>
<li>查找、插入和删除操作的时间复杂度为 O(log n)。</li>
</ul>
</li>
<li>主要操作：<ul>
<li><code>insert(const value_type&amp; val)</code>: 插入元素 <code>val</code>。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const value_type&amp; val)</code>: 查找元素 <code>val</code> 的位置。</li>
<li><code>size()</code>: 返回集合中元素的数量。</li>
<li><code>empty()</code>: 判断集合是否为空。</li>
</ul>
</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出集合中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::set</code> 的基本使用方法，包括插入元素、查找元素、删除元素以及遍历输出集合中的元素。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <set>标准库 详解</h2><p><code>&lt;set&gt;</code> 是 C++ 标准库中的头文件，提供了实现关联容器中集合（Set）的类模板。这些集合类模板允许用户存储一组唯一的、已排序的元素。</p>
<h3 id="std-set-和-std-multiset："><a href="#std-set-和-std-multiset：" class="headerlink" title="std::set 和 std::multiset："></a>std::set 和 std::multiset：</h3><ul>
<li><code>std::set</code> 和 <code>std::multiset</code> 都是关联容器。</li>
<li><code>std::set</code> 存储一组唯一的已排序元素，每个元素只能出现一次。</li>
<li><code>std::multiset</code> 存储一组已排序的元素，允许元素重复出现。</li>
</ul>
<h3 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h3><ul>
<li><strong>有序性：</strong> 内部元素按照某个严格弱顺序（默认是升序）排列。</li>
<li><strong>唯一性：</strong> <code>std::set</code> 中的元素是唯一的，而 <code>std::multiset</code> 允许重复元素存在。</li>
<li><strong>自动排序：</strong> 插入新元素时会自动按照严格弱顺序进行排序。</li>
<li><strong>底层实现：</strong> 通常使用平衡二叉树（红黑树）来实现。</li>
</ul>
<h3 id="主要操作："><a href="#主要操作：" class="headerlink" title="主要操作："></a>主要操作：</h3><ul>
<li><code>insert(const value_type&amp; val)</code>: 插入元素。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const value_type&amp; val)</code>: 查找元素。</li>
<li><code>size()</code>: 返回集合中元素的数量。</li>
<li><code>empty()</code>: 判断集合是否为空。</li>
<li>迭代器支持：可以使用迭代器遍历集合中的元素。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::set</span></span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>); <span class="comment">// 重复元素不会被插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出集合中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此示例演示了 <code>std::set</code> 的基本用法，包括创建、插入、删除、查找元素以及遍历输出集合中的元素。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <set>标准库 常用的类和函数</h2><p>在 C++ <code>&lt;set&gt;</code> 标准库中，最常用的类包括 <code>std::set</code> 和 <code>std::multiset</code>，它们提供了操作集合的常用函数和方法。</p>
<h3 id="主要类："><a href="#主要类：" class="headerlink" title="主要类："></a>主要类：</h3><ol>
<li><p><strong>std::set</strong>：</p>
<ul>
<li>用于存储一组唯一的、已排序的元素。</li>
<li>特点：<ul>
<li>内部元素按照严格弱顺序（默认升序）排列。</li>
<li>元素是唯一的，不允许重复。</li>
</ul>
</li>
<li>主要方法：<ul>
<li><code>insert(const value_type&amp; val)</code>: 插入元素。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const value_type&amp; val)</code>: 查找元素。</li>
<li><code>size()</code>: 返回集合中元素的数量。</li>
<li><code>empty()</code>: 判断集合是否为空。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>std::multiset</strong>：</p>
<ul>
<li>用于存储一组已排序的元素，允许元素重复。</li>
<li>特点：<ul>
<li>内部元素按照严格弱顺序（默认升序）排列。</li>
<li>元素允许重复出现。</li>
</ul>
</li>
<li>主要方法与 <code>std::set</code> 类似。</li>
</ul>
</li>
</ol>
<h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><ul>
<li><code>insert(const value_type&amp; val)</code>: 将元素 <code>val</code> 插入集合。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const value_type&amp; val)</code>: 查找元素 <code>val</code>。</li>
<li><code>size()</code>: 返回集合中元素的数量。</li>
<li><code>empty()</code>: 判断集合是否为空。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::multiset&lt;<span class="type">int</span>&gt; myMultiSet = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line">    myMultiSet.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">    myMultiSet.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in set:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; elem;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in multiset:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myMultiSet) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; elem;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::set</code> 和 <code>std::multiset</code> 的基本用法，包括插入、删除、查找元素以及遍历输出集合中的元素。</p>
<h2 id="std-set"><a href="#std-set" class="headerlink" title="std::set"></a>std::set</h2><p><code>std::set</code> 是 C++ 标准库中定义的关联容器，用于存储一组唯一的、已排序的元素。</p>
<h3 id="主要特点：-1"><a href="#主要特点：-1" class="headerlink" title="主要特点："></a>主要特点：</h3><ul>
<li><strong>有序性：</strong> 内部元素按照某个严格弱顺序（默认是升序）排列。</li>
<li><strong>唯一性：</strong> <code>std::set</code> 中的元素是唯一的，不允许重复。</li>
<li><strong>自动排序：</strong> 插入新元素时会自动按照严格弱顺序进行排序。</li>
<li><strong>底层实现：</strong> 通常使用平衡二叉树（红黑树）来实现。</li>
</ul>
<h3 id="主要操作：-1"><a href="#主要操作：-1" class="headerlink" title="主要操作："></a>主要操作：</h3><ul>
<li><code>insert(const value_type&amp; val)</code>: 插入元素。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const value_type&amp; val)</code>: 查找元素。</li>
<li><code>size()</code>: 返回集合中元素的数量。</li>
<li><code>empty()</code>: 判断集合是否为空。</li>
</ul>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>); <span class="comment">// 重复元素不会被插入</span></span><br><span class="line"></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : mySet) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，展示了 <code>std::set</code> 的基本使用方法，包括创建、插入、删除、查找元素以及遍历输出集合中的元素。</p>
<h2 id="std-set-find"><a href="#std-set-find" class="headerlink" title="std::set::find()"></a>std::set::find()</h2><p><code>std::set::find()</code> 是用于在 <code>std::set</code> 集合中查找特定元素的成员函数。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>key</code>：要查找的元素的键值。</li>
<li>返回值：如果找到匹配的元素，则返回指向该元素的迭代器；如果未找到匹配的元素，则返回指向集合末尾的迭代器 <code>end()</code>。</li>
</ul>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in set: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element not found in set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it = mySet.<span class="built_in">find</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in set: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element not found in set&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::set::find()</code> 用于查找集合中的特定元素。如果找到匹配的元素，则返回指向该元素的迭代器；否则返回 <code>end()</code>。</p>
<h2 id="std-multiset"><a href="#std-multiset" class="headerlink" title="std::multiset"></a>std::multiset</h2><p><code>std::multiset</code> 是 C++ 标准库中定义的关联容器，类似于 <code>std::set</code>，但允许元素重复出现。</p>
<h3 id="主要特点：-2"><a href="#主要特点：-2" class="headerlink" title="主要特点："></a>主要特点：</h3><ul>
<li><strong>有序性：</strong> 内部元素按照某个严格弱顺序（默认是升序）排列。</li>
<li><strong>允许重复：</strong> <code>std::multiset</code> 中的元素可以重复出现，即允许存储相同的元素。</li>
<li><strong>自动排序：</strong> 插入新元素时会自动按照严格弱顺序进行排序。</li>
<li><strong>底层实现：</strong> 通常使用平衡二叉树（红黑树）来实现。</li>
</ul>
<h3 id="主要操作：-2"><a href="#主要操作：-2" class="headerlink" title="主要操作："></a>主要操作：</h3><ul>
<li><code>insert(const value_type&amp; val)</code>: 插入元素。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const value_type&amp; val)</code>: 查找元素。</li>
<li><code>size()</code>: 返回集合中元素的数量。</li>
<li><code>empty()</code>: 判断集合是否为空。</li>
</ul>
<h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multiset&lt;<span class="type">int</span>&gt; myMultiSet = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    myMultiSet.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line">    myMultiSet.<span class="built_in">insert</span>(<span class="number">2</span>); <span class="comment">// 允许重复元素插入</span></span><br><span class="line"></span><br><span class="line">    myMultiSet.<span class="built_in">erase</span>(<span class="number">2</span>); <span class="comment">// 删除一个 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = myMultiSet.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMultiSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in multiset&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : myMultiSet) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了 <code>std::multiset</code> 的基本用法，包括创建、插入、删除、查找元素以及遍历输出集合中的元素。与 <code>std::set</code> 不同的是，<code>std::multiset</code> 允许重复元素的存在。</p>
<h2 id="std-multiset-find"><a href="#std-multiset-find" class="headerlink" title="std::multiset::find()"></a>std::multiset::find()</h2><p><code>std::multiset::find()</code> 是用于在 <code>std::multiset</code> 多重集合中查找特定元素的成员函数。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; key)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>key</code>：要查找的元素的键值。</li>
<li>返回值：如果找到匹配的元素，则返回指向该元素的迭代器；如果未找到匹配的元素，则返回指向集合末尾的迭代器 <code>end()</code>。</li>
</ul>
<h3 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multiset&lt;<span class="type">int</span>&gt; myMultiSet = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = myMultiSet.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMultiSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in multiset: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element not found in multiset&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it = myMultiSet.<span class="built_in">find</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMultiSet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found in multiset: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element not found in multiset&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::multiset::find()</code> 用于查找多重集合中的特定元素。如果找到匹配的元素，则返回指向该元素的迭代器；否则返回 <code>end()</code>。与 <code>std::set</code> 不同，<code>std::multiset</code> 允许元素重复，因此可能会返回多个匹配的元素。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_31_map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_31_map/" class="post-title-link" itemprop="url">C++_10_31_map</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <map>标准库</li>
</ul>
<h2 id="C-std-map-两个值作为一个map中的键"><a href="#C-std-map-两个值作为一个map中的键" class="headerlink" title="C++ std::map 两个值作为一个map中的键"></a>C++ std::map 两个值作为一个map中的键</h2><p>在 C++ 中，如果你想要使用两个值作为 <code>std::map</code> 的键，可以通过定义一个 <code>std::pair</code> 来实现。<code>std::pair</code> 能够将两个值组合成一个键，同时也支持字典序的比较，因此可以很好地用作 <code>std::map</code> 的键。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// std::pair</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::pair 作为键，int 作为值</span></span><br><span class="line">    std::map&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    myMap[&#123;<span class="number">1</span>, <span class="number">2</span>&#125;] = <span class="number">100</span>;</span><br><span class="line">    myMap[&#123;<span class="number">3</span>, <span class="number">4</span>&#125;] = <span class="number">200</span>;</span><br><span class="line">    myMap[&#123;<span class="number">1</span>, <span class="number">3</span>&#125;] = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历和访问元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;entry : myMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key: (&quot;</span> &lt;&lt; entry.first.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; entry.first.second </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;) -&gt; Value: &quot;</span> &lt;&lt; entry.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找特定键</span></span><br><span class="line">    std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; key = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (myMap.<span class="built_in">find</span>(key) != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value for key (1, 2): &quot;</span> &lt;&lt; myMap[key] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>在这个例子中，<code>myMap</code> 的键类型是 <code>std::pair&lt;int, int&gt;</code>，值类型是 <code>int</code>。</li>
<li>通过 <code>&#123;1, 2&#125;</code> 这样的语法，可以直接构造 <code>std::pair&lt;int, int&gt;</code> 并作为键插入到 <code>std::map</code> 中。</li>
<li><code>std::map</code> 会根据键的字典序进行排序，即先比较第一个元素，再比较第二个元素。</li>
</ul>
<h3 id="自定义比较"><a href="#自定义比较" class="headerlink" title="自定义比较"></a>自定义比较</h3><p>如果你希望使用自定义的排序规则，也可以通过定义一个自定义的比较器类并传入 <code>std::map</code> 构造函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomCompare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义排序逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (a.first == b.first) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::map&lt;std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>, CustomCompare&gt; customMap;</span><br></pre></td></tr></table></figure>

<h2 id="有序关联容器"><a href="#有序关联容器" class="headerlink" title="有序关联容器"></a>有序关联容器</h2><ul>
<li>与顺序关联容器不同，有序关联容器不采用线性方式保存元素。相反，有序关联容器将键映射到值。通常情况下，有序关联容器的插入，删除和查找时间是相等的。</li>
<li>标准库提供的4个有序关联容器分别为: map, multimap, set, multiset。</li>
<li>每种有序关联容器都将元素保存在类似于树的有序数据结构。</li>
<li>还有4个无序关联容器: unordered_map, unordered_multimap, unordered_set, unordered_multiset</li>
</ul>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul>
<li>map定义在<map>头文件中，它保存的是键&#x2F;值对，而不是只保存值</li>
<li>插入，查找和删除操作都是基于键的，值只不过是附属品。从概念上讲，map这个术语源于容器将键映射到值</li>
<li>当需要根据键保存或获取元素时，以及需要按照特定顺序保存元素时，应该使用map</li>
</ul>
<h3 id="构建map"><a href="#构建map" class="headerlink" title="构建map"></a>构建map</h3><ul>
<li>map类模板接受4种类型: 键类型，值类型，比较类型以及分配器类型</li>
<li>如果忽略比较参数和分配器参数，那么map的构建和vector或list的构建是一样的，区别在于模板实例化中需要分别指定键和值的类型。</li>
<li>例如构建一个map，使用int值作为键，Data类的对象作为值，map&lt;int, Data&gt; dataMap;在内部，dataMap为map中的每个元素存储一个pair&lt;int, Data&gt;</li>
</ul>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><ul>
<li><p>向顺序容器(例如vector和list)插入元素时，总是需要指定要插入元素的位置，而map不一样，它和其他关联容器都不需要指定插入位置。</p>
</li>
<li><p>map的内部实现会决定要保存新元素的位置，只需要提供键和值即可。</p>
</li>
<li><p>insert()方法。</p>
</li>
<li><p>可以使用insert()方法向map添加元素，它有一个好处：允许判断键是否已经存在。insert()方法的一个问题是必须将键&#x2F;值对指定为pair对象或initializer_list。</p>
</li>
<li><p>insert()的基本形式的返回类型是迭代器和布尔值组成的pair。返回类型这么复杂的原因是：</p>
<ul>
<li>如果指定的键已经存在，那么insert()不会改写元素值。返回的pair中的bool元素指出insert()是否真的插入了新的键&#x2F;值对。</li>
<li>迭代器引用是map中带有指定键的元素(根据插入成功与否这个键对应的值可能是新值或旧值)</li>
</ul>
</li>
<li><p>operator[]</p>
</li>
<li><p>向map插入元素的另一种方法是通过重载的operator[]。这种方法的区别主要在于语法：键和值分别是指定的。</p>
</li>
<li><p>此外，operator[]总是成功的。如果给定键没有对应的元素值，那么就会创建带有对应键值的新元素。如果具有给定键的元素已经存在，operator[]会将元素值替换为新指定的值。</p>
</li>
<li><p>不过operator[]有一点要注意：</p>
<ul>
<li>它总会构建一个新的值对象，即并不需要使用这个值对象，也同样如此。</li>
<li>因为需要为元素提供一个默认的构造函数，这样可能会比insert()的效率低</li>
</ul>
</li>
<li><p>emplace方法</p>
</li>
<li><p>map支持emplace()和emplace_hint()，从而在原位置构建元素，这与vector的emplace方法类似。</p>
</li>
<li><p>还有一个try_emplace()方法，如果给定的键还不存在，那么它将在原位置插入元素；如果map中 已经存在相应的键，则什么也不做。</p>
</li>
</ul>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><ul>
<li>map可根据指定的键查找元素，时间复杂度为指数时间</li>
<li>如果只想指导在map中是否存在具有给定键的元素，那么可以使用count()成员函数。这个函数返回map中给定键的元素个数。对于map来说，这个函数返回的结果不是0就是1,因为map中不允许具有重复键的元素。</li>
</ul>
<h2 id="C-std-map-find-函数-详解"><a href="#C-std-map-find-函数-详解" class="headerlink" title="C++ std::map::find() 函数 详解"></a>C++ std::map::find() 函数 详解</h2><p><code>std::map::find()</code> 是 C++ 标准模板库（STL）中 <code>std::map</code> 类的成员函数之一，用于在 map 中查找给定键的位置。以下是该函数的详细解释：</p>
<p><strong>函数签名：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="type">const</span> key_type&amp; k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数：</strong></p>
<ul>
<li><code>k</code>：要查找的键值。</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>如果找到了给定键，则返回指向该键值对的迭代器；</li>
<li>如果未找到，则返回指向 <code>end()</code> 的迭代器。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入一些键值对</span></span><br><span class="line">    myMap[<span class="number">1</span>] = <span class="string">&quot;One&quot;</span>;</span><br><span class="line">    myMap[<span class="number">2</span>] = <span class="string">&quot;Two&quot;</span>;</span><br><span class="line">    myMap[<span class="number">3</span>] = <span class="string">&quot;Three&quot;</span>;</span><br><span class="line">    myMap[<span class="number">4</span>] = <span class="string">&quot;Four&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找键为2的位置</span></span><br><span class="line">    <span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查结果</span></span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key found: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试查找不存在的键</span></span><br><span class="line">    it = myMap.<span class="built_in">find</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查结果</span></span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key found: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用 <code>myMap.find(2)</code> 查找键为2的位置，并输出结果。然后，我们尝试使用 <code>myMap.find(5)</code> 查找不存在的键，并输出结果。通过使用 <code>find</code> 函数，我们可以有效地检查某个键是否存在于 <code>std::map</code> 中，以及在存在的情况下获取相应的值。</p>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <map>标准库</h2><p><code>&lt;map&gt;</code> 是 C++ 标准库中的头文件，定义了一组容器类模板，用于实现键-值对形式的关联容器。</p>
<h3 id="std-map："><a href="#std-map：" class="headerlink" title="std::map："></a>std::map：</h3><ul>
<li><code>std::map</code> 是一个关联容器，用于存储一组键值对（key-value pairs）。</li>
<li>每个元素都是一个键值对，其中键（key）唯一，用于索引和快速查找值（value）。</li>
<li>内部元素按照键的严格弱顺序（默认是升序）排列。</li>
<li>主要特点：<ul>
<li>键值对按照键的严格弱顺序排列。</li>
<li>键是唯一的，不允许重复。</li>
<li>支持快速的查找、插入和删除操作。</li>
</ul>
</li>
</ul>
<h3 id="主要操作："><a href="#主要操作：" class="headerlink" title="主要操作："></a>主要操作：</h3><ul>
<li><code>insert(const value_type&amp; val)</code>: 插入键值对。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const key_type&amp; key)</code>: 查找键对应的值。</li>
<li><code>size()</code>: 返回 map 中元素的数量。</li>
<li><code>empty()</code>: 判断 map 是否为空。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    myMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob&#x27;s age: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob not found in map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 map 中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::map</code> 的基本使用方法，包括插入键值对、查找元素、遍历输出 map 中的键值对等操作。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <map>标准库 详解</h2><p><code>&lt;map&gt;</code> 是 C++ 标准库中的头文件，定义了一组容器类模板，用于实现关联容器，允许存储一组唯一键和对应的值。主要包括 <code>std::map</code> 和 <code>std::multimap</code>。</p>
<h3 id="std-map：-1"><a href="#std-map：-1" class="headerlink" title="std::map："></a>std::map：</h3><ul>
<li><code>std::map</code> 是一个关联容器，存储键值对，其中每个键都是唯一的，用于快速查找对应的值。</li>
<li>主要特点：<ul>
<li>键值对是按照键的严格弱顺序（默认是升序）排列。</li>
<li>键是唯一的，不允许重复。</li>
</ul>
</li>
<li>主要操作：<ul>
<li><code>insert(const value_type&amp; val)</code>: 插入键值对。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const key_type&amp; key)</code>: 查找键对应的值。</li>
<li><code>size()</code>: 返回 map 中元素的数量。</li>
<li><code>empty()</code>: 判断 map 是否为空。</li>
</ul>
</li>
</ul>
<h3 id="std-multimap："><a href="#std-multimap：" class="headerlink" title="std::multimap："></a>std::multimap：</h3><ul>
<li><code>std::multimap</code> 与 <code>std::map</code> 类似，但允许键重复出现。</li>
<li>主要特点：<ul>
<li>键值对是按照键的严格弱顺序（默认是升序）排列。</li>
<li>键允许重复。</li>
</ul>
</li>
<li>主要操作与 <code>std::map</code> 类似。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    myMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob&#x27;s age: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob not found in map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例演示了 <code>std::map</code> 的基本用法，包括插入键值对、查找元素、遍历输出 map 中的键值对等操作。<code>std::multimap</code> 的使用与此类似，但允许键重复出现。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <map>标准库 常用的类和函数</h2><p>在 C++ <code>&lt;map&gt;</code> 标准库中，最常用的类是 <code>std::map</code> 和 <code>std::multimap</code>，它们提供了操作键-值对集合的常用函数和方法。</p>
<h3 id="主要类："><a href="#主要类：" class="headerlink" title="主要类："></a>主要类：</h3><ol>
<li><p><strong>std::map</strong>：</p>
<ul>
<li>用于存储一组唯一的键值对，其中每个键是唯一的。</li>
<li>特点：<ul>
<li>键值对按照键的严格弱顺序（默认是升序）排列。</li>
<li>键是唯一的，不允许重复。</li>
</ul>
</li>
<li>主要方法：<ul>
<li><code>insert(const value_type&amp; val)</code>: 插入键值对。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const key_type&amp; key)</code>: 查找键对应的值。</li>
<li><code>size()</code>: 返回 map 中元素的数量。</li>
<li><code>empty()</code>: 判断 map 是否为空。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>std::multimap</strong>：</p>
<ul>
<li>与 <code>std::map</code> 类似，但允许键重复出现。</li>
<li>特点：<ul>
<li>键值对按照键的严格弱顺序（默认是升序）排列。</li>
<li>键允许重复。</li>
</ul>
</li>
<li>主要方法与 <code>std::map</code> 类似。</li>
</ul>
</li>
</ol>
<h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><ul>
<li><code>insert(const value_type&amp; val)</code>: 插入键值对。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const key_type&amp; key)</code>: 查找键对应的值。</li>
<li><code>size()</code>: 返回 map 中元素的数量。</li>
<li><code>empty()</code>: 判断 map 是否为空。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    myMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob&#x27;s age: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob not found in map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::map</code> 的基本用法，包括插入键值对、查找元素、遍历输出 map 中的键值对等操作。<code>std::multimap</code> 的使用与此类似，但允许键重复出现。</p>
<h2 id="std-map"><a href="#std-map" class="headerlink" title="std::map"></a>std::map</h2><p><code>std::map</code> 是 C++ 标准库中的关联容器，用于存储一组键值对（key-value pairs）。每个键都是唯一的，可以快速查找对应的值。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li><strong>有序性：</strong> 内部元素按照键的严格弱顺序（默认是升序）排列。</li>
<li><strong>唯一键：</strong> 键是唯一的，每个键对应一个值，不允许键的重复。</li>
<li><strong>底层实现：</strong> 通常使用平衡二叉树（红黑树）来实现。</li>
</ul>
<h3 id="主要操作：-1"><a href="#主要操作：-1" class="headerlink" title="主要操作："></a>主要操作：</h3><ul>
<li><code>insert(const value_type&amp; val)</code>: 插入键值对。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const key_type&amp; key)</code>: 查找键对应的值。</li>
<li><code>size()</code>: 返回 map 中键值对的数量。</li>
<li><code>empty()</code>: 判断 map 是否为空。</li>
</ul>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    myMap[<span class="string">&quot;Alice&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Bob&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    myMap[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob&#x27;s age: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob not found in map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::map</code> 的基本用法，包括插入键值对、查找元素、遍历输出 map 中的键值对等操作。</p>
<h2 id="std-multimap"><a href="#std-multimap" class="headerlink" title="std::multimap"></a>std::multimap</h2><p><code>std::multimap</code> 是 C++ 标准库中的关联容器，类似于 <code>std::map</code>，但允许键重复出现。</p>
<h3 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h3><ul>
<li><strong>有序性：</strong> 内部元素按照键的严格弱顺序（默认是升序）排列。</li>
<li><strong>允许重复键：</strong> <code>std::multimap</code> 中的键允许重复出现，即允许多个键对应不同的值。</li>
<li><strong>底层实现：</strong> 通常使用平衡二叉树（红黑树）来实现。</li>
</ul>
<h3 id="主要操作：-2"><a href="#主要操作：-2" class="headerlink" title="主要操作："></a>主要操作：</h3><ul>
<li><code>insert(const value_type&amp; val)</code>: 插入键值对。</li>
<li><code>erase(const_iterator position)</code>: 删除指定位置的元素。</li>
<li><code>find(const key_type&amp; key)</code>: 查找键对应的值。</li>
<li><code>size()</code>: 返回 multimap 中键值对的数量。</li>
<li><code>empty()</code>: 判断 multimap 是否为空。</li>
</ul>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::multimap&lt;std::string, <span class="type">int</span>&gt; myMultiMap;</span><br><span class="line"></span><br><span class="line">    myMultiMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>));</span><br><span class="line">    myMultiMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>));</span><br><span class="line">    myMultiMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>));</span><br><span class="line">    myMultiMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">32</span>)); <span class="comment">// 允许重复键</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = myMultiMap.<span class="built_in">find</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != myMultiMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob&#x27;s age: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bob not found in multimap&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMultiMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::multimap</code> 的基本用法，包括插入键值对、查找元素、遍历输出 multimap 中的键值对等操作。与 <code>std::map</code> 不同，<code>std::multimap</code> 允许多个键对应不同的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_32_iomanip/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_32_iomanip/" class="post-title-link" itemprop="url">C++_10_32_iomanip</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <iomanip>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <iomanip>标准库</h2><p><code>&lt;iomanip&gt;</code> 是 C++ 标准库中的头文件，提供了与格式化输入输出相关的工具和操作符。这个头文件主要包含了用于控制输入输出格式的类和函数。</p>
<h3 id="主要内容："><a href="#主要内容：" class="headerlink" title="主要内容："></a>主要内容：</h3><ol>
<li><p><strong>操纵符（Manipulators）：</strong></p>
<ul>
<li><code>std::setw(int n)</code>: 设置域宽（用于下一个输出项）。</li>
<li><code>std::setprecision(int n)</code>: 设置浮点数的精度。</li>
<li><code>std::setfill(char c)</code>: 设置填充字符。</li>
<li><code>std::left</code>, <code>std::right</code>, <code>std::internal</code>: 控制输出对齐方式。</li>
<li><code>std::boolalpha</code>: 将布尔值输出为 “true” 或 “false”。</li>
<li><code>std::hex</code>, <code>std::dec</code>, <code>std::oct</code>: 控制输出的进制。</li>
<li>等等。</li>
</ul>
</li>
<li><p><strong>流控制：</strong></p>
<ul>
<li><code>std::fixed</code>, <code>std::scientific</code>: 控制浮点数输出的格式。</li>
<li><code>std::showpoint</code>: 总是显示小数点。</li>
<li><code>std::noshowpoint</code>: 不显示小数点。</li>
<li><code>std::uppercase</code>: 使用大写字母表示科学计数法中的指数。</li>
<li><code>std::nouppercase</code>: 使用小写字母表示科学计数法中的指数。</li>
<li>等等。</li>
</ul>
</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl; <span class="comment">// 设置域宽为 10</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; pi &lt;&lt; std::endl; <span class="comment">// 设置浮点数的精度为 3</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; num &lt;&lt; std::endl; <span class="comment">// 设置域宽为 8，填充字符为 &#x27;*&#x27;</span></span><br><span class="line">    std::cout &lt;&lt; std::left &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; num &lt;&lt; std::endl; <span class="comment">// 左对齐</span></span><br><span class="line">    std::cout &lt;&lt; std::scientific &lt;&lt; pi &lt;&lt; std::endl; <span class="comment">// 科学计数法输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>&lt;iomanip&gt;</code> 中一些常用的格式化输出操作，如设置域宽、设置精度、设置填充字符、对齐方式、科学计数法输出等。这些操作可用于控制输入输出的格式，使输出更易读、更美观。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <iomanip>标准库 详解</h2><p><code>&lt;iomanip&gt;</code> 是 C++ 标准库中的头文件，提供了用于格式化输入输出的工具和操作符。它包含了多种操纵符（manipulators）、流控制器（stream control）、标志（flags）和函数，用于调整输出的格式以及控制流的行为。</p>
<h3 id="主要内容：-1"><a href="#主要内容：-1" class="headerlink" title="主要内容："></a>主要内容：</h3><ol>
<li><p><strong>操纵符（Manipulators）：</strong></p>
<ul>
<li><code>std::setw(int n)</code>: 设置下一个输出项的宽度。</li>
<li><code>std::setprecision(int n)</code>: 设置浮点数的输出精度。</li>
<li><code>std::setfill(char c)</code>: 设置填充字符。</li>
<li><code>std::left</code>, <code>std::right</code>, <code>std::internal</code>: 控制对齐方式。</li>
<li><code>std::boolalpha</code>: 将布尔值以文本形式输出。</li>
<li><code>std::hex</code>, <code>std::dec</code>, <code>std::oct</code>: 控制整数的输出进制。</li>
<li>等等。</li>
</ul>
</li>
<li><p><strong>流控制器（Stream Control）：</strong></p>
<ul>
<li><code>std::fixed</code>, <code>std::scientific</code>: 控制浮点数的输出格式。</li>
<li><code>std::showpoint</code>: 总是显示小数点。</li>
<li><code>std::noshowpoint</code>: 不显示小数点。</li>
<li><code>std::uppercase</code>: 使用大写字母表示科学计数法中的指数部分。</li>
<li><code>std::nouppercase</code>: 使用小写字母表示科学计数法中的指数部分。</li>
<li>等等。</li>
</ul>
</li>
<li><p><strong>标志（Flags）：</strong></p>
<ul>
<li><code>std::ios::fmtflags</code>: 标志位，用于控制输入输出流的格式状态。</li>
<li><code>std::ios::flags()</code>: 设置或查询格式标志位。</li>
<li><code>std::ios::setf()</code>, <code>std::ios::unsetf()</code>: 设置或取消设置格式标志位。</li>
<li>等等。</li>
</ul>
</li>
<li><p><strong>函数：</strong></p>
<ul>
<li><code>std::setiosflags()</code>, <code>std::resetiosflags()</code>: 设置或重置格式标志位。</li>
<li><code>std::get_money()</code>, <code>std::put_money()</code>: 对货币值进行输入输出。</li>
<li><code>std::get_time()</code>, <code>std::put_time()</code>: 对时间进行输入输出。</li>
<li>等等。</li>
</ul>
</li>
</ol>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">    std::chrono::system_clock::time_point now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::<span class="type">time_t</span> time = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl; <span class="comment">// 设置域宽为 10</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; pi &lt;&lt; std::endl; <span class="comment">// 设置浮点数的精度为 3</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; num &lt;&lt; std::endl; <span class="comment">// 设置域宽为 8，填充字符为 &#x27;*&#x27;</span></span><br><span class="line">    std::cout &lt;&lt; std::left &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; num &lt;&lt; std::endl; <span class="comment">// 左对齐</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;time), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) &lt;&lt; std::endl; <span class="comment">// 输出时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上示例展示了 <code>&lt;iomanip&gt;</code> 头文件中一些常用操作的使用方法，如设置域宽、设置精度、设置填充字符、对齐方式、时间输出等。这些操作可以用于调整输出格式以及处理特定类型的输入输出。</p>
<h2 id="C-标准库-常用类和函数"><a href="#C-标准库-常用类和函数" class="headerlink" title="C++ 标准库 常用类和函数"></a>C++ <iomanip>标准库 常用类和函数</h2><p><code>&lt;iomanip&gt;</code> 标准库提供了多种类和函数，用于格式化输入输出。以下是其中一些常用的类和函数：</p>
<h3 id="常用操纵符（Manipulators）："><a href="#常用操纵符（Manipulators）：" class="headerlink" title="常用操纵符（Manipulators）："></a>常用操纵符（Manipulators）：</h3><ul>
<li>**<code>std::setw(int n)</code>**：设置下一个输出项的宽度为 <code>n</code>。</li>
<li>**<code>std::setprecision(int n)</code>**：设置浮点数的输出精度为 <code>n</code>。</li>
<li>**<code>std::setfill(char c)</code>**：设置填充字符为 <code>c</code>。</li>
<li>**<code>std::left</code>, <code>std::right</code>, <code>std::internal</code>**：控制对齐方式。</li>
<li>**<code>std::boolalpha</code>**：以文本形式输出布尔值（true&#x2F;false）。</li>
<li>**<code>std::hex</code>, <code>std::dec</code>, <code>std::oct</code>**：控制整数的输出进制。</li>
<li>**<code>std::fixed</code>, <code>std::scientific</code>**：控制浮点数的输出格式。</li>
<li>**<code>std::showpoint</code>**：总是显示小数点。</li>
<li>**<code>std::uppercase</code>**：使用大写字母表示科学计数法中的指数。</li>
<li>等等。</li>
</ul>
<h3 id="流控制器（Stream-Control）："><a href="#流控制器（Stream-Control）：" class="headerlink" title="流控制器（Stream Control）："></a>流控制器（Stream Control）：</h3><ul>
<li>**<code>std::ios::fmtflags</code>**：用于控制输入输出流的格式状态。</li>
<li>**<code>std::ios::flags()</code>**：设置或查询格式标志位。</li>
<li>**<code>std::ios::setf()</code>, <code>std::ios::unsetf()</code>**：设置或取消设置格式标志位。</li>
<li>**<code>std::setiosflags()</code>, <code>std::resetiosflags()</code>**：设置或重置格式标志位。</li>
<li>等等。</li>
</ul>
<h3 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h3><ul>
<li><strong><code>std::get_money()</code></strong>, <strong><code>std::put_money()</code></strong>: 对货币值进行输入输出。</li>
<li><strong><code>std::get_time()</code></strong>, <strong><code>std::put_time()</code></strong>: 对时间进行输入输出。</li>
<li>等等。</li>
</ul>
<p>这些类和函数可用于控制输入输出流的格式，包括对宽度、精度、对齐方式、填充字符、数字格式、时间格式等进行设置和调整。</p>
<h2 id="std-setw"><a href="#std-setw" class="headerlink" title="std::setw()"></a>std::setw()</h2><p><code>std::setw()</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于设置下一个输出项的宽度。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">setw</span>(<span class="type">int</span> n);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>n</code>：整数值，用于设置下一个输出项的宽度为 <code>n</code>。</li>
<li>返回值：<code>std::setw()</code> 不返回任何值。</li>
</ul>
<h3 id="用法示例："><a href="#用法示例：" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置域宽为 10</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::setw(10)</code> 用于设置输出项的宽度为 10。这意味着下一个输出的内容将在占用的字符宽度上占据 10 个字符位置。如果实际内容不足以填充这个宽度，空格将被用作填充字符。</p>
<h2 id="std-setprecision"><a href="#std-setprecision" class="headerlink" title="std::setprecision()"></a>std::setprecision()</h2><p><code>std::setprecision()</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于设置浮点数的输出精度。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">setprecision</span>(<span class="type">int</span> n);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>n</code>：整数值，用于设置浮点数的输出精度为 <code>n</code>。</li>
<li>返回值：<code>std::setprecision()</code> 不返回任何值。</li>
</ul>
<h3 id="用法示例：-1"><a href="#用法示例：-1" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置浮点数的输出精度为 3</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::setprecision(3)</code> 用于设置输出浮点数的小数位精度为 3。这意味着浮点数在输出时将只显示到小数点后 3 位。</p>
<h2 id="std-setfill"><a href="#std-setfill" class="headerlink" title="std::setfill()"></a>std::setfill()</h2><p><code>std::setfill()</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于设置填充字符。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">setfill</span>(<span class="type">char</span> c);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>c</code>：字符类型，表示要设置的填充字符。</li>
<li>返回值：<code>std::setfill()</code> 不返回任何值。</li>
</ul>
<h3 id="用法示例：-2"><a href="#用法示例：-2" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置填充字符为 &#x27;*&#x27;</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::setfill(&#39;*&#39;)</code> 用于设置填充字符为星号 <code>*</code>，而 <code>std::setw(8)</code> 则用于设置输出项的宽度为 8。这意味着如果实际输出项的字符数少于 8 个，则用星号填充空余位置。</p>
<h2 id="std-left"><a href="#std-left" class="headerlink" title="std::left()"></a>std::left()</h2><p><code>std::left</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于左对齐输出。</p>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::left</span><br></pre></td></tr></table></figure>

<p><code>std::left</code> 被应用于输出流之后，将使得后续的输出项（例如使用 <code>std::setw()</code> 设置宽度后的输出）左对齐显示。</p>
<h3 id="用法示例：-3"><a href="#用法示例：-3" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左对齐输出</span></span><br><span class="line">    std::cout &lt;&lt; std::left &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::left</code> 用于设置输出的左对齐。<code>std::setw(8)</code> 则用于设置输出项的宽度为 8，如果实际输出项的字符数少于 8 个，则在右侧填充空余位置以保持左对齐输出。</p>
<h2 id="std-right"><a href="#std-right" class="headerlink" title="std::right()"></a>std::right()</h2><p><code>std::right</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于右对齐输出。</p>
<h3 id="使用方法：-1"><a href="#使用方法：-1" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::right</span><br></pre></td></tr></table></figure>

<p><code>std::right</code> 被应用于输出流之后，将使得后续的输出项（例如使用 <code>std::setw()</code> 设置宽度后的输出）右对齐显示。</p>
<h3 id="用法示例：-4"><a href="#用法示例：-4" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右对齐输出</span></span><br><span class="line">    std::cout &lt;&lt; std::right &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::right</code> 用于设置输出的右对齐。<code>std::setw(8)</code> 则用于设置输出项的宽度为 8，如果实际输出项的字符数少于 8 个，则在左侧填充空余位置以保持右对齐输出。</p>
<h2 id="std-internal"><a href="#std-internal" class="headerlink" title="std::internal()"></a>std::internal()</h2><p><code>std::internal</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于内部对齐输出。</p>
<h3 id="使用方法：-2"><a href="#使用方法：-2" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::internal</span><br></pre></td></tr></table></figure>

<p><code>std::internal</code> 被应用于输出流之后，将使得后续的输出项（例如使用 <code>std::setw()</code> 设置宽度后的输出）在输出时，数字等内部对齐。</p>
<h3 id="用法示例：-5"><a href="#用法示例：-5" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">-123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部对齐输出</span></span><br><span class="line">    std::cout &lt;&lt; std::internal &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::internal</code> 用于设置输出的内部对齐。<code>std::setw(8)</code> 用于设置输出项的宽度为 8。对于带有符号的整数，使用内部对齐时，会在数字之前打印符号，并将数字右对齐。</p>
<h2 id="std-boolalpha"><a href="#std-boolalpha" class="headerlink" title="std::boolalpha()"></a>std::boolalpha()</h2><p><code>std::boolalpha</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于控制布尔值的输出格式。</p>
<h3 id="使用方法：-3"><a href="#使用方法：-3" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::boolalpha</span><br></pre></td></tr></table></figure>

<p><code>std::boolalpha</code> 被应用于输出流之后，将使得后续的布尔值输出为文本形式，即 <code>true</code> 或 <code>false</code>，而非默认的整数值输出（1 或 0）。</p>
<h3 id="用法示例：-6"><a href="#用法示例：-6" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> status = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置布尔值的输出为文本形式</span></span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; status &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::boolalpha</code> 被用于设置布尔值的输出为文本形式，所以 <code>status</code> 的值 <code>true</code> 将以文本形式输出。</p>
<h2 id="std-hex"><a href="#std-hex" class="headerlink" title="std::hex()"></a>std::hex()</h2><p><code>std::hex</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于控制整数输出的进制为十六进制。</p>
<h3 id="使用方法：-4"><a href="#使用方法：-4" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::hex</span><br></pre></td></tr></table></figure>

<p><code>std::hex</code> 被应用于输出流之后，将使得后续的整数输出为十六进制形式。</p>
<h3 id="用法示例：-7"><a href="#用法示例：-7" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置整数输出为十六进制形式</span></span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::hex</code> 被用于设置整数输出为十六进制形式，所以 <code>num</code> 的值 255 将以十六进制形式输出为 <code>ff</code>。</p>
<h2 id="std-dex"><a href="#std-dex" class="headerlink" title="std::dex()"></a>std::dex()</h2><p><code>std::dec</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于将整数的输出进制设置为十进制。</p>
<h3 id="使用方法：-5"><a href="#使用方法：-5" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::dec</span><br></pre></td></tr></table></figure>

<p><code>std::dec</code> 被应用于输出流之后，将使得后续的整数输出为十进制形式。</p>
<h3 id="用法示例：-8"><a href="#用法示例：-8" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置整数输出为十六进制形式</span></span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置整数输出为十进制形式</span></span><br><span class="line">    std::cout &lt;&lt; std::dec &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，首先使用 <code>std::hex</code> 将整数输出设置为十六进制形式输出 <code>num</code> 的值为 <code>ff</code>，然后使用 <code>std::dec</code> 将整数输出设置回十进制形式输出 <code>num</code> 的值为 <code>255</code>。</p>
<h2 id="std-oct"><a href="#std-oct" class="headerlink" title="std::oct()"></a>std::oct()</h2><p><code>std::oct</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于将整数输出的进制设置为八进制。</p>
<h3 id="使用方法：-6"><a href="#使用方法：-6" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::oct</span><br></pre></td></tr></table></figure>

<p><code>std::oct</code> 被应用于输出流之后，将使得后续的整数输出为八进制形式。</p>
<h3 id="用法示例：-9"><a href="#用法示例：-9" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置整数输出为八进制形式</span></span><br><span class="line">    std::cout &lt;&lt; std::oct &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::oct</code> 被用于设置整数输出为八进制形式，所以 <code>num</code> 的值 <code>255</code> 将以八进制形式输出为 <code>377</code>。</p>
<h2 id="std-fixed"><a href="#std-fixed" class="headerlink" title="std::fixed()"></a>std::fixed()</h2><p><code>std::fixed</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于控制浮点数的输出格式为固定点表示法（fixed-point notation）。</p>
<h3 id="使用方法：-7"><a href="#使用方法：-7" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::fixed</span><br></pre></td></tr></table></figure>

<p><code>std::fixed</code> 被应用于输出流之后，将使得后续的浮点数输出使用固定的小数点位数（小数部分不会自动省略）。</p>
<h3 id="用法示例：-10"><a href="#用法示例：-10" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> value = <span class="number">123.456789</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置浮点数输出为固定点表示法</span></span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::fixed</code> 被用于设置浮点数的输出格式为固定点表示法，因此 <code>value</code> 的值 <code>123.456789</code> 将以固定的小数点位数输出为 <code>123.456789</code>。</p>
<h2 id="std-scientific"><a href="#std-scientific" class="headerlink" title="std::scientific"></a>std::scientific</h2><p><code>std::scientific</code> 是 <code>&lt;iomanip&gt;</code> 标准库中的操纵符（manipulator），用于控制浮点数的输出格式为科学计数法（scientific notation）。</p>
<h3 id="使用方法：-8"><a href="#使用方法：-8" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::scientific</span><br></pre></td></tr></table></figure>

<p><code>std::scientific</code> 被应用于输出流之后，将使得后续的浮点数输出使用科学计数法表示。</p>
<h3 id="用法示例：-11"><a href="#用法示例：-11" class="headerlink" title="用法示例："></a>用法示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> value = <span class="number">123456.789</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置浮点数输出为科学计数法</span></span><br><span class="line">    std::cout &lt;&lt; std::scientific &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>std::scientific</code> 被用于设置浮点数的输出格式为科学计数法，因此 <code>value</code> 的值 <code>123456.789</code> 将以科学计数法形式输出为 <code>1.234568e+05</code>。</p>
<h2 id="std-showpoint"><a href="#std-showpoint" class="headerlink" title="std::showpoint()"></a>std::showpoint()</h2><p><code>std::showpoint()</code> 是 C++ 中用于控制输出浮点数的标志之一。它用于在输出浮点数时始终显示小数点，并显示末尾的零。在使用它后，无论小数部分是否为零，都会显示小数点和末尾的零。</p>
<p>在中文中，<code>std::showpoint()</code> 可以翻译为 “显示小数点”，用于指示程序在输出浮点数时应始终显示小数点及其后的零。</p>
<h2 id="std-noshowpoint"><a href="#std-noshowpoint" class="headerlink" title="std::noshowpoint()"></a>std::noshowpoint()</h2><p><code>std::noshowpoint()</code> 是 C++ 中用于控制浮点数输出的标志之一。它用于取消使用 <code>std::showpoint()</code> 设置，即停止在输出浮点数时始终显示小数点及其后的零。</p>
<p>在中文中，<code>std::noshowpoint()</code> 可以翻译为 “不显示小数点”，用于指示程序在输出浮点数时不显示小数点及其后的零。</p>
<h2 id="std-uppercase"><a href="#std-uppercase" class="headerlink" title="std::uppercase"></a>std::uppercase</h2><p><code>std::uppercase</code> 是 C++ 中用于控制输出的标志之一，它用于设置输出中的字母部分为大写字母。通常，它与输出十六进制数字时一起使用，以确保字母部分以大写形式显示。</p>
<p>例如，当使用输出操作符 <code>&lt;&lt;</code> 将整数以十六进制格式输出时，设置了 <code>std::uppercase</code> 标志后，输出的字母部分（A-F）将以大写字母显示。</p>
<p>在中文中，<code>std::uppercase</code> 可以翻译为 “大写”，表示将输出转换为大写形式。</p>
<h2 id="std-nouppercase"><a href="#std-nouppercase" class="headerlink" title="std::nouppercase"></a>std::nouppercase</h2><p><code>std::nouppercase</code> 是 C++ 中用于控制输出的标志之一，它用于取消设置输出中字母部分为大写字母的状态，即停止将输出的字母部分强制转换为大写形式。</p>
<p>通常情况下，<code>std::nouppercase</code> 用于取消之前设置的 <code>std::uppercase</code> 标志，使得输出的字母部分恢复到默认的小写形式。</p>
<p>在中文中，<code>std::nouppercase</code> 可以翻译为 “不大写”，表示取消将输出转换为大写形式的设置。</p>
<h2 id="std-ios-fmtflags"><a href="#std-ios-fmtflags" class="headerlink" title="std::ios::fmtflags"></a>std::ios::fmtflags</h2><p><code>std::ios::fmtflags</code> 是 C++ 中的一种数据类型，用于表示输入&#x2F;输出流的格式标志。它是 <code>std::ios</code> 类的一部分，用于存储各种控制输出格式的标志位，比如用于控制流的各种格式设置，如对齐、小数点精度、数制、浮点数的显示方式等等。</p>
<p>这个类型通常用于控制输出格式的相关设置，例如 <code>std::ios::hex</code> 用于设置输出流的进制为十六进制，<code>std::ios::scientific</code> 用于设置输出流的科学计数法等等。</p>
<p>它是一个位掩码枚举类型，意味着它的值可以是多个位的组合。通过将各种格式标志进行按位或操作，可以创建包含多个格式标志的组合。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::fmtflags flags = std::cout.<span class="built_in">flags</span>(); <span class="comment">// 获取当前输出流的格式标志</span></span><br><span class="line"></span><br><span class="line">    flags |= std::ios::hex; <span class="comment">// 设置输出流的进制为十六进制</span></span><br><span class="line">    flags &amp;= ~std::ios::dec; <span class="comment">// 取消输出流的十进制设置</span></span><br><span class="line"></span><br><span class="line">    std::cout.<span class="built_in">flags</span>(flags); <span class="comment">// 应用新的格式标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>std::ios::fmtflags</code> 用于存储输出流的格式标志，可以随后使用按位操作符进行修改，并通过 <code>std::cout.flags()</code> 和 <code>std::cout.flags(flags)</code> 方法来获取和设置流的格式标志。</p>
<h2 id="std-ios-flags"><a href="#std-ios-flags" class="headerlink" title="std::ios::flags"></a>std::ios::flags</h2><p><code>std::ios::flags</code> 是 C++ 中的一个成员函数，而非数据类型。这个函数用于设置流的格式标志（flags），它属于 <code>std::ios</code> 类的一部分，用于控制输入&#x2F;输出流的格式。</p>
<p>这个成员函数的作用是设置流的格式控制标志。它接受一个参数，该参数是一个 <code>std::ios::fmtflags</code> 类型的值，这个值包含了要设置的格式标志的组合。</p>
<p>例如，可以使用 <code>std::ios::hex</code> 标志将输出流的进制设置为十六进制。示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout.<span class="built_in">setf</span>(std::ios::hex); <span class="comment">// 设置输出流的进制为十六进制</span></span><br><span class="line">    std::cout &lt;&lt; <span class="number">255</span> &lt;&lt; std::endl; <span class="comment">// 输出 255 的十六进制表示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::cout.setf(std::ios::hex)</code> 用于设置输出流的格式标志为十六进制格式。接下来的 <code>std::cout &lt;&lt; 255 &lt;&lt; std::endl</code> 将以十六进制形式输出整数 255。</p>
<p><code>std::ios::flags</code> 函数主要用于设置输出流的格式标志，以控制输出流的显示格式，比如控制进制、对齐方式、浮点数的显示方式等等。</p>
<h2 id="std-ios-setf"><a href="#std-ios-setf" class="headerlink" title="std::ios::setf()"></a>std::ios::setf()</h2><p><code>std::ios::setf()</code> 是 C++ 中用于设置流的格式标志的成员函数之一。它属于 <code>std::ios</code> 类的一部分，用于控制输入&#x2F;输出流的格式。</p>
<p>这个函数允许你设置指定的格式标志，接受一个参数，即格式标志的组合。你可以使用这个函数来设置需要的格式标志，例如设置浮点数的显示方式、数制、对齐方式等等。</p>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout.<span class="built_in">setf</span>(std::ios::hex); <span class="comment">// 设置输出流的进制为十六进制</span></span><br><span class="line">    std::cout &lt;&lt; <span class="number">255</span> &lt;&lt; std::endl; <span class="comment">// 输出 255 的十六进制表示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::cout.setf(std::ios::hex)</code> 被用来设置输出流的格式标志为十六进制格式。接下来的 <code>std::cout &lt;&lt; 255 &lt;&lt; std::endl</code> 将以十六进制形式输出整数 255。</p>
<p><code>std::ios::setf()</code> 函数是 <code>std::ios</code> 类中用于设置格式标志的函数之一，用于控制输出流的显示格式。</p>
<h2 id="std-ios-unsetf"><a href="#std-ios-unsetf" class="headerlink" title="std::ios::unsetf()"></a>std::ios::unsetf()</h2><p><code>std::unsetf()</code> 是 C++ 中用于取消流的格式标志的成员函数之一，属于 <code>std::ios</code> 类的一部分。它允许你取消特定的格式标志，将其从流的当前格式状态中移除。</p>
<p>这个函数接受一个参数，即要取消的格式标志。它可以取消先前通过 <code>std::ios::setf()</code> 或其他设置格式标志的方式设置的标志。</p>
<p>示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout.<span class="built_in">setf</span>(std::ios::hex); <span class="comment">// 设置输出流的进制为十六进制</span></span><br><span class="line">    std::cout &lt;&lt; <span class="number">255</span> &lt;&lt; std::endl; <span class="comment">// 输出 255 的十六进制表示</span></span><br><span class="line"></span><br><span class="line">    std::cout.<span class="built_in">unsetf</span>(std::ios::hex); <span class="comment">// 取消输出流的十六进制格式标志</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="number">255</span> &lt;&lt; std::endl; <span class="comment">// 输出 255 的默认十进制表示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，首先使用 <code>std::cout.setf(std::ios::hex)</code> 设置了输出流的格式标志为十六进制格式。接下来的 <code>std::cout &lt;&lt; 255 &lt;&lt; std::endl</code> 输出了整数 255 的十六进制表示。</p>
<p>然后使用 <code>std::cout.unsetf(std::ios::hex)</code> 取消了输出流的十六进制格式标志。最后的 <code>std::cout &lt;&lt; 255 &lt;&lt; std::endl</code> 输出了整数 255 的默认十进制表示，因为已取消了十六进制格式标志。</p>
<p><code>std::ios::unsetf()</code> 函数用于取消先前设置的特定格式标志，以便在输出流的格式状态中移除该标志。</p>
<h2 id="std-setiosflags"><a href="#std-setiosflags" class="headerlink" title="std::setiosflags()"></a>std::setiosflags()</h2><p><code>std::setiosflags()</code> 是 C++ 中用于设置流格式标志的函数之一，用于控制输入&#x2F;输出流的格式。这个函数可以设置指定的格式标志，其效果类似于 <code>std::ios::setf()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setiosflags</span>(std::ios::hex); <span class="comment">// 设置输出流的进制为十六进制</span></span><br><span class="line">    std::cout &lt;&lt; <span class="number">255</span> &lt;&lt; std::endl; <span class="comment">// 输出 255 的十六进制表示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::setiosflags(std::ios::hex)</code> 被用来设置输出流的格式标志为十六进制格式。接下来的 <code>std::cout &lt;&lt; 255 &lt;&lt; std::endl</code> 将以十六进制形式输出整数 255。</p>
<p><code>std::setiosflags()</code> 可以用于设置指定的格式标志，与 <code>std::ios::setf()</code> 类似，允许控制输出流的显示格式。</p>
<h2 id="std-resetiosflags"><a href="#std-resetiosflags" class="headerlink" title="std::resetiosflags()"></a>std::resetiosflags()</h2><p><code>std::resetiosflags()</code> 是 C++ 中用于重置流的格式标志的函数之一，用于控制输入&#x2F;输出流的格式。它的作用是取消指定的格式标志，将其从流的当前格式状态中移除。</p>
<p>这个函数接受一个参数，即要重置的格式标志。它可以用来取消先前通过 <code>std::ios::setf()</code>、<code>std::setiosflags()</code> 或其他设置格式标志的方式设置的标志。</p>
<p>示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout.<span class="built_in">setf</span>(std::ios::hex); <span class="comment">// 设置输出流的进制为十六进制</span></span><br><span class="line">    std::cout &lt;&lt; <span class="number">255</span> &lt;&lt; std::endl; <span class="comment">// 输出 255 的十六进制表示</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">resetiosflags</span>(std::ios::hex); <span class="comment">// 重置输出流的十六进制格式标志</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="number">255</span> &lt;&lt; std::endl; <span class="comment">// 输出 255 的默认十进制表示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，首先使用 <code>std::cout.setf(std::ios::hex)</code> 设置了输出流的格式标志为十六进制格式。接下来的 <code>std::cout &lt;&lt; 255 &lt;&lt; std::endl</code> 输出了整数 255 的十六进制表示。</p>
<p>然后使用 <code>std::cout &lt;&lt; std::resetiosflags(std::ios::hex)</code> 重置了输出流的十六进制格式标志。最后的 <code>std::cout &lt;&lt; 255 &lt;&lt; std::endl</code> 输出了整数 255 的默认十进制表示，因为已经重置了十六进制格式标志。</p>
<p><code>std::resetiosflags()</code> 函数用于取消先前设置的特定格式标志，以便从输出流的格式状态中移除该标志。</p>
<h2 id="std-get-money"><a href="#std-get-money" class="headerlink" title="std::get_money()"></a>std::get_money()</h2><p><code>std::get_money()</code> 是 C++ 标准库 <code>&lt;iomanip&gt;</code> 头文件中提供的一个函数，用于将字符串解析为货币值，并将其存储到 <code>std::money_get</code> 类型对象返回的结果中。它通常与 <code>std::put_money()</code> 一起使用，后者用于将货币值以指定的格式输出到输出流中。</p>
<p>这个函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::money_get&lt;charT, InputIterator&gt; <span class="title">get_money</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    T &amp;val, <span class="type">bool</span> intl = <span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>charT</code> 是字符类型。</li>
<li><code>InputIterator</code> 是输入迭代器类型。</li>
<li><code>val</code> 是要存储货币值的对象。</li>
<li><code>intl</code> 是一个布尔值，指示货币值是否采用国际化格式（如果为 <code>true</code>，则表示使用国际化货币格式）。</li>
</ul>
<p>例如，可以使用 <code>std::get_money()</code> 将字符串解析为货币值，然后将其输出到输出流中。示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string input = <span class="string">&quot;123.45&quot;</span>; <span class="comment">// 要解析的字符串</span></span><br><span class="line">    <span class="function">std::stringstream <span class="title">ss</span><span class="params">(input)</span></span>; <span class="comment">// 创建字符串流</span></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> value;</span><br><span class="line">    <span class="function">std::locale <span class="title">loc</span><span class="params">(std::locale(), <span class="keyword">new</span> std::moneypunct&lt;<span class="type">char</span>, <span class="literal">false</span>&gt;)</span></span>;</span><br><span class="line">    std::moneypunct_byname&lt;<span class="type">char</span>, <span class="literal">false</span>&gt; <span class="type">const</span>&amp; mpunct = std::use_facet&lt;std::moneypunct_byname&lt;<span class="type">char</span>, <span class="literal">false</span>&gt;&gt;(loc);</span><br><span class="line"></span><br><span class="line">    std::ios_base::iostate err;</span><br><span class="line">    ss.<span class="built_in">imbue</span>(loc);</span><br><span class="line">    ss &gt;&gt; std::<span class="built_in">get_money</span>(value, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ss.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parsing failed\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parsed value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，字符串 “123.45” 被解析为货币值，存储在 <code>value</code> 中，并输出到标准输出流中。需要注意的是，这是一个简化的示例，实际的用法可能涉及更多的设置和错误处理。</p>
<h2 id="std-put-money"><a href="#std-put-money" class="headerlink" title="std::put_money()"></a>std::put_money()</h2><p><code>std::put_money()</code> 是 C++ 标准库 <code>&lt;iomanip&gt;</code> 头文件中提供的一个函数，用于将货币值以指定的格式输出到输出流中。通常与 <code>std::get_money()</code> 一起使用，后者用于将字符串解析为货币值。</p>
<p>这个函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::money_put&lt;charT, OutputIterator&gt; <span class="title">put_money</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::basic_ostream&lt;charT&gt;&amp; os, <span class="type">bool</span> intl, T val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>charT</code> 是字符类型。</li>
<li><code>OutputIterator</code> 是输出迭代器类型。</li>
<li><code>os</code> 是要写入的输出流。</li>
<li><code>intl</code> 是一个布尔值，指示货币值是否采用国际化格式（如果为 <code>true</code>，则表示使用国际化货币格式）。</li>
<li><code>val</code> 是要输出的货币值。</li>
</ul>
<p>例如，可以使用 <code>std::put_money()</code> 将货币值以指定的格式输出到输出流中。示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> value = <span class="number">123.45</span>; <span class="comment">// 要输出的货币值</span></span><br><span class="line"></span><br><span class="line">    std::cout.<span class="built_in">imbue</span>(std::<span class="built_in">locale</span>(<span class="string">&quot;en_US.UTF-8&quot;</span>)); <span class="comment">// 设置本地化信息</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Formatted output: &quot;</span> &lt;&lt; std::<span class="built_in">put_money</span>(value, <span class="literal">true</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，货币值 123.45 被以国际化的货币格式输出到标准输出流中。这是一个简化的示例，实际的用法可能涉及更多的设置和本地化信息的处理。</p>
<h2 id="std-get-time"><a href="#std-get-time" class="headerlink" title="std::get_time()"></a>std::get_time()</h2><p><code>std::get_time()</code> 是 C++ 中 <code>&lt;iomanip&gt;</code> 头文件中提供的函数，用于将字符串解析为时间对象 <code>std::tm</code>。这个函数允许你从字符串中提取日期和时间信息，并将其存储在 <code>std::tm</code> 结构中。</p>
<p>这个函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::istreambuf_iterator&lt;charT&gt; <span class="title">get_time</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::istreambuf_iterator&lt;charT&gt;&amp; s,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> charT* fmt,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::tm* tmb)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>charT</code> 是字符类型。</li>
<li><code>s</code> 是指向输入流的迭代器。</li>
<li><code>fmt</code> 是描述日期和时间格式的 C 字符串。</li>
<li><code>tmb</code> 是指向 <code>std::tm</code> 结构的指针，用于存储解析后的日期和时间信息。</li>
</ul>
<p>示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::tm tmb;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">ss</span><span class="params">(<span class="string">&quot;2023-12-09 15:30:00&quot;</span>)</span></span>; <span class="comment">// 要解析的时间字符串</span></span><br><span class="line">    ss &gt;&gt; std::<span class="built_in">get_time</span>(&amp;tmb, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>); <span class="comment">// 解析时间字符串并存储到 std::tm 结构中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ss.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parsing failed\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parsed date and time: &quot;</span></span><br><span class="line">                  &lt;&lt; std::<span class="built_in">put_time</span>(&amp;tmb, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，字符串 “2023-12-09 15:30:00” 被解析为时间对象 <code>std::tm</code>，并存储在 <code>tmb</code> 中。然后，<code>std::put_time()</code> 被用于格式化输出解析后的日期和时间信息。如果解析失败，将输出 “Parsing failed”。这是一个简化的示例，实际的用法可能涉及更多的错误处理和格式化字符串。</p>
<h2 id="std-put-time"><a href="#std-put-time" class="headerlink" title="std::put_time()"></a>std::put_time()</h2><p><code>std::put_time()</code> 是 C++ 中 <code>&lt;iomanip&gt;</code> 头文件中提供的一个函数，用于将时间对象 <code>std::tm</code> 按照指定的格式输出为字符串。</p>
<p>这个函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ostreambuf_iterator&lt;charT&gt; <span class="title">put_time</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::tm* tmb,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> charT* fmt)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>tmb</code> 是指向 <code>std::tm</code> 结构的指针，包含要格式化的时间信息。</li>
<li><code>fmt</code> 是描述日期和时间格式的 C 字符串。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::tm timeinfo = &#123;&#125;; <span class="comment">// 初始化时间结构</span></span><br><span class="line">    timeinfo.tm_year = <span class="number">2023</span> - <span class="number">1900</span>; <span class="comment">// 年份减去1900</span></span><br><span class="line">    timeinfo.tm_mon = <span class="number">11</span>; <span class="comment">// 月份，0-11 表示一月到十二月</span></span><br><span class="line">    timeinfo.tm_mday = <span class="number">9</span>; <span class="comment">// 日</span></span><br><span class="line">    timeinfo.tm_hour = <span class="number">15</span>; <span class="comment">// 时</span></span><br><span class="line">    timeinfo.tm_min = <span class="number">30</span>; <span class="comment">// 分</span></span><br><span class="line">    timeinfo.tm_sec = <span class="number">0</span>; <span class="comment">// 秒</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Formatted time: &quot;</span> &lt;&lt; std::<span class="built_in">put_time</span>(&amp;timeinfo, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::put_time()</code> 被用于格式化输出 <code>std::tm</code> 结构中的时间信息。指定的格式字符串 <code>&quot;%Y-%m-%d %H:%M:%S&quot;</code> 代表了年月日时分秒的格式。这样的调用将会把时间信息格式化为字符串，并输出到标准输出流中。</p>
<p>需要注意的是，<code>std::put_time()</code> 在 C++11 中引入，用于便捷地格式化时间信息并输出为字符串。</p>
<h2 id="C-std-put-time-函数返回值存储到字符串"><a href="#C-std-put-time-函数返回值存储到字符串" class="headerlink" title="C++  std::put_time() 函数返回值存储到字符串"></a>C++ <chrono> std::put_time() 函数返回值存储到字符串</h2><p>你可以使用<code>std::put_time()</code>函数结合<code>std::stringstream</code>将格式化后的时间存储到字符串中。下面是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间点</span></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将时间点转换为时间结构体</span></span><br><span class="line">    std::<span class="type">time_t</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::tm* now_tm = std::<span class="built_in">localtime</span>(&amp;now_c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::put_time 格式化时间</span></span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">put_time</span>(now_tm, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将格式化后的时间存储到字符串中</span></span><br><span class="line">    std::string formatted_time = ss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出格式化后的时间字符串</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Formatted Time: &quot;</span> &lt;&lt; formatted_time &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中，<code>std::put_time()</code>函数用于将时间结构体格式化为指定格式的字符串。然后，使用<code>std::stringstream</code>来存储这个格式化后的字符串，最后将其转换为<code>std::string</code>类型。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_33_sstream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_33_sstream/" class="post-title-link" itemprop="url">C++_10_33_sstream</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <sstream>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <sstream>标准库</h2><p><code>&lt;sstream&gt;</code> 是 C++ 标准库中的头文件，它提供了对内存中字符串流的支持。它包含了用于操作内存中字符串流的类，如 <code>std::stringstream</code>、<code>std::ostringstream</code> 和 <code>std::istringstream</code>。</p>
<p>以下是这些类的简要介绍：</p>
<ul>
<li><p><strong>std::stringstream</strong>：这个类提供了一个用于读写内存中字符串的流。可以像使用输入输出流一样使用它，从中读取数据或将数据写入到内存中的字符串。它可以实现将字符串和其他数据类型（如整数、浮点数等）之间的转换。</p>
</li>
<li><p><strong>std::ostringstream</strong>：这个类是 <code>std::stringstream</code> 的派生类，用于输出数据到字符串。它专注于输出，不支持从字符串中读取数据。通常用于构建字符串，将各种数据类型转换为字符串形式。</p>
</li>
<li><p><strong>std::istringstream</strong>：这个类也是 <code>std::stringstream</code> 的派生类，用于从字符串中读取数据。它专注于输入，允许从已有的字符串中读取数据，并按照需要进行解析和处理。</p>
</li>
</ul>
<p>这些类都提供了与输入输出流类似的接口，包括 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 操作符，用于将数据插入或提取到流中，以及各种成员函数用于流操作，例如 <code>str()</code>、<code>clear()</code>、<code>tellg()</code>、<code>tellp()</code> 等等。</p>
<p>这些字符串流类在实际编程中很有用，可以方便地进行字符串的读写和转换操作，尤其是在需要从字符串中提取数据或将数据转换为字符串形式时。例如，将数字转换为字符串、将多个字符串拼接成一个字符串、或者从一个字符串中提取特定的数据等。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <sstream>标准库 详解</h2><p><code>&lt;sstream&gt;</code> 标准库提供了对字符串流的支持，使得可以在内存中对字符串进行输入和输出操作。这个标准库包含了以下三个主要的类：</p>
<ol>
<li><p><strong>std::stringstream</strong>：这个类提供了一个用于读写内存中字符串的流。它可以将数据转换为字符串或从字符串提取数据。主要用途包括将不同类型的数据转换为字符串或从字符串中提取特定类型的数据。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line">std::stringstream ss;</span><br><span class="line"><span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot;The answer is: &quot;</span> &lt;&lt; num;</span><br><span class="line">std::string result = ss.<span class="built_in">str</span>(); <span class="comment">// 获取 stringstream 中的字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::ostringstream</strong>：这个类是 <code>std::stringstream</code> 的派生类，专门用于字符串输出。它允许将各种数据类型转换为字符串并存储在内存中的字符串中。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line">std::ostringstream oss;</span><br><span class="line"><span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line">oss &lt;&lt; <span class="string">&quot;The answer is: &quot;</span> &lt;&lt; num;</span><br><span class="line">std::string result = oss.<span class="built_in">str</span>(); <span class="comment">// 获取 ostringstream 中的字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::istringstream</strong>：这个类也是 <code>std::stringstream</code> 的派生类，专门用于从字符串中读取数据。它允许从内存中的字符串中提取数据并进行解析。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line">std::string data = <span class="string">&quot;123 456&quot;</span>;</span><br><span class="line"><span class="function">std::istringstream <span class="title">iss</span><span class="params">(data)</span></span>;</span><br><span class="line"><span class="type">int</span> num1, num2;</span><br><span class="line">iss &gt;&gt; num1 &gt;&gt; num2; <span class="comment">// 从字符串中提取两个整数</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些类都具有类似于输入输出流的接口，例如 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 操作符，用于向流中插入或提取数据。此外，它们还提供了一些成员函数，例如 <code>str()</code> 用于获取字符串流的内容，<code>clear()</code> 用于清除流的状态，<code>tellg()</code> 和 <code>tellp()</code> 用于获取流指针的位置等。</p>
<p>字符串流可以在很多场景下非常有用，例如将数字转换为字符串、将多个字符串合并成一个字符串、从字符串中提取特定类型的数据等。它们在处理字符串数据时提供了灵活且方便的方式，尤其在需要对字符串中的数据进行处理、转换或解析时。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <sstream>标准库 常用的类和函数</h2><p><code>&lt;sstream&gt;</code> 标准库提供了对字符串流的支持，其中包含一些常用的类和函数，主要有三个核心类：<code>std::stringstream</code>、<code>std::ostringstream</code> 和 <code>std::istringstream</code>。以下是一些常用的类和函数：</p>
<ol>
<li><p><strong>std::stringstream</strong>：用于读写内存中的字符串流。它可以将数据转换为字符串或从字符串中提取数据。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::stringstream ss; <span class="comment">// 创建字符串流对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向字符串流中插入数据</span></span><br><span class="line">ss &lt;&lt; <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">ss &lt;&lt; <span class="number">42</span>;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot; World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串流中获取字符串</span></span><br><span class="line">std::string result = ss.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::ostringstream</strong>：用于将数据输出到字符串流中。主要用于将不同类型的数据转换为字符串并存储在内存中的字符串中。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::ostringstream oss; <span class="comment">// 创建输出字符串流对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向输出字符串流中插入数据</span></span><br><span class="line">oss &lt;&lt; <span class="string">&quot;The answer is: &quot;</span>;</span><br><span class="line">oss &lt;&lt; <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从输出字符串流中获取字符串</span></span><br><span class="line">std::string result = oss.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>std::istringstream</strong>：用于从字符串中读取数据。它允许从内存中的字符串中提取数据并进行解析。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string data = <span class="string">&quot;123 456&quot;</span>;</span><br><span class="line"><span class="function">std::istringstream <span class="title">iss</span><span class="params">(data)</span></span>; <span class="comment">// 创建输入字符串流对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num1, num2;</span><br><span class="line">iss &gt;&gt; num1 &gt;&gt; num2; <span class="comment">// 从字符串流中提取两个整数</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>常用的成员函数：</p>
<ul>
<li>**<code>str()</code>**：用于获取字符串流中的字符串内容。</li>
<li>**<code>clear()</code>**：用于清除流的状态。</li>
<li><strong><code>tellg()</code></strong> 和 **<code>tellp()</code>**：分别用于获取输入流和输出流的当前位置。</li>
<li><strong><code>seekg()</code></strong> 和 **<code>seekp()</code>**：分别用于设置输入流和输出流的读写位置。</li>
</ul>
<p>这些类和函数可以用于将不同类型的数据转换为字符串、将多个字符串拼接为一个字符串、从字符串中提取特定类型的数据等操作。在处理字符串时，字符串流提供了灵活和便捷的方式，特别是在需要对字符串中的数据进行处理、转换或解析时非常有用。</p>
<h2 id="C-std-stringbuf-详解-中文"><a href="#C-std-stringbuf-详解-中文" class="headerlink" title="C++ std::stringbuf 详解 中文"></a>C++ std::stringbuf 详解 中文</h2><p><code>std::stringbuf</code> 是 C++ 标准库提供的一个类，允许在基于字符串的缓冲区上进行输入和输出操作。它是 <code>&lt;sstream&gt;</code> 头文件的一部分。这个类通常与其他 I&#x2F;O 类（如 <code>std::stringstream</code>）一起使用。</p>
<p>以下是 <code>std::stringbuf</code> 的详细解释：</p>
<ol>
<li><p><strong>构造和析构</strong>：</p>
<ul>
<li><code>explicit basic_stringbuf( std::ios_base::openmode which = std::ios_base::in | std::ios_base::out )</code>：使用指定的模式构造一个 <code>std::stringbuf</code> 对象。默认模式是 <code>in|out</code>。</li>
<li><code>virtual ~basic_stringbuf()</code>：析构函数。</li>
</ul>
</li>
<li><p><strong>成员函数</strong>：</p>
<ul>
<li><code>str()</code>：返回底层字符串的副本。</li>
<li><code>str(const std::basic_string&lt;charT,traits,Allocator&gt;&amp; str)</code>：将底层字符串设置为指定字符串的副本。</li>
<li><code>protected</code>：通常，像 <code>underflow()</code>、<code>overflow()</code>、<code>sync()</code> 等函数是受保护的，并由派生类重写。</li>
</ul>
</li>
<li><p><strong>类型定义</strong>：</p>
<ul>
<li><code>char_type</code>：字符的类型（默认为 <code>char</code>）。</li>
<li><code>int_type</code>：表示每个字符的整数类型（通常为 <code>int</code>）。</li>
<li><code>pos_type</code>：表示缓冲区中位置的类型。</li>
<li><code>off_type</code>：表示缓冲区中偏移量的类型。</li>
</ul>
</li>
<li><p><strong>继承</strong>：</p>
<ul>
<li><code>std::basic_streambuf</code>：<code>std::stringbuf</code> 继承自 <code>std::basic_streambuf</code>，使其与流 I&#x2F;O 操作兼容。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li><code>sputc</code>：将字符放入流中。</li>
<li><code>sputn</code>：将一系列字符放入流中。</li>
<li><code>sbumpc</code>、<code>sgetc</code>、<code>sgetn</code>：从流中读取字符。</li>
<li><code>seekoff</code>、<code>seekpos</code>：将获取和&#x2F;或放置指针移动到指定位置。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<ul>
<li><code>std::stringbuf</code> 经常被用作从字符串读取或写入的缓冲区。</li>
<li>它通常与 <code>std::stringstream</code> 结合使用，以对字符串执行格式化的输入&#x2F;输出操作。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stringbuf buf;</span><br><span class="line">    <span class="function">std::ostream <span class="title">os</span><span class="params">(&amp;buf)</span></span>;</span><br><span class="line"></span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; buf.<span class="built_in">str</span>() &lt;&lt; std::endl; <span class="comment">// 输出：Hello, world!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个 <code>std::stringbuf</code> 对象，将它用作输出的缓冲区，然后使用 <code>str()</code> 方法检索缓冲区的内容。</p>
<h2 id="std-stringstream"><a href="#std-stringstream" class="headerlink" title="std::stringstream"></a>std::stringstream</h2><p><code>std::stringstream</code> 是 C++ 标准库中的一个类，位于 <code>&lt;sstream&gt;</code> 头文件中，提供了对字符串进行输入输出操作的功能。它是基于内存缓冲区的流类，允许像操作标准输入输出流（<code>std::cin</code> 和 <code>std::cout</code>）一样操作字符串数据。</p>
<h3 id="主要功能和用途："><a href="#主要功能和用途：" class="headerlink" title="主要功能和用途："></a>主要功能和用途：</h3><ol>
<li><strong>输入输出操作</strong>：允许像标准输入输出流一样对字符串进行输入输出操作。</li>
<li><strong>数据类型转换</strong>：可以方便地将不同类型的数据转换为字符串或从字符串中提取出不同类型的数据。</li>
<li><strong>格式化</strong>：支持格式化输出和输入，可以使用流操作符和 manipulators（例如 <code>std::setw</code>、<code>std::setprecision</code>）对数据进行格式化操作。</li>
</ol>
<h3 id="主要成员函数和用法："><a href="#主要成员函数和用法：" class="headerlink" title="主要成员函数和用法："></a>主要成员函数和用法：</h3><h4 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h4><ul>
<li><strong>默认构造函数</strong>：<code>std::stringstream ss;</code> 创建一个空的 <code>std::stringstream</code> 对象。</li>
</ul>
<h4 id="输入输出操作："><a href="#输入输出操作：" class="headerlink" title="输入输出操作："></a>输入输出操作：</h4><ul>
<li><strong><code>&lt;&lt;</code> 运算符</strong>：用于将数据写入到 <code>std::stringstream</code> 对象中，例如 <code>ss &lt;&lt; &quot;Hello&quot; &lt;&lt; 42;</code> 将字符串 “Hello” 和整数 42 写入流中。</li>
<li><strong><code>&gt;&gt;</code> 运算符</strong>：用于从 <code>std::stringstream</code> 对象中读取数据，例如 <code>ss &gt;&gt; str &gt;&gt; num;</code> 从流中提取字符串和数字。</li>
</ul>
<h4 id="其他操作："><a href="#其他操作：" class="headerlink" title="其他操作："></a>其他操作：</h4><ul>
<li><strong><code>str()</code> 方法</strong>：返回当前流中的字符串副本，例如 <code>std::string content = ss.str();</code>。</li>
<li><strong><code>clear()</code> 方法</strong>：用于清除流的状态。</li>
<li><strong><code>str(const std::string&amp;)</code> 方法</strong>：用于设置流中的字符串。</li>
</ul>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据到流中</span></span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    std::string str;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从流中读取数据</span></span><br><span class="line">    ss &gt;&gt; str &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;String: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取流中的字符串</span></span><br><span class="line">    std::string content = ss.<span class="built_in">str</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stream content: &quot;</span> &lt;&lt; content &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>在使用 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 操作符时，流中的数据会按照空格（空格、制表符、换行符等）分隔。</li>
<li>使用流之前，请确保清除流状态（<code>ss.clear()</code>）以及设置&#x2F;重置需要操作的字符串内容（<code>ss.str(&quot;&quot;)</code>）。</li>
</ul>
<p><code>std::stringstream</code> 提供了方便的方法来处理字符串数据，使得将数据从字符串中读取和写入变得更加简单和灵活。</p>
<h2 id="std-ostringstream"><a href="#std-ostringstream" class="headerlink" title="std::ostringstream"></a>std::ostringstream</h2><p><code>std::ostringstream</code> 是 C++ 标准库中 <code>&lt;sstream&gt;</code> 头文件中提供的一个类，它是 <code>std::stringstream</code> 的派生类之一，专门用于输出数据到字符串流中。<code>std::ostringstream</code> 主要用于将各种数据类型转换为字符串并存储在内存中的字符串中。</p>
<p>它与 <code>std::stringstream</code> 类似，但专注于输出，不支持从字符串中读取数据。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ostringstream oss; <span class="comment">// 创建输出字符串流对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向输出字符串流中插入数据</span></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;The answer is: &quot;</span>;</span><br><span class="line">    oss &lt;&lt; <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从输出字符串流中获取字符串</span></span><br><span class="line">    std::string result = oss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出结果字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个 <code>std::ostringstream</code> 对象 <code>oss</code>，然后使用 <code>&lt;&lt;</code> 操作符将字符串和整数插入到输出字符串流中。最后使用 <code>oss.str()</code> 获取整个输出字符串流的内容，并将其赋值给 <code>result</code>，最终输出结果字符串。</p>
<p><code>std::ostringstream</code> 在需要将数据转换为字符串并存储在内存中的场景中非常有用，例如将日志信息组合成一条字符串、将数据转换为特定格式的字符串等。</p>
<h2 id="std-istringstream"><a href="#std-istringstream" class="headerlink" title="std::istringstream"></a>std::istringstream</h2><p><code>std::istringstream</code> 是 C++ 标准库中 <code>&lt;sstream&gt;</code> 头文件中提供的一个类，它是 <code>std::stringstream</code> 的派生类之一，专门用于从字符串中读取数据。<code>std::istringstream</code> 主要用于从内存中的字符串中提取数据并进行解析。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string data = <span class="string">&quot;123 456&quot;</span>;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">iss</span><span class="params">(data)</span></span>; <span class="comment">// 创建输入字符串流对象</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    iss &gt;&gt; num1 &gt;&gt; num2; <span class="comment">// 从字符串流中提取两个整数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Numbers extracted: &quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; num2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个 <code>std::istringstream</code> 对象 <code>iss</code>，并将字符串 “123 456” 作为输入传递给它。然后使用 <code>&gt;&gt;</code> 操作符从输入字符串流中提取两个整数，并将其分别存储在 <code>num1</code> 和 <code>num2</code> 中。最后将这两个整数输出到控制台。</p>
<p><code>std::istringstream</code> 对于需要从字符串中提取特定类型的数据并进行解析的情况非常有用，例如从文件读取数据并解析、处理用户输入的字符串等场景。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_34_future/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_34_future/" class="post-title-link" itemprop="url">C++_10_34_future</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <future>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <future>标准库</h2><p><code>&lt;future&gt;</code> 标准库是 C++ 中用于支持异步编程的头文件。它提供了 <code>std::future</code>、<code>std::promise</code>、<code>std::packaged_task</code> 等类，以及一些与异步任务相关的函数，如 <code>std::async</code>、<code>std::async</code>、<code>std::packaged_task</code> 等。</p>
<p>以下是 <code>&lt;future&gt;</code> 标准库中常用的类和函数：</p>
<h3 id="1-std-future"><a href="#1-std-future" class="headerlink" title="1. std::future"></a>1. <code>std::future</code></h3><p><code>std::future</code> 是一个模板类，用于存储异步任务的结果。它提供了 <code>.get()</code> 方法来获取异步任务的结果，并且可以检查任务是否已完成。</p>
<h3 id="2-std-promise"><a href="#2-std-promise" class="headerlink" title="2. std::promise"></a>2. <code>std::promise</code></h3><p><code>std::promise</code> 允许在一个线程中设置一个值或异常，并在另一个线程中通过 <code>std::future</code> 获取该值或异常。它通常用于异步任务间的通信。</p>
<h3 id="3-std-packaged-task"><a href="#3-std-packaged-task" class="headerlink" title="3. std::packaged_task"></a>3. <code>std::packaged_task</code></h3><p><code>std::packaged_task</code> 将可调用对象和 <code>std::future</code> 结合在一起，允许你在一个线程中异步执行可调用对象，并在其他线程中通过 <code>std::future</code> 获取结果。</p>
<h3 id="4-std-async"><a href="#4-std-async" class="headerlink" title="4. std::async"></a>4. <code>std::async</code></h3><p><code>std::async</code> 是一个函数，用于异步执行一个函数或可调用对象，并返回一个 <code>std::future</code> 对象，以便获取异步任务的结果。</p>
<h3 id="5-then-方法"><a href="#5-then-方法" class="headerlink" title="5. .then() 方法"></a>5. <code>.then()</code> 方法</h3><p>C++23 标准中引入的 <code>.then()</code> 方法允许将多个异步操作连接起来，以便在前一个操作完成后执行另一个操作。</p>
<p>这些类和函数提供了一种方便的方法来处理异步编程，允许程序在执行耗时的操作时不被阻塞，并在操作完成后获取结果或执行进一步的处理。</p>
<p>下面是一个简单示例，演示了如何使用 <code>std::future</code> 和 <code>std::promise</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_value</span><span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; fut)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = fut.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">print_thread</span><span class="params">(print_value, std::ref(fut))</span></span>;</span><br><span class="line"></span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    print_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::promise</code> 用于设置一个值，并通过 <code>std::future</code> 获取该值。<code>print_value</code> 函数在另一个线程中通过 <code>fut.get()</code> 获取值，并在主线程中调用 <code>prom.set_value()</code> 来设置这个值。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <future>标准库 详解</h2><p><code>&lt;future&gt;</code> 标准库提供了一系列用于异步编程的工具和类，包括 <code>std::future</code>、<code>std::promise</code>、<code>std::packaged_task</code> 等，以及一些与异步任务相关的函数，例如 <code>std::async</code>、<code>std::launch</code> 等。</p>
<h3 id="1-std-future-1"><a href="#1-std-future-1" class="headerlink" title="1. std::future"></a>1. <code>std::future</code></h3><p><code>std::future</code> 是一个模板类，表示异步操作的结果。它允许在一个线程中计算结果，并在另一个线程中等待获取这个结果。可以通过 <code>.get()</code> 方法获取结果值，或者通过 <code>.wait_for()</code> 和 <code>.wait_until()</code> 方法等待结果的完成。</p>
<h3 id="2-std-promise-1"><a href="#2-std-promise-1" class="headerlink" title="2. std::promise"></a>2. <code>std::promise</code></h3><p><code>std::promise</code> 允许在一个线程中设置一个值或异常，并在另一个线程中通过相关联的 <code>std::future</code> 获取该值或异常。通常用于线程间通信，其中一个线程设置结果，另一个线程等待获取结果。</p>
<h3 id="3-std-packaged-task-1"><a href="#3-std-packaged-task-1" class="headerlink" title="3. std::packaged_task"></a>3. <code>std::packaged_task</code></h3><p><code>std::packaged_task</code> 将可调用对象（函数、函数指针、仿函数等）与 <code>std::future</code> 结合起来，允许你在一个线程中异步执行可调用对象，并在其他线程中获取结果。</p>
<h3 id="4-std-async-1"><a href="#4-std-async-1" class="headerlink" title="4. std::async"></a>4. <code>std::async</code></h3><p><code>std::async</code> 是一个函数模板，用于在异步执行一个函数或可调用对象，并返回一个 <code>std::future</code> 对象以便获取异步任务的结果。它可以使用不同的策略来指定任务的执行方式。</p>
<h3 id="5-std-launch"><a href="#5-std-launch" class="headerlink" title="5. std::launch"></a>5. <code>std::launch</code></h3><p><code>std::launch</code> 枚举类型定义了在 <code>std::async</code> 中启动异步任务的不同策略，如 <code>std::launch::async</code> 表示立即启动一个新线程执行任务，而 <code>std::launch::deferred</code> 则推迟任务的执行，直到调用 <code>std::future</code> 对象的 <code>.get()</code> 方法时才执行。</p>
<p>这些类和函数提供了一种方便的方式来处理异步编程，允许程序在执行耗时的操作时不被阻塞，并在操作完成后获取结果或执行进一步的处理。异步编程使得在多线程和并发环境中更容易进行任务处理和线程间通信。</p>
<p>需要注意的是，异步编程需要谨慎处理，正确地管理资源和线程间通信，以避免出现竞态条件或死锁等问题。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <future>标准库 常用的类和函数</h2><p>C++ <code>&lt;future&gt;</code> 标准库提供了一些常用的类和函数，用于支持异步编程。以下是一些常用的类和函数：</p>
<h3 id="1-类："><a href="#1-类：" class="headerlink" title="1. 类："></a>1. 类：</h3><h4 id="std-future"><a href="#std-future" class="headerlink" title="std::future"></a><code>std::future</code></h4><ul>
<li>表示异步操作的结果。</li>
<li>方法：<code>.get()</code> 用于获取结果，<code>.wait_for()</code> 和 <code>.wait_until()</code> 用于等待结果完成，<code>.valid()</code> 用于检查 <code>future</code> 对象是否有效。</li>
</ul>
<h4 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a><code>std::promise</code></h4><ul>
<li>允许在一个线程中设置一个值或异常，并在另一个线程中通过 <code>std::future</code> 获取该值或异常。</li>
</ul>
<h4 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a><code>std::packaged_task</code></h4><ul>
<li>将可调用对象与 <code>std::future</code> 结合在一起，允许在一个线程中异步执行可调用对象，并在其他线程中获取结果。</li>
</ul>
<h3 id="2-函数："><a href="#2-函数：" class="headerlink" title="2. 函数："></a>2. 函数：</h3><h4 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a><code>std::async</code></h4><ul>
<li>用于异步执行函数或可调用对象，并返回一个 <code>std::future</code> 对象，以便获取异步任务的结果。</li>
<li>可以指定不同的启动策略 (<code>std::launch::async</code> 或 <code>std::launch::deferred</code>)。</li>
</ul>
<h4 id="then-方法（C-23-引入）"><a href="#then-方法（C-23-引入）" class="headerlink" title=".then() 方法（C++23 引入）"></a><code>.then()</code> 方法（C++23 引入）</h4><ul>
<li>允许将多个异步操作连接起来，在一个操作完成后执行另一个操作。</li>
</ul>
<p>这些类和函数提供了一种便捷的方式来处理异步编程，允许程序在执行耗时操作时不被阻塞，并在操作完成后获取结果或执行进一步的处理。异步编程是多线程和并发编程的重要组成部分，能够提高程序的性能和响应性。</p>
<h2 id="std-future-1"><a href="#std-future-1" class="headerlink" title="std::future"></a>std::future</h2><p><code>std::future</code> 是 C++ 标准库 <code>&lt;future&gt;</code> 中的一个模板类，用于表示异步操作的结果。它是一种通用的机制，允许你在一个线程中计算结果，并在另一个线程中等待获取这个结果。<code>std::future</code> 提供了一组方法来获取、等待、检查和处理异步操作的结果。</p>
<p>以下是 <code>std::future</code> 的一些主要特点和常用方法：</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li><strong>表示异步操作的结果：</strong> <code>std::future</code> 允许在一个线程中计算某个结果，并在另一个线程中等待获取这个结果。</li>
<li><strong>延迟获取结果：</strong> 当你创建一个异步任务时，可以在未来的某个时间点获取其结果。</li>
<li><strong>线程间通信：</strong> 允许线程之间共享结果，一个线程可以计算结果，另一个线程可以等待并获取结果。</li>
</ul>
<h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><ul>
<li><strong><code>.get()</code>:</strong> 获取异步操作的结果。它是一个阻塞方法，会阻塞当前线程直到结果准备就绪并返回结果值。</li>
<li><strong><code>.wait_for()</code>:</strong> 等待异步操作完成一段指定时间，如果在指定时间内操作完成则返回 <code>std::future_status::ready</code>。</li>
<li><strong><code>.wait_until()</code>:</strong> 等待异步操作完成直到指定的时间点，如果在指定时间点前操作完成则返回 <code>std::future_status::ready</code>。</li>
<li><strong><code>.valid()</code>:</strong> 检查 <code>std::future</code> 对象是否与异步操作相关联，如果 <code>std::future</code> 对象有效则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<p>以下是一个简单示例，展示了如何使用 <code>std::future</code> 获取异步操作的结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">performAsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动异步任务</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::async, performAsyncTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中进行其他操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;正在执行其他任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步任务完成并获取结果</span></span><br><span class="line">    <span class="type">int</span> asyncResult = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;异步任务的结果是: &quot;</span> &lt;&lt; asyncResult &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::future&lt;int&gt;</code> 对象 <code>result</code> 表示异步任务的结果，通过 <code>.get()</code> 方法获取结果。<code>performAsyncTask()</code> 函数是一个简单的模拟耗时操作的函数。在主线程中，执行其他任务后，通过 <code>result.get()</code> 等待异步任务完成并获取其结果。</p>
<h2 id="std-promise-1"><a href="#std-promise-1" class="headerlink" title="std::promise"></a>std::promise</h2><p><code>std::promise</code> 是 C++ 标准库 <code>&lt;future&gt;</code> 中的一个类模板，用于在一个线程中设置某个值或异常，并在另一个线程中通过相关联的 <code>std::future</code> 获取该值或异常。它允许一个线程设定某个值或异常，并且允许另一个线程在未来的某个时间点获取这个值或异常。</p>
<h3 id="主要特点："><a href="#主要特点：" class="headerlink" title="主要特点："></a>主要特点：</h3><ul>
<li><strong>线程间通信：</strong> <code>std::promise</code> 提供了一种线程间通信的方式，一个线程设置值或异常，另一个线程等待获取它。</li>
<li><strong>延迟设置结果：</strong> 允许一个线程在未来某个时间点设置值，而另一个线程在需要时获取该值。</li>
<li><strong>异常传递：</strong> 可以设置异常，使得等待的线程能够获取异常而不是一个值。</li>
</ul>
<h3 id="常用方法：-1"><a href="#常用方法：-1" class="headerlink" title="常用方法："></a>常用方法：</h3><ul>
<li><strong><code>std::promise::get_future()</code>:</strong> 返回一个关联的 <code>std::future</code> 对象，允许其他线程获取该 <code>promise</code> 对象的值或异常。</li>
<li><strong><code>std::promise::set_value()</code>:</strong> 设置值，使得关联的 <code>std::future</code> 对象能够获取这个值。</li>
<li><strong><code>std::promise::set_exception()</code>:</strong> 设置异常，使得等待的 <code>std::future</code> 对象能够获取异常。</li>
</ul>
<p>以下是一个简单示例，演示了 <code>std::promise</code> 的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp; prom)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟延迟设置值</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    prom.<span class="built_in">set_value</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">setterThread</span><span class="params">(setValue, std::ref(prom))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中进行其他操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;正在执行其他任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待设置值并获取结果</span></span><br><span class="line">    <span class="type">int</span> value = fut.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;获取到的值为: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    setterThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::promise&lt;int&gt;</code> 对象 <code>prom</code> 允许一个线程通过 <code>prom.set_value()</code> 设置值，并通过 <code>prom.get_future()</code> 获取与 <code>prom</code> 相关联的 <code>std::future&lt;int&gt;</code> 对象 <code>fut</code>。在主线程中，通过 <code>fut.get()</code> 方法等待获取这个值。另一个线程通过 <code>setValue()</code> 函数设置值。</p>
<h2 id="std-packaged-task-1"><a href="#std-packaged-task-1" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h2><p><code>std::packaged_task</code> 是 C++ 标准库 <code>&lt;future&gt;</code> 中提供的一个类模板，它将可调用对象（函数、函数指针、仿函数等）与 <code>std::future</code> 结合在一起，允许你在一个线程中异步执行可调用对象，并在其他线程中获取结果。</p>
<h3 id="主要特点：-1"><a href="#主要特点：-1" class="headerlink" title="主要特点："></a>主要特点：</h3><ul>
<li><strong>任务封装：</strong> <code>std::packaged_task</code> 封装了一个可调用对象，可以是函数、函数指针或者仿函数。</li>
<li><strong>异步执行：</strong> 可以在一个线程中异步执行封装的任务。</li>
<li><strong>关联 <code>std::future</code>：</strong> 每个 <code>std::packaged_task</code> 对象都与一个 <code>std::future</code> 对象关联，允许获取任务的结果。</li>
</ul>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用于执行一些操作，并返回结果</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">performTask</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 packaged_task 对象，并关联一个函数</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(performTask)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取与 packaged_task 关联的 future</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个新线程执行 packaged_task</span></span><br><span class="line">    <span class="function">std::thread <span class="title">taskThread</span><span class="params">(std::move(task), <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待任务完成并获取结果</span></span><br><span class="line">    <span class="type">int</span> result = fut.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;任务的结果是: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">    taskThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::packaged_task&lt;int(int, int)&gt; task(performTask);</code> 创建了一个 <code>std::packaged_task</code> 对象，并与 <code>performTask</code> 函数关联起来。通过 <code>task.get_future()</code> 获取与 <code>std::packaged_task</code> 对象关联的 <code>std::future</code> 对象。然后，通过 <code>std::thread</code> 启动一个新线程执行 <code>std::packaged_task</code> 对象，传递参数 <code>10</code> 和 <code>20</code> 给 <code>performTask</code> 函数。最后，通过 <code>fut.get()</code> 获取异步任务的结果。</p>
<p><code>std::packaged_task</code> 可以用于将任务和 <code>std::future</code> 结合在一起，使得在一个线程中执行任务，并在其他线程中获取结果变得更加方便。</p>
<h2 id="std-async-1"><a href="#std-async-1" class="headerlink" title="std::async"></a>std::async</h2><p><code>std::async</code> 是 C++ 标准库 <code>&lt;future&gt;</code> 中提供的一个函数模板，用于创建异步任务并返回一个 <code>std::future</code> 对象，以便获取异步任务的结果。</p>
<h3 id="主要特点：-2"><a href="#主要特点：-2" class="headerlink" title="主要特点："></a>主要特点：</h3><ul>
<li><strong>异步执行：</strong> <code>std::async</code> 可以异步执行一个函数或可调用对象，并返回一个 <code>std::future</code> 对象，用于获取异步任务的结果。</li>
<li><strong>灵活性：</strong> 允许指定不同的启动策略，例如 <code>std::launch::async</code> 表示立即启动一个新线程执行任务，而 <code>std::launch::deferred</code> 则推迟任务的执行，直到调用 <code>std::future</code> 对象的 <code>.get()</code> 方法时才执行。</li>
<li><strong>返回结果：</strong> 返回一个 <code>std::future</code> 对象，允许在未来的某个时间点获取异步任务的结果。</li>
</ul>
<h3 id="使用方法：-1"><a href="#使用方法：-1" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">performAsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟耗时操作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动异步任务</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::async, performAsyncTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中进行其他操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;正在执行其他任务...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待异步任务完成并获取结果</span></span><br><span class="line">    <span class="type">int</span> asyncResult = result.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;异步任务的结果是: &quot;</span> &lt;&lt; asyncResult &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::async</code> 函数启动一个异步任务来执行 <code>performAsyncTask()</code> 函数，使用 <code>std::launch::async</code> 策略，它表示立即在新线程中执行任务。在主线程中，执行其他操作后，通过 <code>result.get()</code> 方法等待异步任务完成并获取其结果。</p>
<p><code>std::async</code> 函数是一个非常方便的工具，可以用于创建异步任务，并且使得异步编程更加简单。通过指定不同的启动策略，可以灵活控制任务的执行方式。</p>
<h2 id="std-launch"><a href="#std-launch" class="headerlink" title="std::launch"></a>std::launch</h2><p><code>std::launch</code> 是一个枚举类型，用于指定 <code>std::async</code> 启动异步任务的策略。它允许你控制异步任务的执行方式。</p>
<p>主要的枚举值有两个：</p>
<h3 id="1-std-launch-async"><a href="#1-std-launch-async" class="headerlink" title="1. std::launch::async"></a>1. <code>std::launch::async</code></h3><ul>
<li>这个策略表示在调用 <code>std::async</code> 时立即启动一个新的线程来执行任务。</li>
<li>调用 <code>std::async</code> 时使用 <code>std::launch::async</code> 策略，会导致任务立即在一个新线程中执行，除非系统资源不足，否则不会推迟执行。</li>
</ul>
<h3 id="2-std-launch-deferred"><a href="#2-std-launch-deferred" class="headerlink" title="2. std::launch::deferred"></a>2. <code>std::launch::deferred</code></h3><ul>
<li>这个策略表示推迟任务的执行，直到调用 <code>std::future</code> 对象的 <code>.get()</code> 方法时才执行。</li>
<li>使用 <code>std::launch::deferred</code> 策略调用 <code>std::async</code> 时，不会立即执行任务，而是在调用返回的 <code>std::future</code> 对象的 <code>.get()</code> 方法时才执行任务，且在调用 <code>.get()</code> 之前不会创建新线程。</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">performTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;执行任务&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut_async = std::<span class="built_in">async</span>(std::launch::async, performTask);</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; fut_deferred = std::<span class="built_in">async</span>(std::launch::deferred, performTask);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;其他操作...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result_async = fut_async.<span class="built_in">get</span>();</span><br><span class="line">    <span class="type">int</span> result_deferred = fut_deferred.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::async(std::launch::async, performTask)</code> 使用 <code>std::launch::async</code> 策略启动了一个异步任务，而 <code>std::async(std::launch::deferred, performTask)</code> 使用 <code>std::launch::deferred</code> 策略推迟了任务的执行。在主线程中执行其他操作后，通过 <code>fut_async.get()</code> 和 <code>fut_deferred.get()</code> 获取了异步任务的结果。请注意，对于 <code>std::launch::deferred</code> 策略，任务会在调用 <code>.get()</code> 时执行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_35_bitset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_35_bitset/" class="post-title-link" itemprop="url">C++_10_35_bitset</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <bitset>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <bitset>标准库</h2><p><code>&lt;bitset&gt;</code> 标准库是 C++ 中用于处理固定大小位集的头文件。它提供了 <code>std::bitset</code> 类模板，用于表示固定长度的位序列，并允许对其进行操作。</p>
<h3 id="std-bitset-类"><a href="#std-bitset-类" class="headerlink" title="std::bitset 类"></a><code>std::bitset</code> 类</h3><p><code>std::bitset</code> 是一个固定大小的位集容器。它允许你以比特的形式存储和操作位（0 或 1）。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ol>
<li><p><strong>构造函数</strong>: 可以使用多种方式初始化 <code>std::bitset</code>。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::bitset&lt;8&gt; bits1; <span class="comment">// 初始化一个包含8位的位集，默认所有位都是0</span></span><br><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">bits2</span><span class="params">(<span class="number">42</span>)</span></span>; <span class="comment">// 使用整数初始化位集</span></span><br><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">bits3</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>; <span class="comment">// 使用字符串表示初始化位集</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>位操作</strong>: 可以执行位操作如设置、清除、翻转和获取位的值。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bits<span class="number">1.</span><span class="built_in">set</span>(<span class="number">3</span>, <span class="literal">true</span>); <span class="comment">// 设置第3位为1</span></span><br><span class="line">bits<span class="number">2.</span><span class="built_in">reset</span>(<span class="number">4</span>); <span class="comment">// 清除第4位</span></span><br><span class="line">bits<span class="number">3.f</span>lip(<span class="number">1</span>); <span class="comment">// 翻转第1位的值</span></span><br><span class="line"><span class="type">bool</span> value = bits<span class="number">1.</span><span class="built_in">test</span>(<span class="number">2</span>); <span class="comment">// 获取第2位的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转换与访问</strong>: 可以将位集转换为其他数据类型或者访问其内部表示。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ulong_val = bits<span class="number">1.</span><span class="built_in">to_ulong</span>(); <span class="comment">// 将位集转换为无符号长整型</span></span><br><span class="line">std::string str_val = bits<span class="number">2.</span><span class="built_in">to_string</span>(); <span class="comment">// 将位集转换为字符串表示</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运算符重载</strong>: <code>std::bitset</code> 支持多种位运算符的重载，例如 <code>&amp;</code>、<code>|</code>、<code>^</code> 等，可以进行位与、位或和位异或等操作。</p>
</li>
<li><p><strong>大小和操作</strong>: <code>std::bitset</code> 提供了一些成员函数来获取位集的大小和进行操作，如 <code>size()</code> 返回位集的大小，<code>count()</code> 返回位集中设置为 1 的位的数量。</p>
</li>
</ol>
<h4 id="限制和注意事项"><a href="#限制和注意事项" class="headerlink" title="限制和注意事项"></a>限制和注意事项</h4><ul>
<li><code>std::bitset</code> 的大小必须在编译时确定，并且是固定的。</li>
<li>对于大尺寸的位集，可能会占用较多的内存空间。</li>
</ul>
<p>这个标准库头文件 <code>&lt;bitset&gt;</code> 提供了一些简单而强大的功能，可用于位级操作和处理。使用 <code>std::bitset</code> 可以方便地进行位操作，这在一些需要位级别控制的情况下非常有用。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <bitset>标准库 详解</h2><p><code>&lt;bitset&gt;</code> 是 C++ 标准库中用于处理固定大小位集合的头文件。它提供了 <code>std::bitset</code> 类，用于表示固定长度的位序列，并允许对其进行各种操作。以下是 <code>&lt;bitset&gt;</code> 标准库的详细解释：</p>
<h3 id="std-bitset-类-1"><a href="#std-bitset-类-1" class="headerlink" title="std::bitset 类"></a><code>std::bitset</code> 类</h3><p><code>std::bitset</code> 是一个固定大小的位集容器，每个位的状态可以是 0 或 1。它提供了许多函数和操作符，允许对位集进行各种操作。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li><p><strong>默认构造函数</strong>: <code>std::bitset</code> 可以使用默认构造函数创建，位集中的所有位都被初始化为 0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::bitset&lt;8&gt; bits1; <span class="comment">// 初始化一个包含8位的位集，默认所有位都是0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>整数和字符串构造函数</strong>: <code>std::bitset</code> 可以使用整数或字符串来初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">bits2</span><span class="params">(<span class="number">42</span>)</span></span>; <span class="comment">// 使用整数初始化位集</span></span><br><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">bits3</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>; <span class="comment">// 使用字符串表示初始化位集</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h4><p><code>std::bitset</code> 提供了一系列用于位操作的成员函数：</p>
<ul>
<li><p><strong>set()</strong>: 将指定位置的位设置为指定值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bits<span class="number">1.</span><span class="built_in">set</span>(<span class="number">3</span>, <span class="literal">true</span>); <span class="comment">// 设置第3位为1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>reset()</strong>: 将指定位置的位重置为0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bits<span class="number">2.</span><span class="built_in">reset</span>(<span class="number">4</span>); <span class="comment">// 清除第4位</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>flip()</strong>: 翻转指定位置的位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bits<span class="number">3.f</span>lip(<span class="number">1</span>); <span class="comment">// 翻转第1位的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>test()</strong>: 检查指定位置的位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> value = bits<span class="number">1.</span><span class="built_in">test</span>(<span class="number">2</span>); <span class="comment">// 获取第2位的值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="转换和访问"><a href="#转换和访问" class="headerlink" title="转换和访问"></a>转换和访问</h4><p><code>std::bitset</code> 支持将位集转换为其他类型，并访问其内部表示：</p>
<ul>
<li><p><strong>to_ulong()</strong>: 将位集转换为无符号长整型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ulong_val = bits<span class="number">1.</span><span class="built_in">to_ulong</span>(); <span class="comment">// 将位集转换为无符号长整型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>to_string()</strong>: 将位集转换为字符串表示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::string str_val = bits<span class="number">2.</span><span class="built_in">to_string</span>(); <span class="comment">// 将位集转换为字符串表示</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p><code>std::bitset</code> 支持多种位运算符的重载，如 <code>&amp;</code>、<code>|</code>、<code>^</code> 等，可以进行位与、位或和位异或等操作。</p>
<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><ul>
<li><p><strong>size()</strong>: 获取位集的大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> size = bits<span class="number">1.</span><span class="built_in">size</span>(); <span class="comment">// 获取位集的大小</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>count()</strong>: 获取位集中设置为 1 的位的数量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> count = bits<span class="number">2.</span><span class="built_in">count</span>(); <span class="comment">// 获取位集中设置为1的位的数量</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>std::bitset</code> 在进行位级操作时非常有用，它提供了一种简单且高效的方式来处理固定大小的位序列。通过这个类，可以执行各种位操作，如设置、清除、翻转和获取位的值，以及进行位级运算等。</p>
<h2 id="C-标准库-常用的类和函数"><a href="#C-标准库-常用的类和函数" class="headerlink" title="C++ 标准库 常用的类和函数"></a>C++ <bitset>标准库 常用的类和函数</h2><p>在 <code>&lt;bitset&gt;</code> 标准库中，最主要和常用的类就是 <code>std::bitset</code>。这个类提供了一系列方法和操作符，用于处理固定大小的位集合。以下是 <code>std::bitset</code> 常用的一些类成员函数和操作符：</p>
<h3 id="std-bitset-常用的成员函数："><a href="#std-bitset-常用的成员函数：" class="headerlink" title="std::bitset 常用的成员函数："></a><code>std::bitset</code> 常用的成员函数：</h3><h4 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h4><ul>
<li><code>std::bitset&lt;size&gt;</code>：默认构造函数，创建一个包含 <code>size</code> 位的位集，默认所有位都是0。</li>
</ul>
<h4 id="操作函数："><a href="#操作函数：" class="headerlink" title="操作函数："></a>操作函数：</h4><ul>
<li><code>set(pos, value)</code>：将指定位置 <code>pos</code> 的位设置为 <code>value</code>。</li>
<li><code>reset(pos)</code>：将指定位置 <code>pos</code> 的位重置为0。</li>
<li><code>flip(pos)</code>：翻转指定位置 <code>pos</code> 的位。</li>
</ul>
<h4 id="查询函数："><a href="#查询函数：" class="headerlink" title="查询函数："></a>查询函数：</h4><ul>
<li><code>test(pos)</code>：检查指定位置 <code>pos</code> 的位。</li>
</ul>
<h4 id="转换函数："><a href="#转换函数：" class="headerlink" title="转换函数："></a>转换函数：</h4><ul>
<li><code>to_ulong()</code>：将位集转换为无符号长整型。</li>
<li><code>to_ullong()</code>：将位集转换为无符号长长整型。</li>
<li><code>to_string()</code>：将位集转换为字符串表示。</li>
</ul>
<h4 id="运算符重载："><a href="#运算符重载：" class="headerlink" title="运算符重载："></a>运算符重载：</h4><p><code>std::bitset</code> 支持多种位运算符的重载，可以进行位与 <code>&amp;</code>、位或 <code>|</code>、位异或 <code>^</code> 等操作。</p>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::bitset&lt;8&gt; bits; <span class="comment">// 创建一个8位的位集，默认所有位都是0</span></span><br><span class="line"></span><br><span class="line">    bits.<span class="built_in">set</span>(<span class="number">3</span>, <span class="literal">true</span>); <span class="comment">// 设置第3位为1</span></span><br><span class="line">    bits.<span class="built_in">reset</span>(<span class="number">4</span>); <span class="comment">// 清除第4位</span></span><br><span class="line">    bits.<span class="built_in">flip</span>(<span class="number">1</span>); <span class="comment">// 翻转第1位的值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> value = bits.<span class="built_in">test</span>(<span class="number">2</span>); <span class="comment">// 获取第2位的值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulong_val = bits.<span class="built_in">to_ulong</span>(); <span class="comment">// 将位集转换为无符号长整型</span></span><br><span class="line">    std::string str_val = bits.<span class="built_in">to_string</span>(); <span class="comment">// 将位集转换为字符串表示</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bitset: &quot;</span> &lt;&lt; bits &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value at position 2: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted to unsigned long: &quot;</span> &lt;&lt; ulong_val &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted to string: &quot;</span> &lt;&lt; str_val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::bitset</code> 的常用函数和运算符的用法。你可以使用这些方法来进行位级操作，查询位的值，将位集转换为其他类型等操作。</p>
<h2 id="std-bitset"><a href="#std-bitset" class="headerlink" title="std::bitset"></a>std::bitset</h2><p><code>std::bitset</code> 是 C++ 标准库中用于表示固定大小位集的类。它允许你以位（0 或 1）的形式存储和操作固定长度的二进制数据。</p>
<h3 id="特点和功能："><a href="#特点和功能：" class="headerlink" title="特点和功能："></a>特点和功能：</h3><ol>
<li><p><strong>固定长度的位集合：</strong> <code>std::bitset</code> 表示一个固定大小的位序列，位的数量在编译时即确定。</p>
</li>
<li><p><strong>初始化方式：</strong> 可以使用整数、字符串或默认构造函数来初始化 <code>std::bitset</code> 对象。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::bitset&lt;8&gt; bits1; <span class="comment">// 初始化一个包含8位的位集，默认所有位都是0</span></span><br><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">bits2</span><span class="params">(<span class="number">42</span>)</span></span>; <span class="comment">// 使用整数初始化位集</span></span><br><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">bits3</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>; <span class="comment">// 使用字符串表示初始化位集</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>位操作函数：</strong> 提供了一系列的函数来操作位，如设置、清除、翻转和检查位的状态。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bits<span class="number">1.</span><span class="built_in">set</span>(<span class="number">3</span>, <span class="literal">true</span>); <span class="comment">// 设置第3位为1</span></span><br><span class="line">bits<span class="number">2.</span><span class="built_in">reset</span>(<span class="number">4</span>); <span class="comment">// 清除第4位</span></span><br><span class="line">bits<span class="number">3.f</span>lip(<span class="number">1</span>); <span class="comment">// 翻转第1位的值</span></span><br><span class="line"><span class="type">bool</span> value = bits<span class="number">1.</span><span class="built_in">test</span>(<span class="number">2</span>); <span class="comment">// 获取第2位的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转换函数：</strong> 可以将位集转换为其他数据类型，如整数或字符串。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ulong_val = bits<span class="number">1.</span><span class="built_in">to_ulong</span>(); <span class="comment">// 将位集转换为无符号长整型</span></span><br><span class="line">std::string str_val = bits<span class="number">2.</span><span class="built_in">to_string</span>(); <span class="comment">// 将位集转换为字符串表示</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>位运算符重载：</strong> 支持多种位运算符的重载，如 <code>&amp;</code>、<code>|</code>、<code>^</code> 等，可以进行位与、位或和位异或等操作。</p>
</li>
</ol>
<h3 id="示例用法：-1"><a href="#示例用法：-1" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::bitset&lt;8&gt; bits; <span class="comment">// 创建一个8位的位集，默认所有位都是0</span></span><br><span class="line"></span><br><span class="line">    bits.<span class="built_in">set</span>(<span class="number">3</span>, <span class="literal">true</span>); <span class="comment">// 设置第3位为1</span></span><br><span class="line">    bits.<span class="built_in">reset</span>(<span class="number">4</span>); <span class="comment">// 清除第4位</span></span><br><span class="line">    bits.<span class="built_in">flip</span>(<span class="number">1</span>); <span class="comment">// 翻转第1位的值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> value = bits.<span class="built_in">test</span>(<span class="number">2</span>); <span class="comment">// 获取第2位的值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulong_val = bits.<span class="built_in">to_ulong</span>(); <span class="comment">// 将位集转换为无符号长整型</span></span><br><span class="line">    std::string str_val = bits.<span class="built_in">to_string</span>(); <span class="comment">// 将位集转换为字符串表示</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bitset: &quot;</span> &lt;&lt; bits &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value at position 2: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted to unsigned long: &quot;</span> &lt;&lt; ulong_val &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted to string: &quot;</span> &lt;&lt; str_val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了 <code>std::bitset</code> 的常用功能。通过 <code>std::bitset</code>，你可以轻松进行位级操作，并将位集转换为其他数据类型，如整数或字符串。</p>
<h2 id="std-bitset-set"><a href="#std-bitset-set" class="headerlink" title="std::bitset::set"></a>std::bitset::set</h2><p><code>std::bitset::set</code> 是 <code>std::bitset</code> 类中的一个成员函数，用于设置位集中指定位置的位为指定的值（0 或 1）。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">bool</span> value = <span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>pos</code>：要设置的位的位置，从 0 开始计数。</li>
<li><code>value</code>：要设置的值，默认为 <code>true</code>，表示设置该位为 1；若设置为 <code>false</code>，则表示设置该位为 0。</li>
</ul>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>set</code> 函数用于将 <code>std::bitset</code> 中指定位置 <code>pos</code> 的位设置为指定的值 <code>value</code>。当 <code>value</code> 被设置为 <code>true</code> 时，默认将该位设置为 1；当 <code>value</code> 被设置为 <code>false</code> 时，则将该位设置为 0。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::bitset&lt;8&gt; bits; <span class="comment">// 创建一个8位的位集，默认所有位都是0</span></span><br><span class="line"></span><br><span class="line">    bits.<span class="built_in">set</span>(<span class="number">3</span>); <span class="comment">// 设置第3位为1</span></span><br><span class="line">    bits.<span class="built_in">set</span>(<span class="number">4</span>, <span class="literal">false</span>); <span class="comment">// 设置第4位为0</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bitset after setting bit 3 and clearing bit 4: &quot;</span> &lt;&lt; bits &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>bits.set(3)</code> 将第3位设置为1，<code>bits.set(4, false)</code> 将第4位设置为0。最终输出位集中的状态。</p>
<h2 id="std-bitset-reset"><a href="#std-bitset-reset" class="headerlink" title="std::bitset::reset"></a>std::bitset::reset</h2><p><code>std::bitset::reset</code> 是 <code>std::bitset</code> 类中的一个成员函数，用于将位集中指定位置的位重置为 0。</p>
<h3 id="函数签名：-1"><a href="#函数签名：-1" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">size_t</span> pos)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>pos</code>：要重置的位的位置，从 0 开始计数。</li>
</ul>
<h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>reset</code> 函数将 <code>std::bitset</code> 中指定位置 <code>pos</code> 的位重置为 0。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::bitset&lt;8&gt; bits; <span class="comment">// 创建一个8位的位集，默认所有位都是0</span></span><br><span class="line"></span><br><span class="line">    bits.<span class="built_in">set</span>(<span class="number">3</span>); <span class="comment">// 设置第3位为1</span></span><br><span class="line">    bits.<span class="built_in">reset</span>(<span class="number">4</span>); <span class="comment">// 清除第4位</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bitset after setting bit 3 and clearing bit 4: &quot;</span> &lt;&lt; bits &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>bits.set(3)</code> 将第3位设置为1，<code>bits.reset(4)</code> 清除（重置为0）了第4位。最终输出位集中的状态。</p>
<h2 id="std-bitset-flip"><a href="#std-bitset-flip" class="headerlink" title="std::bitset::flip"></a>std::bitset::flip</h2><p><code>std::bitset::flip</code> 是 <code>std::bitset</code> 类中的一个成员函数，用于翻转位集中指定位置的位（将 0 变为 1，将 1 变为 0）。</p>
<h3 id="函数签名：-2"><a href="#函数签名：-2" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(<span class="type">size_t</span> pos)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-2"><a href="#参数：-2" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>pos</code>：要翻转的位的位置，从 0 开始计数。</li>
</ul>
<h3 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>flip</code> 函数将 <code>std::bitset</code> 中指定位置 <code>pos</code> 的位进行翻转，即将 0 变为 1，将 1 变为 0。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::bitset&lt;8&gt; bits; <span class="comment">// 创建一个8位的位集，默认所有位都是0</span></span><br><span class="line"></span><br><span class="line">    bits.<span class="built_in">set</span>(<span class="number">3</span>); <span class="comment">// 设置第3位为1</span></span><br><span class="line">    bits.<span class="built_in">flip</span>(<span class="number">4</span>); <span class="comment">// 翻转第4位</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bitset after setting bit 3 and flipping bit 4: &quot;</span> &lt;&lt; bits &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>bits.set(3)</code> 将第3位设置为1，<code>bits.flip(4)</code> 对第4位进行翻转操作。最终输出位集中的状态。</p>
<h2 id="std-bitset-test"><a href="#std-bitset-test" class="headerlink" title="std::bitset::test"></a>std::bitset::test</h2><p><code>std::bitset::test</code> 是 <code>std::bitset</code> 类中的一个成员函数，用于检查位集中指定位置的位的状态。</p>
<h3 id="函数签名：-3"><a href="#函数签名：-3" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">size_t</span> pos)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-3"><a href="#参数：-3" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>pos</code>：要检查的位的位置，从 0 开始计数。</li>
</ul>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>bool</code>：如果指定位置 <code>pos</code> 的位为 1，则返回 <code>true</code>；如果为 0，则返回 <code>false</code>。</li>
</ul>
<h3 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>test</code> 函数用于检查 <code>std::bitset</code> 中指定位置 <code>pos</code> 的位的状态。</li>
</ul>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bits</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>; <span class="comment">// 初始化一个8位的位集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> value1 = bits.<span class="built_in">test</span>(<span class="number">2</span>); <span class="comment">// 获取第2位的值</span></span><br><span class="line">    <span class="type">bool</span> value2 = bits.<span class="built_in">test</span>(<span class="number">5</span>); <span class="comment">// 获取第5位的值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value at position 2: &quot;</span> &lt;&lt; value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value at position 5: &quot;</span> &lt;&lt; value2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>bits</code> 是一个包含 8 位的位集。<code>bits.test(2)</code> 检查第2位的值，<code>bits.test(5)</code> 检查第5位的值，并将结果输出。</p>
<h2 id="std-bitset-to-ulong"><a href="#std-bitset-to-ulong" class="headerlink" title="std::bitset::to_ulong"></a>std::bitset::to_ulong</h2><p><code>std::bitset::to_ulong</code> 是 <code>std::bitset</code> 类中的一个成员函数，用于将位集转换为对应的无符号长整型（<code>unsigned long</code>）数值。</p>
<h3 id="函数签名：-4"><a href="#函数签名：-4" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">to_ulong</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>unsigned long</code>：位集表示的无符号长整型数值。</li>
</ul>
<h3 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>to_ulong</code> 函数用于将 <code>std::bitset</code> 中存储的二进制位序列转换为对应的无符号长整型数值。这个函数会将位集中的二进制位转换为对应的整数值。</li>
</ul>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>如果 <code>std::bitset</code> 的大小超过了 <code>unsigned long</code> 的位数，将会抛出 <code>std::overflow_error</code> 异常。</li>
</ul>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bits</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>; <span class="comment">// 初始化一个8位的位集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulong_val = bits.<span class="built_in">to_ulong</span>(); <span class="comment">// 将位集转换为无符号长整型数值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted to unsigned long: &quot;</span> &lt;&lt; ulong_val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>bits</code> 是一个包含 8 位的位集。<code>bits.to_ulong()</code> 将位集转换为对应的无符号长整型数值，并将结果输出。</p>
<h2 id="std-bitset-to-string"><a href="#std-bitset-to-string" class="headerlink" title="std::bitset::to_string"></a>std::bitset::to_string</h2><p><code>std::bitset::to_string</code> 是 <code>std::bitset</code> 类中的一个成员函数，用于将位集转换为对应的字符串表示形式。</p>
<h3 id="函数签名：-5"><a href="#函数签名：-5" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>std::string</code>：表示位集的字符串。</li>
</ul>
<h3 id="功能：-5"><a href="#功能：-5" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>to_string</code> 函数用于将 <code>std::bitset</code> 中存储的二进制位序列转换为字符串表示形式。这个函数会返回一个字符串，其中包含了位集的二进制表示。</li>
</ul>
<h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bits</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>; <span class="comment">// 初始化一个8位的位集</span></span><br><span class="line"></span><br><span class="line">    std::string str_val = bits.<span class="built_in">to_string</span>(); <span class="comment">// 将位集转换为字符串表示形式</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Converted to string: &quot;</span> &lt;&lt; str_val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>bits</code> 是一个包含 8 位的位集。<code>bits.to_string()</code> 将位集转换为对应的字符串表示，并将结果输出。</p>
<h2 id="std-bitset-size"><a href="#std-bitset-size" class="headerlink" title="std::bitset::size"></a>std::bitset::size</h2><p><code>std::bitset::size</code> 是 <code>std::bitset</code> 类中的一个成员函数，用于获取位集的大小，即位集中包含的位数。</p>
<h3 id="函数签名：-6"><a href="#函数签名：-6" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>size_t</code>：位集中包含的位数。</li>
</ul>
<h3 id="功能：-6"><a href="#功能：-6" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>size</code> 函数用于获取 <code>std::bitset</code> 中包含的位数，即位集的大小。返回值为 <code>size_t</code> 类型，表示位集中的位数。</li>
</ul>
<h3 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::bitset&lt;8&gt; bits; <span class="comment">// 创建一个8位的位集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> bits_size = bits.<span class="built_in">size</span>(); <span class="comment">// 获取位集的大小</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of the bitset: &quot;</span> &lt;&lt; bits_size &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>bits</code> 是一个包含 8 位的位集。<code>bits.size()</code> 获取位集的大小，并将结果输出。</p>
<h2 id="std-bitset-count"><a href="#std-bitset-count" class="headerlink" title="std::bitset::count"></a>std::bitset::count</h2><p><code>std::bitset::count</code> 是 <code>std::bitset</code> 类中的一个成员函数，用于计算位集中被设置为 1 的位的数量。</p>
<h3 id="函数签名：-7"><a href="#函数签名：-7" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="返回值：-4"><a href="#返回值：-4" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li><code>size_t</code>：位集中被设置为 1 的位的数量。</li>
</ul>
<h3 id="功能：-7"><a href="#功能：-7" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>count</code> 函数用于计算 <code>std::bitset</code> 中被设置为 1 的位的数量，即统计位集中值为 1 的位的个数。</li>
</ul>
<h3 id="示例：-7"><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::bitset&lt;8&gt; <span class="title">bits</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>; <span class="comment">// 初始化一个8位的位集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> count_of_ones = bits.<span class="built_in">count</span>(); <span class="comment">// 计算位集中被设置为1的位的数量</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Count of ones in the bitset: &quot;</span> &lt;&lt; count_of_ones &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>bits</code> 是一个包含 8 位的位集。<code>bits.count()</code> 统计位集中被设置为 1 的位的数量，并将结果输出。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_36_ratio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_36_ratio/" class="post-title-link" itemprop="url">C++_10_36_ratio</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <ratio>标准库</li>
</ul>
<h2 id="C-是什么"><a href="#C-是什么" class="headerlink" title="C++ 是什么"></a>C++ <ratio>是什么</h2><p>在C++中，<code>&lt;ratio&gt;</code> 是一个头文件，定义了用于表示有理数的模板类 <code>std::ratio</code>。这个头文件引入了与比例相关的模板类，允许在编译时进行精确的有理数计算，通常用于 <code>&lt;chrono&gt;</code> 头文件中，用于定义时间单位。</p>
<h3 id="std-ratio-模板类"><a href="#std-ratio-模板类" class="headerlink" title="std::ratio 模板类"></a><code>std::ratio</code> 模板类</h3><p><code>std::ratio</code> 是一个用于表示有理数的模板类，它的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">intmax_t</span> Num, std::<span class="type">intmax_t</span> Den = <span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">class</span> ratio;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>Num</code> 表示有理数的分子，默认为 1。</li>
<li><code>Den</code> 表示有理数的分母，默认为 1。</li>
</ul>
<p>这个模板类用于表示编译时常量的比率，通常用于 <code>&lt;chrono&gt;</code> 中，定义了时间单位的比例。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一个简单的示例，展示如何使用 <code>std::ratio</code> 来表示一个比例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示比例为 2:3</span></span><br><span class="line">    std::ratio&lt;<span class="number">2</span>, <span class="number">3</span>&gt; myRatio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取分子和分母</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Numerator: &quot;</span> &lt;&lt; myRatio.num &lt;&lt; std::endl;   <span class="comment">// 输出 2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Denominator: &quot;</span> &lt;&lt; myRatio.den &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::ratio&lt;2, 3&gt;</code> 表示比例为 2:3 的有理数。</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><code>std::ratio</code> 的主要用途之一是在 <code>&lt;chrono&gt;</code> 头文件中，用于定义 <code>std::chrono::duration</code> 类型的时间单位。例如，<code>std::ratio&lt;1, 1000&gt;</code> 表示毫秒，<code>std::ratio&lt;60&gt;</code> 表示分钟，等等。这种有理数表示方式在编译时提供了更高的精确度，尤其在需要进行时间单位转换和计算的场景中非常有用。</p>
<h2 id="C-std-ratio详解"><a href="#C-std-ratio详解" class="headerlink" title="C++ std::ratio详解"></a>C++ std::ratio详解</h2><p><code>std::ratio</code> 是 C++11 标准引入的一个模板类，用于表示有理数。它定义在 <code>&lt;ratio&gt;</code> 头文件中。这个模板类非常简单，只有两个整数模板参数，分别表示有理数的分子和分母。</p>
<p>以下是关于 <code>std::ratio</code> 的详细解释：</p>
<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">intmax_t</span> Num, std::<span class="type">intmax_t</span> Den = <span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">class</span> ratio;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Num</code>：表示有理数的分子。</li>
<li><code>Den</code>：表示有理数的分母，默认为 1。</li>
</ul>
<h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示比例为 2:3</span></span><br><span class="line">    std::ratio&lt;<span class="number">2</span>, <span class="number">3</span>&gt; myRatio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取分子和分母</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Numerator: &quot;</span> &lt;&lt; myRatio.num &lt;&lt; std::endl;   <span class="comment">// 输出 2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Denominator: &quot;</span> &lt;&lt; myRatio.den &lt;&lt; std::endl; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-成员变量"><a href="#3-成员变量" class="headerlink" title="3. 成员变量"></a>3. 成员变量</h3><ul>
<li><code>num</code>：表示有理数的分子。</li>
<li><code>den</code>：表示有理数的分母。</li>
</ul>
<h3 id="4-成员函数"><a href="#4-成员函数" class="headerlink" title="4. 成员函数"></a>4. 成员函数</h3><p><code>std::ratio</code> 提供了一些用于执行在编译时进行的算术运算的静态成员函数，例如：</p>
<ul>
<li><code>add&lt;R1, R2&gt;</code>：将两个有理数相加。</li>
<li><code>subtract&lt;R1, R2&gt;</code>：将一个有理数减去另一个有理数。</li>
<li><code>multiply&lt;R1, R2&gt;</code>：将两个有理数相乘。</li>
<li><code>divide&lt;R1, R2&gt;</code>：将一个有理数除以另一个有理数。</li>
</ul>
<p>这些函数返回的都是新的 <code>std::ratio</code> 类型。</p>
<h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. 应用场景</h3><p><code>std::ratio</code> 主要用于在编译时执行精确的比例运算，特别适用于模板元编程或其他需要在编译时进行常量计算的场景。通过使用 <code>std::ratio</code>，可以避免运行时计算的误差，并在编译时得到准确的结果。</p>
<h3 id="6-示例：编译时计算"><a href="#6-示例：编译时计算" class="headerlink" title="6. 示例：编译时计算"></a>6. 示例：编译时计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> r1 = std::ratio&lt;<span class="number">2</span>, <span class="number">3</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> r2 = std::ratio&lt;<span class="number">3</span>, <span class="number">4</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两个有理数的乘积在编译时得到结果</span></span><br><span class="line">    <span class="keyword">using</span> result_ratio = std::ratio_multiply&lt;r1, r2&gt;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result Numerator: &quot;</span> &lt;&lt; result_ratio::num &lt;&lt; std::endl;   <span class="comment">// 输出 6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result Denominator: &quot;</span> &lt;&lt; result_ratio::den &lt;&lt; std::endl; <span class="comment">// 输出 12</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个简单的示例，展示了如何在编译时计算两个有理数的乘积。这种编译时计算可以用于优化和精确控制程序的行为。</p>
<h2 id="C-chrono标准库中使用std-ratio表示秒"><a href="#C-chrono标准库中使用std-ratio表示秒" class="headerlink" title="C++ chrono标准库中使用std::ratio表示秒"></a>C++ chrono标准库中使用std::ratio表示秒</h2><p>在C++标准库中，<code>std::chrono</code> 提供了一种灵活的方式来表示时间间隔，并且可以使用 <code>std::ratio</code> 来指定时间单位。对于秒的表示，可以使用 <code>std::ratio</code> 中的 <code>std::ratio&lt;1, 1&gt;</code>，因为默认情况下，<code>std::ratio</code> 的分子和分母都是1。</p>
<p>以下是一个示例，演示如何使用 <code>std::chrono</code> 表示秒：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示 2 秒的时间间隔</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">int</span>&gt; <span class="title">duration_seconds</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Duration in seconds: &quot;</span> &lt;&lt; duration_seconds.<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::chrono::duration&lt;int&gt;</code> 表示了一个时间间隔为 2 秒的对象，其中 <code>std::ratio&lt;1, 1&gt;</code> 被用作时间单位，表示秒。因为 <code>std::ratio</code> 是一个通用的模板类，你可以根据需要选择不同的分子和分母来表示其他时间单位。例如，使用 <code>std::ratio&lt;1, 1000&gt;</code> 表示毫秒，或者 <code>std::ratio&lt;60&gt;</code> 表示分钟。这种灵活性使得 <code>std::chrono</code> 非常适合处理各种时间单位和精度。</p>
<h2 id="C-std-chrono-duration-和-std-ratio"><a href="#C-std-chrono-duration-和-std-ratio" class="headerlink" title="C++ std::chrono::duration 和 std::ratio"></a>C++ std::chrono::duration 和 std::ratio</h2><p>在C++中，<code>std::chrono::duration</code> 和 <code>std::ratio</code> 是与时间相关的两个重要的组件，用于实现时间单位和时间间隔的表示。</p>
<h3 id="1-std-ratio"><a href="#1-std-ratio" class="headerlink" title="1. std::ratio"></a>1. <code>std::ratio</code></h3><p><code>std::ratio</code> 是一个用于表示有理数的模板类，定义在 <code>&lt;ratio&gt;</code> 头文件中。它通常用于定义时间单位的比率。例如，秒、毫秒、微秒等时间单位可以通过不同的 <code>std::ratio</code> 实例来表示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示比例为 1:1000，用于表示毫秒</span></span><br><span class="line">    <span class="keyword">using</span> milli = std::ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::chrono::duration 表示 5 毫秒</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">int</span>, milli&gt; <span class="title">duration</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Duration in milliseconds: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-std-chrono-duration"><a href="#2-std-chrono-duration" class="headerlink" title="2. std::chrono::duration"></a>2. <code>std::chrono::duration</code></h3><p><code>std::chrono::duration</code> 是一个模板类，定义在 <code>&lt;chrono&gt;</code> 头文件中。它表示时间间隔，可以用不同的时间单位来表示。<code>std::chrono::duration</code> 接受两个模板参数：第一个表示时间的数值类型，第二个表示时间单位的类型（通常是 <code>std::ratio</code>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示 5 秒的时间间隔</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">int</span>&gt; <span class="title">duration_seconds</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示 500 毫秒的时间间隔</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">int</span>, std::milli&gt; <span class="title">duration_milliseconds</span><span class="params">(<span class="number">500</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Duration in seconds: &quot;</span> &lt;&lt; duration_seconds.<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Duration in milliseconds: &quot;</span> &lt;&lt; duration_milliseconds.<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-关系"><a href="#3-关系" class="headerlink" title="3. 关系"></a>3. 关系</h3><p><code>std::ratio</code> 用于定义时间单位的比率，而 <code>std::chrono::duration</code> 使用这些比率来表示时间间隔。在 <code>std::chrono::duration</code> 中，时间单位是通过 <code>std::ratio</code> 实例来指定的。这种结合可以使得时间的表示更加灵活和精确。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示 2.5 秒的时间间隔</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">double</span>&gt; <span class="title">duration_seconds</span><span class="params">(<span class="number">2.5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示 2500 毫秒的时间间隔</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">double</span>, std::milli&gt; <span class="title">duration_milliseconds</span><span class="params">(<span class="number">2500</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Duration in seconds: &quot;</span> &lt;&lt; duration_seconds.<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Duration in milliseconds: &quot;</span> &lt;&lt; duration_milliseconds.<span class="built_in">count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::ratio</code> 用于表示秒和毫秒之间的比率，而 <code>std::chrono::duration</code> 使用这个比率来表示时间间隔。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_37_iterator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_37_iterator/" class="post-title-link" itemprop="url">C++_10_37_iterator</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><iterator>标准库</li>
</ul>
<h2 id="C-是什么"><a href="#C-是什么" class="headerlink" title="C++ 是什么"></a>C++ <iterator>是什么</h2><p>在C++中，<code>&lt;iterator&gt;</code> 是一个标准库头文件，提供了与迭代器相关的功能和模板类。该头文件定义了许多与迭代器操作和适配器相关的模板类和函数，使得对各种容器和序列的操作更加方便和统一。</p>
<p>以下是 <code>&lt;iterator&gt;</code> 头文件中一些常见的内容：</p>
<h3 id="1-迭代器标签"><a href="#1-迭代器标签" class="headerlink" title="1. 迭代器标签"></a>1. 迭代器标签</h3><ul>
<li><code>std::input_iterator_tag</code>：输入迭代器标签。</li>
<li><code>std::output_iterator_tag</code>：输出迭代器标签。</li>
<li><code>std::forward_iterator_tag</code>：前向迭代器标签。</li>
<li><code>std::bidirectional_iterator_tag</code>：双向迭代器标签。</li>
<li><code>std::random_access_iterator_tag</code>：随机访问迭代器标签。</li>
</ul>
<p>这些标签用于指定迭代器的类型，以便在泛型编程中选择适当的算法。</p>
<h3 id="2-迭代器类别"><a href="#2-迭代器类别" class="headerlink" title="2. 迭代器类别"></a>2. 迭代器类别</h3><ul>
<li><code>std::iterator_traits</code>：模板类，提供有关迭代器类型的信息。</li>
</ul>
<h3 id="3-迭代器操作"><a href="#3-迭代器操作" class="headerlink" title="3. 迭代器操作"></a>3. 迭代器操作</h3><ul>
<li><code>std::advance</code>：将迭代器前进指定的步数。</li>
<li><code>std::distance</code>：计算两个迭代器之间的距离。</li>
</ul>
<h3 id="4-插入迭代器"><a href="#4-插入迭代器" class="headerlink" title="4. 插入迭代器"></a>4. 插入迭代器</h3><ul>
<li><code>std::back_inserter</code>：用于在容器尾部插入元素的迭代器适配器。</li>
<li><code>std::front_inserter</code>：用于在容器头部插入元素的迭代器适配器。</li>
<li><code>std::inserter</code>：用于在指定位置插入元素的迭代器适配器。</li>
</ul>
<h3 id="5-流迭代器"><a href="#5-流迭代器" class="headerlink" title="5. 流迭代器"></a>5. 流迭代器</h3><ul>
<li><code>std::istream_iterator</code>：输入流迭代器。</li>
<li><code>std::ostream_iterator</code>：输出流迭代器。</li>
</ul>
<p>这些迭代器适配器使得可以将输入流和输出流与迭代器接口一致地结合使用。</p>
<h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h3><p>还有其他一些辅助功能和模板类，用于处理迭代器和序列的各种操作。</p>
<p>通过使用 <code>&lt;iterator&gt;</code> 头文件中提供的这些功能，开发者可以更方便地进行迭代器的操作、适配和处理，从而提高代码的灵活性和可维护性。</p>
<h2 id="C-详解"><a href="#C-详解" class="headerlink" title="C++ 详解"></a>C++ <iterator>详解</h2><p><code>&lt;iterator&gt;</code> 是C++标准库中的头文件，提供了许多与迭代器相关的工具、类和函数。这个头文件包含了一系列功能，用于支持通用的迭代器操作和适配器。以下是 <code>&lt;iterator&gt;</code> 头文件的主要内容：</p>
<h3 id="1-迭代器标签-1"><a href="#1-迭代器标签-1" class="headerlink" title="1. 迭代器标签"></a>1. 迭代器标签</h3><ul>
<li><code>std::input_iterator_tag</code>：输入迭代器标签。</li>
<li><code>std::output_iterator_tag</code>：输出迭代器标签。</li>
<li><code>std::forward_iterator_tag</code>：前向迭代器标签。</li>
<li><code>std::bidirectional_iterator_tag</code>：双向迭代器标签。</li>
<li><code>std::random_access_iterator_tag</code>：随机访问迭代器标签。</li>
</ul>
<p>这些标签用于表示迭代器的不同特性，以便在泛型算法中根据迭代器的类型选择适当的算法。</p>
<h3 id="2-迭代器类别-1"><a href="#2-迭代器类别-1" class="headerlink" title="2. 迭代器类别"></a>2. 迭代器类别</h3><ul>
<li><code>std::iterator_traits</code>：模板类，提供有关迭代器类型的信息，如迭代器的标签、值类型、指针类型等。</li>
</ul>
<h3 id="3-迭代器操作-1"><a href="#3-迭代器操作-1" class="headerlink" title="3. 迭代器操作"></a>3. 迭代器操作</h3><ul>
<li><code>std::advance</code>：用于将迭代器前进指定的步数。</li>
<li><code>std::distance</code>：用于计算两个迭代器之间的距离。</li>
</ul>
<h3 id="4-插入迭代器-1"><a href="#4-插入迭代器-1" class="headerlink" title="4. 插入迭代器"></a>4. 插入迭代器</h3><ul>
<li><code>std::back_inserter</code>：迭代器适配器，用于在容器尾部插入元素。</li>
<li><code>std::front_inserter</code>：迭代器适配器，用于在容器头部插入元素。</li>
<li><code>std::inserter</code>：迭代器适配器，用于在指定位置插入元素。</li>
</ul>
<p>这些插入迭代器适配器允许将算法应用于容器而无需关心具体插入的位置。</p>
<h3 id="5-流迭代器-1"><a href="#5-流迭代器-1" class="headerlink" title="5. 流迭代器"></a>5. 流迭代器</h3><ul>
<li><code>std::istream_iterator</code>：输入流迭代器，用于从输入流中读取数据。</li>
<li><code>std::ostream_iterator</code>：输出流迭代器，用于向输出流中写入数据。</li>
</ul>
<p>这些迭代器适配器允许将输入流和输出流与迭代器接口一致地结合使用。</p>
<h3 id="6-std-begin-和-std-end"><a href="#6-std-begin-和-std-end" class="headerlink" title="6. std::begin 和 std::end"></a>6. <code>std::begin</code> 和 <code>std::end</code></h3><ul>
<li><code>std::begin</code>：用于获取容器的起始迭代器。</li>
<li><code>std::end</code>：用于获取容器的结束迭代器。</li>
</ul>
<p>这两个函数允许以通用的方式获得容器的起始和结束迭代器。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一个简单的示例，展示了 <code>&lt;iterator&gt;</code> 头文件中的一些功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器适配器将元素复制到输出流</span></span><br><span class="line">    std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(numbers), std::<span class="built_in">end</span>(numbers), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子使用了 <code>std::begin</code> 和 <code>std::end</code> 获取容器的起始和结束迭代器，并使用 <code>std::copy</code> 将容器中的元素复制到输出流中。还使用了 <code>std::ostream_iterator</code> 来实现输出流迭代器。</p>
<h2 id="C-std-prev-函数-详解"><a href="#C-std-prev-函数-详解" class="headerlink" title="C++  std::prev()函数 详解"></a>C++ <iterator> std::prev()函数 详解</h2><p><code>std::prev()</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的函数之一。它的作用是返回一个迭代器，指向指定迭代器之前的位置。</p>
<p>这个函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> BidirIt &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> BidirIt <span class="title">prev</span><span class="params">( BidirIt it, <span class="keyword">typename</span> std::iterator_traits&lt;BidirIt&gt;::difference_type n = <span class="number">1</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>BidirIt</code> 是双向迭代器的类型。</li>
<li><code>it</code> 是要移动的迭代器。</li>
<li><code>n</code> 是要向前移动的步数，默认为1。</li>
</ul>
<p><code>std::prev()</code> 函数返回一个新的迭代器，该迭代器指向传入迭代器的前面。如果没有指定步数 <code>n</code>，默认向前移动一个位置。如果指定了步数 <code>n</code>，则向前移动 <code>n</code> 个位置。</p>
<p>以下是一个简单的例子，演示了 <code>std::prev()</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取迭代器指向第四个元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>() + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::prev() 向前移动两个位置</span></span><br><span class="line">    <span class="keyword">auto</span> prevIt = std::<span class="built_in">prev</span>(it, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current iterator position: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Iterator position after std::prev(): &quot;</span> &lt;&lt; *prevIt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>it</code> 指向第四个元素，然后使用 <code>std::prev()</code> 向前移动两个位置，得到的 <code>prevIt</code> 指向第二个元素。</p>
<h2 id="C-std-advance-函数-详解"><a href="#C-std-advance-函数-详解" class="headerlink" title="C++  std::advance()函数 详解"></a>C++ <iterator> std::advance()函数 详解</h2><p><code>std::advance()</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的函数之一。它的作用是将迭代器前移（或后移）指定的步数。</p>
<p>这个函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> Distance &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">advance</span><span class="params">( InputIt&amp; it, Distance n )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>InputIt</code> 是输入迭代器的类型。</li>
<li><code>it</code> 是要移动的迭代器（传入的是引用）。</li>
<li><code>n</code> 是要移动的步数。</li>
</ul>
<p><code>std::advance()</code> 函数将迭代器 <code>it</code> 前移 <code>n</code> 步。如果 <code>n</code> 为正数，则迭代器向前移动；如果 <code>n</code> 为负数，则迭代器向后移动。</p>
<p>以下是一个简单的例子，演示了 <code>std::advance()</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取迭代器指向第二个元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::advance() 向前移动两个位置</span></span><br><span class="line">    std::<span class="built_in">advance</span>(it, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Iterator position after std::advance(): &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>it</code> 指向第二个元素，然后使用 <code>std::advance()</code> 向前移动两个位置，最终 <code>it</code> 指向第四个元素。</p>
<h2 id="C-std-distance-函数-详解"><a href="#C-std-distance-函数-详解" class="headerlink" title="C++  std::distance()函数 详解"></a>C++ <iterator> std::distance()函数 详解</h2><p><code>std::distance()</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的函数之一。它的作用是计算两个迭代器之间的距离（元素个数）。</p>
<p>这个函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">InputIt</span> &gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> std::iterator_traits&lt;InputIt&gt;::<span class="function">difference_type <span class="title">distance</span><span class="params">( InputIt first, InputIt last )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>InputIt</code> 是输入迭代器的类型。</li>
<li><code>first</code> 是第一个迭代器。</li>
<li><code>last</code> 是第二个迭代器。</li>
</ul>
<p><code>std::distance()</code> 函数返回两个迭代器之间的距离，即 <code>last - first</code>。结果的类型是由迭代器的 <code>difference_type</code> 决定的。</p>
<p>以下是一个简单的例子，演示了 <code>std::distance()</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取两个迭代器分别指向第二个和第四个元素</span></span><br><span class="line">    <span class="keyword">auto</span> first = numbers.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> last = numbers.<span class="built_in">begin</span>() + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::distance() 计算它们之间的距离</span></span><br><span class="line">    std::<span class="type">ptrdiff_t</span> distance = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Distance between iterators: &quot;</span> &lt;&lt; distance &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>first</code> 和 <code>last</code> 分别指向第二个和第四个元素，然后使用 <code>std::distance()</code> 计算它们之间的距离，最终输出结果为 <code>2</code>。</p>
<h2 id="C-std-back-inserter-详解"><a href="#C-std-back-inserter-详解" class="headerlink" title="C++  std::back_inserter 详解"></a>C++ <iterator> std::back_inserter 详解</h2><p><code>std::back_inserter</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的一个函数模板，它创建一个用于在容器尾部插入元素的插入迭代器。</p>
<p>这个函数模板的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Container &gt;</span></span><br><span class="line"><span class="function">std::back_insert_iterator&lt;Container&gt; <span class="title">back_inserter</span><span class="params">( Container&amp; c )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Container</code> 是容器的类型。</li>
</ul>
<p><code>std::back_inserter</code> 返回一个 <code>std::back_insert_iterator</code> 对象，它是一个迭代器，允许通过 <code>operator++</code> 和 <code>operator*</code> 在容器的尾部插入元素。</p>
<p>以下是一个简单的例子，演示了 <code>std::back_inserter</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; destination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::back_inserter 创建插入迭代器</span></span><br><span class="line">    std::back_insert_iterator&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">backInserter</span>(destination);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::copy 将 source 中的元素插入到 destination 的尾部</span></span><br><span class="line">    std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), backInserter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destination vector after insertion: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : destination) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::back_inserter</code> 用于创建一个插入迭代器，然后使用 <code>std::copy</code> 将 <code>source</code> 容器中的元素插入到 <code>destination</code> 容器的尾部。最终输出结果为 <code>Destination vector after insertion: 1 2 3 4 5</code>。</p>
<h2 id="C-std-front-inserter-详解"><a href="#C-std-front-inserter-详解" class="headerlink" title="C++  std::front_inserter 详解"></a>C++ <iterator> std::front_inserter 详解</h2><p>在 C++ 标准库的 <code>&lt;iterator&gt;</code> 头文件中，<code>std::front_inserter</code> 是一个函数模板，用于创建一个插入迭代器，该迭代器允许在容器的开头插入元素。这通常用于在容器的前部执行插入操作。</p>
<p>下面是 <code>std::front_inserter</code> 的声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Container &gt;</span></span><br><span class="line"><span class="function">std::front_insert_iterator&lt;Container&gt; <span class="title">front_inserter</span><span class="params">( Container&amp; c )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Container</code> 是容器的类型。</li>
</ul>
<p><code>std::front_inserter</code> 返回一个 <code>std::front_insert_iterator</code> 对象，该对象可以通过 <code>operator++</code> 和 <code>operator*</code> 来在容器的开头插入元素。</p>
<p>以下是一个简单的例子，演示了 <code>std::front_inserter</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; destination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::front_inserter 创建插入迭代器</span></span><br><span class="line">    std::front_insert_iterator&lt;std::list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">frontInserter</span>(destination);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::copy 将 source 中的元素插入到 destination 的开头</span></span><br><span class="line">    std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), frontInserter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destination list after insertion: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : destination) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::front_inserter</code> 用于创建一个插入迭代器，然后使用 <code>std::copy</code> 将 <code>source</code> 容器中的元素插入到 <code>destination</code> 容器的开头。最终输出结果为 <code>Destination list after insertion: 5 4 3 2 1</code>。</p>
<h2 id="C-std-inserter-详解"><a href="#C-std-inserter-详解" class="headerlink" title="C++  std::inserter 详解"></a>C++ <iterator> std::inserter 详解</h2><p><code>std::inserter</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的一个函数模板，用于创建一个插入迭代器，该迭代器允许在容器的任意位置插入元素。与 <code>std::back_inserter</code> 和 <code>std::front_inserter</code> 不同，<code>std::inserter</code> 允许指定插入位置。</p>
<p>这个函数模板的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Container, <span class="keyword">class</span> Iterator &gt;</span></span><br><span class="line"><span class="function">std::insert_iterator&lt;Container&gt; <span class="title">inserter</span><span class="params">( Container&amp; c, Iterator p )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Container</code> 是容器的类型。</li>
<li><code>Iterator</code> 是指定插入位置的迭代器。</li>
</ul>
<p><code>std::inserter</code> 返回一个 <code>std::insert_iterator</code> 对象，该对象可以通过 <code>operator++</code> 和 <code>operator*</code> 来在指定位置插入元素。</p>
<p>以下是一个简单的例子，演示了 <code>std::inserter</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; destination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 destination 中的迭代器指向第一个元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = destination.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::inserter 创建插入迭代器，指定插入位置为 it</span></span><br><span class="line">    std::insert_iterator&lt;std::set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">inserter</span>(destination, it);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::copy 将 source 中的元素插入到 destination 的指定位置</span></span><br><span class="line">    std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), inserter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Destination set after insertion: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : destination) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::inserter</code> 用于创建一个插入迭代器，指定插入位置为 <code>it</code>，然后使用 <code>std::copy</code> 将 <code>source</code> 容器中的元素插入到 <code>destination</code> 容器的指定位置。最终输出结果为 <code>Destination set after insertion: 1 2 3 4 5</code>。</p>
<h2 id="C-std-istream-iterator-详解"><a href="#C-std-istream-iterator-详解" class="headerlink" title="C++  std::istream_iterator 详解"></a>C++ <iterator> std::istream_iterator 详解</h2><p><code>std::istream_iterator</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的一个模板类，用于创建一个输入迭代器，该迭代器从输入流中读取数据。</p>
<p>这个模板类的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">CharT</span> = <span class="type">char</span>, <span class="keyword">class</span> Traits = std::char_traits&lt;CharT&gt;, <span class="keyword">class</span> Distance = std::<span class="type">ptrdiff_t</span> &gt;</span><br><span class="line"><span class="keyword">class</span> istream_iterator;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code> 是迭代器指向的元素类型。</li>
<li><code>CharT</code> 是字符类型，默认为 <code>char</code>。</li>
<li><code>Traits</code> 是字符特性，用于处理字符操作，默认为 <code>std::char_traits&lt;CharT&gt;</code>。</li>
<li><code>Distance</code> 是迭代器之间的距离类型，默认为 <code>std::ptrdiff_t</code>。</li>
</ul>
<p><code>std::istream_iterator</code> 的对象通过输入流（如 <code>std::cin</code>）进行初始化，并通过 <code>operator++</code> 和 <code>operator*</code> 来读取输入流中的数据。</p>
<p>以下是一个简单的例子，演示了 <code>std::istream_iterator</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::istream_iterator 从标准输入流读取整数</span></span><br><span class="line">    <span class="function">std::istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">it</span><span class="params">(std::cin)</span></span>;</span><br><span class="line">    std::istream_iterator&lt;<span class="type">int</span>&gt; end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::vector 存储从输入流读取的整数</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">numbers</span><span class="params">(it, end)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Numbers entered: &quot;</span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::istream_iterator</code> 用于从标准输入流中读取整数，然后使用 <code>std::vector</code> 存储这些整数，最终输出结果为用户输入的整数序列。</p>
<h2 id="C-std-ostream-iterator-详解"><a href="#C-std-ostream-iterator-详解" class="headerlink" title="C++  std::ostream_iterator 详解"></a>C++ <iterator> std::ostream_iterator 详解</h2><p><code>std::ostream_iterator</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的一个模板类，用于创建一个输出迭代器，该迭代器将数据写入输出流。</p>
<p>这个模板类的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">CharT</span> = <span class="type">char</span>, <span class="keyword">class</span> Traits = std::char_traits&lt;CharT&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> ostream_iterator;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>T</code> 是迭代器指向的元素类型。</li>
<li><code>CharT</code> 是字符类型，默认为 <code>char</code>。</li>
<li><code>Traits</code> 是字符特性，用于处理字符操作，默认为 <code>std::char_traits&lt;CharT&gt;</code>。</li>
</ul>
<p><code>std::ostream_iterator</code> 的对象通过输出流（如 <code>std::cout</code>）进行初始化，并通过 <code>operator++</code> 和 <code>operator*</code> 来将数据写入输出流。</p>
<p>以下是一个简单的例子，演示了 <code>std::ostream_iterator</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::ostream_iterator 将整数输出到标准输出流</span></span><br><span class="line">    <span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">outputIterator</span><span class="params">(std::cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::copy 将 vector 中的整数写入到输出流</span></span><br><span class="line">    std::<span class="built_in">copy</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), outputIterator);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::ostream_iterator</code> 用于将整数输出到标准输出流，并通过 <code>std::copy</code> 将 <code>numbers</code> 容器中的整数写入到输出流。最终输出结果为 <code>1 2 3 4 5</code>。</p>
<h2 id="C-std-begin-函数-详解"><a href="#C-std-begin-函数-详解" class="headerlink" title="C++  std::begin()函数 详解"></a>C++ <iterator> std::begin()函数 详解</h2><p><code>std::begin()</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的一个函数模板，用于获取容器的起始迭代器。</p>
<p>这个函数模板的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Container &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">begin</span><span class="params">( <span class="type">const</span> Container&amp; cont )</span> -&gt; <span class="title">decltype</span><span class="params">(cont.begin())</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Container</code> 是容器类型。</li>
</ul>
<p><code>std::begin()</code> 接受一个容器作为参数，返回该容器的起始迭代器。它是用于支持范围迭代的标准库函数。</p>
<p>以下是一个简单的例子，演示了 <code>std::begin()</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::begin() 获取 vector 的起始迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">begin</span>(numbers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First element of the vector: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::begin()</code> 用于获取 <code>numbers</code> 容器的起始迭代器，然后通过迭代器 <code>it</code> 输出 vector 的第一个元素。最终输出结果为 <code>First element of the vector: 1</code>。</p>
<h2 id="C-std-end-函数-详解"><a href="#C-std-end-函数-详解" class="headerlink" title="C++  std::end()函数 详解"></a>C++ <iterator> std::end()函数 详解</h2><p><code>std::end()</code> 是 C++ 标准库中 <code>&lt;iterator&gt;</code> 头文件中定义的一个函数模板，用于获取容器的结束迭代器。</p>
<p>这个函数模板的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Container &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">end</span><span class="params">( <span class="type">const</span> Container&amp; cont )</span> -&gt; <span class="title">decltype</span><span class="params">(cont.end())</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Container</code> 是容器类型。</li>
</ul>
<p><code>std::end()</code> 接受一个容器作为参数，返回该容器的结束迭代器。它是用于支持范围迭代的标准库函数。</p>
<p>以下是一个简单的例子，演示了 <code>std::end()</code> 的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::end() 获取 vector 的结束迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">end</span>(numbers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Iterator pointing beyond the last element: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::end()</code> 用于获取 <code>numbers</code> 容器的结束迭代器，然后通过迭代器 <code>it</code> 输出 vector 结束位置的元素（由于 <code>it</code> 指向容器的结束位置，解引用操作是未定义行为，这里只是演示目的）。最终输出结果为 “Iterator pointing beyond the last element”。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_38_unordered_map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_38_unordered_map/" class="post-title-link" itemprop="url">C++_10_38_unordered_map</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>unordered_map 标准库</li>
</ul>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <unordered_map>标准库 详解</h2><p>在C++中，<code>&lt;unordered_map&gt;</code> 标准库提供了无序关联容器 <code>std::unordered_map</code>，它是一个键值对的容器，类似于有序关联容器 <code>std::map</code>，但 <code>std::unordered_map</code> 中的元素没有特定的顺序。它使用哈希表来实现快速的元素检索。</p>
<p>以下是一些 <code>std::unordered_map</code> 的重要特性和用法：</p>
<h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个std::unordered_map</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入键值对</span></span><br><span class="line">    myMap[<span class="number">1</span>] = <span class="string">&quot;One&quot;</span>;</span><br><span class="line">    myMap[<span class="number">2</span>] = <span class="string">&quot;Two&quot;</span>;</span><br><span class="line">    myMap[<span class="number">3</span>] = <span class="string">&quot;Three&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value for key 2: &quot;</span> &lt;&lt; myMap[<span class="number">2</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-插入和删除元素"><a href="#2-插入和删除元素" class="headerlink" title="2. 插入和删除元素"></a>2. 插入和删除元素</h3><p>使用 <code>insert</code> 函数可以插入元素，使用 <code>erase</code> 函数可以删除元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">myMap.<span class="built_in">insert</span>(&#123;<span class="number">4</span>, <span class="string">&quot;Four&quot;</span>&#125;);</span><br><span class="line">myMap[<span class="number">5</span>] = <span class="string">&quot;Five&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">myMap.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-查找元素"><a href="#3-查找元素" class="headerlink" title="3. 查找元素"></a>3. 查找元素</h3><p>使用 <code>find</code> 函数可以在 <code>std::unordered_map</code> 中查找元素，如果元素存在，返回指向该元素的迭代器，否则返回 <code>end()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element found: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element not found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-哈希函数和键比较"><a href="#4-哈希函数和键比较" class="headerlink" title="4. 哈希函数和键比较"></a>4. 哈希函数和键比较</h3><p>为了使用自定义类型作为键，你需要提供一个哈希函数和一个相等比较函数。这可以通过定义这两个函数或使用标准库中的 <code>std::hash</code> 和 <code>std::equal_to</code> 来完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyKey</span> &#123;</span><br><span class="line">    <span class="type">int</span> value1;</span><br><span class="line">    <span class="type">int</span> value2;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> MyKey&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (value1 == other.value1) &amp;&amp; (value2 == other.value2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hash</span>&lt;MyKey&gt; &#123;</span><br><span class="line">        <span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> MyKey&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 自定义哈希函数</span></span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(key.value1) ^ std::<span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(key.value2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;MyKey, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line">    MyKey key1&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    myMap[key1] = <span class="string">&quot;Value&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码演示了如何定义自己的哈希函数和相等比较函数，以便将自定义类型 <code>MyKey</code> 用作 <code>std::unordered_map</code> 的键。</p>
<p>总的来说，<code>std::unordered_map</code> 提供了一个快速的无序关联容器，适用于需要高效查找和插入元素的场景。注意，与有序关联容器相比，无序关联容器不会维护元素的特定顺序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_3_vector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_3_vector/" class="post-title-link" itemprop="url">C++_10_3_vector</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><vector>标准库相关笔记</li>
</ul>
<h2 id="C-std-vector和C风格数据互相转换"><a href="#C-std-vector和C风格数据互相转换" class="headerlink" title="C++ std::vector和C风格数据互相转换"></a>C++ std::vector和C风格数据互相转换</h2><p>在C++中，<code>std::vector</code> 是一个动态数组，而C风格的数据通常是指使用指针和数组来管理数据。在实际开发中，有时需要在 <code>std::vector</code> 和 C 风格数组之间进行互相转换。下面是具体的转换方式：</p>
<h3 id="1-从-C-风格数组转换为-std-vector"><a href="#1-从-C-风格数组转换为-std-vector" class="headerlink" title="1. 从 C 风格数组转换为 std::vector"></a>1. 从 C 风格数组转换为 <code>std::vector</code></h3><p>假设有一个C风格的数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c_array[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>要将它转换为 <code>std::vector</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(std::begin(c_array), std::end(c_array))</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>使用 <code>std::begin()</code> 和 <code>std::end()</code> 来获取数组的首尾指针（或使用 <code>&amp;c_array[0]</code> 和 <code>&amp;c_array[size]</code>）。</li>
<li>如果知道数组的长度，你可以直接指定长度：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(c_array, c_array + size)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-从-std-vector-转换为-C-风格数组"><a href="#2-从-std-vector-转换为-C-风格数组" class="headerlink" title="2. 从 std::vector 转换为 C 风格数组"></a>2. 从 <code>std::vector</code> 转换为 C 风格数组</h3><p>假设有一个 <code>std::vector</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>要将其转换为 C 风格的数组，你可以获取 <code>vector</code> 的内部数据指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* c_array = vec.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li><code>vec.data()</code> 返回一个指向 <code>std::vector</code> 内部存储数据的指针，该数据是连续的，与C风格数组类似。</li>
<li>注意：不要手动释放这个指针，因为它是由 <code>std::vector</code> 管理的。</li>
</ul>
<h3 id="3-完整示例"><a href="#3-完整示例" class="headerlink" title="3. 完整示例"></a>3. 完整示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从C风格数组转换为std::vector</span></span><br><span class="line">    <span class="type">int</span> c_array[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(std::begin(c_array), std::end(c_array))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出std::vector的内容</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从std::vector转换为C风格数组</span></span><br><span class="line">    <span class="type">int</span>* c_array_from_vec = vec.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出C风格数组的内容</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;C array: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; c_array_from_vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>当从 <code>std::vector</code> 获取到 C 风格的指针时，不要手动释放内存，因为 <code>std::vector</code> 会自动管理其内存。</li>
<li>从 C 风格数组转换为 <code>std::vector</code> 时，尽量使用 <code>std::begin()</code> 和 <code>std::end()</code> 来避免出错。</li>
</ul>
<p>通过这些方法，你可以轻松地在C++的 <code>std::vector</code> 和C风格数据之间进行转换。</p>
<h2 id="vector-内存分配方案"><a href="#vector-内存分配方案" class="headerlink" title="vector 内存分配方案"></a>vector 内存分配方案</h2><ul>
<li>vector会自动分配内存来保存插入的元素。vector要求必须放在连续的内存中。由于不可能请求在当前的内存块的尾部添加内存，因此每次vector申请更多内存时，都一定要在另一个位置分配一块新的，更大的内存块，然后将所有元素复制&#x2F;移动到新的内存块。</li>
<li>这个过程非常耗时，因此vector的实现在执行重分配时，会分配此次所需内存更多的内存，以尽量避免这个复制转移的过程。通过这种方式，vector可避免在每次插入元素时都重新重新分配内存。</li>
</ul>
<h2 id="C-标准库是什么"><a href="#C-标准库是什么" class="headerlink" title="C++ 标准库是什么"></a>C++ <vector>标准库是什么</h2><p><code>&lt;vector&gt;</code> 是 C++ 标准库提供的头文件之一，用于包含 C++ 标准库中的向量（<code>vector</code>）容器类的定义。向量是一个动态数组，它能够以连续的内存空间存储元素，并提供了灵活的大小调整和高效的随机访问。</p>
<p><code>std::vector</code> 是一个模板类，可以存储任意类型的元素，并具有以下特性：</p>
<ol>
<li><strong>动态大小：</strong> 向量可以根据需要动态增长或缩小其大小，可以通过 <code>push_back</code>、<code>pop_back</code> 等方法在尾部添加或删除元素。</li>
<li><strong>随机访问：</strong> 支持通过索引快速访问和修改元素，时间复杂度为 O(1)。</li>
<li><strong>连续内存存储：</strong> 向量的元素在内存中是连续存储的，这有助于提高数据的访问速度。</li>
<li><strong>尾部插入和删除的高效性：</strong> 在尾部插入或删除元素的操作通常是高效的，时间复杂度为平摊 O(1)。</li>
</ol>
<p>以下是一个简单的示例，演示了如何使用 <code>&lt;vector&gt;</code> 头文件中的 <code>std::vector</code> 类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个整数向量</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在向量尾部添加元素</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历输出向量中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector Elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;vector&gt;</code> 头文件中的 <code>std::vector</code> 类是 C++ 中常用的标准容器之一，它提供了方便的动态数组功能，并且在许多情况下都是一种方便且高效的数据结构选择。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <vector>标准库 详解</h2><p><code>&lt;vector&gt;</code> 是 C++ 标准库提供的头文件之一，包含了 <code>std::vector</code> 类的定义，这是 C++ 中最常用的容器之一。</p>
<h3 id="std-vector-类"><a href="#std-vector-类" class="headerlink" title="std::vector 类"></a><code>std::vector</code> 类</h3><p><code>std::vector</code> 是一个动态数组，它能够存储一系列同类型的元素，并且可以动态地调整其大小。以下是 <code>std::vector</code> 类的一些重要特性和函数：</p>
<ol>
<li><p><strong>动态大小：</strong> 向量的大小可以根据需要动态增长或缩小。通过 <code>push_back()</code> 在尾部添加元素、<code>pop_back()</code> 删除尾部元素，或者直接使用 <code>resize()</code> 调整大小。</p>
</li>
<li><p><strong>随机访问：</strong> 可以通过索引快速访问和修改向量中的元素，支持使用 <code>operator[]</code> 实现随机访问。</p>
</li>
<li><p><strong>连续内存存储：</strong> 向量中的元素在内存中是连续存储的，因此支持高效的随机访问，并且迭代器可用于遍历元素。</p>
</li>
<li><p><strong>内存管理：</strong> 向量会自动处理内存的分配和释放，使得在尾部插入或删除元素的操作通常是高效的。</p>
</li>
<li><p><strong>元素访问：</strong> 提供了 <code>at()</code> 方法和 <code>operator[]</code>，<code>front()</code> 和 <code>back()</code> 方法用于访问首尾元素。</p>
</li>
<li><p><strong>迭代器支持：</strong> 支持使用迭代器进行遍历，如 <code>begin()</code> 和 <code>end()</code> 返回的迭代器用于遍历容器元素。</p>
</li>
<li><p><strong>其他方法：</strong> 包括 <code>empty()</code>、<code>size()</code>、<code>clear()</code>、<code>erase()</code> 等方法用于检查空、获取大小、清空内容和删除元素等。</p>
</li>
</ol>
<p>下面是一个简单示例，展示了如何使用 <code>&lt;vector&gt;</code> 中的 <code>std::vector</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个整数向量并初始化</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在向量尾部添加元素</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器遍历输出向量中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector Elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;vector&gt;</code> 头文件提供了 <code>std::vector</code> 类，它是一个常用的容器，能够满足动态数组的需求，支持高效的元素访问、插入和删除操作，是 C++ 中非常实用的数据结构之一。</p>
<h2 id="C-标准库中-std-vector模板类详解"><a href="#C-标准库中-std-vector模板类详解" class="headerlink" title="C++ 标准库中 std::vector模板类详解"></a>C++ <vector>标准库中 std::vector模板类详解</h2><p><code>std::vector</code> 是 C++ 标准库提供的动态数组容器，属于序列容器的一种。它以连续的内存空间存储元素，并支持动态增长和收缩。以下是 <code>std::vector</code> 的一些重要特性和使用方法：</p>
<h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h3><ol>
<li><p><strong>动态大小：</strong> <code>std::vector</code> 允许在运行时根据需要动态地增加或减少其大小。通过 <code>push_back()</code> 在尾部添加元素，<code>pop_back()</code> 删除尾部元素，或者直接使用 <code>resize()</code> 调整大小。</p>
</li>
<li><p><strong>随机访问：</strong> 可以通过索引快速访问和修改向量中的元素。支持使用 <code>operator[]</code> 实现随机访问，其时间复杂度为 O(1)。</p>
</li>
<li><p><strong>连续内存存储：</strong> 向量的元素在内存中是连续存储的，这有助于提高数据的访问速度，并且迭代器可用于遍历元素。</p>
</li>
<li><p><strong>尾部插入和删除的高效性：</strong> 在尾部插入或删除元素的操作通常是高效的，时间复杂度为平摊 O(1)。</p>
</li>
<li><p><strong>迭代器支持：</strong> 提供了迭代器，如 <code>begin()</code> 和 <code>end()</code> 返回的迭代器用于遍历容器元素。</p>
</li>
<li><p><strong>元素访问：</strong> 可以使用 <code>at()</code> 方法、<code>operator[]</code>、<code>front()</code> 和 <code>back()</code> 方法来访问元素。</p>
</li>
<li><p><strong>其他方法：</strong> 包括 <code>empty()</code>、<code>size()</code>、<code>clear()</code>、<code>erase()</code> 等方法，用于检查空、获取大小、清空内容和删除元素等。</p>
</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个整数向量并初始化</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在向量尾部添加元素</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器遍历输出向量中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector Elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码演示了 <code>std::vector</code> 的一些常见操作，包括初始化、在尾部添加元素、迭代器遍历输出元素等。<code>std::vector</code> 是 C++ 标准库中常用的容器之一，提供了便捷且高效的动态数组功能。</p>
<h2 id="C-标准库中-std-vector模板类所有成员函数"><a href="#C-标准库中-std-vector模板类所有成员函数" class="headerlink" title="C++ 标准库中 std::vector模板类所有成员函数"></a>C++ <vector>标准库中 std::vector模板类所有成员函数</h2><p><code>std::vector</code> 类是 C++ 标准库中的动态数组容器，提供了许多成员函数用于管理其内部的元素。以下是 <code>std::vector</code> 类的一些主要成员函数：</p>
<h3 id="容量相关操作："><a href="#容量相关操作：" class="headerlink" title="容量相关操作："></a>容量相关操作：</h3><ul>
<li><strong><code>size()</code>：</strong> 返回向量中元素的个数。</li>
<li><strong><code>capacity()</code>：</strong> 返回当前向量的容量（即分配的内存大小）。</li>
<li><strong><code>empty()</code>：</strong> 检查向量是否为空。</li>
<li><strong><code>reserve(size_type new_cap)</code>：</strong> 尝试预分配足够的内存以存储指定数量的元素。</li>
</ul>
<h3 id="访问元素操作："><a href="#访问元素操作：" class="headerlink" title="访问元素操作："></a>访问元素操作：</h3><ul>
<li><strong><code>operator[]</code>：</strong> 通过索引访问向量中的元素。</li>
<li><strong><code>at(size_type pos)</code>：</strong> 通过索引访问向量中的元素，提供了边界检查。</li>
<li><strong><code>front()</code>：</strong> 返回向量中第一个元素的引用。</li>
<li><strong><code>back()</code>：</strong> 返回向量中最后一个元素的引用。</li>
<li><strong><code>data()</code>：</strong> 返回指向向量内部数组的指针。</li>
</ul>
<h3 id="修改容器内容操作："><a href="#修改容器内容操作：" class="headerlink" title="修改容器内容操作："></a>修改容器内容操作：</h3><ul>
<li><strong><code>push_back(const T&amp; value)</code>：</strong> 在向量尾部添加一个元素。</li>
<li><strong><code>pop_back()</code>：</strong> 删除向量中最后一个元素。</li>
<li><strong><code>insert(iterator pos, const T&amp; value)</code>：</strong> 在指定位置插入一个元素。</li>
<li><strong><code>erase(iterator pos)</code>：</strong> 删除指定位置的元素。</li>
<li><strong><code>clear()</code>：</strong> 删除向量中的所有元素。</li>
</ul>
<h3 id="其他操作："><a href="#其他操作：" class="headerlink" title="其他操作："></a>其他操作：</h3><ul>
<li><strong><code>swap(vector&amp; other)</code>：</strong> 交换两个向量的内容。</li>
<li><strong><code>assign(count, value)</code>：</strong> 用新值替换向量的内容。</li>
<li><strong><code>resize(size_type new_size)</code>：</strong> 改变向量的大小。</li>
<li><strong><code>shrink_to_fit()</code>：</strong> 要求释放多余的容量。</li>
</ul>
<p>此外，<code>std::vector</code> 还具有迭代器相关的成员函数，如 <code>begin()</code>、<code>end()</code> 用于迭代访问容器的元素。以上列出的成员函数并非全部，但是是 <code>std::vector</code> 常用的一些成员函数，能够对向量的大小、容量、元素访问和修改等进行有效管理。</p>
<h2 id="C-std-vector-swap-函数-详解"><a href="#C-std-vector-swap-函数-详解" class="headerlink" title="C++ std::vector::swap() 函数 详解"></a>C++ std::vector::swap() 函数 详解</h2><p><code>std::vector::swap()</code> 是 C++ 标准库中 <code>std::vector</code> 类的成员函数，用于交换两个 vector 的内容，即交换它们所包含的元素。</p>
<h3 id="函数签名："><a href="#函数签名：" class="headerlink" title="函数签名："></a>函数签名：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(std::vector&amp; x)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>x</code>：另一个 <code>std::vector</code> 对象，其内容将与调用该函数的 vector 对象进行交换。</li>
</ul>
<h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h3><ul>
<li><code>std::vector::swap()</code> 函数用于交换两个 vector 对象的元素内容，使得调用该函数的 vector 与参数 <code>x</code> 所包含的元素互换。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector 1: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec1) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector 2: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec2) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    vec<span class="number">1.</span><span class="built_in">swap</span>(vec2); <span class="comment">// 交换两个 vector 的内容</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nAfter Swap:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector 1: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec1) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector 2: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : vec2) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li><code>std::vector::swap()</code> 函数非常高效，因为它只是交换了两个 vector 内部的数据结构指针，而不是复制每个元素。</li>
<li>交换后，两个 vector 对象的大小和容量可能会发生变化，但其所包含的元素会完全交换。</li>
<li>该函数是 <code>std::vector</code> 类的成员函数，所以需要使用一个已经存在的 vector 对象来调用该函数。</li>
</ul>
<p><code>std::vector::swap()</code> 是一个很有用的函数，特别是在需要交换两个 vector 的元素内容时，可以避免进行元素的逐个复制。</p>
<h2 id="std-vector-size"><a href="#std-vector-size" class="headerlink" title="std::vector::size()"></a>std::vector::size()</h2><p><code>std::vector::size()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于返回 <code>std::vector</code> 容器中当前存储元素的数量（大小）。</p>
<p>在 C++ 中，<code>std::vector</code> 是一个动态数组，它能够自动调整大小，可以根据需要动态地增加或减少存储在其中的元素数量。<code>size()</code> 函数返回的是当前 <code>std::vector</code> 中的元素数量，即容器中元素的个数。</p>
<p>下面是一个简单的示例演示了如何使用 <code>std::vector::size()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的 std::vector 容器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向容器中添加一些元素</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取容器中元素的数量（大小）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector的大小为：&quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个空的 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>。</li>
<li>使用 <code>push_back</code> 方法向容器中添加了三个整数元素。</li>
<li>通过 <code>vec.size()</code> 获取了 <code>vec</code> 容器中元素的数量，并将结果打印出来。</li>
</ul>
<p><code>std::vector::size()</code> 对于获取 <code>std::vector</code> 中元素数量非常方便，它可以帮助你确定容器中元素的个数，从而进行后续的操作或逻辑处理。</p>
<h2 id="std-vector-capacity"><a href="#std-vector-capacity" class="headerlink" title="std::vector::capacity()"></a>std::vector::capacity()</h2><p><code>std::vector::capacity()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于返回当前 <code>std::vector</code> 容器的容量大小。</p>
<p>在 C++ 中，<code>std::vector</code> 是一个动态数组，它能够自动调整大小，可以根据需要动态地增加或减少存储在其中的元素数量。<code>capacity()</code> 函数返回的是当前 <code>std::vector</code> 内部所分配内存空间的大小，即该容器在不分配新的内存的情况下能够容纳的元素数量。</p>
<p>下面是一个简单的示例演示了如何使用 <code>std::vector::capacity()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的 std::vector 容器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向容器中添加一些元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; Capacity: &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个空的 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>。</li>
<li>使用 <code>push_back</code> 方法向容器中循环添加了十个整数元素，并在每次添加后打印了当前容器的大小和容量。</li>
</ul>
<p><code>std::vector::capacity()</code> 是一个重要的函数，它可以用来观察 <code>std::vector</code> 容器当前的内存分配情况。当 <code>std::vector</code> 中的元素数量超过当前分配的容量时，<code>std::vector</code> 会自动重新分配更大的内存空间以容纳更多的元素，这个过程可能会导致容器大小和容量之间的不同步。</p>
<h2 id="std-vector-empty"><a href="#std-vector-empty" class="headerlink" title="std::vector::empty()"></a>std::vector::empty()</h2><p><code>std::vector::empty()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于检查 <code>std::vector</code> 容器是否为空。</p>
<p>当 <code>std::vector</code> 容器中不含有任何元素时，即容器的大小为零时，<code>empty()</code> 函数将返回 <code>true</code>；否则，如果容器中包含至少一个元素，则返回 <code>false</code>。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::empty()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的 std::vector 容器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查容器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;容器为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;容器不为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向容器中添加一个元素</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查容器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;容器为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;容器不为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个空的 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>。</li>
<li>使用 <code>vec.empty()</code> 检查容器是否为空，并根据返回结果打印相应的消息。</li>
<li>使用 <code>push_back</code> 方法向容器中添加了一个整数元素。</li>
<li>再次使用 <code>vec.empty()</code> 检查容器是否为空，并根据返回结果打印相应的消息。</li>
</ul>
<p><code>std::vector::empty()</code> 是一个简单而常用的函数，用于确定 <code>std::vector</code> 容器是否为空，可以在需要检查容器是否含有元素时使用。</p>
<h2 id="std-vector-reserve"><a href="#std-vector-reserve" class="headerlink" title="std::vector::reserve()"></a>std::vector::reserve()</h2><p><code>std::vector::reserve()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于预留 <code>std::vector</code> 容器的存储空间，但不会改变容器中元素的数量。</p>
<p>当你预先知道 <code>std::vector</code> 将要存储大量元素时，可以使用 <code>reserve()</code> 函数来预留足够的内存空间，避免多次重新分配内存，从而提高程序的性能。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::reserve()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的 std::vector 容器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印容器当前的大小和容量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前大小: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; 当前容量: &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预留容器存储空间为 10 个元素</span></span><br><span class="line">    vec.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印预留后的容器当前的大小和容量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;预留后大小: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; 预留后容量: &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个空的 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>。</li>
<li>使用 <code>vec.reserve(10)</code> 预留了容器的存储空间为 10 个元素。</li>
<li>打印了预留前后容器的大小和容量。</li>
</ul>
<p>需要注意的是，<code>reserve()</code> 函数只是预留了足够的存储空间，并没有改变容器的实际大小，容器的大小仍然是 0。容器的大小由实际插入的元素个数决定，而容器的容量则是实际分配的内存大小，<code>reserve()</code> 仅仅是为容器预留了更多的内存空间，以备将来的使用。</p>
<p>这个函数通常在你已经知道将要存储大量元素的情况下使用，以减少因重新分配内存而引起的开销。</p>
<h2 id="std-vector-at"><a href="#std-vector-at" class="headerlink" title="std::vector::at()"></a>std::vector::at()</h2><p><code>std::vector::at()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于访问 <code>std::vector</code> 容器中指定位置的元素，并提供了边界检查。</p>
<p>与 <code>operator[]</code> 不同，<code>at()</code> 函数在访问容器元素时提供了边界检查，如果指定的位置超出了容器的范围，则会抛出 <code>std::out_of_range</code> 异常。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::at()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 at() 访问容器中的元素</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素 at(2): &quot;</span> &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 访问索引为 2 的元素</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;元素 at(5): &quot;</span> &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 尝试访问超出范围的索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; ex) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;发生异常: &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; std::endl; <span class="comment">// 捕获并打印 out_of_range 异常信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec.at(2)</code> 获取了索引为 2 的元素值，并正常打印出来。</li>
<li>然后尝试使用 <code>vec.at(5)</code> 访问超出容器范围的索引，这会导致 <code>std::out_of_range</code> 异常被抛出，并被 <code>catch</code> 语句捕获并处理。</li>
</ul>
<p>总的来说，<code>std::vector::at()</code> 是一个安全的访问元素的方法，可以在需要对访问进行边界检查的情况下使用，以防止意外访问超出容器范围的索引位置。</p>
<h2 id="std-vector-front"><a href="#std-vector-front" class="headerlink" title="std::vector::front()"></a>std::vector::front()</h2><p><code>std::vector::front()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于返回 <code>std::vector</code> 容器中第一个元素的引用。</p>
<p>它提供了对 <code>std::vector</code> 容器中第一个元素的访问，类似于数组的第一个元素。如果 <code>std::vector</code> 容器为空，则调用 <code>front()</code> 函数将会导致未定义行为。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::front()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问容器中的第一个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第一个元素是: &quot;</span> &lt;&lt; vec.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec.front()</code> 获取了容器中的第一个元素值，并将其打印出来。</li>
</ul>
<p>需要注意的是，调用 <code>std::vector::front()</code> 函数时，应确保 <code>std::vector</code> 容器不为空，否则在空容器上调用 <code>front()</code> 将导致未定义行为。因此，在调用 <code>front()</code> 函数之前，最好先检查 <code>std::vector</code> 是否包含元素，可以通过 <code>empty()</code> 函数进行检查。</p>
<h2 id="std-vector-back"><a href="#std-vector-back" class="headerlink" title="std::vector::back()"></a>std::vector::back()</h2><p><code>std::vector::back()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于返回 <code>std::vector</code> 容器中最后一个元素的引用。</p>
<p>它提供了对 <code>std::vector</code> 容器中最后一个元素的访问。如果 <code>std::vector</code> 容器为空，则调用 <code>back()</code> 函数将会导致未定义行为。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::back()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问容器中的最后一个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最后一个元素是: &quot;</span> &lt;&lt; vec.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec.back()</code> 获取了容器中的最后一个元素值，并将其打印出来。</li>
</ul>
<p>需要注意的是，调用 <code>std::vector::back()</code> 函数时，应确保 <code>std::vector</code> 容器不为空，否则在空容器上调用 <code>back()</code> 将导致未定义行为。因此，在调用 <code>back()</code> 函数之前，最好先检查 <code>std::vector</code> 是否包含元素，可以通过 <code>empty()</code> 函数进行检查。</p>
<h2 id="std-vector-data"><a href="#std-vector-data" class="headerlink" title="std::vector::data()"></a>std::vector::data()</h2><p><code>std::vector::data()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于返回指向 <code>std::vector</code> 容器内部存储元素的指针。</p>
<p>这个函数返回一个指向 <code>std::vector</code> 内部数据存储区的指针，该指针可以用于直接访问容器中的元素。如果 <code>std::vector</code> 容器为空，则返回的指针可能为空指针。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::data()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指向容器数据的指针</span></span><br><span class="line">    <span class="type">int</span>* ptr = vec.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印指针指向的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;第一个元素是: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec.data()</code> 获取了指向容器数据存储区的指针，并将其赋值给 <code>ptr</code>。</li>
<li>打印了指针所指向的第一个元素的值。</li>
</ul>
<p>需要注意的是，<code>std::vector::data()</code> 返回的指针可以用于直接访问容器中的元素，但在修改容器中的元素时应格外小心，确保不会越界或者引起其它未定义的行为。此外，如果 <code>std::vector</code> 容器为空，则返回的指针可能为 <code>nullptr</code>。</p>
<h2 id="std-vector-push-back"><a href="#std-vector-push-back" class="headerlink" title="std::vector::push_back()"></a>std::vector::push_back()</h2><p><code>std::vector::push_back()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于在 <code>std::vector</code> 容器的末尾添加一个新的元素。</p>
<p>这个函数将新的元素添加到 <code>std::vector</code> 容器的末尾，并使容器的大小增加 1。如果 <code>std::vector</code> 的容量不足以容纳新元素，则会自动重新分配更大的内存空间以适应新的元素。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::push_back()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的 std::vector 容器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向容器中添加一些元素</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;容器中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个空的 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>。</li>
<li>使用 <code>push_back()</code> 方法向容器中分别添加了三个整数元素。</li>
<li>使用循环遍历容器中的元素，并将它们打印出来。</li>
</ul>
<p><code>std::vector::push_back()</code> 是一个常用的函数，用于向 <code>std::vector</code> 容器的末尾添加新的元素，非常方便实用。</p>
<h2 id="std-vector-pop-back"><a href="#std-vector-pop-back" class="headerlink" title="std::vector::pop_back()"></a>std::vector::pop_back()</h2><p><code>std::vector::pop_back()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于移除 <code>std::vector</code> 容器中的最后一个元素。</p>
<p>该函数会将 <code>std::vector</code> 容器中最后一个元素移除，并且减少容器的大小（size）1。如果 <code>std::vector</code> 容器为空，则调用 <code>pop_back()</code> 函数将导致未定义行为。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::pop_back()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除容器中的最后一个元素</span></span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;移除后的容器中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec.pop_back()</code> 移除了容器中的最后一个元素。</li>
<li>使用循环遍历容器中的元素，并将它们打印出来。</li>
</ul>
<p>需要注意的是，调用 <code>std::vector::pop_back()</code> 之前最好检查容器是否为空，以避免在空容器上调用该函数而导致的未定义行为。这个函数通常用于从 <code>std::vector</code> 容器的末尾删除元素，可以方便地实现栈（stack）等数据结构的功能。</p>
<h2 id="std-vector-insert"><a href="#std-vector-insert" class="headerlink" title="std::vector::insert()"></a>std::vector::insert()</h2><p><code>std::vector::insert()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于在指定位置插入一个或多个元素到 <code>std::vector</code> 容器中。</p>
<p>这个函数允许在指定位置插入一个元素或一组元素。插入操作可能会导致所有在指定位置之后的元素被移动，因为 <code>std::vector</code> 是一个连续存储的容器。</p>
<p>下面是 <code>std::vector::insert()</code> 函数的基本语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(iterator position, <span class="type">const</span> T&amp; val)</span></span>; <span class="comment">// 在 position 位置插入 val</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(iterator position, size_type n, <span class="type">const</span> T&amp; val)</span></span>; <span class="comment">// 在 position 位置插入 n 个 val</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(iterator position, InputIterator first, InputIterator last)</span></span>; <span class="comment">// 在 position 位置插入区间 [first, last) 内的元素</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>position</code> 参数是一个迭代器，指示了插入元素的位置。<code>val</code> 是要插入的元素值，<code>n</code> 是要插入的元素数量，<code>first</code> 和 <code>last</code> 是表示要插入的元素范围的迭代器。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::insert()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在容器的第二个位置插入一个元素 25</span></span><br><span class="line">    <span class="keyword">auto</span> it = vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在容器的末尾插入两个元素，值分别为 40 和 50</span></span><br><span class="line">    vec.<span class="built_in">insert</span>(vec.<span class="built_in">end</span>(), &#123;<span class="number">40</span>, <span class="number">50</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;容器中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec.insert(vec.begin() + 1, 25)</code> 在容器的第二个位置插入了一个值为 25 的元素。</li>
<li>使用 <code>vec.insert(vec.end(), &#123;40, 50&#125;)</code> 在容器的末尾插入了两个值为 40 和 50 的元素。</li>
<li>使用循环遍历容器中的元素，并将它们打印出来。</li>
</ul>
<p><code>std::vector::insert()</code> 函数允许在 <code>std::vector</code> 容器的指定位置插入一个或多个元素，提供了灵活且方便的插入操作。</p>
<h2 id="std-vector-erase"><a href="#std-vector-erase" class="headerlink" title="std::vector::erase()"></a>std::vector::erase()</h2><p><code>std::vector::erase()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于从 <code>std::vector</code> 容器中移除一个或一段元素。</p>
<p>这个函数有多种用法，它可以删除单个元素，也可以删除一个范围内的元素。删除操作可能会导致被移除元素后面的元素向前移动，因为 <code>std::vector</code> 是一个连续存储的容器。</p>
<p>下面是 <code>std::vector::erase()</code> 函数的基本语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator position)</span></span>; <span class="comment">// 移除指定位置的元素</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(iterator first, iterator last)</span></span>; <span class="comment">// 移除位于 [first, last) 区间的元素</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>position</code> 是要移除的元素的位置的迭代器，<code>first</code> 和 <code>last</code> 表示一个范围，用来移除这个范围内的所有元素。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::erase()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除容器中的第二个元素</span></span><br><span class="line">    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除容器中的第三个到第四个元素（迭代器范围 [vec.begin() + 2, vec.begin() + 4)）</span></span><br><span class="line">    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + <span class="number">2</span>, vec.<span class="built_in">begin</span>() + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;容器中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec.erase(vec.begin() + 1)</code> 移除了容器中的第二个元素。</li>
<li>使用 <code>vec.erase(vec.begin() + 2, vec.begin() + 4)</code> 移除了容器中的第三个到第四个元素。</li>
<li>使用循环遍历容器中的元素，并将它们打印出来。</li>
</ul>
<p><code>std::vector::erase()</code> 函数允许从 <code>std::vector</code> 容器中移除指定位置或指定范围内的元素，提供了便捷的删除操作。</p>
<h2 id="std-vector-clear"><a href="#std-vector-clear" class="headerlink" title="std::vector::clear()"></a>std::vector::clear()</h2><p><code>std::vector::clear()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于清空 <code>std::vector</code> 容器中的所有元素。</p>
<p>当调用 <code>clear()</code> 函数时，<code>std::vector</code> 容器的大小变为零，即移除了容器中的所有元素。容器的内存空间不会被释放，但容器中的元素数量将变为零，即容器会变为空。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::clear()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印清空前容器中的元素数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;清空前容器的大小: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空容器</span></span><br><span class="line">    vec.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印清空后容器中的元素数量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;清空后容器的大小: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec.size()</code> 打印了清空前容器中的元素数量。</li>
<li>使用 <code>vec.clear()</code> 清空了容器中的所有元素。</li>
<li>再次使用 <code>vec.size()</code> 打印了清空后容器中的元素数量，这时应该为 0。</li>
</ul>
<p><code>std::vector::clear()</code> 函数是一种快速清空 <code>std::vector</code> 容器中的元素的方法，但并不释放容器的内存空间，仅将容器的大小设置为零，使得容器变为空。</p>
<h2 id="std-vector-swap"><a href="#std-vector-swap" class="headerlink" title="std::vector::swap()"></a>std::vector::swap()</h2><p><code>std::vector::swap()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于交换两个 <code>std::vector</code> 容器的内容。</p>
<p>这个函数接受另一个 <code>std::vector</code> 容器作为参数，并将调用它的容器和传入的容器进行内容交换。交换操作将使得两个容器中的元素互相交换，但它们的内存空间不会发生改变。</p>
<p>以下是 <code>std::vector::swap()</code> 函数的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&amp; other)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>other</code> 是另一个 <code>std::vector</code> 容器，它的内容将与调用函数的容器进行交换。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::swap()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个 std::vector 容器，并分别向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印交换前两个容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;交换前 vec1 中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec1) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;交换前 vec2 中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec2) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 swap() 函数交换两个容器的内容</span></span><br><span class="line">    vec<span class="number">1.</span><span class="built_in">swap</span>(vec2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印交换后两个容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;交换后 vec1 中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec1) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;交换后 vec2 中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec2) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了两个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec1</code> 和 <code>vec2</code>，并初始化了一些整数元素。</li>
<li>使用 <code>vec1.swap(vec2)</code> 对两个容器的内容进行了交换。</li>
<li>分别打印了交换前后两个容器中的元素。</li>
</ul>
<p><code>std::vector::swap()</code> 函数提供了一种快速交换两个 <code>std::vector</code> 容器内容的方法，不需要复制元素，只需交换指针。这对于需要在两个容器间交换数据时非常有用。</p>
<h2 id="std-vector-assign"><a href="#std-vector-assign" class="headerlink" title="std::vector::assign()"></a>std::vector::assign()</h2><p><code>std::vector::assign()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于重新分配 <code>std::vector</code> 容器的内容。</p>
<p>这个函数可以使用多种方式重新设置 <code>std::vector</code> 容器的内容：可以用新值替换已有的内容，也可以设置容器中的元素数量，或者使用一个范围内的值替换容器中的元素。</p>
<p>以下是 <code>std::vector::assign()</code> 函数的不同形式及其基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(size_type count, <span class="type">const</span> T&amp; value)</span></span>; <span class="comment">// 设置容器中元素的数量为 count，并用 value 值替换所有元素 (1)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(InputIterator first, InputIterator last)</span></span>; <span class="comment">// 使用区间 [first, last) 内的元素替换容器的内容 (2)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(std::initializer_list&lt;T&gt; il)</span></span>; <span class="comment">// 使用初始化列表 il 内的元素替换容器的内容 (3)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数</p>
<ul>
<li>count - 容器的新大小</li>
<li>value - 用以初始化容器元素的值</li>
<li>first, last - 复制来源元素的范围</li>
<li>ilist - 复制值来源的initializer_list</li>
</ul>
</li>
<li><p>复杂度</p>
<ul>
<li>1 与count呈线性</li>
<li>2 与first和last间的距离呈线性</li>
<li>3 与il.size()呈线性</li>
</ul>
</li>
</ul>
<p>这里的 <code>count</code> 表示新的元素数量，<code>value</code> 是要赋给新元素的值。<code>first</code> 和 <code>last</code> 是迭代器，表示一个范围，用来替换容器的内容。<code>il</code> 是一个初始化列表，用来替换容器的内容。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::assign()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; characters;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> print_list = [&amp;]()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : characters)</span><br><span class="line">            std::cout &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  </span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    characters.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">print_list</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">const</span> std::string <span class="title">extra</span><span class="params">(<span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>)</span></span>;</span><br><span class="line">    characters.<span class="built_in">assign</span>(extra.<span class="built_in">begin</span>(), extra.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">print_list</span>();</span><br><span class="line"> </span><br><span class="line">    characters.<span class="built_in">assign</span>(&#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;);</span><br><span class="line">    <span class="built_in">print_list</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个空的 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>。</li>
<li>使用 <code>vec.assign(5, 10)</code> 设置容器中的元素数量为 5，并用值 10 替换了所有元素。</li>
<li>使用循环遍历容器中的元素，并将它们打印出来。</li>
</ul>
<p><code>std::vector::assign()</code> 函数提供了多种方式来重新设置 <code>std::vector</code> 容器的内容，使得容器可以被不同类型的数据重新填充。</p>
<h2 id="std-vector-resize"><a href="#std-vector-resize" class="headerlink" title="std::vector::resize()"></a>std::vector::resize()</h2><p><code>std::vector::resize()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于改变 <code>std::vector</code> 容器中的元素数量。</p>
<p>这个函数允许你改变 <code>std::vector</code> 容器中元素的数量。如果新的大小比当前大小大，将会增加元素数量并用默认构造函数的值初始化新的元素。如果新的大小比当前大小小，将会删除超出新大小的元素。</p>
<p>以下是 <code>std::vector::resize()</code> 函数的基本语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type count)</span></span>; <span class="comment">// 设置容器中的元素数量为 count</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size_type count, <span class="type">const</span> value_type&amp; value)</span></span>; <span class="comment">// 设置容器中的元素数量为 count，并用 value 值初始化新元素</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>count</code> 是指定的新的元素数量，<code>value</code> 是可选的值，用于初始化新添加的元素。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::resize()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的 std::vector 容器</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 resize() 设置容器中的元素数量为 5</span></span><br><span class="line">    vec.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;容器中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 resize() 设置容器中的元素数量为 8，并用值 100 初始化新添加的元素</span></span><br><span class="line">    vec.<span class="built_in">resize</span>(<span class="number">8</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次打印容器中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;调整大小后的容器中的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个空的 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>。</li>
<li>使用 <code>vec.resize(5)</code> 设置容器中的元素数量为 5，默认使用默认构造函数进行初始化。</li>
<li>使用 <code>vec.resize(8, 100)</code> 将容器中的元素数量增加到 8，并用值 100 初始化新添加的元素。</li>
<li>分别使用循环遍历容器中的元素，并将它们打印出来。</li>
</ul>
<p><code>std::vector::resize()</code> 函数允许你在运行时动态调整 <code>std::vector</code> 容器的大小，并可以选择性地使用特定的值初始化新添加的元素。</p>
<h2 id="std-vector-shrink-to-fit"><a href="#std-vector-shrink-to-fit" class="headerlink" title="std::vector::shrink_to_fit()"></a>std::vector::shrink_to_fit()</h2><p><code>std::vector::shrink_to_fit()</code> 是 C++ 标准库中 <code>std::vector</code> 类的一个成员函数，用于要求 <code>std::vector</code> 容器减小其容量，使其容量和大小相匹配。</p>
<p><code>std::vector</code> 容器会根据需要分配更多的内存空间以容纳新的元素。然而，当一些元素被删除后，<code>std::vector</code> 容器的实际大小可能小于其容量。<code>shrink_to_fit()</code> 函数就是用来释放容器多余的内存空间，将容器的容量减小到与其大小相匹配。</p>
<p>以下是 <code>std::vector::shrink_to_fit()</code> 函数的基本语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数没有参数，调用它将使 <code>std::vector</code> 容器的容量减小到和当前元素数量相匹配的大小。但并不保证一定会成功减小容器的容量，因为具体实现可能会有所不同。</p>
<p>以下是一个简单的示例演示了如何使用 <code>std::vector::shrink_to_fit()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::vector 容器，并向其中添加一些元素</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除容器中的最后两个元素</span></span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 shrink_to_fit() 函数将容器的容量减小到与其大小相匹配</span></span><br><span class="line">    vec.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印容器的大小和容量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;容器的大小: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;容器的容量: &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li>创建了一个 <code>std::vector&lt;int&gt;</code> 容器 <code>vec</code>，并初始化了一些整数元素。</li>
<li>使用 <code>pop_back()</code> 移除了容器中的最后两个元素。</li>
<li>使用 <code>shrink_to_fit()</code> 函数将容器的容量减小到与其大小相匹配。</li>
<li>使用 <code>size()</code> 和 <code>capacity()</code> 分别打印了容器的大小和容量。</li>
</ul>
<p><code>std::vector::shrink_to_fit()</code> 函数提供了一种手段来释放 <code>std::vector</code> 容器内多余的内存空间，使得容器的实际容量与其大小相匹配。但并不保证一定会成功减小容器的容量，具体情况取决于实现。</p>
<h2 id="std-vector-emplace-back-函数-详解"><a href="#std-vector-emplace-back-函数-详解" class="headerlink" title="std::vector::emplace_back() 函数 详解"></a>std::vector::emplace_back() 函数 详解</h2><p><code>std::vector::emplace_back()</code> 是 C++ 中 <code>std::vector</code> 容器提供的一个函数，用于在容器的末尾直接构造元素，而不是先创建一个临时对象再进行拷贝或移动操作。这个函数允许你在容器中就地构造对象，从而避免额外的拷贝或移动开销。</p>
<p>以下是 <code>std::vector::emplace_back()</code> 的详细解释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace std</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>emplace_back</code> 函数接受任意数量的参数，并将这些参数传递给容器中元素的构造函数，用于在容器的末尾直接构造一个新元素。</p>
</li>
<li><p>参数 <code>Args&amp;&amp;... args</code> 是一个可变参数模板，可以接受任意数量的参数。</p>
</li>
</ul>
<p>使用 <code>emplace_back</code> 的典型用法是，直接在容器末尾构造一个元素，而不需要在代码中创建临时对象。这对于避免额外的拷贝或移动操作特别有用。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructing MyClass with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;MyClass&gt; myVector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 emplace_back 直接在容器末尾构造元素</span></span><br><span class="line">    myVector.<span class="built_in">emplace_back</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 emplace_back 可以避免额外的拷贝或移动操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>emplace_back</code> 直接在 <code>std::vector</code> 的末尾构造了一个 <code>MyClass</code> 对象，而不需要先创建一个临时对象再进行拷贝操作。这样可以提高效率，特别是对于那些不支持移动语义的类。</p>
<h2 id="C-std-vector-拷贝构造函数-详解"><a href="#C-std-vector-拷贝构造函数-详解" class="headerlink" title="C++ std::vector 拷贝构造函数 详解"></a>C++ std::vector 拷贝构造函数 详解</h2><p>在 C++ 中，<code>std::vector</code> 是一个动态数组，它提供了在运行时大小可以动态变化的数组容器。拷贝构造函数是一种特殊的构造函数，用于创建一个对象的副本。<code>std::vector</code> 的拷贝构造函数用于创建一个新的 <code>std::vector</code> 对象，其元素与另一个 <code>std::vector</code> 对象完全相同。</p>
<p>以下是 <code>std::vector</code> 的拷贝构造函数的详细解释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="type">const</span> vector&amp; other);</span><br></pre></td></tr></table></figure>

<p>拷贝构造函数采用另一个 <code>std::vector</code> 对象作为参数，并创建一个新的 <code>std::vector</code> 对象，其中包含与参数相同的元素。这个构造函数通过复制另一个 <code>std::vector</code> 对象的所有元素来构造新的对象。</p>
<p>拷贝构造函数通常在以下情况下被调用：</p>
<ol>
<li>用一个 <code>std::vector</code> 对象初始化另一个 <code>std::vector</code> 对象。</li>
<li>作为函数参数传递 <code>std::vector</code> 对象。</li>
<li>从函数返回 <code>std::vector</code> 对象时。</li>
</ol>
<p>下面是一个简单的示例，展示了如何使用拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个原始的 std::vector 对象</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; originalVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用拷贝构造函数创建一个新的 std::vector 对象</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">copiedVector</span><span class="params">(originalVector)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出新的 std::vector 对象的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : copiedVector) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>copiedVector</code> 对象使用了原始向量 <code>originalVector</code> 的拷贝构造函数创建了一个副本。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_40_variant/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_40_variant/" class="post-title-link" itemprop="url">C++_10_40_variant</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <variant>标准库</li>
</ul>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <variant>标准库 详解</h2><p><code>std::variant</code> 是 C++17 标准库中引入的一种类型，用于在一组指定的类型中存储一个值。它提供了一种类型安全的方式来处理联合类型（Union Types）。在许多情况下，<code>std::variant</code> 可以替代传统的 C 风格联合体（union），并提供更多的类型安全性和便利性。</p>
<p>以下是关于 <code>std::variant</code> 的详细解释：</p>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul>
<li><strong>替代性</strong>：<code>std::variant</code> 类型可以持有一组指定的类型中的任何一个，但一次只能持有其中一个。</li>
<li><strong>类型安全</strong>：编译器在编译时会检查 <code>std::variant</code> 中的值是否与预期的类型匹配，从而提供更好的类型安全性。</li>
<li><strong>异常安全</strong>：<code>std::variant</code> 提供了异常安全性，可以确保在异常抛出时不会出现资源泄漏或不一致的状态。</li>
</ul>
<h3 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2. 使用方法"></a>2. 使用方法</h3><h4 id="2-1-创建-std-variant-对象"><a href="#2-1-创建-std-variant-对象" class="headerlink" title="2.1 创建 std::variant 对象"></a>2.1 创建 <code>std::variant</code> 对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; myVariant;</span><br><span class="line">    myVariant = <span class="number">10</span>; <span class="comment">// 存储 int 类型</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(myVariant) &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-访问-std-variant-中的值"><a href="#2-2-访问-std-variant-中的值" class="headerlink" title="2.2 访问 std::variant 中的值"></a>2.2 访问 <code>std::variant</code> 中的值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; myVariant;</span><br><span class="line">    myVariant = <span class="number">10</span>; <span class="comment">// 存储 int 类型</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">int</span>&gt;(myVariant)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The variant holds an int.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(myVariant) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;<span class="type">double</span>&gt;(myVariant)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The variant holds a double.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(myVariant) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">holds_alternative</span>&lt;std::string&gt;(myVariant)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The variant holds a string.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(myVariant) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-访问可能引发异常的值"><a href="#2-3-访问可能引发异常的值" class="headerlink" title="2.3 访问可能引发异常的值"></a>2.3 访问可能引发异常的值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::variant&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; myVariant;</span><br><span class="line">    myVariant = <span class="number">10</span>; <span class="comment">// 存储 int 类型</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">double</span> value = std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(myVariant);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_variant_access&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p><code>std::variant</code> 提供了一种更安全和灵活的方式来处理多种类型的值，特别适用于函数返回多种类型值的情况，以及需要类型安全的联合类型操作的场景。使用 <code>std::variant</code> 可以避免传统联合体带来的类型不安全性和编程错误，提高了代码的可读性和健壮性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_41_optional/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_41_optional/" class="post-title-link" itemprop="url">C++_10_41_optional</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <optional>标准库</li>
</ul>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++  标准库 详解"></a>C++ <optional> 标准库 详解</h2><p><code>&lt;optional&gt;</code> 是 C++17 引入的标准头文件，其中定义了 <code>std::optional</code> 类模板。<code>std::optional</code> 提供了一种表示可能为空的值的机制，允许程序员在需要时将值包装在可选容器中，以便更安全地处理可能存在的缺失情况。</p>
<p>以下是 <code>&lt;optional&gt;</code> 标准库的一些重要特性和用法：</p>
<ol>
<li><p><strong>表示可能缺失的值</strong>：<code>std::optional</code> 是一种包装器，它可以容纳一个可能缺失的值。与裸指针或引用相比，<code>std::optional</code> 提供了更安全和更明确的语义，因为它明确表达了值的可选性。</p>
</li>
<li><p><strong>安全的值访问</strong>：通过使用 <code>std::optional</code> 提供的 <code>value()</code> 成员函数，你可以安全地访问被包装的值。如果值不存在，则调用 <code>value()</code> 会引发 <code>std::bad_optional_access</code> 异常。此外，<code>std::optional</code> 还提供了 <code>value_or()</code> 成员函数，允许你指定一个默认值，以在值不存在时返回。</p>
</li>
<li><p><strong>条件化的赋值</strong>：你可以将一个值赋给 <code>std::optional</code> 对象，这样如果被赋值的值为空，则 <code>std::optional</code> 也将为空。你也可以使用 <code>reset()</code> 成员函数显式地将 <code>std::optional</code> 设置为空。</p>
</li>
<li><p><strong>空值检查</strong>：通过调用 <code>has_value()</code> 成员函数，你可以检查 <code>std::optional</code> 是否包含了值。</p>
</li>
<li><p><strong>与标准算法的兼容性</strong>：<code>std::optional</code> 与标准库的算法完全兼容，你可以将 <code>std::optional</code> 用作容器中的元素，也可以将其作为算法的参数或返回值。</p>
</li>
<li><p><strong>性能开销</strong>：<code>std::optional</code> 的性能开销通常很小，因为它通常只包装了一个值，并且只有在值存在时才分配存储空间。</p>
</li>
</ol>
<p>使用 <code>std::optional</code> 可以让你的代码更加安全和清晰，因为它提供了一种明确和类型安全的方式来处理可能缺失的值。它是现代 C++ 中处理可选值的首选工具之一。</p>
<h2 id="C-std-optional-详解"><a href="#C-std-optional-详解" class="headerlink" title="C++ std::optional 详解"></a>C++ std::optional 详解</h2><p><code>std::optional</code> 是 C++17 引入的标准库类型，用于表示一个可能包含值的可选对象。它提供了一种方式来处理可能为空的值，而不需要使用指针或特殊的值来表示缺失。<code>std::optional</code> 是一个模板类，可以包含任何类型的值。</p>
<p>以下是 <code>std::optional</code> 的一些主要特性和用法：</p>
<ol>
<li><p><strong>表示可能为空的值</strong>：<code>std::optional</code> 允许你声明一个可能为空的值，这样就可以避免使用裸指针或特殊值来表示缺失。这有助于提高代码的安全性和可读性。</p>
</li>
<li><p><strong>避免空指针异常</strong>：使用 <code>std::optional</code> 可以避免空指针异常，因为它明确表示了值的可能缺失，并提供了相应的处理机制。</p>
</li>
<li><p><strong>安全地访问值</strong>：你可以使用 <code>std::optional</code> 提供的成员函数 <code>value()</code> 来访问值，它会在值为空时抛出异常，或者使用 <code>std::optional</code> 提供的成员函数 <code>value_or()</code> 来获取值或者指定的默认值。</p>
</li>
<li><p><strong>支持空值检查</strong>：你可以使用 <code>std::optional</code> 的成员函数 <code>has_value()</code> 来检查是否包含了值。</p>
</li>
<li><p><strong>条件化的赋值</strong>：可以使用赋值运算符将值分配给 <code>std::optional</code>，如果被分配的值为空，则 <code>std::optional</code> 也将变为空。</p>
</li>
<li><p><strong>与标准库算法的兼容性</strong>：<code>std::optional</code> 与标准库算法完全兼容，可以在容器中使用，也可以作为算法的参数或返回值。</p>
</li>
<li><p><strong>性能开销</strong>：<code>std::optional</code> 的性能开销通常很小，因为它通常是一个类似于指针的轻量级对象，只有在有值时才会分配存储空间。</p>
</li>
</ol>
<p>下面是一个简单的示例，演示了如何使用 <code>std::optional</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; optValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assigning a value</span></span><br><span class="line">    optValue = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (optValue.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; optValue.<span class="built_in">value</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;No value assigned.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using value_or() to get the value or a default value</span></span><br><span class="line">    <span class="type">int</span> val = optValue.<span class="built_in">value_or</span>(<span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value or default: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，<code>std::optional</code> 提供了一种方便、安全和灵活的方式来处理可能为空的值，是现代 C++ 中处理可选值的首选工具。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_39_locale/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_39_locale/" class="post-title-link" itemprop="url">C++_10_39_locale</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <locale>标准库</li>
</ul>
<h2 id="C-标准库-是什么"><a href="#C-标准库-是什么" class="headerlink" title="C++ 标准库 是什么"></a>C++ <locale>标准库 是什么</h2><p>C++ 标准库中的 <code>&lt;locale&gt;</code> 头文件提供了对本地化和文化特定信息的支持。本地化是指根据用户的区域设置和语言首选项来适应软件的行为和输出。<code>&lt;locale&gt;</code> 提供了一种方法来根据用户的偏好格式化数字、货币、日期和时间等信息。</p>
<p>以下是 <code>&lt;locale&gt;</code> 标准库的一些主要功能和概念：</p>
<ol>
<li><p>**本地化对象 (<code>std::locale</code>)**：<code>std::locale</code> 类表示一个特定的本地化环境，可以包含一组本地化设置，例如货币符号、日期格式等。程序可以使用 <code>std::locale</code> 对象来控制输出的格式。</p>
</li>
<li><p>**全局本地化对象 (<code>std::locale::global()</code>)**：<code>std::locale::global()</code> 函数用于设置全局本地化环境。这样设置后，所有的标准 I&#x2F;O 操作和其他与本地化相关的操作都会遵循指定的本地化环境。</p>
</li>
<li><p>**本地化特定的 <code>std::facet</code>**：<code>std::facet</code> 是一种抽象类，用于定义与特定本地化相关的行为，例如日期格式、货币格式等。C++ 标准库提供了一些预定义的 <code>std::facet</code> 类，也允许用户定义自己的本地化特定行为。</p>
</li>
<li><p><strong>本地化特定的 <code>std::locale::facet()</code> 函数</strong>：<code>std::locale::facet()</code> 函数用于获取给定本地化环境中特定类型的 <code>std::facet</code> 对象。</p>
</li>
<li><p><strong>本地化特定的输入&#x2F;输出流 (<code>std::iostream</code>) 操作符重载</strong>：C++ 标准库中的输入&#x2F;输出流操作符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 被重载以支持本地化环境。例如，使用 <code>std::cout</code> 输出数字时，可以根据本地化环境的设置自动格式化数字。</p>
</li>
<li><p>**本地化相关的 <code>std::time_get</code> 和 <code>std::time_put</code>**：这些类用于在不同的本地化环境中解析和格式化日期和时间。</p>
</li>
</ol>
<p>通过使用 <code>&lt;locale&gt;</code> 标准库，程序可以根据用户的偏好和环境设置自动调整输出的格式，使得软件可以在不同的国家和语言环境中以合适的方式显示信息。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <locale>标准库 详解</h2><p><code>&lt;locale&gt;</code> 标准库提供了对本地化（Localization）和国际化（Internationalization）的支持，使得 C++ 程序能够根据用户的地区、语言等偏好来调整输出的格式，包括数字、日期、时间、货币等。下面是对 <code>&lt;locale&gt;</code> 标准库的详细解析：</p>
<h3 id="1-std-locale-类"><a href="#1-std-locale-类" class="headerlink" title="1. std::locale 类"></a>1. <code>std::locale</code> 类</h3><p><code>std::locale</code> 类表示一个特定的本地化环境，包含了一系列本地化设置，如货币符号、日期格式、数字格式等。通过创建 <code>std::locale</code> 对象，可以设置程序的本地化环境。</p>
<h3 id="2-全局本地化设置"><a href="#2-全局本地化设置" class="headerlink" title="2. 全局本地化设置"></a>2. 全局本地化设置</h3><p>使用 <code>std::locale::global()</code> 函数可以设置全局的本地化环境，这样在程序的其他地方就可以自动使用该本地化环境的设置了。</p>
<h3 id="3-std-locale-facet-类"><a href="#3-std-locale-facet-类" class="headerlink" title="3. std::locale::facet 类"></a>3. <code>std::locale::facet</code> 类</h3><p><code>std::locale::facet</code> 是一个抽象基类，用于定义与特定本地化相关的行为。标准库提供了许多预定义的 <code>std::facet</code> 类，如 <code>std::numpunct</code>（用于数字格式化）、<code>std::time_get</code>（用于时间解析）等。</p>
<h3 id="4-std-locale-facet-函数"><a href="#4-std-locale-facet-函数" class="headerlink" title="4. std::locale::facet() 函数"></a>4. <code>std::locale::facet()</code> 函数</h3><p>通过调用 <code>std::locale::facet()</code> 函数可以获取给定本地化环境中特定类型的 <code>std::facet</code> 对象。</p>
<h3 id="5-本地化的输入-输出流操作符重载"><a href="#5-本地化的输入-输出流操作符重载" class="headerlink" title="5. 本地化的输入&#x2F;输出流操作符重载"></a>5. 本地化的输入&#x2F;输出流操作符重载</h3><p>C++ 标准库中的输入&#x2F;输出流操作符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 被重载以支持本地化环境。例如，使用 <code>std::cout</code> 输出数字时，可以根据本地化环境的设置自动格式化数字。</p>
<h3 id="6-std-use-facet-模板函数"><a href="#6-std-use-facet-模板函数" class="headerlink" title="6. std::use_facet 模板函数"></a>6. <code>std::use_facet</code> 模板函数</h3><p><code>std::use_facet</code> 函数用于从 <code>std::locale</code> 对象中获取指定类型的 <code>std::facet</code> 对象，以便对本地化环境进行更详细的定制。</p>
<h3 id="7-std-time-get-和-std-time-put-类"><a href="#7-std-time-get-和-std-time-put-类" class="headerlink" title="7. std::time_get 和 std::time_put 类"></a>7. <code>std::time_get</code> 和 <code>std::time_put</code> 类</h3><p>这些类用于在不同的本地化环境中解析和格式化日期和时间。</p>
<h3 id="8-其他相关类和函数"><a href="#8-其他相关类和函数" class="headerlink" title="8. 其他相关类和函数"></a>8. 其他相关类和函数</h3><p>除了上述提到的类和函数外，<code>&lt;locale&gt;</code> 标准库还提供了许多其他与本地化相关的类和函数，如 <code>std::collate</code>（用于字符串排序）、<code>std::ctype</code>（用于字符分类和转换）、<code>std::messages</code>（用于多语言消息处理）等。</p>
<p>通过 <code>&lt;locale&gt;</code> 标准库，C++ 程序可以更容易地支持不同地区和语言环境下的本地化需求，提高了程序的灵活性和用户体验。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_4_chrono/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_4_chrono/" class="post-title-link" itemprop="url">C++_10_4_chrono</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><chrono>标准库相关笔记</li>
</ul>
<h2 id="std-chrono-duration-时间段转为时分秒的形式输出"><a href="#std-chrono-duration-时间段转为时分秒的形式输出" class="headerlink" title="std::chrono::duration 时间段转为时分秒的形式输出"></a>std::chrono::duration 时间段转为时分秒的形式输出</h2><p>在 C++ 中，<code>std::chrono::duration</code> 表示一个时间间隔，你可以将其转换为时、分、秒的形式进行输出。下面是具体方法：</p>
<h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><ol>
<li>**使用 <code>std::chrono::duration_cast</code> 将 <code>duration</code> 转换为 <code>hours</code>、<code>minutes</code> 和 <code>seconds</code>**。</li>
<li><strong>使用取模运算 (<code>%</code>) 计算去掉小时后的分钟数，去掉分钟后的秒数</strong>。</li>
</ol>
<hr>
<h2 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_duration</span><span class="params">(std::chrono::seconds duration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取小时、分钟、秒</span></span><br><span class="line">    <span class="keyword">auto</span> h = <span class="built_in">duration_cast</span>&lt;hours&gt;(duration);</span><br><span class="line">    <span class="keyword">auto</span> m = <span class="built_in">duration_cast</span>&lt;minutes&gt;(duration % <span class="built_in">hours</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">auto</span> s = <span class="built_in">duration_cast</span>&lt;seconds&gt;(duration % <span class="built_in">minutes</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    std::cout &lt;&lt; h.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;h &quot;</span></span><br><span class="line">              &lt;&lt; m.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;m &quot;</span></span><br><span class="line">              &lt;&lt; s.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="function">chrono::seconds <span class="title">duration</span><span class="params">(<span class="number">3665</span>)</span></span>; <span class="comment">// 3665秒 = 1小时 1分 5秒</span></span><br><span class="line">    <span class="built_in">print_duration</span>(duration);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1h 1m 5s</span><br></pre></td></tr></table></figure>

<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><ul>
<li><code>duration_cast&lt;std::chrono::hours&gt;(duration)</code> 计算完整的小时数。</li>
<li><code>duration % std::chrono::hours(1)</code> 获取去掉小时后剩余的时间，然后转换为分钟。</li>
<li><code>duration % std::chrono::minutes(1)</code> 获取去掉分钟后剩余的秒数。</li>
</ul>
<p>这样，你可以把任何 <code>std::chrono::duration</code> 转换为 <code>hh:mm:ss</code> 的格式！</p>
<h2 id="持续时间的表示-Duration-Representation"><a href="#持续时间的表示-Duration-Representation" class="headerlink" title="持续时间的表示(Duration Representation)"></a>持续时间的表示(Duration Representation)</h2><ul>
<li>持续时间在std::chrono中是以一种非常直观的方式表示的，它反映了我们对时间的基本理解：时间是连续的，并且可以以不同的单位来衡量。在std::chrono中，持续时间是通过两个模板参数来定义的：一个是用于存储时间值的底层类型（如int64_t），另一个是时间单位（如秒、毫秒）。</li>
</ul>
<h2 id="C-标准库是什么"><a href="#C-标准库是什么" class="headerlink" title="C++ 标准库是什么"></a>C++ <chrono>标准库是什么</h2><p>C++ 标准库中的 <code>&lt;chrono&gt;</code> 是用于处理时间相关操作的头文件，提供了时间点（<code>time_point</code>）和持续时间（<code>duration</code>）的类模板，以及用于操作时间的各种函数和工具。</p>
<p>主要包括以下内容：</p>
<h3 id="时间点（time-point）和持续时间（duration）："><a href="#时间点（time-point）和持续时间（duration）：" class="headerlink" title="时间点（time_point）和持续时间（duration）："></a>时间点（<code>time_point</code>）和持续时间（<code>duration</code>）：</h3><ul>
<li><strong><code>std::chrono::time_point</code>：</strong> 代表时间的点，通常表示自某个特定时钟起的时间。例如，<code>std::chrono::system_clock::time_point</code> 表示系统时钟的时间点。</li>
<li><strong><code>std::chrono::duration</code>：</strong> 表示时间间隔的持续时间，可以用于表示一段时间的长度。例如，<code>std::chrono::duration&lt;int&gt;</code> 表示以整数单位的时间段。</li>
</ul>
<h3 id="时钟（Clocks）："><a href="#时钟（Clocks）：" class="headerlink" title="时钟（Clocks）："></a>时钟（Clocks）：</h3><ul>
<li><strong><code>std::chrono::system_clock</code>：</strong> 代表系统时钟，提供了从 Epoch（通常是 1970 年 1 月 1 日）起的时间点。</li>
<li><strong><code>std::chrono::steady_clock</code>：</strong> 代表一个单调递增的时钟，不受系统时间调整影响，适合测量时间间隔。</li>
<li><strong><code>std::chrono::high_resolution_clock</code>：</strong> 代表一个高分辨率的时钟，提供了更高精度的计时。</li>
</ul>
<h3 id="时间相关工具和函数："><a href="#时间相关工具和函数：" class="headerlink" title="时间相关工具和函数："></a>时间相关工具和函数：</h3><ul>
<li><strong>时间单位转换：</strong> 提供了 <code>duration_cast</code> 函数用于不同时间单位之间的转换。</li>
<li><strong>时间点的算术运算：</strong> 可以对时间点进行加减运算。</li>
<li><strong>定时器操作：</strong> 可以用于实现定时器，比如 <code>std::this_thread::sleep_for</code> 和 <code>std::this_thread::sleep_until</code>。</li>
<li><strong>时钟的特性和属性：</strong> 可以获取时钟的特性，如时钟的最小精度、是否稳定等。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间点</span></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间点转换为时间戳</span></span><br><span class="line">    std::<span class="type">time_t</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current time: &quot;</span> &lt;&lt; std::<span class="built_in">ctime</span>(&amp;now_c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建持续时间并延迟一段时间</span></span><br><span class="line">    std::<span class="function">chrono::milliseconds <span class="title">delay</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(delay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;chrono&gt;</code> 提供了一种标准化的时间处理方式，可用于测量和管理时间，执行定时操作以及进行时间单位转换。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <chrono>标准库 详解</h2><p><code>&lt;chrono&gt;</code> 是 C++ 标准库中用于处理时间相关操作的头文件，自 C++11 起引入。它提供了时间点（<code>time_point</code>）、持续时间（<code>duration</code>）、时钟（<code>clock</code>）以及与时间相关的函数和工具，使得在 C++ 中对时间进行精确测量和处理变得更加方便和标准化。</p>
<h3 id="重要的类型和类："><a href="#重要的类型和类：" class="headerlink" title="重要的类型和类："></a>重要的类型和类：</h3><ul>
<li><strong><code>std::chrono::time_point</code>：</strong> 表示时间的点，在特定时钟下的时间。例如，<code>std::chrono::system_clock::time_point</code> 表示系统时钟的时间点。</li>
<li><strong><code>std::chrono::duration</code>：</strong> 表示时间间隔的持续时间，可以用于表示一段时间的长度。例如，<code>std::chrono::duration&lt;int&gt;</code> 表示以整数单位的时间段。</li>
</ul>
<h3 id="重要的时钟（Clocks）："><a href="#重要的时钟（Clocks）：" class="headerlink" title="重要的时钟（Clocks）："></a>重要的时钟（Clocks）：</h3><ul>
<li><strong><code>std::chrono::system_clock</code>：</strong> 代表系统时钟，提供了从 Epoch（通常是 1970 年 1 月 1 日）起的时间点。</li>
<li><strong><code>std::chrono::steady_clock</code>：</strong> 代表一个单调递增的时钟，不受系统时间调整影响，适合测量时间间隔。</li>
<li><strong><code>std::chrono::high_resolution_clock</code>：</strong> 代表一个高分辨率的时钟，提供了更高精度的计时。</li>
</ul>
<h3 id="主要函数和工具："><a href="#主要函数和工具：" class="headerlink" title="主要函数和工具："></a>主要函数和工具：</h3><ul>
<li><strong>时间单位转换：</strong> 提供了 <code>std::chrono::duration_cast</code> 函数用于不同时间单位之间的转换。</li>
<li><strong>时间点的算术运算：</strong> 可以对时间点进行加减运算。</li>
<li><strong>定时器操作：</strong> 可以用于实现定时器，比如 <code>std::this_thread::sleep_for</code> 和 <code>std::this_thread::sleep_until</code>。</li>
<li><strong>获取时间点：</strong> 提供了 <code>std::chrono::system_clock::now()</code> 用于获取当前时间点。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间点</span></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间点转换为时间戳</span></span><br><span class="line">    std::<span class="type">time_t</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current time: &quot;</span> &lt;&lt; std::<span class="built_in">ctime</span>(&amp;now_c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建持续时间并延迟一段时间</span></span><br><span class="line">    std::<span class="function">chrono::milliseconds <span class="title">delay</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(delay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;chrono&gt;</code> 提供了一种标准化的时间处理方式，可用于测量和管理时间，执行定时操作以及进行时间单位转换。它的引入使得在 C++ 中对时间进行处理更加方便和跨平台。</p>
<h2 id="C-标准库-常用函数"><a href="#C-标准库-常用函数" class="headerlink" title="C++ 标准库 常用函数"></a>C++ <chrono>标准库 常用函数</h2><p>C++ <code>&lt;chrono&gt;</code> 标准库提供了用于处理时间的功能，包括时间点（time points）、时间间隔（durations）、时钟（clocks）等。以下是一些 <code>&lt;chrono&gt;</code> 标准库中常用的函数和类：</p>
<h3 id="类和类型"><a href="#类和类型" class="headerlink" title="类和类型"></a>类和类型</h3><ol>
<li><p>**<code>std::chrono::duration</code>**：表示时间间隔的类型。例如 <code>std::chrono::duration&lt;int&gt;</code> 表示以整数秒为单位的时间间隔。</p>
</li>
<li><p>**<code>std::chrono::time_point</code>**：表示特定时钟的时间点。它由时钟和持续时间构成。</p>
</li>
<li><p>**<code>std::chrono::system_clock</code>**：提供当前时间，并使用 UNIX 时间（1970 年 1 月 1 日午夜起的秒数）作为其时间起点。</p>
</li>
<li><p>**<code>std::chrono::steady_clock</code>**：提供一个稳定的时钟，用于测量时间间隔，不受系统时间调整的影响。</p>
</li>
<li><p>**<code>std::chrono::high_resolution_clock</code>**：提供高分辨率时钟，尽可能提供最高精度的计时，但其精度因平台而异。</p>
</li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol>
<li><p>**<code>std::chrono::duration_cast</code>**：用于将一个时间间隔类型转换为另一个时间间隔类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::minutes&gt;(some_duration);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>std::chrono::time_point_cast</code>**：用于将一个时间点类型转换为另一个时间点类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::hours&gt;(some_time_point);</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>std::chrono::system_clock::now</code>**：获取当前时间点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> current_time = std::chrono::system_clock::<span class="built_in">now</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>std::chrono::steady_clock::now</code>**：获取当前稳定时钟的时间点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> current_time = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>std::chrono::duration</code> 中的各种算术运算</strong>：例如加法、减法、乘法和除法，用于处理时间间隔之间的运算。</p>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前系统时间点</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一段程序执行时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 做一些计算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结束时间点</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算程序执行时间间隔</span></span><br><span class="line">    <span class="keyword">auto</span> duration = end_time - start_time;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program execution time: &quot;</span> &lt;&lt; std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(duration).<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; milliseconds\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是 C++ <code>&lt;chrono&gt;</code> 标准库中一些常用的函数和类，可以用于时间点和时间间隔的操作和管理。</p>
<h2 id="std-chrono-duration"><a href="#std-chrono-duration" class="headerlink" title="std::chrono::duration"></a>std::chrono::duration</h2><p><code>std::chrono::duration</code> 是 C++ <code>&lt;chrono&gt;</code> 标准库中表示时间间隔的类模板。它表示一个时间段，可以用于测量不同时间点之间的时间差，以及进行时间单位之间的转换。<code>std::chrono::duration</code> 的模板定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span> = std::ratio&lt;<span class="number">1</span>&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> duration;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Rep</code>：表示持续时间的类型，通常是一个整数类型，用于存储时间长度。</li>
<li><code>Period</code>：表示时间单位的类型，通常是 <code>std::ratio</code> 类型，它定义了时间间隔的基本单位。</li>
</ul>
<h3 id="示例用法："><a href="#示例用法：" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个持续时间为10秒的duration</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">int</span>&gt; <span class="title">ten_seconds</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取duration的值和单位</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ten_seconds: &quot;</span> &lt;&lt; ten_seconds.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个浮点型持续时间，表示0.5秒</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">double</span>&gt; <span class="title">half_second</span><span class="params">(<span class="number">0.5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取duration的值和单位</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;half_second: &quot;</span> &lt;&lt; half_second.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行duration之间的加法操作</span></span><br><span class="line">    <span class="keyword">auto</span> total_duration = ten_seconds + half_second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取总持续时间的值和单位</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;total_duration: &quot;</span> &lt;&lt; total_duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>std::chrono::duration</code> 被用来表示不同的时间间隔，可以通过 <code>count()</code> 函数获取其持续时间的值，并且支持多种时间间隔的算术操作，如加法、减法等。</p>
<h2 id="std-chrono-time-point"><a href="#std-chrono-time-point" class="headerlink" title="std::chrono::time_point"></a>std::chrono::time_point</h2><p><code>std::chrono::time_point</code> 是 C++ <code>&lt;chrono&gt;</code> 标准库中的类模板，用于表示特定时钟（<code>Clock</code>）的时间点。它结合了时钟（<code>Clock</code>）和持续时间（<code>Duration</code>），可以表示从时钟的起点开始经过的时间。<code>std::chrono::time_point</code> 的模板定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Clock</span>, <span class="keyword">class</span> <span class="title class_">Duration</span> = <span class="keyword">typename</span> Clock::duration&gt;</span><br><span class="line"><span class="keyword">class</span> time_point;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Clock</code>：表示时钟类型，例如 <code>std::chrono::system_clock</code>、<code>std::chrono::steady_clock</code> 等。</li>
<li><code>Duration</code>：表示时间间隔的类型，通常是 <code>std::chrono::duration</code> 类型。</li>
</ul>
<h3 id="示例用法：-1"><a href="#示例用法：-1" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 system_clock 获取当前时间点</span></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::system_clock&gt; current_time = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 steady_clock 获取当前时间点</span></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::steady_clock&gt; start_time = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行一些操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取另一个时间点并计算时间间隔</span></span><br><span class="line">    std::chrono::time_point&lt;std::chrono::steady_clock&gt; end_time = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>&gt; duration = end_time - start_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出时间间隔</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Duration: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>std::chrono::time_point</code> 被用于存储不同时钟类型（<code>std::chrono::system_clock</code> 和 <code>std::chrono::steady_clock</code>）的时间点。可以使用 <code>now()</code> 函数获取当前时间点，也可以进行时间点之间的算术运算（例如计算时间间隔）。</p>
<h2 id="std-chrono-system-clock"><a href="#std-chrono-system-clock" class="headerlink" title="std::chrono::system_clock"></a>std::chrono::system_clock</h2><p><code>std::chrono::system_clock</code> 是 C++ <code>&lt;chrono&gt;</code> 标准库中的时钟类型，用于提供当前系统时间和日期。它是一个基于实时时钟的时钟类，使用的时钟起点通常是 UNIX 时间（1970 年 1 月 1 日午夜起的秒数）。<code>std::chrono::system_clock</code> 提供了获取当前时间的方法。</p>
<h3 id="示例用法：-2"><a href="#示例用法：-2" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前系统时间点</span></span><br><span class="line">    std::chrono::system_clock::time_point now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将时间点转换为时间戳（秒数）</span></span><br><span class="line">    std::<span class="type">time_t</span> timestamp = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出时间戳</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current timestamp: &quot;</span> &lt;&lt; timestamp &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将时间戳转换回时间点</span></span><br><span class="line">    std::chrono::system_clock::time_point time_from_timestamp = std::chrono::system_clock::<span class="built_in">from_time_t</span>(timestamp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查时间点是否相同</span></span><br><span class="line">    <span class="keyword">if</span> (time_from_timestamp == now) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Time points are equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Time points are not equal.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>std::chrono::system_clock</code> 被用于获取当前系统时间点 (<code>now</code>)，并且可以将时间点转换为时间戳 (<code>std::time_t</code>)，以及将时间戳转换回时间点。这允许在不同的时钟表示之间进行转换和比较。</p>
<h2 id="std-chrono-steady-clock"><a href="#std-chrono-steady-clock" class="headerlink" title="std::chrono::steady_clock"></a>std::chrono::steady_clock</h2><p><code>std::chrono::steady_clock</code> 是 C++ <code>&lt;chrono&gt;</code> 标准库中的时钟类型，用于提供稳定、不受系统时间调整影响的时钟。它用于测量时间间隔，适合于需要精确计时而不受系统时间调整（例如时间同步或夏令时变化）影响的场景。</p>
<h3 id="示例用法：-3"><a href="#示例用法：-3" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取起始时间点</span></span><br><span class="line">    std::chrono::steady_clock::time_point start_time = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一段程序执行时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 做一些计算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结束时间点</span></span><br><span class="line">    std::chrono::steady_clock::time_point end_time = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算程序执行时间间隔</span></span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>&gt; duration = end_time - start_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出程序执行时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program execution time: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::chrono::steady_clock</code> 被用于获取程序开始和结束时的时间点，并计算两个时间点之间的持续时间。这种时钟不受系统时间调整的影响，适用于需要精确计时的场景，比如性能测试或计时要求较高的应用程序。</p>
<h2 id="std-chrono-high-resolution-clock"><a href="#std-chrono-high-resolution-clock" class="headerlink" title="std::chrono::high_resolution_clock"></a>std::chrono::high_resolution_clock</h2><p><code>std::chrono::high_resolution_clock</code> 是 C++ <code>&lt;chrono&gt;</code> 标准库中的时钟类型，提供了高精度计时功能，尽可能提供最高分辨率的时间测量。然而，精度和实际分辨率可能因平台和实现而异。</p>
<h3 id="示例用法：-4"><a href="#示例用法：-4" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取起始时间点</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟一段程序执行时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 做一些计算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结束时间点</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算程序执行时间间隔</span></span><br><span class="line">    <span class="keyword">auto</span> duration = end_time - start_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出程序执行时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program execution time: &quot;</span> &lt;&lt; std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(duration).<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>std::chrono::high_resolution_clock</code> 被用于测量程序执行时间。需要注意的是，尽管这个时钟通常提供较高的分辨率，但实际精度取决于系统的支持以及硬件平台。因此，在不同的系统上，精度和分辨率可能会有所不同。</p>
<h2 id="std-chrono-duration-cast"><a href="#std-chrono-duration-cast" class="headerlink" title="std::chrono::duration_cast"></a>std::chrono::duration_cast</h2><p><code>std::chrono::duration_cast</code> 是 <code>&lt;chrono&gt;</code> 标准库中的函数，用于执行 <code>std::chrono::duration</code> 类型之间的转换。它允许将一个持续时间（duration）对象从一种单位转换为另一种单位。常用于从高精度单位（例如纳秒或微秒）转换为较低精度单位（例如秒或毫秒）。</p>
<h3 id="示例用法：-5"><a href="#示例用法：-5" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个高精度的持续时间（纳秒）</span></span><br><span class="line">    std::<span class="function">chrono::nanoseconds <span class="title">ns_duration</span><span class="params">(<span class="number">123456789</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将纳秒转换为毫秒</span></span><br><span class="line">    std::chrono::milliseconds ms_duration = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(ns_duration);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出转换后的持续时间</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Milliseconds: &quot;</span> &lt;&lt; ms_duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>std::chrono::duration_cast</code> 将纳秒时间持续时间对象 <code>ns_duration</code> 转换为毫秒时间持续时间对象 <code>ms_duration</code>。<code>count()</code> 函数用于获取转换后持续时间的数值，并输出转换后的持续时间。这个函数非常有用，因为它允许你在不同时间单位之间进行安全和精确的转换。</p>
<h2 id="std-chrono-time-point-cast"><a href="#std-chrono-time-point-cast" class="headerlink" title="std::chrono::time_point_cast"></a>std::chrono::time_point_cast</h2><p><code>std::chrono::time_point_cast</code> 是 <code>&lt;chrono&gt;</code> 标准库中的函数，用于将 <code>std::chrono::time_point</code> 对象从一种时钟类型（<code>Clock</code>）转换为另一种时钟类型，并指定新的时间单位。</p>
<h3 id="示例用法：-6"><a href="#示例用法：-6" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个时间点，使用系统时钟</span></span><br><span class="line">    std::chrono::system_clock::time_point sys_time = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将系统时钟时间点转换为稳定时钟时间点</span></span><br><span class="line">    std::chrono::steady_clock::time_point steady_time = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::steady_clock::duration&gt;(sys_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出转换后的时间点（稳定时钟）</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Steady clock time: &quot;</span> &lt;&lt; std::chrono::steady_clock::<span class="built_in">to_time_t</span>(steady_time) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::chrono::time_point_cast</code> 用于将系统时钟 (<code>std::chrono::system_clock</code>) 的时间点 <code>sys_time</code> 转换为稳定时钟 (<code>std::chrono::steady_clock</code>) 的时间点 <code>steady_time</code>。这种转换可能导致精度损失，因为不同的时钟可能具有不同的分辨率和特性。</p>
<h2 id="std-chrono-system-clock-now"><a href="#std-chrono-system-clock-now" class="headerlink" title="std::chrono::system_clock::now"></a>std::chrono::system_clock::now</h2><p><code>std::chrono::system_clock::now</code> 是 C++ <code>&lt;chrono&gt;</code> 标准库中的函数，用于获取当前系统时间点，返回一个 <code>std::chrono::time_point</code> 对象，表示当前的系统时间。</p>
<h3 id="示例用法：-7"><a href="#示例用法：-7" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前系统时间点</span></span><br><span class="line">    std::chrono::system_clock::time_point now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将时间点转换为时间戳（秒数）</span></span><br><span class="line">    std::<span class="type">time_t</span> timestamp = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出时间戳</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current timestamp: &quot;</span> &lt;&lt; timestamp &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::chrono::system_clock::now()</code> 用于获取当前系统时间点，然后通过 <code>std::chrono::system_clock::to_time_t</code> 将时间点转换为时间戳（秒数）以便输出。</p>
<h2 id="std-chrono-steady-clock-now"><a href="#std-chrono-steady-clock-now" class="headerlink" title="std::chrono::steady_clock::now"></a>std::chrono::steady_clock::now</h2><p><code>std::chrono::steady_clock::now()</code> 是 C++ <code>&lt;chrono&gt;</code> 标准库中的函数，用于获取当前稳定时钟（<code>std::chrono::steady_clock</code>）的时间点，返回一个 <code>std::chrono::time_point</code> 对象，表示当前的稳定时钟时间点。</p>
<h3 id="示例用法：-8"><a href="#示例用法：-8" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前稳定时钟时间点</span></span><br><span class="line">    std::chrono::steady_clock::time_point now = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行一些操作...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取经过的时间间隔</span></span><br><span class="line">    std::chrono::steady_clock::time_point later = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>&gt; duration = later - now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出经过的时间间隔</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elapsed time: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::chrono::steady_clock::now()</code> 被用于获取程序执行时的稳定时钟时间点，然后可以计算程序执行所经过的时间间隔，这在需要精确计时而又不受系统时间变化影响的场景下非常有用。</p>
<h2 id="std-chrono-duration-1"><a href="#std-chrono-duration-1" class="headerlink" title="std::chrono::duration"></a>std::chrono::duration</h2><p><code>std::chrono::duration</code> 是 C++ <code>&lt;chrono&gt;</code> 标准库中用于表示时间间隔的类模板。它能够表示一个时间段，即持续时间，以及可以用于测量不同时间点之间的时间差。</p>
<h3 id="模板定义："><a href="#模板定义：" class="headerlink" title="模板定义："></a>模板定义：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Rep</span>, <span class="keyword">class</span> <span class="title class_">Period</span> = std::ratio&lt;<span class="number">1</span>&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> duration;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Rep</code>：表示时间长度的类型，通常是一个整数类型，用于存储时间的长度。</li>
<li><code>Period</code>：表示时间单位的类型，通常是 <code>std::ratio</code> 类型，定义了时间间隔的基本单位。</li>
</ul>
<h3 id="示例用法：-9"><a href="#示例用法：-9" class="headerlink" title="示例用法："></a>示例用法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个持续时间为 5 秒的 duration 对象</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">int</span>&gt; <span class="title">five_seconds</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 duration 对象的值和单位</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Five seconds: &quot;</span> &lt;&lt; five_seconds.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个浮点型持续时间，表示 2.5 秒</span></span><br><span class="line">    std::<span class="function">chrono::duration&lt;<span class="type">double</span>&gt; <span class="title">two_and_half_seconds</span><span class="params">(<span class="number">2.5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取浮点型 duration 对象的值和单位</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Two and a half seconds: &quot;</span> &lt;&lt; two_and_half_seconds.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行 duration 对象之间的加法操作</span></span><br><span class="line">    <span class="keyword">auto</span> total_duration = five_seconds + two_and_half_seconds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取总持续时间的值和单位</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total duration: &quot;</span> &lt;&lt; total_duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>std::chrono::duration</code> 用于表示不同的时间间隔，并可以通过 <code>count()</code> 函数获取持续时间的值。同时，<code>std::chrono::duration</code> 还支持不同时间间隔之间的算术操作，比如加法、减法等。</p>
<h2 id="C-格式化输出年月日-时分秒"><a href="#C-格式化输出年月日-时分秒" class="headerlink" title="C++  格式化输出年月日-时分秒"></a>C++ <chrono> 格式化输出年月日-时分秒</h2><p>要格式化输出年月日-时分秒，你可以使用<code>std::put_time</code>函数。这个函数允许你将<code>std::tm</code>结构体转换为一个字符串，以指定的格式输出。下面是一个示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间点</span></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将时间点转换为时间结构体</span></span><br><span class="line">    std::<span class="type">time_t</span> now_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line">    std::tm* now_tm = std::<span class="built_in">localtime</span>(&amp;now_c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化输出年月日-时分秒</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前时间：&quot;</span> &lt;&lt; std::<span class="built_in">put_time</span>(now_tm, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码使用<code>std::put_time</code>将<code>now_tm</code>结构体以指定格式输出，即”%Y-%m-%d %H:%M:%S”，其中：</p>
<ul>
<li><code>%Y</code>表示年份（四位数）</li>
<li><code>%m</code>表示月份（两位数）</li>
<li><code>%d</code>表示日期（两位数）</li>
<li><code>%H</code>表示小时（24小时制，两位数）</li>
<li><code>%M</code>表示分钟（两位数）</li>
<li><code>%S</code>表示秒（两位数）</li>
</ul>
<p>运行这段代码将输出当前的年月日-时分秒。</p>
<h2 id="C-std-chrono-literals-是什么"><a href="#C-std-chrono-literals-是什么" class="headerlink" title="C++ std::chrono_literals 是什么"></a>C++ std::chrono_literals 是什么</h2><p>C++ 标准库中的 <code>std::chrono_literals</code> 是 C++11 引入的一个命名空间，用于提供方便的时间单位字面量，使得在编写时间相关代码时更加直观和易读。</p>
<p>这个命名空间中包含了各种时间单位的字面量，例如：</p>
<ul>
<li><code>1s</code>：表示一秒钟。</li>
<li><code>1ms</code>：表示一毫秒（千分之一秒）。</li>
<li><code>1us</code>：表示一微秒（百万分之一秒）。</li>
<li><code>1ns</code>：表示一纳秒（十亿分之一秒）。</li>
</ul>
<p>通过使用这些字面量，你可以在代码中直接使用自然的时间单位，而不需要手动计算时间的毫秒、微秒或纳秒值，从而提高了代码的可读性和可维护性。</p>
<p>例如，你可以这样使用 <code>std::chrono_literals</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> duration = <span class="number">100</span>ms;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Duration: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; milliseconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> timeout = <span class="number">5</span>s;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Timeout: &quot;</span> &lt;&lt; timeout.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>100ms</code> 和 <code>5s</code> 就是使用 <code>std::chrono_literals</code> 提供的时间单位字面量，分别表示 100 毫秒和 5 秒。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_42_semaphore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_42_semaphore/" class="post-title-link" itemprop="url">C++_10_42_semaphore</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <semaphore>标准库 详解</li>
</ul>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <semaphore>标准库 详解</h2><p>在C++20标准中引入了 <code>&lt;semaphore&gt;</code> 头文件，提供了信号量（Semaphore）的标准库实现。信号量是一种经典的同步原语，用于控制对共享资源的访问。</p>
<h3 id="创建信号量"><a href="#创建信号量" class="headerlink" title="创建信号量"></a>创建信号量</h3><p>使用 <code>std::counting_semaphore</code> 来创建一个计数信号量，或者使用 <code>std::binary_semaphore</code> 来创建一个二进制信号量。计数信号量允许指定一个初始计数值，而二进制信号量的初始状态是锁定的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::counting_semaphore</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::counting_semaphore</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::counting_semaphore</span><br><span class="line"></span><br><span class="line">### 使用计数信号量</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::counting_semaphore&lt;<span class="type">int</span>&gt; <span class="title">mySemaphore</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 创建一个初始计数值为1的计数信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    mySemaphore.<span class="built_in">acquire</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// Simulate some work</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    mySemaphore.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(worker, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用二进制信号量"><a href="#使用二进制信号量" class="headerlink" title="使用二进制信号量"></a>使用二进制信号量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::binary_semaphore <span class="title">mySemaphore</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 创建一个初始状态为1的二进制信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    mySemaphore.<span class="built_in">acquire</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// Simulate some work</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    mySemaphore.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(worker, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两种信号量，一种是计数信号量，另一种是二进制信号量。计数信号量允许多个线程同时访问共享资源，而二进制信号量一次只允许一个线程访问共享资源。</p>
<p>标准库的信号量实现提供了一个简单而强大的工具，用于管理多线程环境中的资源访问。</p>
<h2 id="C-std-semaphore-详解"><a href="#C-std-semaphore-详解" class="headerlink" title="C++ std::semaphore 详解"></a>C++ std::semaphore 详解</h2><p>在C++20中，标准库引入了信号量 (<code>std::semaphore</code>)。信号量是一种经典的同步原语，用于控制多个线程对共享资源的访问。让我们详细了解一下 <code>std::semaphore</code>：</p>
<h3 id="创建信号量-1"><a href="#创建信号量-1" class="headerlink" title="创建信号量"></a>创建信号量</h3><p>你可以使用 <code>std::semaphore</code> 的构造函数来创建一个信号量。构造函数需要一个参数，即初始的信号量计数值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::semaphore <span class="title">mySemaphore</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 创建一个初始计数值为1的信号量</span></span><br></pre></td></tr></table></figure>

<h3 id="P-操作（等待）"><a href="#P-操作（等待）" class="headerlink" title="P 操作（等待）"></a>P 操作（等待）</h3><p>当一个线程想要访问共享资源时，它必须执行 P 操作，也称为等待操作。如果信号量的计数值大于 0，则计数值减 1，线程继续执行。如果计数值为 0，则线程被阻塞，直到有其他线程执行 V 操作（释放）来增加计数值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mySemaphore.<span class="built_in">acquire</span>(); <span class="comment">// 等待（等同于 P 操作）</span></span><br></pre></td></tr></table></figure>

<h3 id="V-操作（释放）"><a href="#V-操作（释放）" class="headerlink" title="V 操作（释放）"></a>V 操作（释放）</h3><p>当一个线程完成对共享资源的访问时，它执行 V 操作，也称为释放操作。这会增加信号量的计数值，并唤醒等待的线程（如果有的话）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mySemaphore.<span class="built_in">release</span>(); <span class="comment">// 释放（等同于 V 操作）</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::semaphore <span class="title">mySemaphore</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 创建一个初始计数值为1的信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    mySemaphore.<span class="built_in">acquire</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// Simulate some work</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; finished.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    mySemaphore.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(worker, <span class="number">2</span>)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，两个线程共享一个信号量 <code>mySemaphore</code>。只有一个线程能够获得信号量，另一个线程必须等待，直到第一个线程释放信号量。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>如果信号量的计数值小于0，<code>acquire()</code> 将会阻塞当前线程。</li>
<li><code>release()</code> 会递增信号量的计数值，并唤醒一个等待的线程（如果有）。</li>
<li>使用信号量时，要注意正确地保证计数值的增减，以免造成死锁或者资源泄漏。</li>
</ul>
<p>通过 <code>std::semaphore</code>，C++标准库提供了一种简单而强大的机制来处理多线程间的同步问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_5_string/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_5_string/" class="post-title-link" itemprop="url">C++_10_5_string</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><string>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++  标准库"></a>C++ <string> 标准库</h2><p>C++ 标准库中的 <code>&lt;string&gt;</code> 头文件提供了许多操作字符串的功能，包括创建、操作、处理和管理字符串。使用这个头文件，可以方便地使用字符串并执行各种操作，例如连接字符串、查找子串、截取部分字符串等。</p>
<p>以下是 <code>&lt;string&gt;</code> 标准库中一些常用的类和函数：</p>
<h3 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h3><ul>
<li><strong><code>std::string</code></strong>: 提供了一个可变长度的字符序列，支持字符串的各种操作和方法，如插入、删除、查找、替换等。</li>
</ul>
<h3 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h3><ul>
<li><strong><code>std::to_string()</code></strong>: 将基本数据类型转换为对应的字符串。</li>
<li><strong><code>std::stoi()</code>, <code>std::stol()</code>, <code>std::stoll()</code>, <code>std::stof()</code>, <code>std::stod()</code>, <code>std::stold()</code></strong>: 将字符串转换为对应的数值类型。</li>
<li><strong><code>std::getline()</code></strong>: 从输入流中读取一行数据到字符串中。</li>
</ul>
<h3 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h3><ul>
<li><strong><code>size()</code>, <code>length()</code></strong>: 返回字符串的长度。</li>
<li><strong><code>append()</code>, <code>+=</code></strong>: 在字符串末尾追加内容。</li>
<li><strong><code>insert()</code>, <code>erase()</code>, <code>replace()</code></strong>: 插入、删除、替换子串。</li>
<li><strong><code>substr()</code>, <code>find()</code>, <code>rfind()</code></strong>: 提取子串、查找子串的位置。</li>
</ul>
<h3 id="字符串比较和转换"><a href="#字符串比较和转换" class="headerlink" title="字符串比较和转换"></a>字符串比较和转换</h3><ul>
<li><strong><code>compare()</code></strong>: 比较字符串。</li>
<li><strong><code>toupper()</code>, <code>tolower()</code></strong>: 转换为大写或小写。</li>
</ul>
<h3 id="字符串查询和搜索"><a href="#字符串查询和搜索" class="headerlink" title="字符串查询和搜索"></a>字符串查询和搜索</h3><ul>
<li><strong><code>find()</code>, <code>rfind()</code>, <code>find_first_of()</code>, <code>find_last_of()</code>, <code>find_first_not_of()</code>, <code>find_last_not_of()</code></strong>: 查找字符串中特定子串或字符的位置。</li>
</ul>
<h3 id="其他实用函数"><a href="#其他实用函数" class="headerlink" title="其他实用函数"></a>其他实用函数</h3><ul>
<li><strong><code>c_str()</code>, <code>data()</code></strong>: 返回以 null 结尾的 C 风格字符串的指针。</li>
<li><strong><code>empty()</code>, <code>clear()</code>, <code>reserve()</code>, <code>shrink_to_fit()</code></strong>: 管理字符串的空间和大小。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">    str += <span class="string">&quot;world!&quot;</span>; <span class="comment">// 连接字符串</span></span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Length of str: &quot;</span> &lt;&lt; str.<span class="built_in">length</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找子串</span></span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">find</span>(<span class="string">&quot;world&quot;</span>) != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Substring &#x27;world&#x27; found at position: &quot;</span> &lt;&lt; str.<span class="built_in">find</span>(<span class="string">&quot;world&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取子串</span></span><br><span class="line">    std::string sub = str.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Substring: &quot;</span> &lt;&lt; sub &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码演示了一些常见的字符串操作，包括字符串连接、长度获取、查找子串位置、提取子串等。 <code>&lt;string&gt;</code> 头文件提供了丰富的功能，用于处理字符串以及执行各种字符串操作。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <string>标准库 详解</h2><p>C++ 标准库中的 <code>&lt;string&gt;</code> 头文件提供了丰富的字符串操作功能，使得在程序中处理字符串变得更加方便和灵活。以下是 <code>&lt;string&gt;</code> 标准库中一些常用的类和函数的详细解释：</p>
<h3 id="std-string-类"><a href="#std-string-类" class="headerlink" title="std::string 类"></a><code>std::string</code> 类</h3><p><code>std::string</code> 是 C++ 标准库中表示字符串的类。它提供了一系列的方法来操作和管理字符串。这些方法包括：</p>
<ul>
<li><p><strong>构造函数</strong>：<code>std::string</code> 提供了多种构造函数，允许你用不同的方式初始化字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str1;                 <span class="comment">// 初始化为空字符串</span></span><br><span class="line">std::string str2 = <span class="string">&quot;Hello&quot;</span>;       <span class="comment">// 用 C 风格字符串初始化</span></span><br><span class="line"><span class="function">std::string <span class="title">str3</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;         <span class="comment">// 初始化为重复字符的字符串，&quot;aaaaa&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>size()</code> 和 <code>length()</code>**：返回字符串的长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Length of str: &quot;</span> &lt;&lt; str.<span class="built_in">length</span>() &lt;&lt; std::endl; <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串连接</strong>：可以使用 <code>+</code> 运算符或 <code>append()</code> 方法来连接字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">std::string str2 = <span class="string">&quot;world!&quot;</span>;</span><br><span class="line">std::string result = str1 + str2; <span class="comment">// 使用 + 运算符</span></span><br><span class="line">str<span class="number">1.</span><span class="built_in">append</span>(str2);                <span class="comment">// 使用 append() 方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串比较</strong>：使用 <code>compare()</code> 方法进行字符串的比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str1 = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">std::string str2 = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line"><span class="type">int</span> result = str<span class="number">1.</span><span class="built_in">compare</span>(str2);  <span class="comment">// 返回值 &lt; 0 表示 str1 小于 str2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提取子串</strong>：使用 <code>substr()</code> 方法提取子串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">std::string sub = str.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">5</span>); <span class="comment">// 提取从位置 7 开始的长度为 5 的子串 &quot;world&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查找子串</strong>：使用 <code>find()</code> 方法查找子串的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">&quot;world&quot;</span>); <span class="comment">// 查找子串 &quot;world&quot; 的位置，返回 7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转换为 C 风格字符串</strong>：可以使用 <code>c_str()</code> 方法将 <code>std::string</code> 转换为以 null 结尾的 C 风格字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>(); <span class="comment">// 返回以 null 结尾的 C 风格字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>其他方法</strong>：还有很多其他方法，如 <code>insert()</code> 插入子串、<code>erase()</code> 删除子串、<code>replace()</code> 替换子串等。</p>
</li>
</ul>
<h3 id="其他函数和功能"><a href="#其他函数和功能" class="headerlink" title="其他函数和功能"></a>其他函数和功能</h3><ul>
<li><p>**<code>std::to_string()</code>**：将数值转换为对应的字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">std::string str = std::<span class="built_in">to_string</span>(num); <span class="comment">// 将整数转换为字符串 &quot;123&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串流</strong>：<code>std::stringstream</code> 可以用于字符串和其他数据类型之间的转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; num;               <span class="comment">// 将整数写入字符串流</span></span><br><span class="line">std::string str = ss.<span class="built_in">str</span>(); <span class="comment">// 从字符串流中获取字符串 &quot;123&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>这些只是 <code>&lt;string&gt;</code> 标准库中一部分功能，该库还提供了更多用于字符串处理和操作的功能。使用这些功能，可以更方便地对字符串进行操作、处理和管理。</p>
<h2 id="C-标准库-常用函数"><a href="#C-标准库-常用函数" class="headerlink" title="C++ 标准库 常用函数"></a>C++ <string>标准库 常用函数</h2><p>C++ 标准库 <code>&lt;string&gt;</code> 中提供了许多常用的函数，用于处理和操作字符串。以下是一些常用的函数及其简要说明：</p>
<h3 id="字符串长度和容量"><a href="#字符串长度和容量" class="headerlink" title="字符串长度和容量"></a>字符串长度和容量</h3><ul>
<li><strong><code>size()</code> 和 <code>length()</code></strong>: 返回字符串的长度。</li>
<li><strong><code>capacity()</code></strong>: 返回字符串当前分配的存储容量。</li>
</ul>
<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><ul>
<li><strong><code>append()</code></strong>: 在字符串末尾添加内容。</li>
<li><strong><code>insert()</code></strong>: 在指定位置插入内容。</li>
<li><strong><code>erase()</code></strong>: 从字符串中删除指定范围的内容。</li>
<li><strong><code>replace()</code></strong>: 替换指定范围的内容为另一个字符串。</li>
<li><strong><code>substr()</code></strong>: 提取子串。</li>
<li><strong><code>swap()</code></strong>: 交换两个字符串的内容。</li>
</ul>
<h3 id="字符串搜索和查找"><a href="#字符串搜索和查找" class="headerlink" title="字符串搜索和查找"></a>字符串搜索和查找</h3><ul>
<li><strong><code>find()</code> 和 <code>rfind()</code></strong>: 查找子串的位置，<code>find()</code> 从前往后找，<code>rfind()</code> 从后往前找。</li>
<li><strong><code>find_first_of()</code> 和 <code>find_last_of()</code></strong>: 在字符串中查找字符序列中任意字符的第一个&#x2F;最后一个匹配位置。</li>
<li><strong><code>find_first_not_of()</code> 和 <code>find_last_not_of()</code></strong>: 查找字符串中第一个&#x2F;最后一个不在指定字符序列中的字符位置。</li>
</ul>
<h3 id="字符串比较和处理"><a href="#字符串比较和处理" class="headerlink" title="字符串比较和处理"></a>字符串比较和处理</h3><ul>
<li><strong><code>compare()</code></strong>: 比较两个字符串的大小。</li>
<li><strong><code>tolower()</code> 和 <code>toupper()</code></strong>: 将字符串转换为小写或大写。</li>
<li><strong><code>std::stoi()</code>, <code>std::stol()</code>, <code>std::stoll()</code>, <code>std::stof()</code>, <code>std::stod()</code>, <code>std::stold()</code></strong>: 将字符串转换为对应的数值类型。</li>
</ul>
<h3 id="C-风格字符串处理"><a href="#C-风格字符串处理" class="headerlink" title="C 风格字符串处理"></a>C 风格字符串处理</h3><ul>
<li><strong><code>c_str()</code></strong>: 返回以 null 结尾的 C 风格字符串的指针。</li>
<li><strong><code>data()</code></strong>: 返回指向字符串缓冲区的指针。</li>
</ul>
<h3 id="字符串空间管理"><a href="#字符串空间管理" class="headerlink" title="字符串空间管理"></a>字符串空间管理</h3><ul>
<li><strong><code>reserve()</code></strong>: 设置字符串的预留空间。</li>
<li><strong><code>shrink_to_fit()</code></strong>: 请求释放未使用的内存空间，将容器的容量减小到与其大小相匹配。</li>
</ul>
<h3 id="其他实用函数-1"><a href="#其他实用函数-1" class="headerlink" title="其他实用函数"></a>其他实用函数</h3><ul>
<li><strong><code>std::getline()</code></strong>: 从输入流中读取一行数据到字符串中。</li>
<li><strong><code>std::to_string()</code></strong>: 将数值转换为对应的字符串。</li>
</ul>
<p>这些函数提供了对字符串进行各种操作和处理的功能，可以轻松地执行字符串的连接、查找、替换、截取等操作，以及对字符串的大小、长度、容量进行管理。</p>
<h2 id="std-string-size"><a href="#std-string-size" class="headerlink" title="std::string::size()"></a>std::string::size()</h2><p><code>std::string::size()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数，用于获取字符串的长度，即字符的个数。</p>
<p>这个函数返回一个 <code>size_t</code> 类型的无符号整数，代表字符串中字符的数量。这个字符数量不包括字符串末尾的 null 终止符。</p>
<p>示例用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> len = str.<span class="built_in">size</span>(); <span class="comment">// 获取字符串的长度</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符串长度为: &quot;</span> &lt;&lt; len &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str.size()</code> 返回的值将是字符串 “Hello, world!” 中字符的总数，包括逗号、空格和感叹号在内。</p>
<h2 id="std-string-length"><a href="#std-string-length" class="headerlink" title="std::string::length()"></a>std::string::length()</h2><p><code>std::string::length()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，与 <code>size()</code> 函数类似，用于获取字符串的长度，即字符的个数。</p>
<p>这两个函数 <code>size()</code> 和 <code>length()</code> 在 <code>std::string</code> 类中是等价的，都用于返回字符串中字符的数量，不包括末尾的空字符（null terminator）。</p>
<p>示例用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> len = str.<span class="built_in">length</span>(); <span class="comment">// 或者使用 str.size() 获取字符串的长度</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符串长度为: &quot;</span> &lt;&lt; len &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str.length()</code> 返回的值将是字符串 “Hello, world!” 中字符的总数，包括逗号、空格和感叹号在内。通常来说，<code>length()</code> 和 <code>size()</code> 都可用于获取字符串的长度，并且在 <code>std::string</code> 类中它们的功能是一样的。</p>
<h2 id="std-string-append"><a href="#std-string-append" class="headerlink" title="std::string::append()"></a>std::string::append()</h2><p><code>std::string::append()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于将指定的内容追加到字符串的末尾。</p>
<p>这个函数可以接受多种类型的参数来追加内容，包括：</p>
<ul>
<li>另一个 <code>std::string</code> 对象</li>
<li>字符串的一部分（通过指定位置和长度）</li>
<li>C 风格的字符串</li>
<li>字符或者重复的字符</li>
</ul>
<p>以下是 <code>std::string::append()</code> 函数的几种重载形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>; <span class="comment">// 将另一个字符串追加到末尾</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> pos, <span class="type">size_t</span> len)</span></span>; <span class="comment">// 将字符串的一部分追加到末尾</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">// 将 C 风格的字符串追加到末尾</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>; <span class="comment">// 将指定长度的 C 风格字符串追加到末尾</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">append</span><span class="params">(<span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>; <span class="comment">// 将字符 c 重复追加 n 次到末尾</span></span><br></pre></td></tr></table></figure>

<p>以下是一个简单的示例演示了如何使用 <code>std::string::append()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 追加另一个字符串到末尾</span></span><br><span class="line">    str.<span class="built_in">append</span>(<span class="string">&quot; world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追加字符串的一部分到末尾</span></span><br><span class="line">    std::string anotherStr = <span class="string">&quot; This is a test.&quot;</span>;</span><br><span class="line">    str.<span class="built_in">append</span>(anotherStr, <span class="number">0</span>, <span class="number">11</span>); <span class="comment">// 从另一个字符串的指定位置追加一部分内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 追加重复的字符到末尾</span></span><br><span class="line">    str.<span class="built_in">append</span>(<span class="number">3</span>, <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;结果字符串: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::string::append()</code> 函数被用于将不同类型的内容追加到字符串 <code>str</code> 的末尾，包括另一个字符串、另一个字符串的一部分以及重复的字符。最终输出的字符串将是 “Hello world! This is a test.!!!”。</p>
<h2 id="std-string-insert"><a href="#std-string-insert" class="headerlink" title="std::string::insert()"></a>std::string::insert()</h2><p><code>std::string::insert()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于在指定位置插入内容到字符串中。</p>
<p>这个函数允许在字符串的特定位置插入另一个字符串、子串或字符。它的重载版本可以用于不同的插入操作，可以指定要插入的位置和内容。</p>
<p>以下是 <code>std::string::insert()</code> 函数的几种重载形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> std::string&amp; str)</span></span>; <span class="comment">// 在指定位置插入另一个字符串</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> subpos, <span class="type">size_t</span> sublen)</span></span>; <span class="comment">// 在指定位置插入另一个字符串的一部分</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">// 在指定位置插入 C 风格的字符串</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>; <span class="comment">// 在指定位置插入指定长度的 C 风格字符串</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">insert</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>; <span class="comment">// 在指定位置插入重复的字符</span></span><br></pre></td></tr></table></figure>

<p>以下是一个简单的示例演示了如何使用 <code>std::string::insert()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在指定位置插入另一个字符串</span></span><br><span class="line">    str.<span class="built_in">insert</span>(<span class="number">5</span>, <span class="string">&quot;beautiful &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在指定位置插入重复的字符</span></span><br><span class="line">    str.<span class="built_in">insert</span>(<span class="number">6</span>, <span class="number">3</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;结果字符串: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::string::insert()</code> 函数被用于在字符串 <code>str</code> 的指定位置进行插入操作。首先，在位置 5 插入了另一个字符串 “beautiful “，然后在位置 6 插入了重复的字符 ‘<em>‘。最终输出的字符串将是 “Hello</em> * * beautiful world!”。</p>
<h2 id="std-string-erase"><a href="#std-string-erase" class="headerlink" title="std::string::erase()"></a>std::string::erase()</h2><p><code>std::string::erase()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于从字符串中删除指定位置的字符或一段子串。</p>
<p>这个函数有多个重载版本，允许你指定要删除的位置和要删除的字符数。你可以删除单个字符、一段字符，或者从指定位置开始一直删除到字符串末尾。</p>
<p>以下是 <code>std::string::erase()</code> 函数的几种重载形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">erase</span><span class="params">(<span class="type">size_t</span> pos = <span class="number">0</span>, <span class="type">size_t</span> len = npos)</span></span>; <span class="comment">// 从指定位置开始删除指定数量的字符</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span>; <span class="comment">// 删除指定位置处的字符</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>; <span class="comment">// 删除指定范围内的字符</span></span><br></pre></td></tr></table></figure>

<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, beautiful world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定位置开始的 7 个字符</span></span><br><span class="line">    str.<span class="built_in">erase</span>(<span class="number">7</span>, <span class="number">7</span>); <span class="comment">// 从位置 7 开始，删除 7 个字符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从迭代器位置开始删除一段字符</span></span><br><span class="line">    std::string::iterator it = str.<span class="built_in">begin</span>() + <span class="number">13</span>;</span><br><span class="line">    str.<span class="built_in">erase</span>(it, str.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;结果字符串: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，首先使用 <code>erase()</code> 函数从位置 7 开始删除了 7 个字符，然后使用迭代器指定的位置开始删除了一段字符，直到字符串的末尾。最终输出的字符串将是 “Hello, “。</p>
<h2 id="std-string-replace"><a href="#std-string-replace" class="headerlink" title="std::string::replace()"></a>std::string::replace()</h2><p><code>std::string::replace()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于替换字符串中的部分内容。</p>
<p>这个函数允许你用另一个字符串、子串或字符序列替换指定位置和长度的内容。你可以选择性地替换指定位置开始的一定数量的字符，也可以替换整个字符串的一部分。</p>
<p>以下是 <code>std::string::replace()</code> 函数的几种重载形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> std::string&amp; str)</span></span>; <span class="comment">// 用另一个字符串替换指定位置和长度的内容</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">replace</span><span class="params">(iterator i1, iterator i2, <span class="type">const</span> std::string&amp; str)</span></span>; <span class="comment">// 用另一个字符串替换指定范围的内容</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> subpos, <span class="type">size_t</span> sublen)</span></span>; <span class="comment">// 用另一个字符串的一部分替换指定位置和长度的内容</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">// 用 C 风格的字符串替换指定位置和长度的内容</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">replace</span><span class="params">(iterator i1, iterator i2, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span></span>; <span class="comment">// 用指定长度的 C 风格字符串替换指定范围的内容</span></span><br><span class="line"><span class="function">std::string&amp; <span class="title">replace</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">size_t</span> n, <span class="type">char</span> c)</span></span>; <span class="comment">// 用重复的字符替换指定位置和长度的内容</span></span><br></pre></td></tr></table></figure>

<p>以下是一个示例演示了如何使用 <code>std::string::replace()</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, beautiful world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用另一个字符串替换指定位置和长度的内容</span></span><br><span class="line">    str.<span class="built_in">replace</span>(<span class="number">7</span>, <span class="number">9</span>, <span class="string">&quot;wonderful&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用重复的字符替换指定位置和长度的内容</span></span><br><span class="line">    str.<span class="built_in">replace</span>(<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;结果字符串: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，首先使用 <code>replace()</code> 函数将字符串中位置 7 开始、长度为 9 的部分替换为另一个字符串 “wonderful”，然后用重复的字符 ‘*’ 替换了字符串的前 7 个字符。最终输出的字符串将是 “*******wonderful world!”。</p>
<h2 id="std-string-substr"><a href="#std-string-substr" class="headerlink" title="std::string::substr()"></a>std::string::substr()</h2><p><code>std::string::substr()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于提取字符串的子串。</p>
<p>这个函数接受两个参数，第一个参数是子串的起始位置（索引），第二个参数是子串的长度。如果只提供一个参数，它将从指定位置开始提取直到字符串末尾的所有字符。</p>
<p>以下是 <code>std::string::substr()</code> 函数的形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">substr</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len = npos)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pos</code> 是子串的起始位置（索引），从 0 开始计数。</li>
<li><code>len</code> 是子串的长度，默认值是 <code>npos</code>，表示提取从 <code>pos</code> 开始到字符串末尾的所有字符。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取从索引为 7 开始的子串</span></span><br><span class="line">    std::string sub1 = str.<span class="built_in">substr</span>(<span class="number">7</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子串1: &quot;</span> &lt;&lt; sub1 &lt;&lt; std::endl; <span class="comment">// 输出 &quot;world!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取从索引为 0 开始，长度为 5 的子串</span></span><br><span class="line">    std::string sub2 = str.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;子串2: &quot;</span> &lt;&lt; sub2 &lt;&lt; std::endl; <span class="comment">// 输出 &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str.substr(7)</code> 提取了从索引 7 开始到字符串末尾的子串（”world!”），而 <code>str.substr(0, 5)</code> 提取了从索引 0 开始长度为 5 的子串（”Hello”）。</p>
<h2 id="std-string-swap"><a href="#std-string-swap" class="headerlink" title="std::string::swap()"></a>std::string::swap()</h2><p><code>std::string::swap()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一。它用于交换两个 <code>std::string</code> 对象的内容，但是它的作用并不是直接交换字符串的内容，而是交换它们内部指向字符数据的指针，这样可以在不复制字符串的情况下快速交换它们的内容。</p>
<h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(std::string&amp; str)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>: 另一个 <code>std::string</code> 对象，它的内容将与当前对象的内容进行交换。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    std::string str2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;交换前:\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2: &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 swap() 函数交换 str1 和 str2 的内容</span></span><br><span class="line">    str<span class="number">1.</span><span class="built_in">swap</span>(str2);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n交换后:\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str2: &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">交换前:</span><br><span class="line">str1: Hello</span><br><span class="line">str2: World</span><br><span class="line"></span><br><span class="line">交换后:</span><br><span class="line">str1: World</span><br><span class="line">str2: Hello</span><br></pre></td></tr></table></figure>

<p><code>str1.swap(str2);</code> 执行后，<code>str1</code> 的内容变为 “World”，<code>str2</code> 的内容变为 “Hello”。这种交换方式使得操作更高效，特别是当处理大量字符数据时。</p>
<h2 id="std-string-find"><a href="#std-string-find" class="headerlink" title="std::string::find()"></a>std::string::find()</h2><p><code>std::string::find()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于在字符串中查找指定子串第一次出现的位置。</p>
<h3 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> count)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要查找的子串。</li>
<li><code>s</code>：要查找的 C 风格字符串（以 null 结尾的字符数组）。</li>
<li><code>count</code>：要查找的 C 风格字符串中的字符数。</li>
<li><code>c</code>：要查找的字符。</li>
<li><code>pos</code>：搜索的起始位置，默认为 0。</li>
</ul>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><p>返回第一次出现子串或字符的位置，如果未找到，则返回 <code>std::string::npos</code>（<code>static const size_t npos = -1;</code>）。</p>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找子串 &quot;World&quot;</span></span><br><span class="line">    <span class="type">size_t</span> found = str.<span class="built_in">find</span>(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;子串 &#x27;World&#x27; 第一次出现的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到子串 &#x27;World&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找字符 &#x27;o&#x27; 第一次出现的位置</span></span><br><span class="line">    found = str.<span class="built_in">find</span>(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;字符 &#x27;o&#x27; 第一次出现的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到字符 &#x27;o&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子串 &#x27;World&#x27; 第一次出现的位置：7</span><br><span class="line">字符 &#x27;o&#x27; 第一次出现的位置：4</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>str.find(&quot;World&quot;)</code> 查找子串 “World” 在 <code>str</code> 中第一次出现的位置，返回 7。而 <code>str.find(&#39;o&#39;)</code> 查找字符 ‘o’ 在 <code>str</code> 中第一次出现的位置，返回 4。</p>
<h2 id="std-string-rfind"><a href="#std-string-rfind" class="headerlink" title="std::string::rfind()"></a>std::string::rfind()</h2><p><code>std::string::rfind()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于在字符串中从末尾开始查找指定子串最后一次出现的位置。</p>
<h3 id="函数原型：-2"><a href="#函数原型：-2" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> count)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">rfind</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-2"><a href="#参数：-2" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要查找的子串。</li>
<li><code>s</code>：要查找的 C 风格字符串（以 null 结尾的字符数组）。</li>
<li><code>count</code>：要查找的 C 风格字符串中的字符数。</li>
<li><code>c</code>：要查找的字符。</li>
<li><code>pos</code>：搜索的起始位置，默认为 <code>std::string::npos</code>，表示从末尾开始搜索。</li>
</ul>
<h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h3><p>返回最后一次出现子串或字符的位置，如果未找到，则返回 <code>std::string::npos</code>（<code>static const size_t npos = -1;</code>）。</p>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World! Hello again.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从末尾开始查找子串 &quot;Hello&quot;</span></span><br><span class="line">    <span class="type">size_t</span> found = str.<span class="built_in">rfind</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;子串 &#x27;Hello&#x27; 最后一次出现的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到子串 &#x27;Hello&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从末尾开始查找字符 &#x27;o&#x27;</span></span><br><span class="line">    found = str.<span class="built_in">rfind</span>(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;字符 &#x27;o&#x27; 最后一次出现的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到字符 &#x27;o&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子串 &#x27;Hello&#x27; 最后一次出现的位置：14</span><br><span class="line">字符 &#x27;o&#x27; 最后一次出现的位置：24</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>str.rfind(&quot;Hello&quot;)</code> 从末尾开始查找子串 “Hello” 在 <code>str</code> 中最后一次出现的位置，返回 14。而 <code>str.rfind(&#39;o&#39;)</code> 从末尾开始查找字符 ‘o’ 在 <code>str</code> 中最后一次出现的位置，返回 24。</p>
<h2 id="std-string-find-first-of"><a href="#std-string-find-first-of" class="headerlink" title="std::string::find_first_of()"></a>std::string::find_first_of()</h2><p><code>std::string::find_first_of()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于在字符串中查找与给定字符序列中任何字符匹配的第一个位置。</p>
<h3 id="函数原型：-3"><a href="#函数原型：-3" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> count)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_of</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-3"><a href="#参数：-3" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要查找的字符序列。</li>
<li><code>s</code>：要查找的 C 风格字符串（以 null 结尾的字符数组）。</li>
<li><code>count</code>：要查找的 C 风格字符串中的字符数。</li>
<li><code>c</code>：要查找的字符。</li>
<li><code>pos</code>：搜索的起始位置，默认为 0。</li>
</ul>
<h3 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h3><p>返回第一个与字符序列中任何字符匹配的位置，如果未找到，则返回 <code>std::string::npos</code>（<code>static const size_t npos = -1;</code>）。</p>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个匹配字符序列中任何字符的位置</span></span><br><span class="line">    <span class="type">size_t</span> found = str.<span class="built_in">find_first_of</span>(<span class="string">&quot;aeiou&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第一个匹配元音字母的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到匹配的元音字母&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个匹配字符 &#x27;o&#x27; 的位置</span></span><br><span class="line">    found = str.<span class="built_in">find_first_of</span>(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第一个匹配字符 &#x27;o&#x27; 的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到字符 &#x27;o&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-3"><a href="#输出：-3" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一个匹配元音字母的位置：1</span><br><span class="line">第一个匹配字符 &#x27;o&#x27; 的位置：4</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>str.find_first_of(&quot;aeiou&quot;)</code> 查找字符序列中任何元音字母（’a’、’e’、’i’、’o’、’u’）第一次出现的位置，返回 1。而 <code>str.find_first_of(&#39;o&#39;)</code> 查找字符 ‘o’ 第一次出现的位置，返回 4。</p>
<h2 id="std-string-find-last-of"><a href="#std-string-find-last-of" class="headerlink" title="std::string::find_last_of()"></a>std::string::find_last_of()</h2><p><code>std::string::find_last_of()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于在字符串中查找与给定字符序列中任何字符匹配的最后一个位置。</p>
<h3 id="函数原型：-4"><a href="#函数原型：-4" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> count)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_of</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-4"><a href="#参数：-4" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要查找的字符序列。</li>
<li><code>s</code>：要查找的 C 风格字符串（以 null 结尾的字符数组）。</li>
<li><code>count</code>：要查找的 C 风格字符串中的字符数。</li>
<li><code>c</code>：要查找的字符。</li>
<li><code>pos</code>：搜索的起始位置，默认为 <code>std::string::npos</code>，表示从末尾开始搜索。</li>
</ul>
<h3 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a>返回值：</h3><p>返回最后一个与字符序列中任何字符匹配的位置，如果未找到，则返回 <code>std::string::npos</code>（<code>static const size_t npos = -1;</code>）。</p>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最后一个匹配字符序列中任何字符的位置</span></span><br><span class="line">    <span class="type">size_t</span> found = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;aeiou&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;最后一个匹配元音字母的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到匹配的元音字母&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最后一个匹配字符 &#x27;o&#x27; 的位置</span></span><br><span class="line">    found = str.<span class="built_in">find_last_of</span>(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;最后一个匹配字符 &#x27;o&#x27; 的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到字符 &#x27;o&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-4"><a href="#输出：-4" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最后一个匹配元音字母的位置：9</span><br><span class="line">最后一个匹配字符 &#x27;o&#x27; 的位置：8</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>str.find_last_of(&quot;aeiou&quot;)</code> 查找字符序列中任何元音字母（’a’、’e’、’i’、’o’、’u’）最后一次出现的位置，返回 9。而 <code>str.find_last_of(&#39;o&#39;)</code> 查找字符 ‘o’ 最后一次出现的位置，返回 8。</p>
<h2 id="std-string-find-first-not-of"><a href="#std-string-find-first-not-of" class="headerlink" title="std::string::find_first_not_of()"></a>std::string::find_first_not_of()</h2><p><code>std::string::find_first_not_of()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于在字符串中查找第一个不属于给定字符序列的字符位置。</p>
<h3 id="函数原型：-5"><a href="#函数原型：-5" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> count)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_first_not_of</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = <span class="number">0</span>)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-5"><a href="#参数：-5" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要查找的字符序列。</li>
<li><code>s</code>：要查找的 C 风格字符串（以 null 结尾的字符数组）。</li>
<li><code>count</code>：要查找的 C 风格字符串中的字符数。</li>
<li><code>c</code>：要查找的字符。</li>
<li><code>pos</code>：搜索的起始位置，默认为 0。</li>
</ul>
<h3 id="返回值：-4"><a href="#返回值：-4" class="headerlink" title="返回值："></a>返回值：</h3><p>返回第一个不属于字符序列中任何字符的位置，如果未找到，则返回 <code>std::string::npos</code>（<code>static const size_t npos = -1;</code>）。</p>
<h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;   Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个不属于空格字符的位置</span></span><br><span class="line">    <span class="type">size_t</span> found = str.<span class="built_in">find_first_not_of</span>(<span class="string">&quot; \t\n\v\f\r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第一个不属于空白字符的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到不属于空白字符的位置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个不属于字符 &#x27;H&#x27; 的位置</span></span><br><span class="line">    found = str.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;第一个不属于字符 &#x27;H&#x27; 的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到不属于字符 &#x27;H&#x27; 的位置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-5"><a href="#输出：-5" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一个不属于空白字符的位置：3</span><br><span class="line">第一个不属于字符 &#x27;H&#x27; 的位置：0</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>str.find_first_not_of(&quot; \t\n\v\f\r&quot;)</code> 查找第一个不属于空白字符（空格、制表符、换行符等）的位置，返回 3。而 <code>str.find_first_not_of(&#39;H&#39;)</code> 查找第一个不属于字符 ‘H’ 的位置，返回 0。</p>
<h2 id="std-string-find-last-not-of"><a href="#std-string-find-last-not-of" class="headerlink" title="std::string::find_last_not_of()"></a>std::string::find_last_not_of()</h2><p><code>std::string::find_last_not_of()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于在字符串中查找最后一个不属于给定字符序列的字符位置。</p>
<h3 id="函数原型：-6"><a href="#函数原型：-6" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> count)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find_last_not_of</span><span class="params">(<span class="type">char</span> c, <span class="type">size_t</span> pos = npos)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-6"><a href="#参数：-6" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要查找的字符序列。</li>
<li><code>s</code>：要查找的 C 风格字符串（以 null 结尾的字符数组）。</li>
<li><code>count</code>：要查找的 C 风格字符串中的字符数。</li>
<li><code>c</code>：要查找的字符。</li>
<li><code>pos</code>：搜索的起始位置，默认为 <code>std::string::npos</code>，表示从末尾开始搜索。</li>
</ul>
<h3 id="返回值：-5"><a href="#返回值：-5" class="headerlink" title="返回值："></a>返回值：</h3><p>返回最后一个不属于字符序列中任何字符的位置，如果未找到，则返回 <code>std::string::npos</code>（<code>static const size_t npos = -1;</code>）。</p>
<h3 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;   Hello, World!   &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最后一个不属于空格字符的位置</span></span><br><span class="line">    <span class="type">size_t</span> found = str.<span class="built_in">find_last_not_of</span>(<span class="string">&quot; \t\n\v\f\r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;最后一个不属于空白字符的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到不属于空白字符的位置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最后一个不属于字符 &#x27;!&#x27; 的位置</span></span><br><span class="line">    found = str.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;最后一个不属于字符 &#x27;!&#x27; 的位置：&quot;</span> &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未找到不属于字符 &#x27;!&#x27; 的位置&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-6"><a href="#输出：-6" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最后一个不属于空白字符的位置：14</span><br><span class="line">最后一个不属于字符 &#x27;!&#x27; 的位置：13</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str.find_last_not_of(&quot; \t\n\v\f\r&quot;)</code> 查找最后一个不属于空白字符（空格、制表符、换行符等）的位置，返回 14。而 <code>str.find_last_not_of(&#39;!&#39;)</code> 查找最后一个不属于字符 ‘!’ 的位置，返回 13。</p>
<h2 id="std-string-compare"><a href="#std-string-compare" class="headerlink" title="std::string::compare()"></a>std::string::compare()</h2><p><code>std::string::compare()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于比较两个字符串的大小关系。</p>
<h3 id="函数原型：-7"><a href="#函数原型：-7" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> std::string&amp; str)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> std::string&amp; str, <span class="type">size_t</span> subpos, <span class="type">size_t</span> sublen)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span>* s)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">size_t</span> pos, <span class="type">size_t</span> len, <span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-7"><a href="#参数：-7" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要比较的另一个字符串。</li>
<li><code>s</code>：要比较的 C 风格字符串（以 null 结尾的字符数组）。</li>
<li><code>pos</code>：字符串中的起始位置，默认为 0。</li>
<li><code>len</code>：要比较的字符数，默认为 <code>std::string::npos</code>。</li>
<li><code>subpos</code>：子串的起始位置，默认为 0。</li>
<li><code>sublen</code>：子串的字符数，默认为 <code>std::string::npos</code>。</li>
<li><code>n</code>：要比较的字符数。</li>
</ul>
<h3 id="返回值：-6"><a href="#返回值：-6" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回值为负数：表示调用对象小于参数字符串。</li>
<li>返回值为零：表示调用对象等于参数字符串。</li>
<li>返回值为正数：表示调用对象大于参数字符串。</li>
</ul>
<h3 id="示例：-7"><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    std::string str2 = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个字符串</span></span><br><span class="line">    <span class="type">int</span> result = str<span class="number">1.</span><span class="built_in">compare</span>(str2);</span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 小于 str2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 等于 str2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;str1 大于 str2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-7"><a href="#输出：-7" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1 小于 str2</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str1.compare(str2)</code> 比较了两个字符串 <code>str1</code> 和 <code>str2</code>。由于 “apple” 在字典序中小于 “banana”，所以返回值为负数，输出表明 <code>str1</code> 小于 <code>str2</code>。</p>
<h2 id="std-stoi"><a href="#std-stoi" class="headerlink" title="std::stoi()"></a>std::stoi()</h2><p><code>std::stoi()</code> 是 C++ 标准库中 <code>&lt;string&gt;</code> 头文件中提供的函数之一，用于将字符串转换为整数类型（<code>int</code>）。</p>
<h3 id="函数原型：-8"><a href="#函数原型：-8" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stoi</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span>* pos = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-8"><a href="#参数：-8" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要转换为整数的字符串。</li>
<li><code>pos</code>：指向存储第一个无效字符位置的指针，可选参数，默认为 <code>nullptr</code>。</li>
<li><code>base</code>：进制，默认为 10（十进制）。可以是 0 或者介于 2 到 36 之间的值，表示字符序列的进制基数。</li>
</ul>
<h3 id="返回值：-7"><a href="#返回值：-7" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回转换后的整数值。如果转换过程中出现错误，会抛出 <code>std::invalid_argument</code> 或 <code>std::out_of_range</code> 异常。</li>
</ul>
<h3 id="示例：-8"><a href="#示例：-8" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> num = std::<span class="built_in">stoi</span>(str);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换后的整数为: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-8"><a href="#输出：-8" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换后的整数为: 12345</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::stoi()</code> 将字符串 “12345” 转换为整数类型并输出。如果无法转换字符串为整数，例如，当字符串包含非数字字符时，将抛出异常。</p>
<h2 id="std-stol"><a href="#std-stol" class="headerlink" title="std::stol()"></a>std::stol()</h2><p><code>std::stol()</code> 是 C++ 标准库中 <code>&lt;string&gt;</code> 头文件中提供的函数之一，用于将字符串转换为长整型（<code>long</code>）。</p>
<h3 id="函数原型：-9"><a href="#函数原型：-9" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">stol</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span>* pos = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-9"><a href="#参数：-9" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要转换为长整型的字符串。</li>
<li><code>pos</code>：指向存储第一个无效字符位置的指针，可选参数，默认为 <code>nullptr</code>。</li>
<li><code>base</code>：进制，默认为 10（十进制）。可以是 0 或者介于 2 到 36 之间的值，表示字符序列的进制基数。</li>
</ul>
<h3 id="返回值：-8"><a href="#返回值：-8" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回转换后的长整型值。如果转换过程中出现错误，会抛出 <code>std::invalid_argument</code> 或 <code>std::out_of_range</code> 异常。</li>
</ul>
<h3 id="示例：-9"><a href="#示例：-9" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> num = std::<span class="built_in">stol</span>(str);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换后的长整数为: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-9"><a href="#输出：-9" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换后的长整数为: 123456789</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>std::stol()</code> 将字符串 “123456789” 转换为长整数类型并输出。如果无法转换字符串为长整数，例如，当字符串包含非数字字符时，将抛出异常。</p>
<h2 id="std-stoll"><a href="#std-stoll" class="headerlink" title="std::stoll()"></a>std::stoll()</h2><p><code>std::stoll()</code> 是 C++ 标准库中 <code>&lt;string&gt;</code> 头文件中提供的函数之一，用于将字符串转换为长长整型（<code>long long</code>）。</p>
<h3 id="函数原型：-10"><a href="#函数原型：-10" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">stoll</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span>* pos = <span class="number">0</span>, <span class="type">int</span> base = <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-10"><a href="#参数：-10" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要转换为长长整型的字符串。</li>
<li><code>pos</code>：指向存储第一个无效字符位置的指针，可选参数，默认为 <code>nullptr</code>。</li>
<li><code>base</code>：进制，默认为 10（十进制）。可以是 0 或者介于 2 到 36 之间的值，表示字符序列的进制基数。</li>
</ul>
<h3 id="返回值：-9"><a href="#返回值：-9" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回转换后的长长整型值。如果转换过程中出现错误，会抛出 <code>std::invalid_argument</code> 或 <code>std::out_of_range</code> 异常。</li>
</ul>
<h3 id="示例：-10"><a href="#示例：-10" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;1234567890123456789&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num = std::<span class="built_in">stoll</span>(str);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换后的长长整数为: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-10"><a href="#输出：-10" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换后的长长整数为: 1234567890123456789</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>std::stoll()</code> 将字符串 “1234567890123456789” 转换为长长整数类型并输出。如果无法转换字符串为长长整数，例如，当字符串包含非数字字符时，将抛出异常。</p>
<h2 id="std-stof"><a href="#std-stof" class="headerlink" title="std::stof()"></a>std::stof()</h2><p><code>std::stof()</code> 是 C++ 标准库中 <code>&lt;string&gt;</code> 头文件中提供的函数之一，用于将字符串转换为单精度浮点数（<code>float</code>）。</p>
<h3 id="函数原型：-11"><a href="#函数原型：-11" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">stof</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span>* pos = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-11"><a href="#参数：-11" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要转换为单精度浮点数的字符串。</li>
<li><code>pos</code>：指向存储第一个无效字符位置的指针，可选参数，默认为 <code>nullptr</code>。</li>
</ul>
<h3 id="返回值：-10"><a href="#返回值：-10" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回转换后的单精度浮点数值。如果转换过程中出现错误，会抛出 <code>std::invalid_argument</code> 或 <code>std::out_of_range</code> 异常。</li>
</ul>
<h3 id="示例：-11"><a href="#示例：-11" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;3.14159&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">float</span> num = std::<span class="built_in">stof</span>(str);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换后的单精度浮点数为: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-11"><a href="#输出：-11" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换后的单精度浮点数为: 3.14159</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>std::stof()</code> 将字符串 “3.14159” 转换为单精度浮点数类型并输出。如果无法转换字符串为单精度浮点数，例如，当字符串包含非数字字符时，将抛出异常。</p>
<h2 id="std-stod"><a href="#std-stod" class="headerlink" title="std::stod()"></a>std::stod()</h2><p><code>std::stod()</code> 是 C++ 标准库中 <code>&lt;string&gt;</code> 头文件中提供的函数之一，用于将字符串转换为双精度浮点数（<code>double</code>）。</p>
<h3 id="函数原型：-12"><a href="#函数原型：-12" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">stod</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span>* pos = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-12"><a href="#参数：-12" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要转换为双精度浮点数的字符串。</li>
<li><code>pos</code>：指向存储第一个无效字符位置的指针，可选参数，默认为 <code>nullptr</code>。</li>
</ul>
<h3 id="返回值：-11"><a href="#返回值：-11" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回转换后的双精度浮点数值。如果转换过程中出现错误，会抛出 <code>std::invalid_argument</code> 或 <code>std::out_of_range</code> 异常。</li>
</ul>
<h3 id="示例：-12"><a href="#示例：-12" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;3.14159265359&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">double</span> num = std::<span class="built_in">stod</span>(str);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换后的双精度浮点数为: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-12"><a href="#输出：-12" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换后的双精度浮点数为: 3.14159265359</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>std::stod()</code> 将字符串 “3.14159265359” 转换为双精度浮点数类型并输出。如果无法转换字符串为双精度浮点数，例如，当字符串包含非数字字符时，将抛出异常。</p>
<h2 id="std-stold"><a href="#std-stold" class="headerlink" title="std::stold()"></a>std::stold()</h2><p><code>std::stold()</code> 是 C++ 标准库中 <code>&lt;string&gt;</code> 头文件中提供的函数之一，用于将字符串转换为长双精度浮点数（<code>long double</code>）。</p>
<h3 id="函数原型：-13"><a href="#函数原型：-13" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">stold</span><span class="params">(<span class="type">const</span> std::string&amp; str, <span class="type">size_t</span>* pos = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-13"><a href="#参数：-13" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>str</code>：要转换为长双精度浮点数的字符串。</li>
<li><code>pos</code>：指向存储第一个无效字符位置的指针，可选参数，默认为 <code>nullptr</code>。</li>
</ul>
<h3 id="返回值：-12"><a href="#返回值：-12" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回转换后的长双精度浮点数值。如果转换过程中出现错误，会抛出 <code>std::invalid_argument</code> 或 <code>std::out_of_range</code> 异常。</li>
</ul>
<h3 id="示例：-13"><a href="#示例：-13" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;3.141592653589793238&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">double</span> num = std::<span class="built_in">stold</span>(str);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换后的长双精度浮点数为: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;转换失败: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-13"><a href="#输出：-13" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换后的长双精度浮点数为: 3.141592653589793238</span><br></pre></td></tr></table></figure>

<p>这个示例中，<code>std::stold()</code> 将字符串 “3.141592653589793238” 转换为长双精度浮点数类型并输出。如果无法转换字符串为长双精度浮点数，例如，当字符串包含非数字字符时，将抛出异常。</p>
<h2 id="std-string-c-str"><a href="#std-string-c-str" class="headerlink" title="std::string::c_str()"></a>std::string::c_str()</h2><p><code>std::string::c_str()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数，用于返回一个指向以 null 结尾的 C 风格字符串（字符数组）的指针，即指向 <code>std::string</code> 对象中存储的字符数据。</p>
<h3 id="函数原型：-14"><a href="#函数原型：-14" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="返回值：-13"><a href="#返回值：-13" class="headerlink" title="返回值："></a>返回值：</h3><p>返回一个指向以 null 结尾的字符数组的指针，该字符数组存储了 <code>std::string</code> 对象中的字符串内容。</p>
<h3 id="示例：-14"><a href="#示例：-14" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;C 风格字符串为: &quot;</span> &lt;&lt; cstr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-14"><a href="#输出：-14" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C 风格字符串为: Hello, World!</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str.c_str()</code> 返回一个指向字符串 “Hello, World!” 的 C 风格字符串的指针，并通过 <code>std::cout</code> 输出该字符串。需要注意的是，<code>c_str()</code> 返回的指针指向的字符数组是以 null 结尾的，因此可以被正常地当做 C 风格字符串处理。</p>
<h2 id="std-string-data"><a href="#std-string-data" class="headerlink" title="std::string::data()"></a>std::string::data()</h2><p><code>std::string::data()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数，用于返回一个指向字符数据的指针，但不一定以 null 结尾。</p>
<h3 id="函数原型：-15"><a href="#函数原型：-15" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">data</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="返回值：-14"><a href="#返回值：-14" class="headerlink" title="返回值："></a>返回值：</h3><p>返回一个指向存储在 <code>std::string</code> 对象中的字符数据的指针。与 <code>c_str()</code> 不同的是，<code>data()</code> 不一定会在字符串的末尾添加 null 终止符。</p>
<h3 id="示例：-15"><a href="#示例：-15" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* strData = str.<span class="built_in">data</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符数据为: &quot;</span> &lt;&lt; strData &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-15"><a href="#输出：-15" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符数据为: Hello, World!</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str.data()</code> 返回一个指向字符串 “Hello, World!” 的字符数据的指针，并通过 <code>std::cout</code> 输出该字符串。需要注意的是，<code>data()</code> 返回的指针可能不以 null 结尾，并且对返回指针所指向的数据进行修改时，需要谨慎处理末尾的 null 终止符。</p>
<h2 id="std-string-reserve"><a href="#std-string-reserve" class="headerlink" title="std::string::reserve()"></a>std::string::reserve()</h2><p><code>std::string::reserve()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于请求字符串预留足够的内存空间，以容纳指定数量的字符，而不会更改字符串的大小。</p>
<h3 id="函数原型：-16"><a href="#函数原型：-16" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-14"><a href="#参数：-14" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>n</code>：要预留的字符数量。</li>
</ul>
<h3 id="返回值：-15"><a href="#返回值：-15" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>无（<code>void</code>）。</li>
</ul>
<h3 id="示例：-16"><a href="#示例：-16" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;初始容量: &quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">reserve</span>(<span class="number">20</span>); <span class="comment">// 预留至少可以容纳 20 个字符的空间</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;预留后的容量: &quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-16"><a href="#输出：-16" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始容量: 5</span><br><span class="line">预留后的容量: 20</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str.reserve(20)</code> 调用了 <code>reserve()</code> 函数来预留至少可以容纳 20 个字符的空间。请注意，<code>reserve()</code> 只是预留了空间，并不改变字符串的长度。这对于在预先知道要存储大量字符的情况下，避免多次重新分配内存而提高性能是很有用的。</p>
<h2 id="std-string-shrink-to-fit"><a href="#std-string-shrink-to-fit" class="headerlink" title="std::string::shrink_to_fit()"></a>std::string::shrink_to_fit()</h2><p><code>std::string::shrink_to_fit()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于要求字符串收缩其容量以适应当前字符串的大小。</p>
<h3 id="函数原型：-17"><a href="#函数原型：-17" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shrink_to_fit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="返回值：-16"><a href="#返回值：-16" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>无（<code>void</code>）。</li>
</ul>
<h3 id="示例：-17"><a href="#示例：-17" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;初始容量: &quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">reserve</span>(<span class="number">100</span>); <span class="comment">// 分配较大的空间</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;扩大容量后的容量: &quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    str.<span class="built_in">shrink_to_fit</span>(); <span class="comment">// 收缩容量以适应当前大小</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;收缩容量后的容量: &quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-17"><a href="#输出：-17" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始容量: 5</span><br><span class="line">扩大容量后的容量: 100</span><br><span class="line">收缩容量后的容量: 5</span><br></pre></td></tr></table></figure>

<p>在这个示例中，首先创建了一个字符串 <code>str</code>，然后通过 <code>str.reserve(100)</code> 手动扩大了其容量。随后调用 <code>str.shrink_to_fit()</code> 来收缩字符串的容量以适应当前字符串的大小。这对于释放不再需要的内存空间是有用的，可以减少不必要的内存浪费。</p>
<h2 id="std-string-capacity"><a href="#std-string-capacity" class="headerlink" title="std::string::capacity()"></a>std::string::capacity()</h2><p><code>std::string::capacity()</code> 是 C++ 标准库中 <code>std::string</code> 类的成员函数之一，用于返回当前字符串能够容纳的字符数量，即分配给字符串的内存空间大小。</p>
<h3 id="函数原型：-18"><a href="#函数原型：-18" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="返回值：-17"><a href="#返回值：-17" class="headerlink" title="返回值："></a>返回值：</h3><p>返回字符串当前可容纳的字符数量，即字符串所分配的内存空间大小。</p>
<h3 id="示例：-18"><a href="#示例：-18" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符串当前容量: &quot;</span> &lt;&lt; str.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-18"><a href="#输出：-18" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串当前容量: 15</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>str.capacity()</code> 返回了字符串 <code>str</code> 当前的容量。需要注意的是，字符串的容量并不等同于字符串的长度（即字符个数），而是指字符串当前已分配的内存大小。容量通常大于或等于字符串的长度，因为字符串预留了额外的空间以便于扩展和操作。</p>
<h2 id="std-getline"><a href="#std-getline" class="headerlink" title="std::getline()"></a>std::getline()</h2><p><code>std::getline()</code> 是 C++ 标准库中 <code>&lt;string&gt;</code> 头文件中提供的函数，用于从输入流中读取一行文本并存储到字符串中。</p>
<h3 id="函数原型：-19"><a href="#函数原型：-19" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::istream&amp; <span class="title">getline</span><span class="params">(std::istream&amp; is, std::string&amp; str, <span class="type">char</span> delim = <span class="string">&#x27;\n&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-15"><a href="#参数：-15" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>is</code>：输入流，例如 <code>std::cin</code>（标准输入）或文件流。</li>
<li><code>str</code>：用于存储输入行的字符串。</li>
<li><code>delim</code>：可选参数，表示行的结束符，默认为换行符 <code>&#39;\n&#39;</code>。</li>
</ul>
<h3 id="返回值：-18"><a href="#返回值：-18" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回输入流 <code>is</code> 的引用，以便进行链式输入。</li>
</ul>
<h3 id="示例：-19"><a href="#示例：-19" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string input;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一行文本：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::<span class="built_in">getline</span>(std::cin, input);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你输入的内容是：&quot;</span> &lt;&lt; input &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-19"><a href="#输出：-19" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入一行文本：</span><br><span class="line">[用户输入]</span><br><span class="line">你输入的内容是：[用户输入的内容]</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>std::getline(std::cin, input)</code> 从标准输入中读取一行用户输入的文本，并将其存储在 <code>input</code> 字符串中。如果输入的行超过了字符串的最大长度，<code>std::getline()</code> 会自动调整字符串的大小以容纳整个输入行。</p>
<h2 id="std-to-string"><a href="#std-to-string" class="headerlink" title="std::to_string()"></a>std::to_string()</h2><p><code>std::to_string()</code> 是 C++ 标准库中 <code>&lt;string&gt;</code> 头文件中提供的函数之一，用于将数值类型转换为对应的字符串形式。</p>
<h3 id="函数原型：-20"><a href="#函数原型：-20" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">long</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">long</span> <span class="type">long</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">float</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">double</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="type">long</span> <span class="type">double</span> value)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-16"><a href="#参数：-16" class="headerlink" title="参数："></a>参数：</h3><ul>
<li>不同版本的 <code>to_string()</code> 接受不同的数值类型作为参数，并将其转换为对应的字符串形式。</li>
</ul>
<h3 id="返回值：-19"><a href="#返回值：-19" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>返回包含数值转换后的字符串。</li>
</ul>
<h3 id="示例：-20"><a href="#示例：-20" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> intValue = <span class="number">42</span>;</span><br><span class="line">    <span class="type">float</span> floatValue = <span class="number">3.14159f</span>;</span><br><span class="line"></span><br><span class="line">    std::string strInt = std::<span class="built_in">to_string</span>(intValue);</span><br><span class="line">    std::string strFloat = std::<span class="built_in">to_string</span>(floatValue);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;整数转换后的字符串: &quot;</span> &lt;&lt; strInt &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;浮点数转换后的字符串: &quot;</span> &lt;&lt; strFloat &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-20"><a href="#输出：-20" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">整数转换后的字符串: 42</span><br><span class="line">浮点数转换后的字符串: 3.141590</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::to_string()</code> 将整数和浮点数分别转换为对应的字符串形式，并将其存储在 <code>strInt</code> 和 <code>strFloat</code> 中。这是一个方便的函数，用于将不同类型的数值转换为字符串，以便于输出或字符串处理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_9_memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_9_memory/" class="post-title-link" itemprop="url">C++_10_9_memory</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <memory>标准库</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <memory>标准库</h2><p><code>&lt;memory&gt;</code> 是 C++ 标准库中的头文件，提供了一些内存管理相关的类和函数，用于帮助管理动态分配的内存和智能指针等。</p>
<p>以下是 <code>&lt;memory&gt;</code> 标准库中一些重要的内容：</p>
<ol>
<li><p><strong>动态内存分配：</strong></p>
<ul>
<li><code>std::allocator</code>：是用于分配和释放内存的默认分配器。</li>
<li><code>std::unique_ptr</code>：一种独占指针，用于管理动态分配的对象，确保内存的释放。</li>
<li><code>std::shared_ptr</code>：一种共享指针，多个指针可以共享对同一个对象的所有权，使用引用计数来管理内存释放。</li>
<li><code>std::weak_ptr</code>：弱引用指针，用于解决 <code>std::shared_ptr</code> 可能导致的循环引用问题。</li>
</ul>
</li>
<li><p><strong>智能指针相关函数和工具：</strong></p>
<ul>
<li><code>std::make_unique</code>：用于创建动态分配的对象并返回一个 <code>std::unique_ptr</code>。</li>
<li><code>std::make_shared</code>：用于创建动态分配的对象并返回一个 <code>std::shared_ptr</code>。</li>
</ul>
</li>
<li><p><strong>内存管理相关工具和函数：</strong></p>
<ul>
<li><code>std::addressof</code>：获取对象的地址。</li>
<li><code>std::pointer_traits</code>：提供了对指针类型的通用操作。</li>
<li><code>std::default_delete</code>：默认删除器，用于指定 <code>std::unique_ptr</code> 的删除策略。</li>
</ul>
</li>
<li><p><strong>特定内存工具和操作：</strong></p>
<ul>
<li><code>std::align</code>：在给定地址处对齐内存。</li>
<li><code>std::allocator_traits</code>：提供了对分配器的通用操作。</li>
</ul>
</li>
</ol>
<p>使用 <code>&lt;memory&gt;</code> 标准库，可以更安全地管理动态分配的内存，避免内存泄漏和悬挂指针等问题。智能指针类能够自动处理内存的释放，大大简化了内存管理的复杂性。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <memory>标准库 详解</h2><p><code>&lt;memory&gt;</code> 标准库提供了许多功能，主要用于在 C++ 中管理内存和智能指针。以下是 <code>&lt;memory&gt;</code> 标准库中的一些重要组件和功能：</p>
<ol>
<li><p><strong>智能指针：</strong></p>
<ul>
<li><code>std::unique_ptr</code>：独占所有权的智能指针，确保只有一个指针可以管理一个对象。当 <code>std::unique_ptr</code> 被销毁时，它所管理的对象也会被自动释放。</li>
<li><code>std::shared_ptr</code>：允许多个指针共享对同一对象的所有权，使用引用计数来管理对象的生命周期。当最后一个 <code>std::shared_ptr</code> 被销毁时，关联的对象才会被释放。</li>
<li><code>std::weak_ptr</code>：弱引用指针，用于打破 <code>std::shared_ptr</code> 可能产生的循环引用问题。</li>
</ul>
</li>
<li><p><strong>内存管理相关工具和函数：</strong></p>
<ul>
<li><code>std::make_unique</code>：用于创建动态分配的对象并返回一个 <code>std::unique_ptr</code>。</li>
<li><code>std::make_shared</code>：用于创建动态分配的对象并返回一个 <code>std::shared_ptr</code>。</li>
<li><code>std::allocator</code>：用于动态内存分配和释放的默认分配器。</li>
<li><code>std::default_delete</code>：默认的删除器，通常与智能指针 <code>std::unique_ptr</code> 结合使用，指定对象的释放方式。</li>
</ul>
</li>
<li><p><strong>工具和类型特征：</strong></p>
<ul>
<li><code>std::addressof</code>：获取对象的地址。</li>
<li><code>std::pointer_traits</code>：提供了对指针类型的通用操作。</li>
<li><code>std::allocator_traits</code>：提供了对分配器的通用操作。</li>
</ul>
</li>
<li><p><strong>内存操作和指针工具：</strong></p>
<ul>
<li><code>std::align</code>：在给定地址处对齐内存。</li>
<li><code>std::memcpy</code> 和 <code>std::memset</code>：用于内存复制和内存设置。</li>
</ul>
</li>
</ol>
<p><code>&lt;memory&gt;</code> 标准库提供了许多工具和类，使得在 C++ 中进行内存管理变得更加安全和方便。智能指针能够避免常见的内存管理问题，如悬挂指针、内存泄漏等，有助于提高代码的健壮性和可靠性。同时，这些功能也让程序员更加轻松地进行动态内存管理。</p>
<h2 id="C-标准库-常用类和函数"><a href="#C-标准库-常用类和函数" class="headerlink" title="C++ 标准库 常用类和函数"></a>C++ <memory>标准库 常用类和函数</h2><p><code>&lt;memory&gt;</code> 标准库中有许多常用的类和函数，主要用于内存管理和智能指针。以下是一些常用的类和函数：</p>
<h3 id="常用类："><a href="#常用类：" class="headerlink" title="常用类："></a>常用类：</h3><ol>
<li><strong>智能指针类：</strong><ul>
<li><code>std::unique_ptr&lt;T&gt;</code>：独占所有权的智能指针，确保只有一个指针可以管理一个对象。</li>
<li><code>std::shared_ptr&lt;T&gt;</code>：允许多个指针共享对同一对象的所有权。</li>
<li><code>std::weak_ptr&lt;T&gt;</code>：弱引用指针，用于打破 <code>std::shared_ptr</code> 可能产生的循环引用问题。</li>
</ul>
</li>
</ol>
<h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><ol>
<li><p><strong>内存管理相关函数：</strong></p>
<ul>
<li><code>std::make_unique&lt;T&gt;()</code>：用于创建动态分配的对象并返回一个 <code>std::unique_ptr&lt;T&gt;</code>。</li>
<li><code>std::make_shared&lt;T&gt;()</code>：用于创建动态分配的对象并返回一个 <code>std::shared_ptr&lt;T&gt;</code>。</li>
<li><code>std::allocate_shared&lt;T&gt;()</code>：分配一个对象的共享内存。</li>
<li><code>std::allocate_shared&lt;T, Args...&gt;()</code>：使用自定义分配器分配一个对象的共享内存。</li>
</ul>
</li>
<li><p><strong>其他函数：</strong></p>
<ul>
<li><code>std::addressof()</code>：获取对象的地址。</li>
<li><code>std::memcpy()</code> 和 <code>std::memset()</code>：用于内存复制和内存设置。</li>
</ul>
</li>
</ol>
<h3 id="类型特征和工具："><a href="#类型特征和工具：" class="headerlink" title="类型特征和工具："></a>类型特征和工具：</h3><ol>
<li><p><strong>指针和分配器相关的类型特征：</strong></p>
<ul>
<li><code>std::pointer_traits&lt;T&gt;</code>：提供了对指针类型 <code>T</code> 的通用操作。</li>
<li><code>std::allocator_traits&lt;Allocator&gt;</code>：提供了对分配器 <code>Allocator</code> 的通用操作。</li>
</ul>
</li>
<li><p><strong>分配器相关类：</strong></p>
<ul>
<li><code>std::allocator&lt;T&gt;</code>：用于动态内存分配和释放的默认分配器。</li>
</ul>
</li>
</ol>
<p><code>&lt;memory&gt;</code> 标准库提供了强大的工具和类来管理动态分配的内存，帮助避免内存泄漏和悬挂指针等问题。智能指针类使得在 C++ 中进行内存管理变得更加方便和安全。</p>
<h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p><code>std::unique_ptr</code> 是 C++ 标准库 <code>&lt;memory&gt;</code> 中定义的智能指针类，用于管理动态分配的对象，并且在其生命周期结束时自动释放所管理的对象。</p>
<p><code>std::unique_ptr</code> 具有独占所有权的特性，即同一时间只能有一个 <code>std::unique_ptr</code> 指向一个对象。当 <code>std::unique_ptr</code> 被销毁时（例如超出作用域、被赋予新值或者显式释放），它所管理的对象也会被自动释放，从而避免内存泄漏。</p>
<p>以下是 <code>std::unique_ptr</code> 的主要特点和用法：</p>
<ul>
<li><p><strong>独占所有权：</strong> 一个 <code>std::unique_ptr</code> 实例是对象的唯一所有者，不能被复制，但可以被移动。</p>
</li>
<li><p><strong>创建 <code>std::unique_ptr</code>：</strong></p>
<ul>
<li>使用 <code>std::make_unique&lt;T&gt;()</code>：用于创建动态分配的对象并返回一个 <code>std::unique_ptr&lt;T&gt;</code>。</li>
<li>直接声明：<code>std::unique_ptr&lt;T&gt; ptr(new T())</code>，但不推荐直接使用 <code>new</code>。</li>
</ul>
</li>
<li><p><strong>移动语义：</strong> <code>std::unique_ptr</code> 支持移动语义，可以使用 <code>std::move</code> 来将所有权从一个 <code>std::unique_ptr</code> 转移到另一个。</p>
</li>
<li><p><strong>释放内存：</strong> 当 <code>std::unique_ptr</code> 超出作用域时，它所管理的对象会被自动释放。</p>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// ptr 在此处超出作用域，触发自动释放所管理的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">someFunction</span>();</span><br><span class="line">    <span class="comment">// 在此处无法访问 ptr，因为它已经超出了作用域</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::make_unique&lt;int&gt;(42)</code> 创建了一个动态分配的整数对象，并将其存储在 <code>std::unique_ptr&lt;int&gt;</code> 中。当 <code>ptr</code> 超出作用域时，所管理的对象会被自动释放。</p>
<h2 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h2><p><code>std::shared_ptr</code> 是 C++ 标准库 <code>&lt;memory&gt;</code> 中定义的智能指针类，用于管理动态分配的对象，并且可以让多个指针共享对同一对象的所有权。</p>
<p>与 <code>std::unique_ptr</code> 不同，<code>std::shared_ptr</code> 允许多个 <code>std::shared_ptr</code> 实例共享对同一对象的控制权。它使用引用计数机制来管理内存，当最后一个 <code>std::shared_ptr</code> 指向对象时，对象会被销毁。</p>
<p>以下是 <code>std::shared_ptr</code> 的主要特点和用法：</p>
<ul>
<li><p><strong>共享所有权：</strong> 多个 <code>std::shared_ptr</code> 可以指向同一个对象，共享对该对象的所有权。</p>
</li>
<li><p><strong>引用计数：</strong> 使用引用计数来追踪对象的所有权，当最后一个 <code>std::shared_ptr</code> 被销毁时，才会释放对象。</p>
</li>
<li><p><strong>创建 <code>std::shared_ptr</code>：</strong></p>
<ul>
<li>使用 <code>std::make_shared&lt;T&gt;()</code>：用于创建动态分配的对象并返回一个 <code>std::shared_ptr&lt;T&gt;</code>。</li>
<li>直接声明：<code>std::shared_ptr&lt;T&gt; ptr = std::shared_ptr&lt;T&gt;(new T())</code>，但不推荐直接使用 <code>new</code>。</li>
</ul>
</li>
<li><p><strong>复制和移动语义：</strong> <code>std::shared_ptr</code> 支持复制和移动语义。复制 <code>std::shared_ptr</code> 会增加引用计数，移动 <code>std::shared_ptr</code> 会将所有权转移给另一个对象。</p>
</li>
<li><p><strong>释放内存：</strong> 当最后一个 <code>std::shared_ptr</code> 超出作用域时，所管理的对象会被释放。</p>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 共享指针 ptr1 的所有权</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value of ptr1: &quot;</span> &lt;&lt; *ptr1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value of ptr2: &quot;</span> &lt;&lt; *ptr2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// ptr1 和 ptr2 在此处超出作用域，引用计数减少，对象不会被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">someFunction</span>();</span><br><span class="line">    <span class="comment">// 在此处无法访问 ptr1 和 ptr2，因为它们已经超出了作用域</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>ptr1</code> 和 <code>ptr2</code> 都指向同一个动态分配的整数对象。当函数结束时，引用计数减少，但由于 <code>ptr1</code> 和 <code>ptr2</code> 都超出作用域，所管理的对象最终会被释放。</p>
<h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p><code>std::weak_ptr</code> 是 C++ 标准库 <code>&lt;memory&gt;</code> 中定义的智能指针类，用于解决 <code>std::shared_ptr</code> 可能导致的循环引用问题，并且不影响所管理对象的生命周期。</p>
<p><code>std::weak_ptr</code> 是一种弱引用指针，它可以指向由 <code>std::shared_ptr</code> 管理的对象，但并不拥有对象的所有权。它不会增加对象的引用计数，因此也不会阻止对象的销毁。通常用于观察或临时访问由 <code>std::shared_ptr</code> 管理的对象。</p>
<p>以下是 <code>std::weak_ptr</code> 的主要特点和用法：</p>
<ul>
<li><p><strong>弱引用：</strong> 不持有对象的所有权，不会影响对象的生命周期。</p>
</li>
<li><p><strong>与 <code>std::shared_ptr</code> 搭配使用：</strong> <code>std::weak_ptr</code> 可以从 <code>std::shared_ptr</code> 创建，并通过 <code>std::lock()</code> 方法转换为 <code>std::shared_ptr</code>，以临时获取对象的所有权。</p>
</li>
<li><p><strong>检查对象是否存在：</strong> 可以使用 <code>expired()</code> 方法检查与 <code>std::weak_ptr</code> 关联的对象是否被销毁。</p>
</li>
<li><p><strong>安全地访问对象：</strong> 使用 <code>std::lock()</code> 方法可以安全地获取 <code>std::shared_ptr</code>，如果对象存在，则返回 <code>std::shared_ptr</code>，否则返回空的 <code>std::shared_ptr</code>。</p>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">observe</span><span class="params">(std::weak_ptr&lt;<span class="type">int</span>&gt; weakPtr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> sharedPtr = weakPtr.<span class="built_in">lock</span>()) &#123; <span class="comment">// 尝试获取 shared_ptr</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value observed: &quot;</span> &lt;&lt; *sharedPtr &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object has been destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sharedPtr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::weak_ptr&lt;<span class="type">int</span>&gt; weakPtr = sharedPtr; <span class="comment">// 创建 weak_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">observe</span>(weakPtr); <span class="comment">// 观察对象</span></span><br><span class="line"></span><br><span class="line">    sharedPtr.<span class="built_in">reset</span>(); <span class="comment">// 销毁 shared_ptr</span></span><br><span class="line">    <span class="built_in">observe</span>(weakPtr); <span class="comment">// 再次观察对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>weakPtr</code> 弱引用指向 <code>sharedPtr</code> 所管理的整数对象。通过 <code>std::lock()</code> 方法，<code>weakPtr</code> 可以安全地转换为 <code>std::shared_ptr</code>，以临时获取对象的所有权。在 <code>observe()</code> 函数中，可以检查对象是否存在，并安全地访问对象。当 <code>sharedPtr</code> 被销毁后，通过 <code>weakPtr</code> 观察对象时，将得到对象已被销毁的信息。</p>
<h2 id="std-make-unique"><a href="#std-make-unique" class="headerlink" title="std::make_unique"></a>std::make_unique</h2><p><code>std::make_unique</code> 是 C++11 标准引入的一个函数模板，用于创建动态分配的对象并返回一个 <code>std::unique_ptr</code> 智能指针。它是用于创建 <code>std::unique_ptr</code> 的首选方式，具有安全和简洁的特性。</p>
<p>与直接使用 <code>new</code> 来分配内存并创建 <code>std::unique_ptr</code> 不同，<code>std::make_unique</code> 提供了更加安全和简洁的方式，它在分配对象的同时将其封装到 <code>std::unique_ptr</code> 中。</p>
<p>基本用法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::unique_ptr，管理一个动态分配的整数对象</span></span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl; <span class="comment">// 访问所管理的整数对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::make_unique&lt;int&gt;(42)</code> 创建了一个动态分配的整数对象，并将其封装到 <code>std::unique_ptr&lt;int&gt;</code> 中。这种方式简洁、安全，并且避免了手动管理内存，提高了代码的可读性和健壮性。</p>
<p>需要注意的是，<code>std::make_unique</code> 在 C++11 中引入，但用于创建 <code>std::unique_ptr</code>。而对于 <code>std::shared_ptr</code>，C++11 并没有提供 <code>std::make_shared</code>，但在 C++14 中引入了这个功能。所以在 C++14 中，可以使用 <code>std::make_shared</code> 来创建 <code>std::shared_ptr</code>。</p>
<h2 id="std-make-shared"><a href="#std-make-shared" class="headerlink" title="std::make_shared"></a>std::make_shared</h2><p><code>std::make_shared</code> 是 C++11 引入的函数模板，用于创建动态分配的对象并返回一个 <code>std::shared_ptr</code> 智能指针。它是创建 <code>std::shared_ptr</code> 的推荐方式，提供了安全和高效的对象分配和管理。</p>
<p>基本用法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 std::shared_ptr，管理一个动态分配的整数对象</span></span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl; <span class="comment">// 访问所管理的整数对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::make_shared&lt;int&gt;(42)</code> 创建了一个动态分配的整数对象，并将其封装到 <code>std::shared_ptr&lt;int&gt;</code> 中。<code>std::make_shared</code> 可以接收参数并直接传递给对象的构造函数。</p>
<p>与直接使用 <code>new</code> 来分配内存并创建 <code>std::shared_ptr</code> 不同，<code>std::make_shared</code> 提供了更高效的内存分配，因为它会分配一个单一的内存块用于存储对象和控制块（用于跟踪引用计数等信息）。这种方式可以减少额外的开销，并且可以更有效地使用内存。</p>
<p>需要注意的是，<code>std::make_shared</code> 是 C++11 引入的，在 C++11 之前，可以使用 <code>std::shared_ptr&lt;T&gt;(new T(args))</code> 的方式创建 <code>std::shared_ptr</code>，但这种方式可能导致额外的内存分配和性能损耗。</p>
<h2 id="std-allocate-shared"><a href="#std-allocate-shared" class="headerlink" title="std::allocate_shared"></a>std::allocate_shared</h2><p><code>std::allocate_shared</code> 是 C++11 引入的函数模板，用于创建动态分配的对象并返回一个 <code>std::shared_ptr</code> 智能指针。与 <code>std::make_shared</code> 类似，<code>std::allocate_shared</code> 也用于动态分配对象，但允许指定自定义的分配器。</p>
<p>基本用法示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyStruct</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用自定义分配器创建一个 std::shared_ptr，管理一个动态分配的 MyStruct 对象</span></span><br><span class="line">    std::allocator&lt;MyStruct&gt; alloc;</span><br><span class="line">    <span class="keyword">auto</span> ptr = std::<span class="built_in">allocate_shared</span>&lt;MyStruct&gt;(alloc, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; ptr-&gt;value &lt;&lt; std::endl; <span class="comment">// 访问所管理的对象的成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::allocate_shared&lt;MyStruct&gt;(alloc, 42)</code> 使用自定义的分配器 <code>std::allocator&lt;MyStruct&gt;</code> 创建了一个动态分配的 <code>MyStruct</code> 对象，并将其封装到 <code>std::shared_ptr&lt;MyStruct&gt;</code> 中。第一个参数是分配器对象，第二个参数是传递给对象构造函数的参数。</p>
<p>相较于 <code>std::shared_ptr</code> 的其他构造函数和 <code>std::make_shared</code>，<code>std::allocate_shared</code> 允许程序员提供自定义的分配器，以满足特定的内存管理需求。这个函数在一些特殊情况下可以提供更大的灵活性。</p>
<h2 id="std-addressof"><a href="#std-addressof" class="headerlink" title="std::addressof"></a>std::addressof</h2><p><code>std::addressof</code> 是 C++ 标准库 <code>&lt;memory&gt;</code> 中定义的函数模板，用于获取对象的地址。</p>
<p>与 C++ 内置的取地址运算符 <code>&amp;</code> 不同，<code>std::addressof</code> 能够确保即使重载了取地址运算符的类，也能获得对象的真实地址。</p>
<p><code>std::addressof</code> 的基本用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* ptr = std::<span class="built_in">addressof</span>(num); <span class="comment">// 获取变量 num 的地址</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Address of num: &quot;</span> &lt;&lt; ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::addressof</code> 获取了变量 <code>num</code> 的地址，并将其存储在指针 <code>ptr</code> 中。使用 <code>std::cout</code> 打印出 <code>num</code> 的地址。</p>
<p>通常情况下，直接使用取地址运算符 <code>&amp;</code> 可以获取对象的地址。但是，如果类重载了取地址运算符（<code>operator&amp;</code>），可能会导致取到重载后的地址。在这种情况下，使用 <code>std::addressof</code> 可以确保获取到对象的真实地址。</p>
<h2 id="std-allocator"><a href="#std-allocator" class="headerlink" title="std::allocator"></a>std::allocator</h2><p><code>std::allocator</code> 是 C++ 标准库 <code>&lt;memory&gt;</code> 头文件中定义的默认分配器类模板。它是 C++ 中动态内存分配和释放的接口之一，用于管理内存的分配和释放。</p>
<p><code>std::allocator</code> 作为内存分配器，提供了用于分配和释放内存的一组操作，其中包括 <code>allocate()</code>、<code>deallocate()</code>、<code>construct()</code> 和 <code>destroy()</code> 等函数。</p>
<p>以下是 <code>std::allocator</code> 的主要操作：</p>
<ul>
<li><code>allocate()</code>：分配指定数量的未初始化内存块。</li>
<li><code>deallocate()</code>：释放之前分配的内存块。</li>
<li><code>construct()</code>：在分配的内存中构造一个对象。</li>
<li><code>destroy()</code>：在分配的内存中销毁一个对象。</li>
</ul>
<p>它是 C++ 标准库提供的默认分配器，并且也是许多容器（如 <code>std::vector</code>、<code>std::list</code> 等）的默认分配器。</p>
<p>通常情况下，如果不提供自定义的分配器，标准库的容器会默认使用 <code>std::allocator</code> 进行内存管理。当然，如果需要更多的定制或特定的内存管理方式，可以通过定义自己的分配器类并符合特定的接口来实现。</p>
<p>以下是一个简单示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::allocator&lt;<span class="type">int</span>&gt; myAllocator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存来存储 5 个整数</span></span><br><span class="line">    <span class="type">int</span>* ptr = myAllocator.<span class="built_in">allocate</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        myAllocator.<span class="built_in">construct</span>(&amp;ptr[i], i); <span class="comment">// 构造对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出分配的整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; ptr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁对象并释放内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        myAllocator.<span class="built_in">destroy</span>(&amp;ptr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    myAllocator.<span class="built_in">deallocate</span>(ptr, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::allocator</code> 被用来分配和释放一块存储整数的内存，然后构造并输出这些整数，最后销毁并释放分配的内存。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_6_cctype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_6_cctype/" class="post-title-link" itemprop="url">C++_10_6_cctype</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><cctype> 标准库相关笔记</li>
</ul>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ <cctype>标准库</h2><p>C++ 标准库 <code>&lt;cctype&gt;</code> 提供了一组用于对字符进行分类和简单字符处理的函数。这些函数在 <code>&lt;cctype&gt;</code> 头文件中声明，并且是 C++ 中处理字符的标准方式。</p>
<p>以下是 <code>&lt;cctype&gt;</code> 头文件中常用的一些函数：</p>
<h3 id="字符分类函数："><a href="#字符分类函数：" class="headerlink" title="字符分类函数："></a>字符分类函数：</h3><ul>
<li><code>std::isalnum(int c)</code>: 检查字符是否是字母或数字。</li>
<li><code>std::isalpha(int c)</code>: 检查字符是否是字母。</li>
<li><code>std::isdigit(int c)</code>: 检查字符是否是十进制数字。</li>
<li><code>std::islower(int c)</code>: 检查字符是否是小写字母。</li>
<li><code>std::isupper(int c)</code>: 检查字符是否是大写字母。</li>
<li><code>std::isspace(int c)</code>: 检查字符是否是空格或类似的空白字符。</li>
<li><code>std::iscntrl(int c)</code>: 检查字符是否是控制字符。</li>
<li><code>std::ispunct(int c)</code>: 检查字符是否是标点符号。</li>
<li><code>std::isprint(int c)</code>: 检查字符是否是可打印字符。</li>
<li><code>std::isxdigit(int c)</code>: 检查字符是否是十六进制数字。</li>
</ul>
<h3 id="字符转换函数："><a href="#字符转换函数：" class="headerlink" title="字符转换函数："></a>字符转换函数：</h3><ul>
<li><code>std::tolower(int c)</code>: 将字符转换为小写形式。</li>
<li><code>std::toupper(int c)</code>: 将字符转换为大写形式。</li>
</ul>
<h3 id="其他函数："><a href="#其他函数：" class="headerlink" title="其他函数："></a>其他函数：</h3><ul>
<li><code>std::tolower()</code> 和 <code>std::toupper()</code> 还有版本可用于处理字符的宽字符版本 <code>wchar_t</code>，其函数名为 <code>std::towlower()</code> 和 <code>std::towupper()</code>。</li>
</ul>
<p>这些函数都接受一个整数参数，通常是 <code>int</code> 类型，表示要检查或转换的字符。函数返回值为 <code>int</code> 类型，通常表示一个非零值（真）或零值（假）来指示检查的条件是否满足。</p>
<p>这些函数通常用于检查或转换字符，例如，检查一个字符是否是字母、数字，或者将字符转换为大写或小写形式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">isupper</span>(ch)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;字符 &quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot; 是大写字母&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> lowercase = std::<span class="built_in">tolower</span>(ch);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;将字符 &quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot; 转换为小写形式为: &quot;</span> &lt;&lt; lowercase &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上示例演示了 <code>std::isupper()</code> 函数检查一个字符是否为大写字母，以及 <code>std::tolower()</code> 函数将一个字符转换为小写形式。</p>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <cctype>标准库 详解</h2><p><code>&lt;cctype&gt;</code> 是 C++ 标准库中的头文件，提供了一系列操作 C 风格字符串中字符的函数，这些函数是字符分类函数（character classification functions），用于检查和操作字符的特性。</p>
<p>以下是 <code>&lt;cctype&gt;</code> 头文件中常见的函数及其功能：</p>
<ol>
<li><p><strong>字符分类函数</strong>：</p>
<ul>
<li><code>isalnum(int c)</code>：检查字符是否是字母或数字。</li>
<li><code>isalpha(int c)</code>：检查字符是否是字母。</li>
<li><code>isdigit(int c)</code>：检查字符是否是十进制数字。</li>
<li><code>isxdigit(int c)</code>：检查字符是否是十六进制数字。</li>
<li><code>islower(int c)</code>：检查字符是否是小写字母。</li>
<li><code>isupper(int c)</code>：检查字符是否是大写字母。</li>
<li><code>isspace(int c)</code>：检查字符是否是空白字符（空格、制表符、换行符等）。</li>
<li><code>iscntrl(int c)</code>：检查字符是否是控制字符。</li>
<li><code>ispunct(int c)</code>：检查字符是否是标点符号。</li>
<li><code>isprint(int c)</code>：检查字符是否是可打印字符（包括空格）。</li>
<li><code>isgraph(int c)</code>：检查字符是否是可打印字符，但不包括空格。</li>
</ul>
</li>
<li><p><strong>字符转换函数</strong>：</p>
<ul>
<li><code>tolower(int c)</code>：将字符转换为小写字母（如果是大写字母的话）。</li>
<li><code>toupper(int c)</code>：将字符转换为大写字母（如果是小写字母的话）。</li>
</ul>
</li>
</ol>
<p>这些函数通常用于对字符进行分类、转换或验证操作。它们的参数一般是一个整数（<code>int</code> 类型），这个整数可以是字符，也可以是 <code>EOF</code>（文件结束符）的值。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>以下是一个简单的示例，展示了 <code>&lt;cctype&gt;</code> 头文件中的一些函数的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">isalnum</span>(ch)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character is alphanumeric.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character is a digit.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lowercase: &quot;</span> &lt;&lt; std::<span class="built_in">tolower</span>(ch) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Uppercase: &quot;</span> &lt;&lt; std::<span class="built_in">toupper</span>(ch) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此示例中，使用了 <code>isalnum()</code>、<code>isdigit()</code>、<code>tolower()</code> 和 <code>toupper()</code> 函数来检查和转换字符的特性。<code>isalnum()</code> 检查字符是否是字母或数字，<code>isdigit()</code> 检查字符是否是数字，<code>tolower()</code> 和 <code>toupper()</code> 分别将字符转换为小写和大写形式。</p>
<h2 id="std-tolower"><a href="#std-tolower" class="headerlink" title="std::tolower()"></a>std::tolower()</h2><p><code>std::tolower()</code> 是 C++ 标准库中 <code>&lt;cctype&gt;</code> 头文件中提供的函数，用于将单个字符转换为小写形式。</p>
<h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tolower</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>c</code>：要转换为小写的字符。</li>
</ul>
<h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果 <code>c</code> 是大写字母，则返回对应的小写字母，否则返回 <code>c</code> 本身。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> uppercase = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> lowercase = std::<span class="built_in">tolower</span>(uppercase);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;大写字母 &quot;</span> &lt;&lt; uppercase &lt;&lt; <span class="string">&quot; 转换为小写字母为: &quot;</span> &lt;&lt; lowercase &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大写字母 A 转换为小写字母为: a</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::tolower(&#39;A&#39;)</code> 将大写字母 ‘A’ 转换为小写字母 ‘a’。</p>
<h2 id="std-toupper"><a href="#std-toupper" class="headerlink" title="std::toupper()"></a>std::toupper()</h2><p><code>std::toupper()</code> 是 C++ 标准库中 <code>&lt;cctype&gt;</code> 头文件中提供的函数之一，用于将字符转换为大写形式。</p>
<h3 id="函数原型：-1"><a href="#函数原型：-1" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">toupper</span><span class="params">(<span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h3><ul>
<li><code>c</code>：要转换为大写的字符。</li>
</ul>
<h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h3><ul>
<li>如果 <code>c</code> 是小写字母，则返回对应的大写字母；否则返回 <code>c</code> 本身。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> lowercase = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> uppercase = std::<span class="built_in">toupper</span>(lowercase);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;小写字母 &quot;</span> &lt;&lt; lowercase &lt;&lt; <span class="string">&quot; 转换为大写字母为: &quot;</span> &lt;&lt; uppercase &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小写字母 a 转换为大写字母为: A</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>std::toupper(&#39;a&#39;)</code> 将小写字母 ‘a’ 转换为大写字母 ‘A’。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_7_array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_7_array/" class="post-title-link" itemprop="url">C++_10_7_array</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <array>标准库笔记</li>
</ul>
<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><ul>
<li>和vector类似，区别在于array的大小是固定的，不能增加或收缩</li>
<li>这个类的目的是让array能分配在栈上，而不是像vector那样总是需要访问自由存储区</li>
<li>对于包含基本类型(整数，浮点数，字符，布尔值等)的array，初始化元素的方式与vector,list等容器的初始化不同，如果在创建array时没有给初始化值，那么array的元素将是未初始化的，即包含垃圾。对于其他容器，例如vector和list，元素总是初始化的，要么是给定值，要么使用零初始化。因此，array的行为实际上与C风格数组相同。</li>
<li>和vector一样，array支持随机访问迭代器，元素都保存在连续内存中。array支持front()，back(),at()和operator[]，还支持使用fill()方法通过特定元素将array填满</li>
<li>与vector相比，array的缺点是，array的swap()方法具有线性时间复杂度，而vector的swap()方法具有常量时间复杂度。array的移动不是常量时间，vector是</li>
<li>array有size()方法，这显然是优于C风格数组。</li>
</ul>
<h2 id="C-标准库-详解"><a href="#C-标准库-详解" class="headerlink" title="C++ 标准库 详解"></a>C++ <array>标准库 详解</h2><p><code>&lt;array&gt;</code> 标准库提供了 <code>std::array</code> 类模板，用于表示固定大小的数组。以下是一些关键点：</p>
<ol>
<li><strong>固定大小：</strong> <code>std::array</code> 的大小在创建时确定，并且无法改变。</li>
<li><strong>内存分配：</strong> 与内置数组类似，<code>std::array</code> 在栈上分配内存，因此大小必须在编译时确定。</li>
<li><strong>元素访问：</strong> 与内置数组类似，可以使用下标操作符 <code>[]</code> 来访问元素。也可以使用 <code>at()</code> 函数进行安全的边界检查。</li>
<li><strong>迭代器支持：</strong> 提供迭代器支持，可以使用迭代器来遍历数组。</li>
<li><strong>容器功能：</strong> 支持一些容器方法，如 <code>size()</code>、<code>empty()</code> 等。</li>
<li><strong>数组间的比较：</strong> 支持数组之间的比较操作，可以使用 <code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code> 等运算符进行比较。</li>
<li><strong>类型安全：</strong> 提供了类型安全的数组访问和操作，因此可以更轻松地避免指针错误和越界访问。</li>
</ol>
<p>使用 <code>std::array</code> 可以简化对数组的管理和操作，提供更多的安全性和方便性，是 C++ 中常用的容器之一。</p>
<h2 id="C-标准库常用函数"><a href="#C-标准库常用函数" class="headerlink" title="C++ 标准库常用函数"></a>C++ <array>标准库常用函数</h2><p><code>&lt;array&gt;</code> 标准库中的 <code>std::array</code> 类提供了一些常用的函数和方法，以下是其中一些常见的：</p>
<ol>
<li><p><strong><code>at()</code>：</strong> 以安全的方式访问指定位置的元素，并进行边界检查，如果索引超出范围，则抛出 <code>std::out_of_range</code> 异常。</p>
</li>
<li><p><strong><code>operator[]</code>：</strong> 使用下标操作符 <code>[]</code> 访问数组的特定元素。不进行边界检查，因此需要确保索引在合法范围内。</p>
</li>
<li><p><strong><code>front()</code> 和 <code>back()</code>：</strong> 分别返回数组的第一个元素和最后一个元素。</p>
</li>
<li><p><strong><code>data()</code>：</strong> 返回指向数组第一个元素的指针。</p>
</li>
<li><p><strong><code>fill()</code>：</strong> 将数组中的所有元素设置为特定的值。</p>
</li>
<li><p><strong><code>empty()</code>：</strong> 检查数组是否为空，即大小是否为零。</p>
</li>
<li><p><strong><code>size()</code>：</strong> 返回数组中元素的数量。</p>
</li>
<li><p><strong><code>swap()</code>：</strong> 交换两个数组的内容。</p>
</li>
</ol>
<p>这些函数和方法使得 <code>std::array</code> 更加方便和易于使用，可以轻松地进行数组的访问、操作和管理。</p>
<h2 id="std-array-operator"><a href="#std-array-operator" class="headerlink" title="std::array::operator[]"></a>std::array::operator[]</h2><p><code>std::array::operator[]</code> 是 <code>std::array</code> 类中重载的下标访问操作符。它允许像普通数组一样使用 <code>[]</code> 运算符来访问数组中特定位置的元素，但不进行边界检查。</p>
<p>与 <code>std::array::at()</code> 不同，<code>std::array::operator[]</code> 不会检查索引是否超出数组边界。因此，如果使用 <code>[]</code> 运算符访问超出数组范围的索引，将导致未定义行为，可能会读取到未知的内存或导致程序崩溃。</p>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value = arr[<span class="number">2</span>]; <span class="comment">// 访问数组索引为 2 的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value at index 2: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问超出数组范围的索引，这可能导致未定义行为</span></span><br><span class="line">    <span class="type">int</span> out_of_range_value = arr[<span class="number">7</span>];</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value at index 7: &quot;</span> &lt;&lt; out_of_range_value &lt;&lt; std::endl; <span class="comment">// 可能导致程序崩溃或未定义行为</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>arr[2]</code> 访问了数组索引为 2 的元素，而 <code>arr[7]</code> 尝试访问了超出数组范围的索引。请注意，访问超出范围的索引可能会导致程序运行时的不可预测行为。</p>
<h2 id="std-array-front"><a href="#std-array-front" class="headerlink" title="std::array::front()"></a>std::array::front()</h2><p><code>std::array::front()</code> 是 <code>std::array</code> 类提供的成员函数之一，用于获取数组的第一个元素。</p>
<p>它类似于 <code>std::array</code> 的下标访问方式，但是 <code>front()</code> 更直观和语义化，专门用于访问数组的第一个元素。这个函数对于代码的可读性很有帮助，因为它清晰地表达了获取数组第一个元素的意图。</p>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> first_element = arr.<span class="built_in">front</span>(); <span class="comment">// 获取数组的第一个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The first element is: &quot;</span> &lt;&lt; first_element &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>arr.front()</code> 获取了数组 <code>arr</code> 的第一个元素，并将其存储在 <code>first_element</code> 变量中，然后将其打印输出。</p>
<h2 id="std-array-back"><a href="#std-array-back" class="headerlink" title="std::array::back"></a>std::array::back</h2><p><code>std::array::back()</code> 是 <code>std::array</code> 类提供的成员函数之一，用于获取数组的最后一个元素。</p>
<p>与 <code>std::array::front()</code> 类似，<code>std::array::back()</code> 专门用于获取数组的最后一个元素，这样可以更清晰地表达获取最后一个元素的意图，提高代码的可读性。</p>
<p>以下是一个示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> last_element = arr.<span class="built_in">back</span>(); <span class="comment">// 获取数组的最后一个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The last element is: &quot;</span> &lt;&lt; last_element &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>arr.back()</code> 获取了数组 <code>arr</code> 的最后一个元素，并将其存储在 <code>last_element</code> 变量中，然后将其打印输出。</p>
<h2 id="std-array-data"><a href="#std-array-data" class="headerlink" title="std::array::data()"></a>std::array::data()</h2><p><code>std::array::data()</code> 是 <code>std::array</code> 类提供的成员函数之一，用于获取指向数组首元素的指针。</p>
<p>它返回一个指向数组中第一个元素的指针，允许直接访问数组的底层数据。这个函数在需要以 C 风格的函数或需要传递数组数据的情况下很有用，因为它提供了指向数组数据的指针。</p>
<p>以下是一个示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* ptr = arr.<span class="built_in">data</span>(); <span class="comment">// 获取指向数组首元素的指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First element of the array: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>arr.data()</code> 返回指向数组 <code>arr</code> 第一个元素的指针，并将其存储在 <code>ptr</code> 变量中。然后，<code>*ptr</code> 打印出指针所指向的第一个元素的值。</p>
<h2 id="std-array-fill"><a href="#std-array-fill" class="headerlink" title="std::array::fill()"></a>std::array::fill()</h2><p><code>std::array::fill()</code> 是 <code>std::array</code> 类提供的成员函数之一，用于将数组中的所有元素设置为特定的值。</p>
<p>这个函数接受一个参数，用来指定要填充到数组中的值。调用 <code>fill()</code> 函数会将数组中的所有元素都设置为该指定值。</p>
<p>以下是一个示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    arr.<span class="built_in">fill</span>(<span class="number">0</span>); <span class="comment">// 将数组中的所有元素设置为 0</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array after filling with 0s: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>arr.fill(0)</code> 调用将数组 <code>arr</code> 中的所有元素都设置为 0。然后使用循环遍历数组并打印出填充后的数组元素。</p>
<h2 id="std-array-empty"><a href="#std-array-empty" class="headerlink" title="std::array::empty()"></a>std::array::empty()</h2><p><code>std::array::empty()</code> 是 <code>std::array</code> 类提供的成员函数之一，用于检查数组是否为空。</p>
<p>对于 <code>std::array</code> 类型，它的大小是在编译时确定的，因此不会存在空数组的情况。<code>empty()</code> 函数对于 <code>std::array</code> 始终会返回 <code>false</code>，因为它不具备动态大小调整的能力，数组的大小在创建时已经固定。</p>
<p>下面是一个示例代码，展示了 <code>empty()</code> 函数的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Array is empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Array is not empty.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管调用 <code>empty()</code> 函数并不会报错，但对于 <code>std::array</code> 类型，它永远返回 <code>false</code>，因为该类型的数组大小在创建时就被确定了，不允许为空。</p>
<h2 id="std-array-size"><a href="#std-array-size" class="headerlink" title="std::array::size()"></a>std::array::size()</h2><p><code>std::array::size()</code> 是 <code>std::array</code> 类提供的成员函数之一，用于获取数组中元素的数量。</p>
<p>它返回 <code>std::array</code> 中的元素个数，这个值是在编译时确定的，因为 <code>std::array</code> 是一个固定大小的数组容器。</p>
<p>以下是一个示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of the array: &quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>arr.size()</code> 返回数组 <code>arr</code> 中元素的数量，即 5。这个函数对于确定数组的大小非常方便，可以在不需要硬编码数组大小的情况下获得数组的实际大小。</p>
<h2 id="std-array-swap"><a href="#std-array-swap" class="headerlink" title="std::array::swap()"></a>std::array::swap()</h2><p><code>std::array::swap()</code> 是 <code>std::array</code> 类提供的成员函数之一，用于交换两个数组的内容。</p>
<p>这个函数接受另一个 <code>std::array</code> 作为参数，并交换调用该函数的数组对象和传入的数组对象的内容。要注意的是，这两个数组必须具有相同的大小和类型。</p>
<p>以下是一个示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr2 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array 1 before swap:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; element;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array 2 before swap:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; element;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    arr<span class="number">1.</span><span class="built_in">swap</span>(arr2); <span class="comment">// 交换两个数组的内容</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array 1 after swap:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; element;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array 2 after swap:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : arr2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; element;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>arr1</code> 和 <code>arr2</code> 的内容被交换。<code>arr1.swap(arr2)</code> 将数组 <code>arr1</code> 和 <code>arr2</code> 的内容互换，使得 <code>arr1</code> 包含原来的 <code>arr2</code> 内容，<code>arr2</code> 包含原来的 <code>arr1</code> 内容。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_8_exception/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_8_exception/" class="post-title-link" itemprop="url">C++_10_8_exception</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++ <exception> 标准库</li>
</ul>
<h2 id="c-标准库"><a href="#c-标准库" class="headerlink" title="c++ 标准库"></a>c++ <exception>标准库</h2><p><code>&lt;exception&gt;</code> 标准库提供了异常处理相关的功能，包含了一些用于异常处理的类和函数。在 C++ 中，异常处理允许程序在运行时检测到错误，并且在适当的地方进行处理，而不是导致程序异常终止。</p>
<p>一些 <code>&lt;exception&gt;</code> 标准库中的重要组件包括：</p>
<ol>
<li><p><strong><code>std::exception</code> 类：</strong> 是所有标准异常类的基类。它定义了一些公共成员函数，如 <code>what()</code>，用于返回异常的描述信息。</p>
</li>
<li><p><strong>标准异常类：</strong> 包括 <code>std::bad_alloc</code>、<code>std::bad_cast</code>、<code>std::bad_exception</code>、<code>std::bad_typeid</code>、<code>std::logic_error</code> 和 <code>std::runtime_error</code> 等。这些类继承自 <code>std::exception</code>，用于表示不同类型的异常情况。</p>
</li>
<li><p><strong>异常处理关键字：</strong> <code>try</code>、<code>catch</code> 和 <code>throw</code>。<code>try</code> 用于包裹可能引发异常的代码块，<code>catch</code> 用于捕获并处理异常，<code>throw</code> 用于抛出异常。</p>
</li>
<li><p><strong><code>std::nested_exception</code>：</strong> 这是一个模板类，它允许异常在一个异常处理器中重新抛出。</p>
</li>
</ol>
<p>通过使用 <code>&lt;exception&gt;</code> 标准库，程序员可以更加精细地控制代码中可能出现的异常，并且可以根据情况进行处理或传递异常信息，从而提高程序的健壮性和可靠性。</p>
<h2 id="c-标准库-详解"><a href="#c-标准库-详解" class="headerlink" title="c++ 标准库 详解"></a>c++ <exception>标准库 详解</h2><p><code>&lt;exception&gt;</code> 标准库提供了在 C++ 中处理异常的相关功能。以下是该标准库中的一些重要组件和使用方法的详细解释：</p>
<ol>
<li><p><strong><code>std::exception</code> 类：</strong> 是所有标准异常类的基类。它包含了一个虚拟成员函数 <code>what()</code>，允许派生类提供描述异常的字符串。程序员通常通过继承 <code>std::exception</code> 来创建自定义异常类，并重写 <code>what()</code> 函数以提供特定异常的描述信息。</p>
</li>
<li><p><strong>标准异常类：</strong> <code>std::exception</code> 的派生类包括：</p>
<ul>
<li><code>std::bad_alloc</code>：用于表示动态分配内存失败的情况。</li>
<li><code>std::bad_cast</code>：用于表示类型转换失败的情况。</li>
<li><code>std::bad_exception</code>：用于表示异常规范（exception specifications）未匹配的情况。</li>
<li><code>std::bad_typeid</code>：用于表示 typeid 运算符失败的情况。</li>
<li><code>std::logic_error</code>：用于表示在程序逻辑上可被预见的异常。</li>
<li><code>std::runtime_error</code>：用于表示在运行时可能发生的异常。</li>
</ul>
</li>
<li><p><strong>异常处理关键字：</strong></p>
<ul>
<li><code>try</code>：用于将可能引发异常的代码块包裹起来。</li>
<li><code>catch</code>：用于捕获和处理 <code>try</code> 块中抛出的异常。</li>
<li><code>throw</code>：用于手动抛出异常对象。</li>
</ul>
</li>
<li><p><strong><code>std::nested_exception</code>：</strong> 这个模板类允许异常在一个异常处理器中重新抛出。它允许在捕获异常后保留异常信息，然后在另一个上下文中重新抛出异常。</p>
</li>
</ol>
<p>异常处理是一种用于控制程序在遇到错误时如何处理的机制。通过 <code>&lt;exception&gt;</code> 标准库，程序员可以使用异常来跳出错误的代码块并在适当的地方进行处理，而不是让程序非正常终止。这有助于提高程序的可靠性和健壮性。</p>
<h2 id="c-标准库-常用函数"><a href="#c-标准库-常用函数" class="headerlink" title="c++ 标准库 常用函数"></a>c++ <exception>标准库 常用函数</h2><p><code>&lt;exception&gt;</code> 标准库并未提供太多直接调用的函数，但它定义了一些关键的类和机制来处理异常。以下是一些常用的函数和类：</p>
<ol>
<li><p><strong><code>std::exception</code>：</strong> 是所有标准异常类的基类，它包含了一个虚拟成员函数 <code>what()</code>，用于返回描述异常的字符串。常用于自定义异常类的基类。</p>
</li>
<li><p><strong>标准异常类：</strong> 派生自 <code>std::exception</code>，如 <code>std::bad_alloc</code>、<code>std::bad_cast</code>、<code>std::logic_error</code> 和 <code>std::runtime_error</code> 等。每个异常类都可以通过构造函数接受字符串来描述异常。</p>
</li>
<li><p><strong>异常处理关键字：</strong> <code>try</code>、<code>catch</code> 和 <code>throw</code>。</p>
<ul>
<li><code>try</code> 用于包裹可能引发异常的代码块。</li>
<li><code>catch</code> 用于捕获并处理 <code>try</code> 块中抛出的异常，其语法为 <code>catch (const SomeExceptionType&amp; ex)</code>。</li>
<li><code>throw</code> 用于手动抛出异常对象，可以是标准异常类的实例或者用户自定义的异常类的实例。</li>
</ul>
</li>
<li><p><strong><code>std::nested_exception</code>：</strong> 模板类允许异常在一个异常处理器中重新抛出，以便在另一个上下文中处理异常。</p>
</li>
</ol>
<p>虽然 <code>&lt;exception&gt;</code> 标准库并不包含太多的直接函数，但它提供了一套机制和类，可以帮助程序员在程序执行过程中检测和处理异常，从而提高程序的可靠性和健壮性。</p>
<h2 id="std-exception"><a href="#std-exception" class="headerlink" title="std::exception"></a>std::exception</h2><p><code>std::exception</code> 是 C++ 标准库 <code>&lt;exception&gt;</code> 中的一个类，是所有标准异常类的基类。它被设计为一个抽象基类，用于派生出各种不同类型的异常类，以表示不同的异常情况。</p>
<p><code>std::exception</code> 包含了一个虚拟成员函数 <code>what()</code>，允许派生类提供描述异常的字符串。派生类应该覆盖 <code>what()</code> 函数，并返回一个 C 风格的字符串，描述了异常的信息。</p>
<p>例如，下面是一个简单的例子展示了如何使用 <code>std::exception</code> 的派生类，并重写 <code>what()</code> 函数来提供异常信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;This is a custom exception.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>MyException</code> 是一个自定义异常类，它继承自 <code>std::exception</code>。它重写了 <code>what()</code> 函数，返回一个描述异常信息的字符串。在 <code>main()</code> 函数中，<code>throw MyException()</code> 语句抛出一个 <code>MyException</code> 类的实例，然后在 <code>catch</code> 块中捕获并打印异常信息。</p>
<h2 id="std-bad-alloc"><a href="#std-bad-alloc" class="headerlink" title="std::bad_alloc"></a>std::bad_alloc</h2><p><code>std::bad_alloc</code> 是 C++ 标准库 <code>&lt;exception&gt;</code> 中的一个异常类，它是 <code>std::exception</code> 的一个派生类。<code>std::bad_alloc</code> 类通常用于表示动态内存分配失败的情况，比如使用 <code>new</code> 操作符申请内存时，如果内存不足或分配失败，就会抛出这个异常。</p>
<p>这个异常通常在需要动态分配内存（比如使用 <code>new</code>、<code>malloc</code> 或其他动态内存分配方式）的情况下使用。如果动态内存分配失败，比如尝试分配比系统可用内存还多的内存时，就会抛出 <code>std::bad_alloc</code> 异常。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span>* myArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10000000000000000</span>]; <span class="comment">// 尝试分配一个非常大的数组</span></span><br><span class="line">        <span class="keyword">delete</span>[] myArray;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught bad_alloc exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>new int[10000000000000000]</code> 尝试分配一个非常大的数组，可能超出系统可用内存的范围，因此会抛出 <code>std::bad_alloc</code> 异常。<code>catch</code> 块捕获这个异常，并打印出异常信息。</p>
<h2 id="std-bad-cast"><a href="#std-bad-cast" class="headerlink" title="std::bad_cast"></a>std::bad_cast</h2><p><code>std::bad_cast</code> 是 C++ 标准库 <code>&lt;exception&gt;</code> 中的一个异常类，它是 <code>std::exception</code> 的一个派生类。<code>std::bad_cast</code> 类通常用于表示在类型转换失败的情况下抛出的异常。</p>
<p>这个异常通常与 C++ 中的类型转换运算符 <code>dynamic_cast</code> 相关。当使用 <code>dynamic_cast</code> 进行转换时，如果无法将一个指针或引用转换为所需的目标类型，则会抛出 <code>std::bad_cast</code> 异常。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (derivedPtr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Successful dynamic_cast.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">typeid</span>(*basePtr) == <span class="built_in">typeid</span>(Derived)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">bad_cast</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in">catch</span>(<span class="type">const</span> std::bad_cast&amp; e) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Caught bad_cast exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Base</code> 和 <code>Derived</code> 是类的继承关系。在 <code>main()</code> 函数中，使用 <code>dynamic_cast</code> 尝试将 <code>Base</code> 指针 <code>basePtr</code> 转换为 <code>Derived</code> 类型的指针 <code>derivedPtr</code>。如果转换失败，<code>dynamic_cast</code> 返回 <code>nullptr</code>。在这种情况下，通过 <code>typeid</code> 运算符检查类型，如果类型不匹配，则手动抛出 <code>std::bad_cast</code> 异常。<code>catch</code> 块捕获这个异常，并打印出异常信息。</p>
<h2 id="std-bad-exception"><a href="#std-bad-exception" class="headerlink" title="std::bad_exception"></a>std::bad_exception</h2><p><code>std::bad_exception</code> 是 C++ 标准库 <code>&lt;exception&gt;</code> 中的一个异常类，它是 <code>std::exception</code> 的一个派生类。<code>std::bad_exception</code> 类通常用于表示异常规范（exception specifications）未匹配的情况。</p>
<p>在 C++ 中，异常规范（exception specifications）被用来指定一个函数可以抛出的异常类型。如果一个函数声明了它可以抛出某种异常类型，但在实际执行中抛出了不属于这个类型的异常，那么就会抛出 <code>std::bad_exception</code> 异常。</p>
<p>需要注意的是，异常规范在 C++ 中并不是强制性的，而且在现代 C++ 中，使用异常规范的做法已经不再推荐，因为它们在实际应用中存在一些问题，例如可能导致程序终止。</p>
<p>以下是一个简单的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">10</span>; <span class="comment">// 抛出一个 int 类型的异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">myFunction</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_exception&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught bad_exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>myFunction()</code> 声明了它可以抛出异常（使用 <code>noexcept(false)</code>），但实际上抛出了一个 <code>int</code> 类型的异常。由于 <code>std::bad_exception</code> 指示了异常规范不匹配的情况，所以在 <code>catch</code> 块中捕获了 <code>std::bad_exception</code> 并打印出异常信息。</p>
<h2 id="std-bad-typeid"><a href="#std-bad-typeid" class="headerlink" title="std::bad_typeid"></a>std::bad_typeid</h2><p><code>std::bad_typeid</code> 是 C++ 标准库 <code>&lt;exception&gt;</code> 中的一个异常类，它是 <code>std::exception</code> 的一个派生类。<code>std::bad_typeid</code> 类通常用于表示 <code>typeid</code> 运算符失败的情况。</p>
<p>在 C++ 中，<code>typeid</code> 运算符可以用来获取对象的类型信息。如果 <code>typeid</code> 运算符无法识别对象的类型，比如对象为空指针或者对象类型是不可识别的，则会抛出 <code>std::bad_typeid</code> 异常。</p>
<p>以下是一个简单的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">const</span> std::type_info&amp; info = <span class="built_in">typeid</span>(<span class="literal">nullptr</span>); <span class="comment">// typeid 对空指针的运算</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Type info: &quot;</span> &lt;&lt; info.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_typeid&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught bad_typeid: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>typeid(nullptr)</code> 尝试获取空指针的类型信息，由于空指针不引用任何实际对象，因此 <code>typeid</code> 运算符无法获取其类型信息，导致抛出 <code>std::bad_typeid</code> 异常。<code>catch</code> 块捕获这个异常，并打印出异常信息。</p>
<h2 id="std-logic-error"><a href="#std-logic-error" class="headerlink" title="std::logic_error"></a>std::logic_error</h2><p><code>std::logic_error</code> 是 C++ 标准库 <code>&lt;stdexcept&gt;</code> 头文件中的一个异常类，它是 <code>std::exception</code> 的一个派生类。<code>std::logic_error</code> 类通常用于表示在程序逻辑上可被预见的异常情况。</p>
<p><code>std::logic_error</code> 类及其派生类用于表示在程序执行期间由于程序逻辑错误导致的异常，这些错误是可以在代码设计阶段预见到的。例如，当函数接收到不合理的参数时，可能会抛出 <code>std::logic_error</code> 异常。</p>
<p>以下是一个简单的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;Division by zero is not allowed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result of division: &quot;</span> &lt;&lt; x / y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>); <span class="comment">// 尝试对 10 进行除以 0 的操作</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::logic_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught logic_error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>divide()</code> 函数用于执行除法操作，但在除数为 0 的情况下会抛出 <code>std::logic_error</code> 异常。在 <code>main()</code> 函数中，<code>divide(10, 0)</code> 尝试对 10 进行除以 0 的操作，触发了异常，并在 <code>catch</code> 块中捕获并打印出异常信息。</p>
<h2 id="std-runtime-error"><a href="#std-runtime-error" class="headerlink" title="std::runtime_error"></a>std::runtime_error</h2><p><code>std::runtime_error</code> 是 C++ 标准库 <code>&lt;stdexcept&gt;</code> 头文件中的一个异常类，它是 <code>std::exception</code> 的一个派生类。<code>std::runtime_error</code> 类通常用于表示在程序运行期间可能发生的异常情况。</p>
<p><code>std::runtime_error</code> 类及其派生类用于表示在程序运行期间由于不可预测的情况导致的异常，例如文件打开失败、内存不足等。与 <code>std::logic_error</code> 不同，<code>std::runtime_error</code> 表示的异常是在运行时才能被检测到的，而不是在程序设计阶段就可以预见到的。</p>
<p>以下是一个简单的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设在打开文件时可能发生异常</span></span><br><span class="line">    <span class="comment">// 这里使用 std::ifstream 模拟文件操作</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to open the file.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他文件操作...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">processFile</span>(<span class="string">&quot;nonexistent_file.txt&quot;</span>); <span class="comment">// 尝试处理一个不存在的文件</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Caught runtime_error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>processFile()</code> 函数尝试打开一个文件。如果文件打开失败，就会抛出 <code>std::runtime_error</code> 异常。在 <code>main()</code> 函数中，<code>processFile(&quot;nonexistent_file.txt&quot;)</code> 尝试处理一个不存在的文件，触发了异常，并在 <code>catch</code> 块中捕获并打印出异常信息。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/23/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="extend next" rel="next" href="/page/25/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
