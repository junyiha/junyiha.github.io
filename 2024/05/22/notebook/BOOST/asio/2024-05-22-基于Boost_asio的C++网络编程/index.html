<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="简介 关于Boost.asio库的笔记，原文链接: https:&#x2F;&#x2F;xzchsia.github.io&#x2F;2020&#x2F;03&#x2F;06&#x2F;boost-asio-learning&#x2F;  概述 Asio,即 异步IO(Asynchronous Input&#x2F;Output)，本是一个独立的C++网络程序库，后来加入Boost  从设计上来看，Asio 相似且重度依赖于 Boost，与 thread、bind、">
<meta property="og:type" content="article">
<meta property="og:title" content="基于Boost_asio的C++网络编程">
<meta property="og:url" content="https://junyiha.github.io/2024/05/22/notebook/BOOST/asio/2024-05-22-%E5%9F%BA%E4%BA%8EBoost_asio%E7%9A%84C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="简介 关于Boost.asio库的笔记，原文链接: https:&#x2F;&#x2F;xzchsia.github.io&#x2F;2020&#x2F;03&#x2F;06&#x2F;boost-asio-learning&#x2F;  概述 Asio,即 异步IO(Asynchronous Input&#x2F;Output)，本是一个独立的C++网络程序库，后来加入Boost  从设计上来看，Asio 相似且重度依赖于 Boost，与 thread、bind、">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-05-22T01:00:00.000Z">
<meta property="article:modified_time" content="2025-04-28T08:08:39.120Z">
<meta property="article:author" content="zhang junyi">
<meta property="article:tag" content="boost.asio">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/asio/2024-05-22-%E5%9F%BA%E4%BA%8EBoost_asio%E7%9A%84C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>基于Boost_asio的C++网络编程 | junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/asio/2024-05-22-%E5%9F%BA%E4%BA%8EBoost_asio%E7%9A%84C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基于Boost_asio的C++网络编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>关于Boost.asio库的笔记，原文链接: <a target="_blank" rel="noopener" href="https://xzchsia.github.io/2020/03/06/boost-asio-learning/">https://xzchsia.github.io/2020/03/06/boost-asio-learning/</a></li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>Asio,即 异步IO(Asynchronous Input&#x2F;Output)，本是一个独立的C++网络程序库，后来加入Boost</p>
</li>
<li><p>从设计上来看，Asio 相似且重度依赖于 Boost，与 thread、bind、smart pointers 等结合时，体验顺滑。从使用上来看，依然是重组合而轻继承，一贯的 C++ 标准库风格</p>
</li>
<li><p>什么是异步IO？</p>
<ul>
<li>简单来说，就是你发起一个 IO 操作，却不用等它结束，你可以继续做其他事情，当它结束时，你会得到通知。</li>
</ul>
</li>
<li><p>当然这种表述是不精确的，操作系统并没有直接提供这样的机制。以 Unix 为例，有五种 IO 模型可用：</p>
<ul>
<li>阻塞 I&#x2F;O</li>
<li>非阻塞 I&#x2F;O</li>
<li>I&#x2F;O 多路复用（multiplexing）（select 和 poll）</li>
<li>信号驱动 I&#x2F;O（SIGIO）</li>
<li>异步 I&#x2F;O（POSIX aio_ 系列函数）</li>
</ul>
</li>
<li><p>这五种模型的定义和比较，详见「Unix Network Programming, Volume 1: The Sockets Networking API」一书 6.2 节</p>
</li>
<li><p>Asio 封装的正是「I&#x2F;O 多路复用」。具体一点，epoll 之于 Linux，kqueue 之于 Mac 和 BSD。epoll 和 kqueue 比 select 和 poll 更高效。当然在 Windows 上封装的则是 IOCP（完成端口）</p>
</li>
<li><p>Asio 的「I&#x2F;O 操作」，主要还是指「网络 IO」，比如 socket 读写。由于网络传输的特性，「网络 IO」相对比较费时，设计良好的服务器，不可能同步等待一个 IO 操作的结束，这太浪费 CPU 了。</p>
</li>
<li><p>对于普通的「文件 IO」，操作系统并没有提供“异步”读写机制，libuv 的做法是用线程模拟异步，为网络和文件提供了一致的接口。Asio 并没有这样做，它专注于网络。提供机制而不是策略，这很符合 C++ 哲学</p>
</li>
</ul>
<h2 id="I-O-Context"><a href="#I-O-Context" class="headerlink" title="I&#x2F;O Context"></a>I&#x2F;O Context</h2><ul>
<li>每个 Asio 程序都至少有一个 io_context 对象，它代表了操作系统的 I&#x2F;O 服务（io_context 在 Boost 1.66 之前一直叫 io_service），把你的程序和这些服务链接起来<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  ioc.<span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>io_context.run 是一个阻塞（blocking）调用，姑且把它想象成一个 loop（事件循环），直到所有异步操作完成后，loop 才结束，run 才返回。但是这个程序没有任何异步操作，所以 loop 直接就结束了</li>
</ul>
<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><ul>
<li><p>有了 io_context 还不足以完成 I&#x2F;O 操作，用户一般也不跟 io_context 直接交互</p>
</li>
<li><p>根据 I&#x2F;O 操作的不同，Asio 提供了不同的 I&#x2F;O 对象，比如 timer（定时器），socket，等等。 Timer 是最简单的一种 I&#x2F;O 对象，可以用来实现异步调用的超时机制，下面是最简单的用法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(boost::system::error_code ec)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(ioc, std::chrono::seconds(<span class="number">3</span>))</span></span>;</span><br><span class="line">  timer.<span class="built_in">async_wait</span>(&amp;Print);</span><br><span class="line">  ioc.<span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>先创建一个 steady_timer，指定时间 3 秒，然后异步等待这个 timer，3 秒后，timer 超时结束，Print 被调用</p>
</li>
<li><p>以下几点需要注意：</p>
<ul>
<li>所有 I&#x2F;O 对象都依赖 io_context，一般在构造时指定</li>
<li>async_wait 初始化了一个异步操作，但是这个异步操作的执行，要等到 io_context.run 时才开始</li>
<li>Timer 除了异步等待（async_wait），还可以同步等待（wait）。同步等待是阻塞的，直到 timer 超时结束。基本上所有 I&#x2F;O 对象的操作都有同步和异步两个版本，也许是出于设计上的完整性</li>
<li>async_wait 的参数是一个函数对象，异步操作完成时它会被调用，所以也叫 completion handler，简称 handler，可以理解成回调函数</li>
<li>所有 I&#x2F;O 对象的 async_xyz 函数都有 handler 参数，对于 handler 的签名，不同的异步操作有不同的要求，除了官方文档里的说明，也可以直接查看 Boost 源码。</li>
</ul>
</li>
<li><p>async_wait 的 handler 签名为 void (boost::system::error_code)，如果要传递额外的参数，就得用 bind</p>
</li>
<li><p>不妨修改一下 Print，让它每隔一秒打印一次计数，从 0 递增到 3</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(boost::system::error_code ec,</span></span></span><br><span class="line"><span class="params"><span class="function">           boost::asio::steady_timer* timer,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">int</span>* count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (*count &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; *count &lt;&lt; std::endl;</span><br><span class="line">    ++(*count);</span><br><span class="line"></span><br><span class="line">    timer-&gt;<span class="built_in">expires_after</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    timer-&gt;<span class="built_in">async_wait</span>(std::<span class="built_in">bind</span>(&amp;Print, std::placeholders::_1, timer, count));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(ioc, std::chrono::seconds(<span class="number">1</span>))</span></span>;</span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  timer.<span class="built_in">async_wait</span>(std::<span class="built_in">bind</span>(&amp;Print, std::placeholders::_1, &amp;timer, &amp;count));</span><br><span class="line"></span><br><span class="line">  ioc.<span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>与前版相比，Print 多了两个参数，以便访问当前计数及重启 timer。</p>
</li>
<li><p>调用 bind 时，使用了占位符（placeholder）std::placeholders::_1。数字占位符共有 9 个，_1 - _9</p>
</li>
</ul>
<h2 id="Echo-Server"><a href="#Echo-Server" class="headerlink" title="Echo Server"></a>Echo Server</h2><ul>
<li>Socket 也是一种 I&#x2F;O 对象，这一点前面已经提及。相比于 timer，socket 更为常用，毕竟 Asio 是一个网络程序库</li>
<li>下面以经典的 Echo 程序为例，实现一个 TCP Server。所谓 Echo，就是 Server 把 Client 发来的内容原封不动发回给 Client</li>
</ul>
<h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><ul>
<li><p>Session 代表会话，负责管理一个 client 的连接。参数 socket 传的是值，但是会用到 move 语义来避免拷贝</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Session</span><span class="params">(tcp::socket socket)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      boost::array&lt;<span class="type">char</span>, BUF_SIZE&gt; data;</span><br><span class="line"></span><br><span class="line">      boost::system::error_code ec;</span><br><span class="line">      std::<span class="type">size_t</span> length = socket.<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(data), ec);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ec == boost::asio::error::eof) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;连接被 client 妥善的关闭了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">        <span class="comment">// 其他错误</span></span><br><span class="line">        <span class="keyword">throw</span> boost::system::<span class="built_in">system_error</span>(ec);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      boost::asio::<span class="built_in">write</span>(socket, boost::asio::<span class="built_in">buffer</span>(data, length));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt;  e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其中，tcp 即 boost::asio::ip::tcp；BUF_SIZE 定义为 enum { BUF_SIZE &#x3D; 1024 };。这些都是细节，后面的例子不再赘述</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;port&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> port = std::<span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 Acceptor 侦听新的连接</span></span><br><span class="line">  <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(ioc, tcp::endpoint(tcp::v4(), port))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 一次处理一个连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="built_in">Session</span>(acceptor.<span class="built_in">accept</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt;  e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动时，通过命令行参数指定端口号，比如：</p>
</li>
<li><p><code>echo_server_sync 8080</code></p>
</li>
<li><p>以下几点需要注意：</p>
<ul>
<li>tcp::acceptor 也是一种 I&#x2F;O 对象，用来接收 TCP 连接，连接端口由 tcp::endpoint 指定</li>
<li>数据 buffer 以 boost::array&lt;char, BUF_SIZE&gt; 表示，也可以用 char data[BUF_SIZE]，或 std::vector<char> data(BUF_SIZE)。事实上，用 std::vector 是最推荐的，因为它不但可以动态调整大小，还支持 Buffer Debugging。</li>
<li>同步方式下，没有调用 io_context.run，因为 accept、read_some 和 write 都是阻塞的。这也意味着一次只能处理一个 Client 连接，但是可以连续 echo，除非 Client 断开连接</li>
<li>写回数据时，没有直接调用 socket.write_some，因为它不能保证一次写完所有数据，但是 boost::asio::write 可以。我觉得这是 Asio 接口设计不周，应该提供 socket.write</li>
<li>acceptor.accept 返回一个新的 socket 对象，利用 move 语义，直接就转移给了 Session 的参数，期间并没有拷贝开销</li>
</ul>
</li>
</ul>
<h3 id="异步方式"><a href="#异步方式" class="headerlink" title="异步方式"></a>异步方式</h3><ul>
<li><p>异步方式下，困难在于对象的生命周期，可以用 shared_ptr 解决</p>
</li>
<li><p>为了同时处理多个 Client 连接，需要保留每个连接的 socket 对象，于是抽象出一个表示连接会话的类，叫 Session：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Session</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Session&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Session</span>(tcp::socket socket) : <span class="built_in">socket_</span>(std::<span class="built_in">move</span>(socket)) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DoRead</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">self</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">    socket_.<span class="built_in">async_read_some</span>(</span><br><span class="line">        boost::asio::<span class="built_in">buffer</span>(buffer_),</span><br><span class="line">        [<span class="keyword">this</span>, self](boost::system::error_code ec, std::<span class="type">size_t</span> length) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            <span class="built_in">DoWrite</span>(length);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DoWrite</span><span class="params">(std::<span class="type">size_t</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">self</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">    boost::asio::<span class="built_in">async_write</span>(</span><br><span class="line">        socket_,</span><br><span class="line">        boost::asio::<span class="built_in">buffer</span>(buffer_, length),</span><br><span class="line">        [<span class="keyword">this</span>, self](boost::system::error_code ec, std::<span class="type">size_t</span> length) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            <span class="built_in">DoRead</span>();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  tcp::socket socket_;</span><br><span class="line">  std::array&lt;<span class="type">char</span>, BUF_SIZE&gt; buffer_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>就代码风格来说，有以下几点需要注意：</p>
<ul>
<li>优先使用 STL，比如 std::enable_shared_from_this，std::bind，std::array，等等</li>
<li>定义 handler 时，尽量使用匿名函数（lambda 表达式）</li>
<li>以 C++ std::size_t 替 C size_t。 刚开始，你可能会不习惯，我也是这样，过了好久才慢慢拥抱 C++11 乃至 C++14</li>
</ul>
</li>
<li><p>Session 有两个成员变量，socket_ 与 Client 通信，buffer_ 是接收 Client 数据的缓存。只要 Session 对象在，socket 就在，连接就不断。Socket 对象是构造时传进来的，而且是通过 move 语义转移进来的。</p>
</li>
<li><p>虽然还没看到 Session 对象是如何创建的，但可以肯定的是，它必须用 std::shared_ptr 进行封装，这样才能保证异步模式下对象的生命周期。</p>
</li>
<li><p>此外，在 Session::DoRead 和 Session::DoWrite 中，因为读写都是异步的，同样为了防止当前 Session 不被销毁（因为超出作用域），所以要增加它的引用计数，即 auto self(shared_from_this()); 这一句的作用</p>
</li>
<li><p>至于读写的逻辑，基本上就是把 read_some 换成 async_read_some，把 write 换成 async_write，然后以匿名函数作为 completion handler</p>
</li>
<li><p>接收 Client 连接的代码，提取出来，抽象成一个类 Server</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Server</span>(boost::asio::io_context&amp; ioc, std::<span class="type">uint16_t</span> port)</span><br><span class="line">      : <span class="built_in">acceptor_</span>(ioc, tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(), port)) &#123;</span><br><span class="line">    <span class="built_in">DoAccept</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DoAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acceptor_.<span class="built_in">async_accept</span>(</span><br><span class="line">        [<span class="keyword">this</span>](boost::system::error_code ec, tcp::socket socket) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">            std::<span class="built_in">make_shared</span>&lt;Session&gt;(std::<span class="built_in">move</span>(socket))-&gt;<span class="built_in">Start</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">DoAccept</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  tcp::acceptor acceptor_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>同样，async_accept 替换了 accept。async_accept 不再阻塞，DoAccept 即刻就会返回。 为了保证 Session 对象继续存在，使用 std::shared_ptr 代替普通的栈对象，同时把新接收的 socket 对象转移过去</p>
</li>
<li><p>最后是 main()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;port&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::<span class="type">uint16_t</span> port = std::<span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  <span class="function">Server <span class="title">server</span><span class="params">(ioc, port)</span></span>;</span><br><span class="line"></span><br><span class="line">  ioc.<span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Echo-Client"><a href="#Echo-Client" class="headerlink" title="Echo Client"></a>Echo Client</h2><ul>
<li>虽然用 netcat 测试 Echo Server 非常方便，但是自己动手写一个 Echo Client 仍然十分必要。 还是先考虑同步方式。</li>
</ul>
<h3 id="同步方式-1"><a href="#同步方式-1" class="headerlink" title="同步方式"></a>同步方式</h3><ul>
<li><p>首先通过 host 和 port 解析出 endpoints（对，是复数！）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(ioc)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> endpoints = resolver.<span class="built_in">resolve</span>(tcp::<span class="built_in">v4</span>(), host, port);</span><br></pre></td></tr></table></figure></li>
<li><p>resolve 返回的 endpoints 类型为 tcp::resolver::results_type，代之以 auto 可以简化代码。类型推导应适当使用，至于连 int 都用 auto 就没有必要了。 host 和 port 通过命令行参数指定，比如 localhost 和 8080</p>
</li>
<li><p>接着创建 socket，建立连接：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tcp::socket <span class="title">socket</span><span class="params">(ioc)</span></span>;</span><br><span class="line">boost::asio::<span class="built_in">connect</span>(socket, endpoints);</span><br></pre></td></tr></table></figure></li>
<li><p>这里没有直接调用 socket.connect，因为 endpoints 可能会有多个，boost::asio::connect 会挨个尝试，逐一调用 socket.connect 直到连接成功。</p>
</li>
<li><p>其实这样说不太严谨，根据我的测试，resolve 在没有指定 protocol 时，确实会返回多个 endpoints，一个是 IPv6，一个是 IPv4。但是我们已经指定了 protocol 为 tcp::v4()：</p>
</li>
<li><p>接下来，从标准输入（std::cin）读一行数据，然后通过 boost::asio::write 发送给 Server：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> request[BUF_SIZE];</span><br><span class="line">std::<span class="type">size_t</span> request_length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Enter message: &quot;</span>;</span><br><span class="line">  std::cin.<span class="built_in">getline</span>(request, BUF_SIZE);</span><br><span class="line">  request_length = std::<span class="built_in">strlen</span>(request);</span><br><span class="line">&#125; <span class="keyword">while</span> (request_length == <span class="number">0</span>);</span><br><span class="line">boost::asio::<span class="built_in">write</span>(socket, boost::asio::<span class="built_in">buffer</span>(request, request_length));</span><br></pre></td></tr></table></figure></li>
<li><p>do…while 是为了防止用户直接 Enter 导致输入为空。boost::asio::write 是阻塞调用，发送完才返回</p>
</li>
<li><p>从 Server 同步接收数据有两种方式：</p>
<ul>
<li>使用 boost::asio::read（对应于 boost::asio::write）；</li>
<li>使用 socket.read_some。</li>
</ul>
</li>
<li><p>两者的差别是</p>
<ul>
<li>boost::asio::read 读到指定长度时，就会返回，你需要知道你想读多少；</li>
<li>而 socket.read_some 一旦读到一些数据就会返回，所以必须放在循环里，然后手动判断是否已经读到想要的长度，否则无法退出循环。</li>
</ul>
</li>
<li><p>下面分别是两种实现的代码。</p>
<ul>
<li>使用 boost::asio::read：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> reply[BUF_SIZE];</span><br><span class="line">std::<span class="type">size_t</span> reply_length = boost::asio::<span class="built_in">read</span>(</span><br><span class="line">    socket,</span><br><span class="line">    boost::asio::<span class="built_in">buffer</span>(reply, request_length));</span><br><span class="line"></span><br><span class="line">std::cout.<span class="built_in">write</span>(reply, reply_length);</span><br></pre></td></tr></table></figure></li>
<li>使用 socket.read_some：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="type">size_t</span> total_reply_length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  std::array&lt;<span class="type">char</span>, BUF_SIZE&gt; reply;</span><br><span class="line">  std::<span class="type">size_t</span> reply_length = socket.<span class="built_in">read_some</span>(boost::asio::<span class="built_in">buffer</span>(reply));</span><br><span class="line"></span><br><span class="line">  std::cout.<span class="built_in">write</span>(reply.<span class="built_in">data</span>(), reply_length);</span><br><span class="line"></span><br><span class="line">  total_reply_length += reply_length;</span><br><span class="line">  <span class="keyword">if</span> (total_reply_length &gt;= request_length) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>不难看出，socket.read_some 用起来更为复杂。 Echo 程序的特殊之处就是，你可以假定 Server 会原封不动的把请求发回来，所以你知道 Client 要读多少。 但是很多时候，我们不知道要读多少数据。 所以，socket.read_some 反倒更为实用</p>
</li>
<li><p>此外，在这个例子中，我们没有为各函数指定输出参数 boost::system::error_code，而是使用了异常，把整个代码块放在 try…catch 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">  std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Asio 的 API 基本都通过重载（overload），提供了 error_code 和 exception 两种错误处理方式。使用异常更易于错误处理，也可以简化代码，但是 try…catch 该包含多少代码，并不是那么明显，新手很容易误用，什么都往 try…catch 里放</p>
</li>
<li><p>一般来说，异步方式下，使用 error_code 更方便一些。所以 complete handler 的参数都有 error_code</p>
</li>
</ul>
<h3 id="异步方式-1"><a href="#异步方式-1" class="headerlink" title="异步方式"></a>异步方式</h3><ul>
<li><p>首先，抽取出一个类 Client</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Client</span>(boost::asio::io_context&amp; ioc,</span><br><span class="line">         <span class="type">const</span> std::string&amp; host, <span class="type">const</span> std::string&amp; port)</span><br><span class="line">      : <span class="built_in">socket_</span>(ioc), <span class="built_in">resolver_</span>(ioc) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  tcp::socket socket_;</span><br><span class="line">  tcp::resolver resolver_;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> cin_buf_[BUF_SIZE];</span><br><span class="line">  std::array&lt;<span class="type">char</span>, BUF_SIZE&gt; buf_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>resolver_ 是为了 async_resolve，作为成员变量，生命周期便得到了保证，不会因为函数结束而失效。</p>
</li>
<li><p>下面来看 async_resolve 实现（代码在构造函数中）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Client</span>(...) &#123;</span><br><span class="line">  resolver_.<span class="built_in">async_resolve</span>(tcp::<span class="built_in">v4</span>(), host, port,</span><br><span class="line">                          std::<span class="built_in">bind</span>(&amp;Client::OnResolve, <span class="keyword">this</span>,</span><br><span class="line">                                    std::placeholders::_1,</span><br><span class="line">                                    std::placeholders::_2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>async_resolve 的 handler：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnResolve</span><span class="params">(boost::system::error_code ec,</span></span></span><br><span class="line"><span class="params"><span class="function">               tcp::resolver::results_type endpoints)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Resolve: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    boost::asio::<span class="built_in">async_connect</span>(socket_, endpoints,</span><br><span class="line">                               std::<span class="built_in">bind</span>(&amp;Client::OnConnect, <span class="keyword">this</span>,</span><br><span class="line">                                         std::placeholders::_1,</span><br><span class="line">                                         std::placeholders::_2));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>async_connect 的 handler：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnConnect</span><span class="params">(boost::system::error_code ec, tcp::endpoint endpoint)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Connect failed: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">    socket_.<span class="built_in">close</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">DoWrite</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>连接成功后，调用 DoWrite，从标准输入读取一行数据，然后异步发送给 Server。 下面是异步读写相关的函数，一并给出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::<span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter message: &quot;</span>;</span><br><span class="line">    std::cin.<span class="built_in">getline</span>(cin_buf_, BUF_SIZE);</span><br><span class="line">    len = <span class="built_in">strlen</span>(cin_buf_);</span><br><span class="line">  &#125; <span class="keyword">while</span> (len == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  boost::asio::<span class="built_in">async_write</span>(socket_,</span><br><span class="line">                           boost::asio::<span class="built_in">buffer</span>(cin_buf_, len),</span><br><span class="line">                           std::<span class="built_in">bind</span>(&amp;Client::OnWrite, <span class="keyword">this</span>,</span><br><span class="line">                                     std::placeholders::_1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnWrite</span><span class="params">(boost::system::error_code ec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reply is: &quot;</span>;</span><br><span class="line"></span><br><span class="line">    socket_.<span class="built_in">async_read_some</span>(boost::asio::<span class="built_in">buffer</span>(buf_),</span><br><span class="line">                            std::<span class="built_in">bind</span>(&amp;Client::OnRead, <span class="keyword">this</span>,</span><br><span class="line">                                      std::placeholders::_1,</span><br><span class="line">                                      std::placeholders::_2));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnRead</span><span class="params">(boost::system::error_code ec, std::<span class="type">size_t</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">    std::cout.<span class="built_in">write</span>(buf_.<span class="built_in">data</span>(), length);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 如果想继续下一轮，可以在这里调用 DoWrite()。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后是 main()：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;host&gt; &lt;port&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* host = argv[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* port = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  <span class="function">Client <span class="title">client</span><span class="params">(ioc, host, port)</span></span>;</span><br><span class="line"></span><br><span class="line">  ioc.<span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>asio示例的代码链接 : <a target="_blank" rel="noopener" href="https://github.com/sprinfall/boost-asio-study.git">https://github.com/sprinfall/boost-asio-study.git</a></p>
</li>
</ul>
<h2 id="Asio-Tips-And-Notes"><a href="#Asio-Tips-And-Notes" class="headerlink" title="Asio Tips And Notes"></a>Asio Tips And Notes</h2><ul>
<li>本文列举Asio各种值的注意的细节</li>
</ul>
<h3 id="No-Deprecated"><a href="#No-Deprecated" class="headerlink" title="No Deprecated"></a>No Deprecated</h3><ul>
<li>在包含 Asio 头文件之前，定义宏 BOOST_ASIO_NO_DEPRECATED，这样在编译时，Asio 就会剔除那些已经过时的接口</li>
<li>比如在最新的 Boost 1.66 中，io_service 已经改名为 io_context，如果没有 BOOST_ASIO_NO_DEPRECATED，还是可以用 io_service 的，虽然那只是 io_context 的一个 typedef</li>
<li>BOOST_ASIO_NO_DEPRECATED 可以保证你用的是最新修订的 API。长期来看，有便于代码的维护。何况，这些修订正是 Asio 进入标准库的前奏<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BOOST_ASIO_NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;boost/asio/io_context.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;boost/asio/steady_timer.hpp&quot;</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="WIN32-WINNT-Warning"><a href="#WIN32-WINNT-Warning" class="headerlink" title="_WIN32_WINNT Warning"></a>_WIN32_WINNT Warning</h3><ul>
<li>在 Windows 平台，编译时会遇到关于 _WIN32_WINNT 的警告。 可以说，这是 Asio 自身的问题。 它应该在某个地方包含 SDKDDKVer.h。 不应该让用户自己去定义平台的版本</li>
<li>如果你用 CMake，可以借助下面这个宏自动检测 _WIN32_WINNT： (详见：<a target="_blank" rel="noopener" href="https://stackoverflow.com/a/40217291/6825348">https://stackoverflow.com/a/40217291/6825348</a>)<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (WIN32)</span><br><span class="line">    <span class="keyword">macro</span>(get_WIN32_WINNT version)</span><br><span class="line">        <span class="keyword">if</span> (CMAKE_SYSTEM_VERSION)</span><br><span class="line">            <span class="keyword">set</span>(ver <span class="variable">$&#123;CMAKE_SYSTEM_VERSION&#125;</span>)</span><br><span class="line">            <span class="keyword">string</span>(REGEX MATCH <span class="string">&quot;^([0-9]+).([0-9])&quot;</span> ver <span class="variable">$&#123;ver&#125;</span>)</span><br><span class="line">            <span class="keyword">string</span>(REGEX MATCH <span class="string">&quot;^([0-9]+)&quot;</span> verMajor <span class="variable">$&#123;ver&#125;</span>)</span><br><span class="line">            <span class="comment"># Check for Windows 10, b/c we&#x27;ll need to convert to hex &#x27;A&#x27;.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;$&#123;verMajor&#125;&quot;</span> <span class="keyword">MATCHES</span> <span class="string">&quot;10&quot;</span>)</span><br><span class="line">                <span class="keyword">set</span>(verMajor <span class="string">&quot;A&quot;</span>)</span><br><span class="line">                <span class="keyword">string</span>(REGEX REPLACE <span class="string">&quot;^([0-9]+)&quot;</span> <span class="variable">$&#123;verMajor&#125;</span> ver <span class="variable">$&#123;ver&#125;</span>)</span><br><span class="line">            <span class="keyword">endif</span> (<span class="string">&quot;$&#123;verMajor&#125;&quot;</span> <span class="keyword">MATCHES</span> <span class="string">&quot;10&quot;</span>)</span><br><span class="line">            <span class="comment"># Remove all remaining &#x27;.&#x27; characters.</span></span><br><span class="line">            <span class="keyword">string</span>(REPLACE <span class="string">&quot;.&quot;</span> <span class="string">&quot;&quot;</span> ver <span class="variable">$&#123;ver&#125;</span>)</span><br><span class="line">            <span class="comment"># Prepend each digit with a zero.</span></span><br><span class="line">            <span class="keyword">string</span>(REGEX REPLACE <span class="string">&quot;([0-9A-Z])&quot;</span> <span class="string">&quot;0\\1&quot;</span> ver <span class="variable">$&#123;ver&#125;</span>)</span><br><span class="line">            <span class="keyword">set</span>(<span class="variable">$&#123;version&#125;</span> <span class="string">&quot;0x$&#123;ver&#125;&quot;</span>)</span><br><span class="line">        <span class="keyword">endif</span>(CMAKE_SYSTEM_VERSION)</span><br><span class="line">    <span class="keyword">endmacro</span>(get_WIN32_WINNT)</span><br><span class="line"></span><br><span class="line">    get_WIN32_WINNT(ver)</span><br><span class="line">    <span class="keyword">add_definitions</span>(-D_WIN32_WINNT=<span class="variable">$&#123;ver&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>(WIN32)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="尽量少包含头文件"><a href="#尽量少包含头文件" class="headerlink" title="尽量少包含头文件"></a>尽量少包含头文件</h3><ul>
<li>尽量不要直接包含大而全的 boost&#x2F;asio.hpp。 这样做，是为了帮助自己记忆哪个类源于哪个具体的头文件，以及避免包含那些不必要的头文件</li>
<li>在实际项目中，在你自己的某个「头文件」里简单粗暴的包含 boost&#x2F;asio.hpp 是很不妥的；当然，在你的「源文件」里包含 boost&#x2F;asio.hpp 是可以接受的，毕竟实际项目依赖的东西比较多，很难搞清楚每一个定义源自哪里</li>
</ul>
<h3 id="Handler签名问题"><a href="#Handler签名问题" class="headerlink" title="Handler签名问题"></a>Handler签名问题</h3><ul>
<li>虽然关于 Handler 的签名，文档里都有说明，但是直接定位到源码，更方便，也更精确</li>
<li>以 steady_timer.async_wait() 为例，在 IDE 里定位到 async_wait() 的定义，代码（片段）如下<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> WaitHandler&gt;</span><br><span class="line"><span class="built_in">BOOST_ASIO_INITFN_RESULT_TYPE</span>(WaitHandler,</span><br><span class="line">    <span class="built_in">void</span> (boost::system::error_code))</span><br><span class="line"><span class="built_in">async_wait</span>(<span class="built_in">BOOST_ASIO_MOVE_ARG</span>(WaitHandler) handler)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure></li>
<li>通过宏 BOOST_ASIO_INITFN_RESULT_TYPE，WaitHandler 的签名一目了然。</li>
</ul>
<h3 id="Handler-的-error-code-参数到底是不是引用？"><a href="#Handler-的-error-code-参数到底是不是引用？" class="headerlink" title="Handler 的 error_code 参数到底是不是引用？"></a>Handler 的 error_code 参数到底是不是引用？</h3><ul>
<li>其实，早期的版本应该是 const boost::system::error_code&amp;，现在文档和代码注释里还有这么写的，估计是没来得及更新。 前面在说 Handler 签名时，已经看到 BOOST_ASIO_INITFN_RESULT_TYPE 这个宏的提示作用，翻一翻 Asio 源码，error_code 其实都已经传值了</li>
<li>奇怪的是，即使你的 Handler 传 error_code 为引用，编译运行也都没有问题<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> boost::system::error_code&amp; ec)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  boost::asio::io_context ioc;</span><br><span class="line">  boost::<span class="function">asio::steady_timer <span class="title">timer</span><span class="params">(ioc, std::chrono::seconds(<span class="number">3</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">  timer.<span class="built_in">async_wait</span>(&amp;Print);</span><br><span class="line"></span><br><span class="line">  ioc.<span class="built_in">run</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>而我发现，当 Handler 是成员函数时，就不行了。下面这个 timer 的例子，如果把 Print 的 error_code 改成引用，就不能编译了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    timer_.<span class="built_in">async_wait</span>(std::<span class="built_in">bind</span>(&amp;Printer::Print, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 不能用 const boost::system::error_code&amp;</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(boost::system::error_code ec)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  boost::asio::steady_timer timer_;</span><br><span class="line">  <span class="type">int</span> count_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这个问题在习惯了引用的情况下，害苦了我，真是百思不得其解！也算是 Boost 比较坑的一个地方吧。 2019&#x2F;08&#x2F;30: 实测 1.70 没有这个问题，可以用 const reference。也许是 1.66 的 bug 吧。</li>
</ul>
<h3 id="Bind-占位符"><a href="#Bind-占位符" class="headerlink" title="Bind 占位符"></a>Bind 占位符</h3><ul>
<li><p>调用 bind 时，使用了占位符（placeholder），其实下面四种写法都可以：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">boost::<span class="built_in">bind</span>(Print, boost::asio::placeholders::error, &amp;timer, &amp;count)</span><br><span class="line">boost::<span class="built_in">bind</span>(Print, boost::placeholders::_1, &amp;timer, &amp;count);</span><br><span class="line">boost::<span class="built_in">bind</span>(Print, _1, &amp;timer, &amp;count);</span><br><span class="line">std::<span class="built_in">bind</span>(Print, std::placeholders::_1, &amp;timer, &amp;count);</span><br></pre></td></tr></table></figure></li>
<li><p>第一种，占位符是 Boost Asio 定义的。 </p>
</li>
<li><p>第二种，占位符是 Boost Bind 定义的。 </p>
</li>
<li><p>第三种，同第二种，之所以可行，是因为 boost&#x2F;bind.hpp 里有一句 using namespace boost::placeholders;。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// boost/bind.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/bind/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BOOST_BIND_NO_PLACEHOLDERS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::placeholders;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>第四种，STL Bind，类似于 Boost Bind，只是没有声明 using namespace std::placeholders;</p>
</li>
<li><p>四种写法，推荐使用二或四。至于是用 Boost Bind 还是 STL Bind，没那么重要。 此外，数字占位符共有 9 个，_1 - _9</p>
</li>
</ul>
<h3 id="Endpoint-是一个单词"><a href="#Endpoint-是一个单词" class="headerlink" title="Endpoint 是一个单词"></a>Endpoint 是一个单词</h3><ul>
<li>不要写成”end point”</li>
</ul>
<h3 id="Server-也可以用Resolver"><a href="#Server-也可以用Resolver" class="headerlink" title="Server 也可以用Resolver"></a>Server 也可以用Resolver</h3><ul>
<li><p>TCP Server 的 acceptor 一般是这样构造的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp::<span class="built_in">acceptor</span>(io_context, tcp::<span class="built_in">endpoint</span>(tcp::<span class="built_in">v4</span>(), port))</span><br></pre></td></tr></table></figure></li>
<li><p>也就是说，指定 protocol (tcp::v4()) 和 port 就行了。</p>
</li>
<li><p>但是，Asio 的 http 这个例子，确实用了 resolver，根据 IP 地址 resolve 出 endpoint：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(io_context_)</span></span>;</span><br><span class="line">tcp::resolver::results_type endpoints = resolver.<span class="built_in">resolve</span>(address, port);</span><br><span class="line">tcp::endpoint endpoint = *endpoints.<span class="built_in">begin</span>();</span><br><span class="line">acceptor_.<span class="built_in">open</span>(endpoint.<span class="built_in">protocol</span>());</span><br><span class="line">acceptor_.<span class="built_in">set_option</span>(tcp::acceptor::<span class="built_in">reuse_address</span>(<span class="literal">true</span>));</span><br><span class="line">acceptor_.<span class="built_in">bind</span>(endpoint);</span><br><span class="line">acceptor_.<span class="built_in">listen</span>();</span><br><span class="line">acceptor_.<span class="built_in">async_accept</span>(...);</span><br></pre></td></tr></table></figure></li>
<li><p>http 这个例子之所以这么写，主要是初始化 acceptor_ 时，还拿不到 endpoint，否则可以直接用下面这个构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">basic_socket_acceptor</span>(boost::asio::io_context&amp; io_context,</span><br><span class="line">      <span class="type">const</span> endpoint_type&amp; endpoint, <span class="type">bool</span> reuse_addr = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>这个构造函数注释说它等价于下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">basic_socket_acceptor&lt;Protocol&gt; <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">open</span>(endpoint.<span class="built_in">protocol</span>());</span><br><span class="line"><span class="keyword">if</span> (reuse_addr)</span><br><span class="line">  acceptor.<span class="built_in">set_option</span>(socket_base::<span class="built_in">reuse_address</span>(<span class="literal">true</span>));</span><br><span class="line">acceptor.<span class="built_in">bind</span>(endpoint);</span><br><span class="line">acceptor.<span class="built_in">listen</span>(listen_backlog);</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面是不同的 address 对应的 endpoints 结果（假定 port 都是 8080）：</p>
<ul>
<li>“localhost”: [::1]:8080, v6; [127.0.0.1]:8080, v4</li>
<li>“0.0.0.0”: 0.0.0.0:8080, v4</li>
<li>“0::0”: [::]:8080, v6</li>
<li>本机实际 IP 地址 (e.g., IPv4 “10.123.164.142”): 10.123.164.142:8080, v4。这时候，本机 client 无法通过 “localhost” 连接到这个 server，通过具体的 IP 地址则可以。</li>
<li>一个具体的非本机地址 (e.g., IPv4 “10.123.164.145”): exception: bind: The requested address is not valid in its context</li>
</ul>
</li>
</ul>
<h3 id="Move-Acceptable-Handle"><a href="#Move-Acceptable-Handle" class="headerlink" title="Move Acceptable Handle"></a>Move Acceptable Handle</h3><ul>
<li><p>使用 acceptor.async_accept 时，发现了 Move Acceptable Handler。</p>
</li>
<li><p>简单来说，async_accept 接受两种 AcceptHandler，直接看源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MoveAcceptHandler&gt;</span><br><span class="line"><span class="built_in">BOOST_ASIO_INITFN_RESULT_TYPE</span>(MoveAcceptHandler,</span><br><span class="line">    <span class="built_in">void</span> (boost::system::error_code, <span class="keyword">typename</span> Protocol::socket))</span><br><span class="line"><span class="built_in">async_accept</span>(<span class="built_in">BOOST_ASIO_MOVE_ARG</span>(MoveAcceptHandler) handler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Protocol1, <span class="keyword">typename</span> AcceptHandler&gt;</span><br><span class="line"><span class="built_in">BOOST_ASIO_INITFN_RESULT_TYPE</span>(AcceptHandler,</span><br><span class="line">    <span class="built_in">void</span> (boost::system::error_code))</span><br><span class="line"><span class="built_in">async_accept</span>(basic_socket&lt;Protocol1&gt;&amp; peer,</span><br><span class="line">    <span class="built_in">BOOST_ASIO_MOVE_ARG</span>(AcceptHandler) handler,</span><br><span class="line">    <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;Protocol, Protocol1&gt;::value&gt;::type* = <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>第一种是 Move Acceptable Handler，它的第二个参数是新 accept 的 socket。 </p>
</li>
<li><p>第二种是普通的 Handler，它的第一个参数是预先构造的 socket</p>
</li>
<li><p>结论是，对于 Move Acceptable Handler，不要用 bind，直接用 lambda 表达式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  acceptor_.<span class="built_in">async_accept</span>(</span><br><span class="line">    [<span class="keyword">this</span>](boost::system::error_code ec, boost::asio::ip::tcp::socket socket) &#123;</span><br><span class="line">    <span class="comment">// Check whether the server was stopped by a signal before this</span></span><br><span class="line">    <span class="comment">// completion handler had a chance to run.</span></span><br><span class="line">    <span class="keyword">if</span> (!acceptor_.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ec) &#123;</span><br><span class="line">      connection_manager_.<span class="built_in">Start</span>(</span><br><span class="line">        std::<span class="built_in">make_shared</span>&lt;Connection&gt;(std::<span class="built_in">move</span>(socket),</span><br><span class="line">        connection_manager_,</span><br><span class="line">        request_handler_));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DoAccept</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div>感谢老板支持！敬礼(^^ゞ</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="zhang junyi WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="zhang junyi Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/boost-asio/" rel="tag"># boost.asio</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/22/notebook/BOOST/beast/2024-05-22-tcp_stream/" rel="prev" title="tcp_stream">
      <i class="fa fa-chevron-left"></i> tcp_stream
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/05/22/notebook/BOOST/beast/2024-05-22-1_3_beast_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" rel="next" title="1_3_beast_理论基础">
      1_3_beast_理论基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-Context"><span class="nav-number">3.</span> <span class="nav-text">I&#x2F;O Context</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Timer"><span class="nav-number">4.</span> <span class="nav-text">Timer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Echo-Server"><span class="nav-number">5.</span> <span class="nav-text">Echo Server</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.</span> <span class="nav-text">同步方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">5.2.</span> <span class="nav-text">异步方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Echo-Client"><span class="nav-number">6.</span> <span class="nav-text">Echo Client</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F-1"><span class="nav-number">6.1.</span> <span class="nav-text">同步方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%96%B9%E5%BC%8F-1"><span class="nav-number">6.2.</span> <span class="nav-text">异步方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Asio-Tips-And-Notes"><span class="nav-number">7.</span> <span class="nav-text">Asio Tips And Notes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#No-Deprecated"><span class="nav-number">7.1.</span> <span class="nav-text">No Deprecated</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WIN32-WINNT-Warning"><span class="nav-number">7.2.</span> <span class="nav-text">_WIN32_WINNT Warning</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%BD%E9%87%8F%E5%B0%91%E5%8C%85%E5%90%AB%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">7.3.</span> <span class="nav-text">尽量少包含头文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Handler%E7%AD%BE%E5%90%8D%E9%97%AE%E9%A2%98"><span class="nav-number">7.4.</span> <span class="nav-text">Handler签名问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Handler-%E7%9A%84-error-code-%E5%8F%82%E6%95%B0%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="nav-number">7.5.</span> <span class="nav-text">Handler 的 error_code 参数到底是不是引用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bind-%E5%8D%A0%E4%BD%8D%E7%AC%A6"><span class="nav-number">7.6.</span> <span class="nav-text">Bind 占位符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Endpoint-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D"><span class="nav-number">7.7.</span> <span class="nav-text">Endpoint 是一个单词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Server-%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%94%A8Resolver"><span class="nav-number">7.8.</span> <span class="nav-text">Server 也可以用Resolver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Move-Acceptable-Handle"><span class="nav-number">7.9.</span> <span class="nav-text">Move Acceptable Handle</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
