<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="简介 asio库使用总结 原文参考链接 : https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;583533338  概述 Asio 是一个用于网络和低级 I&#x2F;O 编程的跨平台 C++ 库，它使用现代 C++ 方法为开发人员提供一致的异步模型.  io_context io_context 类为异步I&#x2F;O对象的用户提供了核心I&#x2F;O功能，包含: asio::ip:">
<meta property="og:type" content="article">
<meta property="og:title" content="C++网络编程asio使用总结">
<meta property="og:url" content="https://junyiha.github.io/2024/05/22/notebook/BOOST/asio/2024-05-22-C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8Basio%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="简介 asio库使用总结 原文参考链接 : https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;583533338  概述 Asio 是一个用于网络和低级 I&#x2F;O 编程的跨平台 C++ 库，它使用现代 C++ 方法为开发人员提供一致的异步模型.  io_context io_context 类为异步I&#x2F;O对象的用户提供了核心I&#x2F;O功能，包含: asio::ip:">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-05-22T01:00:00.000Z">
<meta property="article:modified_time" content="2025-04-28T08:08:39.119Z">
<meta property="article:author" content="zhang junyi">
<meta property="article:tag" content="boost.asio">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/asio/2024-05-22-C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8Basio%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>C++网络编程asio使用总结 | junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/BOOST/asio/2024-05-22-C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8Basio%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++网络编程asio使用总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BOOST/" itemprop="url" rel="index"><span itemprop="name">BOOST</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>asio库使用总结 原文参考链接 : <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/583533338">https://zhuanlan.zhihu.com/p/583533338</a></li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Asio 是一个用于网络和低级 I&#x2F;O 编程的跨平台 C++ 库，它使用现代 C++ 方法为开发人员提供一致的异步模型.</li>
</ul>
<h2 id="io-context"><a href="#io-context" class="headerlink" title="io_context"></a>io_context</h2><ul>
<li>io_context 类为异步I&#x2F;O对象的用户提供了核心I&#x2F;O功能，包含:<ul>
<li>asio::ip::tcp::socket</li>
<li>asio::ip::tcp::acceptor</li>
<li>asio::ip::udp::socket</li>
<li>asio::deadline_timer</li>
</ul>
</li>
</ul>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul>
<li><p>Boost.Asio 的线程安全模型。对于大多数 Boost.Asio 对象，在一个对象上挂起多个异步操作是安全的；只是指定对该对象的并发调用是不安全的。在下图中，每一列代表一个线程，每一行代表一个线程在某个时刻正在做什么。</p>
</li>
<li><p>单个线程进行顺序调用而其他线程不进行调用是安全的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread_1 | thread_2</span><br><span class="line">--------------------------------------+------------ ----------------------------</span><br><span class="line">socket.async_receive(...); | ...</span><br><span class="line">socket.async_write_some(...); | ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个线程进行调用是安全的，但不能同时进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread_1 | thread_2</span><br><span class="line">--------------------------------------+------------ ----------------------------</span><br><span class="line">socket.async_receive(...); | ...</span><br><span class="line">... | socket.async_write_some(...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是，多个线程并发调用是不安全的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread_1 | thread_2</span><br><span class="line">--------------------------------------+------------ ----------------------------</span><br><span class="line">socket.async_receive(...); | socket.async_write_some(...);</span><br><span class="line">... | ...</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="向io-context-提交任意任务"><a href="#向io-context-提交任意任务" class="headerlink" title="向io_context 提交任意任务"></a>向io_context 提交任意任务</h3><ul>
<li>要向 io_context 提交函数，请使用 asio::dispatch、asio::post 或 asio::defer 自由函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    <span class="comment">//提交一个函数</span></span><br><span class="line">    asio::<span class="built_in">post</span>(io_context, my_task);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提交一个lambda 表达式</span></span><br><span class="line">    asio::<span class="built_in">post</span>(io_context, []()&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行 io_context 直到它用完为止。</span></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="阻止-io-context-耗尽工作"><a href="#阻止-io-context-耗尽工作" class="headerlink" title="阻止 io_context 耗尽工作"></a>阻止 io_context 耗尽工作</h3><ul>
<li><p>某些应用程序可能需要阻止 io_context 对象的 run() 调用在没有更多工作要做时返回。 例如，io_context 可能在应用程序的异步操作之前启动的后台线程中运行。 run() 调用可以通过创建一个针对 io_context 跟踪工作的执行器来保持运行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    <span class="keyword">auto</span> work = asio::<span class="built_in">require</span>(io_context.<span class="built_in">get_executor</span>(), </span><br><span class="line">        asio::execution::outstanding_work.tracked);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了实现关闭，应用程序需要调用 io_context 对象的 stop() 成员函数。 这将导致 io_context run() 调用尽快返回，放弃未完成的操作并且不允许分派准备好的处理程序。<br>或者，如果应用程序要求允许所有操作和处理程序正常完成，请将工作跟踪执行程序存储在 any_io_executor 对象中，以便可以显式重置它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::any_io_executor work = asio::<span class="built_in">require</span>(io_context.<span class="built_in">get_executor</span>(),</span><br><span class="line">        asio::execution::outstanding_work.tracked);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    work = asio::<span class="built_in">any_io_executor</span>();<span class="comment">//允许 run() 退出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="io-context-run"><a href="#io-context-run" class="headerlink" title="io_context.run()"></a>io_context.run()</h3><ul>
<li><p>当线程调用 io_context.run() 时，工作和处理程序将从该线程内调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">asio::io_context io_context;</span><br><span class="line">asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line"></span><br><span class="line">io_context.<span class="built_in">post</span>(&amp;print);                             <span class="comment">// 1</span></span><br><span class="line">socket.<span class="built_in">connect</span>(endpoint);                            <span class="comment">// 2</span></span><br><span class="line">socket.<span class="built_in">async_receive</span>(buffer, &amp;handle_async_receive); <span class="comment">// 3</span></span><br><span class="line">io_context.<span class="built_in">post</span>(&amp;print);                             <span class="comment">// 4</span></span><br><span class="line">io_context.<span class="built_in">run</span>();                                    <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li>
<li><p>在上面的示例中，io_context .run()(5) 将阻塞直到：</p>
<ul>
<li>它已从两个print处理程序调用并返回，接收操作成功或失败完成，并且其handle_async_receive处理程序已被调用并返回。</li>
<li>通过 io_context 明确停止 io_context.stop()。</li>
<li>从处理程序中抛出异常。</li>
</ul>
</li>
<li><p>请注意，当 io_context 工作用完时，应用程序必须 reset(), 在 io_context 再次运行之前。</p>
</li>
<li><p>run() 函数会阻塞，直到所有工作完成并且没有更多的处理程序要分派，或者直到 io_context 停止。</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Do you reckon this line displays?&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output: Do you reckon this line displays?</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们的程序用完了怎么办？工作类是一个“在有工作要做时通知 io_context 的类”。换句话说，只要 io_context 有一个与之关联的工作对象，它就永远不会无事可做。</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::<span class="function">io_context::work <span class="title">work</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Do you reckon this line displays?&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output: </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们不喜欢这种必须阻塞线程来工作的想法怎么办？我们将简单地模拟一个循环，调用io_context 的poll函数。poll 函数“运行 io_context 对象的事件处理循环来执行就绪的处理程序”</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">42</span>; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        io_context.<span class="built_in">poll</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Counter: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output: 我们将看到 42 行文本输出到控制台，然后程序退出</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当我们运行这个程序时，我们得到与之前完全相同的输出和结果。这是因为当有更多工作要做时，轮询函数不会阻塞。它只是执行当前的一组工作然后返回。在一个真实的程序中，循环将基于一些其他事件，但为了简单起见，我们只使用一个固定的事件。</p>
</li>
<li><p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::<span class="function">io_context::work <span class="title">work</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">42</span>; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        io_context.<span class="built_in">poll</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Counter: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们想要从 io_context 中删除一个工作对象怎么办？为了实现此功能，我们必须改用指向工作对象的指针。与 boost 库保持一致，我们将使用shared_ptr，一个智能指针类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;asio::io_context::work&gt; <span class="title">work</span><span class="params">(<span class="keyword">new</span> asio::io_context::work(io_context))</span></span>;</span><br><span class="line"></span><br><span class="line">    work.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Do you reckon this line displays?&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们运行该程序，我们将看到显示的文本行。这有效地向我们展示了如何从 io_service 中删除工作对象。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>现在我们知道如何用一个线程驱动 io_context ，我们需要弄清楚更多线程需要什么。io_context 文档页面告诉我们“多个线程可以调用 run() 函数来设置一个线程池，io_context 可以从中执行处理程序。池中等待的所有线程都是等效的，io_context 可以选择其中的任何一个他们调用处理程序。”</p>
</li>
</ul>
<h2 id="Asio-多线程"><a href="#Asio-多线程" class="headerlink" title="Asio 多线程"></a>Asio 多线程</h2><ul>
<li>在多线程的场景下，每个线程都持有一个 io_context ，并且每个线程都调用各自的 io_context 的run()方法。</li>
<li>全局只分配一个io_context ，并且让这个 io_context 在多个线程之间共享，每个线程都调用全局的 io_context 的run()方法</li>
</ul>
<h3 id="每个线程一个I-O-Context"><a href="#每个线程一个I-O-Context" class="headerlink" title="每个线程一个I&#x2F;O Context"></a>每个线程一个I&#x2F;O Context</h3><ul>
<li>特点：<ul>
<li>在多核的机器上，这种方案可以充分利用多个 CPU 核心。</li>
<li>某个 socket 描述符并不会在多个线程之间共享，所以不需要引入同步机制</li>
<li>在 event handler 中不能执行阻塞的操作，否则将会阻塞掉 io_context 所在的线程</li>
</ul>
</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsioIOContextPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> IOContext = asio::io_context;</span><br><span class="line">    <span class="keyword">using</span> Work = asio::io_context::work;</span><br><span class="line">    <span class="keyword">using</span> WorkPtr = std::unique_ptr&lt;Work&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前系统支持的并发线程数</span></span><br><span class="line">    <span class="built_in">AsioIOContextPool</span>(std::<span class="type">size_t</span> size = std::thread::<span class="built_in">hardware_concurrency</span>()) : </span><br><span class="line">        <span class="built_in">ioContexts_</span>(size), </span><br><span class="line">        <span class="built_in">works_</span>(size),</span><br><span class="line">        <span class="built_in">nextIOContext_</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            works_[i] = std::<span class="built_in">unique_ptr</span>&lt;Work&gt;(<span class="keyword">new</span> <span class="built_in">Work</span>(ioContexts_[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ioContexts_.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            threads_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, i]()&#123;</span><br><span class="line">                ioContexts_[i].<span class="built_in">run</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AsioIOContextPool</span>(<span class="type">const</span> AsioIOContextPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    AsioIOContextPool &amp;<span class="keyword">operator</span>=(<span class="type">const</span> AsioIOContextPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">asio::io_context&amp; <span class="title">getIOContext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;context = ioContexts_[nextIOContext_++];</span><br><span class="line">        <span class="keyword">if</span>(nextIOContext_ == ioContexts_.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            nextIOContext_ = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;work : works_)</span><br><span class="line">        &#123;</span><br><span class="line">            work.<span class="built_in">reset</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t : threads_)</span><br><span class="line">        &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;IOContext&gt; ioContexts_;</span><br><span class="line">    std::vector&lt;WorkPtr&gt; works_;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads_;</span><br><span class="line">    std::<span class="type">size_t</span> nextIOContext_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    AsioIOContextPool pool;</span><br><span class="line">    asio::steady_timer timer&#123;pool.<span class="built_in">getIOContext</span>(), std::chrono::seconds&#123;<span class="number">2</span>&#125;&#125;;</span><br><span class="line">    timer.<span class="built_in">async_wait</span>([&amp;mtx](<span class="type">const</span> asio::error_code &amp;ec)&#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    pool.<span class="built_in">stop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="一个I-O-Service与多个线程"><a href="#一个I-O-Service与多个线程" class="headerlink" title="一个I&#x2F;O Service与多个线程"></a>一个I&#x2F;O Service与多个线程</h3><ul>
<li><p>先分配一个全局 io_context，然后开启多个线程，每个线程都调用这个 io_context的run()方法。这样，当某个异步事件完成时，io_context 就会将相应的 event handler 交给任意一个线程去执行</p>
</li>
<li><p>然而这种方案在实际使用中，需要注意一些问题：</p>
<ul>
<li>在 event handler 中允许执行阻塞的操作 (例如数据库查询操作)。</li>
<li>线程数可以大于 CPU 核心数，譬如说，如果需要在 event handler 中执行阻塞的操作，为了提高程序的响应速度，这时就需要提高线程的数目</li>
<li>由于多个线程同时运行事件循环(event loop)，所以会导致一个问题：即一个 socket 描述符可能会在多个线程之间共享，容易出现竞态条件 (race condition)。譬如说，如果某个 socket 的可读事件很快发生了两次，那么就会出现两个线程同时读同一个 socket 的问题 (可以使用strand解决这个问题)。</li>
</ul>
</li>
<li><p>无锁的同步方式：</p>
<ul>
<li>Asio 提供了 io_context::strand：如果多个 event handler 通过同一个 strand 对象分发 (dispatch)，那么这些 event handler 就会保证顺序地执行。</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsioThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//返回当前系统支持的并发线程数</span></span><br><span class="line">    <span class="built_in">AsioThreadPool</span>(std::<span class="type">size_t</span> size = std::thread::<span class="built_in">hardware_concurrency</span>()) : </span><br><span class="line">        <span class="built_in">work_</span>(<span class="keyword">new</span> asio::io_context::<span class="built_in">work</span>(io_context_))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            threads_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>]()&#123;</span><br><span class="line">                io_context_.<span class="built_in">run</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AsioThreadPool</span>(<span class="type">const</span> AsioThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    AsioThreadPool &amp;<span class="keyword">operator</span>=(<span class="type">const</span> AsioThreadPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">asio::io_context&amp; <span class="title">getIOContext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> io_context_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        work_.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t : threads_)</span><br><span class="line">        &#123;</span><br><span class="line">            t.<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    asio::io_context io_context_;</span><br><span class="line">    std::unique_ptr&lt;asio::io_context::work&gt; work_;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">AsioThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;    <span class="comment">// 开启 4 个线程</span></span><br><span class="line">    asio::steady_timer timer1&#123;pool.<span class="built_in">getIOContext</span>(), std::chrono::seconds&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    asio::steady_timer timer2&#123;pool.<span class="built_in">getIOContext</span>(), std::chrono::seconds&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    asio::io_context::strand strand&#123;pool.<span class="built_in">getIOContext</span>()&#125;;</span><br><span class="line"></span><br><span class="line">    timer<span class="number">1.</span><span class="built_in">async_wait</span>(strand.<span class="built_in">wrap</span>([&amp;value] (<span class="type">const</span> asio::error_code &amp;ec)</span><br><span class="line">                              &#123;</span><br><span class="line">                                  std::cout &lt;&lt; <span class="string">&quot;Hello, World! &quot;</span> &lt;&lt; value++ &lt;&lt; std::endl;</span><br><span class="line">                              &#125;));</span><br><span class="line">    timer<span class="number">2.</span><span class="built_in">async_wait</span>(strand.<span class="built_in">wrap</span>([&amp;value] (<span class="type">const</span> asio::error_code &amp;ec)</span><br><span class="line">                              &#123;</span><br><span class="line">                                  std::cout &lt;&lt; <span class="string">&quot;Hello, World! &quot;</span> &lt;&lt; value++ &lt;&lt; std::endl;</span><br><span class="line">                              &#125;));</span><br><span class="line">    pool.<span class="built_in">stop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="socket连接相关的函数"><a href="#socket连接相关的函数" class="headerlink" title="socket连接相关的函数"></a>socket连接相关的函数</h2><h3 id="socket-初始化"><a href="#socket-初始化" class="headerlink" title="socket 初始化"></a>socket 初始化</h3><ul>
<li>context 提供 I&#x2F;O 执行程序的执行上下文，默认情况下，套接字将使用该执行程序为在套接字上执行的任何异步操作分派处理程序<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asio::io_context io_context;</span><br><span class="line">asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="socket-open"><a href="#socket-open" class="headerlink" title="socket.open"></a>socket.open</h3><ul>
<li>open 此函数打开套接字，以便它将使用指定的协议。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asio::io_context io_context;</span><br><span class="line">asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">socket.<span class="built_in">open</span>(asio::ip::tcp::<span class="built_in">v4</span>());</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="socket-bind"><a href="#socket-bind" class="headerlink" title="socket.bind"></a>socket.bind</h3><ul>
<li>将套接字绑定到给定的本地端点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asio::error_code ec;</span><br><span class="line">socket.<span class="built_in">bind</span>(asio::ip::tcp::<span class="built_in">endpoint</span>(</span><br><span class="line">        asio::ip::tcp::<span class="built_in">v4</span>(), <span class="number">12345</span>), ec);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="socket-close"><a href="#socket-close" class="headerlink" title="socket.close"></a>socket.close</h3><ul>
<li>该函数用于关闭套接字。任何异步发送、接收或连接操作都将立即取消，并以 asio::error::operation_aborted 错误完成</li>
<li>asio::system_error 失败时抛出。 请注意，即使函数指示错误，底层描述符也会关闭。</li>
<li>对于与正常关闭已连接套接字相关的可移植行为，请在关闭套接字之前调用 shutdown()。</li>
<li>ec 设置以指示发生了什么错误（如果有）。请注意，即使函数指示错误，底层描述符也会关闭。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asio::error_code ec;</span><br><span class="line">socket.<span class="built_in">close</span>(ec);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="socket-connect"><a href="#socket-connect" class="headerlink" title="socket.connect"></a>socket.connect</h3><ul>
<li>此函数用于将套接字连接到指定的远程端点。 函数调用将阻塞，直到连接成功或发生错误</li>
<li>如果套接字尚未打开，它会自动打开。 如果连接失败，套接字自动打开，则套接字不会返回到关闭状态。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">asio::io_context io_context;</span><br><span class="line">asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(asio::ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">12345</span>)</span></span>;</span><br><span class="line">socket.<span class="built_in">connect</span>(endpoint, ec);</span><br><span class="line"><span class="keyword">if</span>(!ec)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;socket connect&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="socket-async-connect"><a href="#socket-async-connect" class="headerlink" title="socket.async_connect"></a>socket.async_connect</h3><ul>
<li>此函数用于将套接字异步连接到指定的远程端点。 函数调用总是立即返回</li>
<li>如果套接字尚未打开，它会自动打开。 如果连接失败，套接字自动打开，则套接字不会返回到关闭状态</li>
<li>无论异步操作是否立即完成，都不会从此函数中调用处理程序。 立即完成后，处理程序的调用将以等同于使用 asio::post() 的方式执行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">connect_handler</span><span class="params">(<span class="type">const</span> asio::error_code&amp; ec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ec)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Connect success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(asio::ip::address::from_string(<span class="string">&quot;180.222.102.202&quot;</span>), <span class="number">80</span>)</span></span>;</span><br><span class="line">    socket.<span class="built_in">async_connect</span>(endpoint, connect_handler);</span><br><span class="line">    </span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="asio-connect"><a href="#asio-connect" class="headerlink" title="asio::connect"></a>asio::connect</h3><ul>
<li><p>connect 函数是一个组合操作，它通过按顺序尝试每个端点来建立套接字连接</p>
</li>
<li><p>此函数尝试将套接字连接到一系列端点之一。 它通过重复调用套接字的 connect 成员函数来完成此操作，对序列中的每个端点调用一次，直到成功建立连接</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::ip::<span class="function">tcp::resolver <span class="title">r</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::ip::tcp::<span class="function">resolver::query <span class="title">q</span><span class="params">(<span class="string">&quot;www.yahoo.com&quot;</span>, <span class="string">&quot;http&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::error_code ec;</span><br><span class="line">    asio::<span class="built_in">connect</span>(socket, r.<span class="built_in">resolve</span>(q), ec);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以下连接条件函数对象可用于输出有关各个连接尝试的信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_connect_condition</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> asio::error_code&amp; ec, <span class="type">const</span> asio::ip::tcp::endpoint&amp; next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ec) std::cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::ip::<span class="function">tcp::resolver <span class="title">r</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::ip::tcp::<span class="function">resolver::query <span class="title">q</span><span class="params">(<span class="string">&quot;www.yahoo.com&quot;</span>, <span class="string">&quot;http&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::ip::tcp::endpoint e = asio::<span class="built_in">connect</span>(socket, r.<span class="built_in">resolve</span>(q), <span class="built_in">my_connect_condition</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Connected to: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//Trying: 180.222.102.201:80</span></span><br><span class="line"><span class="comment">//Connected to: 180.222.102.201:80</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>或者:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在每次连接尝试之前调用的函数对象。 函数对象的签名必须是：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_connect_condition</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//ec 参数包含最近连接操作的结果。 在第一次连接尝试之前，ec 总是设置为指示成功。 </span></span><br><span class="line">    <span class="comment">//next 参数是要尝试的下一个端点。 如果应尝试下一个端点，则函数对象应返回 true，如果应跳过，则返回 false。</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> asio::error_code&amp; ec, <span class="type">const</span> asio::ip::tcp::endpoint&amp; next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ec) std::cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::ip::<span class="function">tcp::resolver <span class="title">r</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::ip::tcp::<span class="function">resolver::query <span class="title">q</span><span class="params">(<span class="string">&quot;www.yahoo.com&quot;</span>, <span class="string">&quot;http&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    asio::ip::tcp::resolver::results_type e = r.<span class="built_in">resolve</span>(q);</span><br><span class="line">    asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::error_code ec;</span><br><span class="line">    asio::ip::tcp::resolver::results_type::iterator i = </span><br><span class="line">        asio::<span class="built_in">connect</span>(socket, e.<span class="built_in">begin</span>(), e.<span class="built_in">end</span>(), <span class="built_in">my_connect_condition</span>(), ec);</span><br><span class="line">    <span class="keyword">if</span>(ec)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//发生错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Connected to: &quot;</span> &lt;&lt; i-&gt;<span class="built_in">endpoint</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="asio-async-connect"><a href="#asio-async-connect" class="headerlink" title="asio::async_connect"></a>asio::async_connect</h3><ul>
<li>async_connect 函数是一个组合的异步操作，它通过按顺序尝试每个端点来建立套接字连接。</li>
<li>此函数尝试将套接字连接到一系列端点之一。 它通过重复调用套接字的 async_connect 成员函数来完成此操作，对序列中的每个端点调用一次，直到成功建立连接<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//socket: 要连接的套接字。 如果套接字已经打开，它将被关闭。</span></span><br><span class="line"><span class="comment">//endpoints: 一系列端点。</span></span><br><span class="line"><span class="comment">//connect_handler: 连接操作完成时要调用的处理程序。</span></span><br><span class="line">asio::<span class="built_in">async_connect</span>(socket, results, connect_handler);</span><br></pre></td></tr></table></figure></li>
<li>示例:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">client</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">client</span>(asio::io_context&amp; io_context) : <span class="built_in">resolver_</span>(io_context), <span class="built_in">socket_</span>(io_context)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Connect</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handle_read_header</span><span class="params">(<span class="type">const</span> asio::error_code&amp; ec, asio::ip::tcp::resolver::results_type results)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">connect_handler</span><span class="params">(<span class="type">const</span> asio::error_code&amp; ec, <span class="type">const</span> asio::ip::tcp::endpoint&amp; endpoint)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    asio::ip::tcp::resolver resolver_;</span><br><span class="line">    asio::ip::tcp::socket socket_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client::Connect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// resolver_.async_resolve(&quot;www.yahoo.com&quot;, &quot;http&quot;, std::bind(&amp;client::handle_read_header, this,</span></span><br><span class="line">    <span class="comment">//                               std::placeholders::_1,</span></span><br><span class="line">    <span class="comment">//                               std::placeholders::_2));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不传入this Error: error C4573: “client::socket_”的用法要求编译器捕获“this”，但当前默认捕获模式不允许使用“this”</span></span><br><span class="line">    resolver_.<span class="built_in">async_resolve</span>(<span class="string">&quot;www.yahoo.com&quot;</span>, <span class="string">&quot;http&quot;</span>, [<span class="keyword">this</span>](<span class="type">const</span> asio::error_code&amp; ec, asio::ip::tcp::resolver::results_type results)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ec)</span><br><span class="line">        &#123;</span><br><span class="line">            asio::<span class="built_in">async_connect</span>(socket_, results, [](<span class="type">const</span> asio::error_code&amp; ec, <span class="type">const</span> asio::ip::tcp::endpoint&amp; endpoint)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ec)</span><br><span class="line">                &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client::handle_read_header</span><span class="params">(<span class="type">const</span> asio::error_code&amp; ec, asio::ip::tcp::resolver::results_type results)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ec)</span><br><span class="line">    &#123;</span><br><span class="line">        asio::<span class="built_in">async_connect</span>(socket_, results, std::<span class="built_in">bind</span>(&amp;client::connect_handler, <span class="keyword">this</span>,</span><br><span class="line">                                  std::placeholders::_1,</span><br><span class="line">                                  std::placeholders::_2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client::connect_handler</span><span class="params">(<span class="type">const</span> asio::error_code&amp; ec, <span class="type">const</span> asio::ip::tcp::endpoint&amp; endpoint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ec)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    <span class="function">client <span class="title">c</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    c.<span class="built_in">Connect</span>();</span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="asio-ip-tcp-endpoint"><a href="#asio-ip-tcp-endpoint" class="headerlink" title="asio::ip::tcp::endpoint"></a>asio::ip::tcp::endpoint</h3><ul>
<li><p>端点是使用某个端口连接到一个地址</p>
</li>
<li><p>创建方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(1) Default constructor</span></span><br><span class="line"><span class="built_in">basic_endpoint</span>() ASIO_NOEXCEPT : <span class="built_in">impl_</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2) 使用按主机字节顺序指定的端口号构造端点。IP地址将是任意地址（即INADDR_any或in6addr_any）。</span></span><br><span class="line"><span class="comment">//    此构造函数通常用于接受新连接。</span></span><br><span class="line"><span class="built_in">basic_endpoint</span>(<span class="type">const</span> InternetProtocol&amp; internet_protocol, <span class="type">unsigned</span> <span class="type">short</span> port_num) ASIO_NOEXCEPT</span><br><span class="line">: <span class="built_in">impl_</span>(internet_protocol.<span class="built_in">family</span>(), port_num) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3) 使用端口号和IP地址构造端点。此构造函数可用于接受特定接口上的连接或建立到远程端点的连接。</span></span><br><span class="line"><span class="built_in">basic_endpoint</span>(<span class="type">const</span> asio::ip::address&amp; addr, <span class="type">unsigned</span> <span class="type">short</span> port_num) ASIO_NOEXCEPT : <span class="built_in">impl_</span>(addr, port_num)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::<span class="function">tcp::endpoint <span class="title">ep</span><span class="params">(asio::ip::tcp::v4(), <span class="number">1234</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想连接一台主机,例如 “<a target="_blank" rel="noopener" href="http://www.yahoo.com/">http://www.yahoo.com</a>“</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::ip::<span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::ip::tcp::<span class="function">resolver::query <span class="title">query</span><span class="params">(<span class="string">&quot;www.yahoo.com&quot;</span>, <span class="string">&quot;80&quot;</span>)</span></span>;</span><br><span class="line">    asio::ip::tcp::resolver::iterator iter = resolver.<span class="built_in">resolve</span>(query);</span><br><span class="line">    asio::ip::tcp::endpoint ep = *iter;</span><br><span class="line">    std::cout &lt;&lt; ep.<span class="built_in">address</span>().<span class="built_in">to_string</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output: 180.222.102.202</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="asio-ip-tcp-acceptor"><a href="#asio-ip-tcp-acceptor" class="headerlink" title="asio::ip::tcp::acceptor"></a>asio::ip::tcp::acceptor</h3><ul>
<li><p>如果底层操作系统调用也是线程安全的，则同步接受操作是线程安全的。 这意味着允许对单个套接字对象执行同步接受操作的并发调用。 其他同步操作，如打开或关闭，不是线程安全的</p>
</li>
<li><p>打开一个启用了 SO_REUSEADDR 选项的套接字接收器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    asio::io_context io_context;</span><br><span class="line">    asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line">    asio::ip::<span class="function">tcp::endpoint <span class="title">endpoint</span><span class="params">(asio::ip::tcp::v4(), <span class="number">8888</span>)</span></span>;</span><br><span class="line">    <span class="comment">//此函数打开套接字接受器，以便它使用指定的协议。</span></span><br><span class="line">    acceptor.<span class="built_in">open</span>(endpoint.<span class="built_in">protocol</span>());</span><br><span class="line">    acceptor.<span class="built_in">set_option</span>(asio::ip::tcp::acceptor::<span class="built_in">reuse_address</span>(<span class="literal">true</span>));</span><br><span class="line">    <span class="comment">//将接受器绑定到给定的本地端点。</span></span><br><span class="line">    acceptor.<span class="built_in">bind</span>(endpoint);</span><br><span class="line">    asio::error_code ec;</span><br><span class="line">    <span class="comment">//max_listen_connections: 待处理连接队列的最大长度。</span></span><br><span class="line">    <span class="comment">//此函数将套接字接受器置于可以接受新连接的状态。</span></span><br><span class="line">    acceptor.<span class="built_in">listen</span>(asio::socket_base::max_listen_connections, ec);</span><br><span class="line">    <span class="keyword">if</span>(!ec)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;listen success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    io_context.<span class="built_in">run</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>asio::ip::tcp::acceptor::open()</p>
<ul>
<li>此函数打开套接字接受器，以便它使用指定的协议</li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::set_option()</p>
<ul>
<li>此函数用于在接受器上设置选项。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">acceptor.<span class="built_in">open</span>(endpoint.<span class="built_in">protocol</span>());</span><br><span class="line">acceptor.<span class="built_in">set_option</span>(asio::ip::tcp::acceptor::<span class="built_in">reuse_address</span>(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::get_option()</p>
<ul>
<li>此函数用于获取接受器上选项的当前值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::tcp::acceptor::reuse_address option;</span><br><span class="line">acceptor.<span class="built_in">get_option</span>(option);</span><br><span class="line"><span class="type">bool</span> is_set = option.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::bind()</p>
<ul>
<li>将接受器绑定到给定的本地端点。</li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::listen()</p>
<ul>
<li>max_listen_connections: 待处理连接队列的最大长度</li>
<li>此函数将套接字接受器置于可以接受新连接的状态</li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::close()</p>
<ul>
<li>此函数用于关闭接受器。 任何异步接受操作将立即取消<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asio::error_code ec;</span><br><span class="line">acceptor.<span class="built_in">close</span>(ec);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::cacel()</p>
<ul>
<li>此函数会导致所有未完成的异步连接、发送和接收操作立即完成，并且取消操作的处理程序将传递 asio::error::operation_aborted 错误</li>
</ul>
</li>
<li><p>asio::ip::tcp::socket::io_control()</p>
<ul>
<li>该函数用于在接收器上执行 IO 控制命令。</li>
<li>例如：获取准备读取的字节数：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::tcp::<span class="function">acceptor::non_blocking_io <span class="title">command</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">socket.<span class="built_in">io_control</span>(command);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::local_endpoint()</p>
<ul>
<li>此函数用于获取接受器的本地绑定端点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::ip::tcp::endpoint endpoint = acceptor.<span class="built_in">local_endpoint</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::wait()</p>
<ul>
<li>此函数用于执行阻塞等待，以等待接受器进入准备好读、写或错误条件状态。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acceptor.<span class="built_in">wait</span>(asio::ip::tcp::acceptor::wait_read);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::async_wait()</p>
<ul>
<li>此函数用于执行异步等待接受器进入准备好读取、写入或错误条件状态。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acceptor.<span class="built_in">async_wait</span>(</span><br><span class="line">    asio::ip::tcp::acceptor::wait_read,</span><br><span class="line">    wait_handler);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::accept()</p>
<ul>
<li>此函数用于接受从对等点到给定套接字的新连接。 函数调用将阻塞，直到成功接受新连接或发生错误。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asio::io_context io_context;</span><br><span class="line">asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">accept</span>(socket);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::acceptor::async_accept()</p>
<ul>
<li>此函数用于异步接受到套接字的新连接。 函数调用总是立即返回。</li>
<li>接受新连接的套接字。 对等对象的所有权由调用者保留，调用者必须保证在调用处理程序之前它是有效的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asio::io_context io_context;</span><br><span class="line">asio::ip::<span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context)</span></span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">asio::ip::<span class="function">tcp::socket <span class="title">socket</span><span class="params">(io_context)</span></span>;</span><br><span class="line">acceptor.<span class="built_in">async_accept</span>(socket, accept_handle);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::socket::async_read_some()</p>
<ul>
<li>开始异步读取。</li>
<li>此函数用于从流套接字中异步读取数据。</li>
<li>函数调用总是立即返回。</li>
<li>buffers： 一个或多个缓冲区，数据将被读入其中。</li>
<li>尽管可以根据需要复制缓冲区对象，但底层内存块的所有权由调用者保留，调用者必须保证它们在调用处理程序之前保持有效。</li>
<li>handler： 读取操作完成时要调用的处理程序。将根据需要制作处理程序的副本。的函数签名</li>
<li>无论异步操作是否立即完成，都不会从此函数中调用处理程序。立即完成后，处理程序的调用将以等同于使用 asio::post() 的方式执行。</li>
<li>读取操作可能无法读取所有请求的字节数。如果需要确保在异步操作完成之前读取请求的数据量，请考虑使用 async_read 函数。</li>
<li>要读入单个数据缓冲区，请使用缓冲区函数，如下所示：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="built_in">async_read_some</span>(asio::<span class="built_in">buffer</span>(data, size), handler);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::ip::tcp::socket::async_read()</p>
<ul>
<li>async_read 函数是一个组合的异步操作，它在完成之前从流中读取一定数量的数据。</li>
<li>启动异步操作以从流中读取一定数量的数据。</li>
<li>此函数用于从流中异步读取一定数量字节的数据。函数调用总是立即返回。异步操作将继续，直到以下条件之一为真：</li>
<li>此操作是根据对流的 async_read_some 函数的零次或多次调用来实现的，称为组合操作。程序必须确保流不执行其他读取操作（例如 async_read、流的 async_read_some 函数或任何其他执行读取的组合操作），直到此操作完成。</li>
<li>s： 要从中读取数据的流。该类型必须支持 AsyncReadStream 概念。</li>
<li>buffers： 一个或多个缓冲区，数据将被读入其中。缓冲区大小的总和表示要从流中读取的最大字节数。尽管可以根据需要复制缓冲区对象，但底层内存块的所有权由调用者保留，调用者必须保证它们在调用处理程序之前保持有效。</li>
<li>handler： 读取操作完成时要调用的处理程序。将根据需要制作处理程序的副本。的函数签名</li>
<li>无论异步操作是否立即完成，都不会从此函数中调用处理程序。立即完成后，处理程序的调用将以等同于使用 asio::post() 的方式执行。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::<span class="built_in">async_read</span>(s, asio::<span class="built_in">buffer</span>(data, size), handler);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>async_read_some 和 async_read 的区别</p>
<ul>
<li>asio::async_read 通常用户读取指定长度的数据，读完或出错才返回</li>
<li>socket.async_read_some读取到数据或出错就返回，不一定读完了整个包</li>
</ul>
</li>
<li><p>asio::ip::tcp::socket::async_write_some()</p>
<ul>
<li>此函数用于将数据异步写入流套接字。函数调用总是立即返回。</li>
<li>buffers 一个或多个要写入套接字的数据缓冲区。</li>
<li>尽管可以根据需要复制缓冲区对象，但底层内存块的所有权由调用者保留，调用者必须保证它们在调用处理程序之前保持有效。</li>
<li>handler 写入操作完成时要调用的处理程序。 将根据需要制作处理程序的副本。</li>
<li>无论异步操作是否立即完成，都不会从此函数中调用处理程序。 立即完成后，处理程序的调用将以等同于使用 asio::post() 的方式执行。</li>
<li>写操作可能不会将所有数据传输到对等方。</li>
<li>如果需要确保在异步操作完成之前写入所有数据，请考虑使用 async_write 函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="built_in">async_write_some</span>(asio::<span class="built_in">buffer</span>(data, size), handler);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>asio::async_write()</p>
<ul>
<li>此函数用于将一定数量的字节数据异步写入流。函数调用总是立即返回。异步操作将继续，直到以下条件之一为真：</li>
<li>提供的缓冲区中的所有数据都已写入。也就是说，传输的字节数等于缓冲区大小的总和。</li>
<li>此操作是根据对流的 async_write_some 函数的零次或多次调用来实现的，称为组合操作。程序必须确保流不执行其他写入操作（例如 async_write、流的 async_write_some 函数或任何其他执行写入的组合操作），直到此操作完成。</li>
<li>s 要写入数据的流。该类型必须支持 AsyncWriteStream 概念。</li>
<li>buffers 一个或多个包含要写入的数据的缓冲区。</li>
<li>尽管可以根据需要复制缓冲区对象，但底层内存块的所有权由调用者保留，调用者必须保证它们在调用处理程序之前保持有效。</li>
<li>param handler 写入操作完成时要调用的处理程序。</li>
<li>将根据需要制作处理程序的副本。</li>
<li>无论异步操作是否立即完成，都不会从此函数中调用处理程序。立即完成后，处理程序的调用将以等同于使用 asio::post() 的方式执行<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asio::<span class="built_in">async_write</span>(s, asio::<span class="built_in">buffer</span>(data, size), handler);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><ul>
<li>asio在处理I&#x2F;O操作时支持两种类型的buffer<ul>
<li>asio::buffer</li>
<li>asio::streambuffer</li>
</ul>
</li>
</ul>
<h3 id="asio-buffer"><a href="#asio-buffer" class="headerlink" title="asio::buffer"></a>asio::buffer</h3><ul>
<li>asio::buffer 函数用于创建一个缓冲区对象来表示原始内存、POD 元素数组、POD 元素向量或 std::string</li>
<li>缓冲区对象将连续的内存区域表示为由指针和字节大小组成的二元组。{void*, size_t} 形式的元组指定内存的可变（可修改）区域。 类似地，{const void*, size_t} 形式的元组指定一个常量（不可修改的）内存区域。 这两种形式分别对应类mutable_buffer和const_buffer。 为了反映 C++ 的转换规则，mutable_buffer 可以隐式转换为 const_buffer，并且不允许进行相反的转换<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sock.<span class="built_in">send</span>(asio::<span class="built_in">buffer</span>(data, size));</span><br></pre></td></tr></table></figure></li>
<li>在上面的例子中，asio::buffer 的返回值满足了ConstBufferSequence 概念的要求，可以直接传递给socket 的write 函数。 为可修改内存创建的缓冲区也符合 MutableBufferSequence 概念的要求</li>
<li>可以从 POD 元素的内置数组、std::vector、std::array 或 boost::array 创建一个单独的缓冲区。 这有助于通过自动确定缓冲区的大小来防止缓冲区溢出<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> d1[<span class="number">128</span>];</span><br><span class="line"><span class="type">size_t</span> bytes_transferred = sock.<span class="built_in">receive</span>(asio::<span class="built_in">buffer</span>(d1));</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">128</span>)</span></span>;</span><br><span class="line">bytes_transferred = sock.<span class="built_in">receive</span>(asio::<span class="built_in">buffer</span>(d2));</span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="type">char</span>, 128&gt; d3;</span><br><span class="line">bytes_transferred = sock.<span class="built_in">receive</span>(asio::<span class="built_in">buffer</span>(d3));</span><br></pre></td></tr></table></figure></li>
<li>在上述所有三种情况下，创建的缓冲区恰好为 128 字节长。 请注意，在创建或使用缓冲区时，向量永远不会自动调整大小。 缓冲区大小是使用向量的 size() 成员函数确定的，而不是其容量</li>
<li>可以使用 data() 和 size() 成员函数访问缓冲区的内容：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过 std::string 构造 asio::buffer</span></span><br><span class="line">    std::string str = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    asio::const_buffer const_buffer = asio::<span class="built_in">buffer</span>(str.<span class="built_in">data</span>(), str.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    std::<span class="type">size_t</span> s1 = const_buffer.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>* p1 = const_buffer.<span class="built_in">data</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s1: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot; p1: &quot;</span> &lt;&lt; p1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//output: s1: 4 p1: 000000D5A6B0F510</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过std::array构造asio::buffer</span></span><br><span class="line">    std::array&lt;<span class="type">char</span>, 5&gt; arrData = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    asio::mutable_buffer mutable_buffer = asio::<span class="built_in">buffer</span>(arrData.<span class="built_in">data</span>(), arrData.<span class="built_in">size</span>());</span><br><span class="line">    std::<span class="type">size_t</span> s2 = mutable_buffer.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p2 = <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>*&gt;(mutable_buffer.<span class="built_in">data</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s2: &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&quot; p2: &quot;</span> &lt;&lt; p2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//output: s2: 5 p2: test</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过std::vector构造asio::buffer</span></span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; vecData = &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    asio::mutable_buffer v_buffer = asio::<span class="built_in">buffer</span>(vecData.<span class="built_in">data</span>(), vecData.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    std::<span class="type">size_t</span> s3 = asio::<span class="built_in">buffer_size</span>(v_buffer);</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>* p3 = asio::<span class="built_in">buffer_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(v_buffer);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s3: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="string">&quot; p3: &quot;</span> &lt;&lt; p3 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//output: s3: 5 p3: 000001F890A53410</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="asio-streambuf"><a href="#asio-streambuf" class="headerlink" title="asio::streambuf"></a>asio::streambuf</h3><ul>
<li>基于 std::streambuf 的可自动调整大小的缓冲区类</li>
<li>basic_streambuf 类派生自 std::streambuf 以将 streambuf 的输入和输出序列与一个或多个字符数组相关联。 这些字符数组在 basic_streambuf 对象内部，但提供了对数组元素的直接访问，以允许它们在 I&#x2F;O 操作中有效使用。 写入 basic_streambuf 对象的输出序列的字符将附加到同一对象的输入序列</li>
</ul>
<h3 id="asio-buffer-获取缓冲区大小并防止缓冲区溢出"><a href="#asio-buffer-获取缓冲区大小并防止缓冲区溢出" class="headerlink" title="asio::buffer 获取缓冲区大小并防止缓冲区溢出"></a>asio::buffer 获取缓冲区大小并防止缓冲区溢出</h3><ul>
<li><p>Asio 使用 Buffer 类来表示缓冲区。这些类提供抽象并保护 Asio 操作免受缓冲区溢出。尽管将结果asio::buffer()传递给操作，但不会传输原数据，例如缓冲区的大小或其基础类型。此外，这些缓冲区不拥有内存，因此应用程序有责任确保底层内存在缓冲区抽象的整个生命周期内保持有效</p>
</li>
<li><p>该 asio::buffer() 函数提供了一种创建缓冲区类的便捷方法，其中缓冲区的大小是从可能的类型中推导出来的。当 Asio 能够推导出缓冲区长度时，Asio 操作在使用结果缓冲区类型时不会引发缓冲区溢出。但是，如果应用程序代码将缓冲区的大小指定为 asio::buffer()，则应用程序有责任确保该大小不大于底层内存</p>
</li>
<li><p>读取数据时，需要缓冲区。如果 Asio 不传输大小，那么根本问题就变成了如何知道要分配多少内存。这个问题有几个解决方案</p>
<ul>
<li>通过查询套接字有多少数据可用 socket::available()，然后相应地分配缓冲区<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">data</span><span class="params">(socket_.available())</span></span>;</span><br><span class="line">asio::<span class="built_in">read</span>(socket_, asio::<span class="built_in">buffer</span>(data));</span><br></pre></td></tr></table></figure></li>
<li>使用Asio可用内存中增长的类，如 asio::streambuf。一些操作，比如asio::read()接受streambuf对象作为它们的缓冲区，并将根据操作的需要分配内存。但是应提供完成条件；否则操作将继续，直到缓冲区已满<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asio::streambuf data; </span><br><span class="line">asio::<span class="built_in">read</span>(socket_, data, asio::<span class="built_in">transfer_at_least</span>(socket_.<span class="built_in">avaliable</span>()));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在固定大小的协议中，数据生产者和消费者都使用相同大小的消息。由于读者知道消息的大小，读者可以预先分配一个缓冲区</p>
</li>
<li><p>在可变长度协议中，消息通常分为两部分：头部和主体。标头通常是固定大小的，并且可以包含各种元信息，例如正文的长度。这允许读取器将标头读入固定大小的缓冲区，提取正文长度，为正文分配缓冲区，然后读取正文。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read fixed header.</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">data</span><span class="params">(fixed_header_size)</span></span>;</span><br><span class="line">boost::asio::<span class="built_in">read</span>(socket_, boost::asio::<span class="built_in">buffer</span>(data));</span><br><span class="line"></span><br><span class="line"><span class="function">protocol::header <span class="title">header</span><span class="params">(data)</span></span>;</span><br><span class="line"><span class="built_in">network_to_local</span>(header); <span class="comment">// Handle endianess.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read body.</span></span><br><span class="line">data.<span class="built_in">resize</span>(header.<span class="built_in">body_length</span>());</span><br><span class="line">boost::asio::<span class="built_in">read</span>(socket_, boost::asio::<span class="built_in">buffer</span>(data));  </span><br><span class="line"></span><br><span class="line"><span class="function">protocol::body <span class="title">body</span><span class="params">(data)</span></span>;</span><br><span class="line"><span class="built_in">network_to_local</span>(body); <span class="comment">// Handle endianess.</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="mutable-buffer"><a href="#mutable-buffer" class="headerlink" title="mutable_buffer"></a>mutable_buffer</h3><ul>
<li>mutable_buffer 类提供了可以修改的缓冲区的安全表示。 它不拥有底层数据，因此复制或分配的成本很低</li>
<li>示例:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span> <span class="comment">// std::array</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::bind</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout, std::endl</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">noop</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> protocol &#123;</span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">  header_size = <span class="built_in">sizeof</span>(std::<span class="type">size_t</span>)</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace protocol</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">build_header</span><span class="params">(<span class="type">const</span> std::string&amp; body)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buffer</span><span class="params">(protocol::header_size)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> body_size = body.<span class="built_in">size</span>();</span><br><span class="line">  std::<span class="built_in">memcpy</span>(&amp;buffer[<span class="number">0</span>], &amp;body_size, <span class="keyword">sizeof</span> body_size);</span><br><span class="line">  <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">parse_header</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt;&amp; buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> std::<span class="type">size_t</span>*&gt;(&amp;buffer[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> asio::ip::tcp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create all I/O objects.</span></span><br><span class="line">  asio::io_context io_context;</span><br><span class="line">  <span class="function">tcp::acceptor <span class="title">acceptor</span><span class="params">(io_context, tcp::endpoint(asio::ip::address::from_string(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">1234</span>))</span></span>;</span><br><span class="line">  <span class="function">tcp::socket <span class="title">socket1</span><span class="params">(io_context)</span></span>;</span><br><span class="line">  <span class="function">tcp::socket <span class="title">socket2</span><span class="params">(io_context)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Connect the sockets.</span></span><br><span class="line">  acceptor.<span class="built_in">async_accept</span>(socket1, std::<span class="built_in">bind</span>(&amp;noop, <span class="string">&quot;accept&quot;</span>));</span><br><span class="line">  socket<span class="number">2.</span><span class="built_in">async_connect</span>(acceptor.<span class="built_in">local_endpoint</span>(), std::<span class="built_in">bind</span>(&amp;noop, <span class="string">&quot;connect&quot;</span>));</span><br><span class="line">  </span><br><span class="line">  io_context.<span class="built_in">run</span>();</span><br><span class="line">  io_context.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Write a message from socket1 to socket2.</span></span><br><span class="line">  std::string test_message = <span class="string">&quot;this is a test message&quot;</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> header = <span class="built_in">build_header</span>(test_message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gather header and body into a single buffer.</span></span><br><span class="line">    std::array&lt;asio::const_buffer, 2&gt; buffers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write header and body to socket.</span></span><br><span class="line">    std::cout &lt;&lt; socket<span class="number">1.</span><span class="built_in">is_open</span>() &lt;&lt; std::endl;</span><br><span class="line">    asio::<span class="built_in">write</span>(socket1, buffers);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read from socket2.</span></span><br><span class="line">  &#123;  </span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read header.</span></span><br><span class="line">    buffer.<span class="built_in">resize</span>(protocol::header_size);</span><br><span class="line">    asio::<span class="built_in">read</span>(socket2, asio::<span class="built_in">buffer</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extract body size from header, resize buffer, then read body.</span></span><br><span class="line">    <span class="keyword">auto</span> body_size = <span class="built_in">parse_header</span>(buffer);</span><br><span class="line">    buffer.<span class="built_in">resize</span>(body_size);</span><br><span class="line">    asio::<span class="built_in">read</span>(socket2, asio::<span class="built_in">buffer</span>(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify body was read.</span></span><br><span class="line">    <span class="built_in">assert</span>(std::<span class="built_in">equal</span>(<span class="built_in">begin</span>(buffer), <span class="built_in">end</span>(buffer), </span><br><span class="line">                      <span class="built_in">begin</span>(test_message)));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;received: \n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  header: &quot;</span> &lt;&lt; body_size &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  body: &quot;</span>;</span><br><span class="line">    std::cout.<span class="built_in">write</span>(&amp;buffer[<span class="number">0</span>], buffer.<span class="built_in">size</span>());</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div>感谢老板支持！敬礼(^^ゞ</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="zhang junyi WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="zhang junyi Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/boost-asio/" rel="tag"># boost.asio</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/22/notebook/BOOST/asio/2024-05-22-1_2_asio_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" rel="prev" title="1_2_asio_理论基础">
      <i class="fa fa-chevron-left"></i> 1_2_asio_理论基础
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/05/22/notebook/BOOST/asio/2024-05-22-1_2_asio_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" rel="next" title="1_2_asio_常用函数">
      1_2_asio_常用函数 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io-context"><span class="nav-number">3.</span> <span class="nav-text">io_context</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">3.1.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91io-context-%E6%8F%90%E4%BA%A4%E4%BB%BB%E6%84%8F%E4%BB%BB%E5%8A%A1"><span class="nav-number">3.2.</span> <span class="nav-text">向io_context 提交任意任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E6%AD%A2-io-context-%E8%80%97%E5%B0%BD%E5%B7%A5%E4%BD%9C"><span class="nav-number">3.3.</span> <span class="nav-text">阻止 io_context 耗尽工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io-context-run"><span class="nav-number">3.4.</span> <span class="nav-text">io_context.run()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Asio-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">Asio 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%80%E4%B8%AAI-O-Context"><span class="nav-number">4.1.</span> <span class="nav-text">每个线程一个I&#x2F;O Context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AAI-O-Service%E4%B8%8E%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">一个I&#x2F;O Service与多个线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket%E8%BF%9E%E6%8E%A5%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">socket连接相关的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.1.</span> <span class="nav-text">socket 初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-open"><span class="nav-number">5.2.</span> <span class="nav-text">socket.open</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-bind"><span class="nav-number">5.3.</span> <span class="nav-text">socket.bind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-close"><span class="nav-number">5.4.</span> <span class="nav-text">socket.close</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-connect"><span class="nav-number">5.5.</span> <span class="nav-text">socket.connect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket-async-connect"><span class="nav-number">5.6.</span> <span class="nav-text">socket.async_connect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#asio-connect"><span class="nav-number">5.7.</span> <span class="nav-text">asio::connect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#asio-async-connect"><span class="nav-number">5.8.</span> <span class="nav-text">asio::async_connect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#asio-ip-tcp-endpoint"><span class="nav-number">5.9.</span> <span class="nav-text">asio::ip::tcp::endpoint</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#asio-ip-tcp-acceptor"><span class="nav-number">5.10.</span> <span class="nav-text">asio::ip::tcp::acceptor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer"><span class="nav-number">6.</span> <span class="nav-text">Buffer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#asio-buffer"><span class="nav-number">6.1.</span> <span class="nav-text">asio::buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#asio-streambuf"><span class="nav-number">6.2.</span> <span class="nav-text">asio::streambuf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#asio-buffer-%E8%8E%B7%E5%8F%96%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%E5%B9%B6%E9%98%B2%E6%AD%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="nav-number">6.3.</span> <span class="nav-text">asio::buffer 获取缓冲区大小并防止缓冲区溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mutable-buffer"><span class="nav-number">6.4.</span> <span class="nav-text">mutable_buffer</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
