<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="简介 C&#x2F;C++常用的编程技巧">
<meta property="og:type" content="article">
<meta property="og:title" content="C++_06_2_编程技巧">
<meta property="og:url" content="https://junyiha.github.io/2024/05/22/notebook/C++/C++_06_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-C++_06_2_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="简介 C&#x2F;C++常用的编程技巧">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-05-22T01:00:00.000Z">
<meta property="article:modified_time" content="2025-04-28T08:08:39.174Z">
<meta property="article:author" content="zhang junyi">
<meta property="article:tag" content="CppTechnique">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_06_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-C++_06_2_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>C++_06_2_编程技巧 | junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_06_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-C++_06_2_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++_06_2_编程技巧
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C&#x2F;C++常用的编程技巧</li>
</ul>
<span id="more"></span>

<h2 id="C-将uchar数组转为字符串"><a href="#C-将uchar数组转为字符串" class="headerlink" title="C++ 将uchar数组转为字符串"></a>C++ 将uchar数组转为字符串</h2><p>要将 <code>std::vector&lt;uchar&gt;</code>（或者 <code>uchar[]</code> 数组）转换为字符串，您可以使用字符串流 <code>std::stringstream</code> 或者直接操作字符数组的方法。下面是这两种方法的示例代码：</p>
<p>使用字符串流 <code>std::stringstream</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; buffer = &#123;<span class="number">0x48</span>, <span class="number">0x65</span>, <span class="number">0x6C</span>, <span class="number">0x6C</span>, <span class="number">0x6F</span>&#125;; <span class="comment">// 示例uchar数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用字符串流</span></span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">char</span> byte : buffer) &#123;</span><br><span class="line">        ss &lt;&lt; byte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string result = ss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result using stringstream: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接操作字符数组的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; buffer = &#123;<span class="number">0x48</span>, <span class="number">0x65</span>, <span class="number">0x6C</span>, <span class="number">0x6C</span>, <span class="number">0x6F</span>&#125;; <span class="comment">// 示例uchar数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接操作字符数组</span></span><br><span class="line">    <span class="function">std::string <span class="title">result</span><span class="params">(buffer.begin(), buffer.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result using direct manipulation: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方法都会将 <code>buffer</code> 中的数据转换为字符串 <code>result</code>。您可以根据您的偏好选择其中之一来实现。</p>
<h2 id="C-父类调用子类的成员函数"><a href="#C-父类调用子类的成员函数" class="headerlink" title="C++ 父类调用子类的成员函数"></a>C++ 父类调用子类的成员函数</h2><p>在 C++ 中，父类无法直接调用子类的成员函数。通常情况下，父类对子类的行为是无知的，这是遵循了面向对象编程的封装原则。</p>
<p>但是，如果你有一个父类指针或引用指向一个子类对象，并且子类对象中有重写（override）了父类的成员函数，那么通过这个指针或引用调用的成员函数将会是子类中的版本，这被称为多态性。这是 C++ 中实现运行时多态的一种方式。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived::foo()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">// 父类指针指向子类对象</span></span><br><span class="line">    basePtr-&gt;<span class="built_in">foo</span>(); <span class="comment">// 调用子类的成员函数</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>Base</code> 类有一个虚拟函数 <code>foo()</code>，<code>Derived</code> 类重写了这个函数。在 <code>main()</code> 函数中，<code>basePtr</code> 是一个指向 <code>Base</code> 类的指针，但它指向一个 <code>Derived</code> 类的对象。当调用 <code>basePtr-&gt;foo()</code> 时，实际上调用的是 <code>Derived</code> 类中的 <code>foo()</code> 函数，因为它已经被重写了。</p>
<h2 id="C-子类对象调用父类函数"><a href="#C-子类对象调用父类函数" class="headerlink" title="C++ 子类对象调用父类函数"></a>C++ 子类对象调用父类函数</h2><p>在C++中，子类对象可以调用父类函数。这是通过继承来实现的。假设有一个父类<code>Parent</code>和一个子类<code>Child</code>，<code>Child</code>是<code>Parent</code>的派生类。如果<code>Child</code>想要调用<code>Parent</code>的函数，可以使用以下方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">parentFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is the parent function.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">childFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is the child function.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">callParentFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">parentFunction</span>(); <span class="comment">// 调用父类函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Child childObj;</span><br><span class="line">    childObj.<span class="built_in">callParentFunction</span>(); <span class="comment">// 调用子类对象的函数，间接调用父类函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Child</code>类继承了<code>Parent</code>类。<code>Child</code>类中的<code>callParentFunction</code>函数通过<code>parentFunction()</code>直接调用了父类<code>Parent</code>的函数。在<code>main()</code>函数中，创建了<code>Child</code>类的对象<code>childObj</code>，然后通过<code>childObj.callParentFunction()</code>来调用子类的函数，间接地调用了父类的函数。</p>
<h2 id="C-linux-获取硬盘序列号"><a href="#C-linux-获取硬盘序列号" class="headerlink" title="C++ linux 获取硬盘序列号"></a>C++ linux 获取硬盘序列号</h2><p>在Linux系统上，获取硬盘序列号通常需要依赖于特定的命令行工具或文件。一个常用的方法是使用<code>udevadm</code>工具来获取硬盘的序列号。下面是一个示例代码，演示如何使用C++调用<code>udevadm</code>命令获取硬盘序列号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute a shell command and return the output as a string</span></span><br><span class="line"><span class="function">std::string <span class="title">exec</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cmd)</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">char</span>, 128&gt; buffer;</span><br><span class="line">    std::string result;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;FILE, <span class="title">decltype</span><span class="params">(&amp;pclose)</span>&gt; <span class="title">pipe</span><span class="params">(popen(cmd, <span class="string">&quot;r&quot;</span>), pclose)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!pipe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;popen() failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(buffer.<span class="built_in">data</span>(), buffer.<span class="built_in">size</span>(), pipe.<span class="built_in">get</span>()) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        result += buffer.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get disk serial number by executing udevadm command</span></span><br><span class="line"><span class="function">std::string <span class="title">GetDiskSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::string output = <span class="built_in">exec</span>(<span class="string">&quot;udevadm info --query=all --name=/dev/sda | grep ID_SERIAL_SHORT&quot;</span>);</span><br><span class="line">        <span class="function">std::regex <span class="title">regex</span><span class="params">(<span class="string">&quot;\\bID_SERIAL_SHORT=(.*)\\b&quot;</span>)</span></span>;</span><br><span class="line">        std::smatch match;</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(output, match, regex) &amp;&amp; match.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> match.<span class="built_in">str</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string serialNumber = <span class="built_in">GetDiskSerialNumber</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Disk Serial Number: &quot;</span> &lt;&lt; serialNumber &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>exec</code>函数用于执行shell命令并返回输出。<code>GetDiskSerialNumber</code>函数调用<code>udevadm</code>命令来获取硬盘的序列号，然后使用正则表达式来提取序列号信息。请确保你的系统上已经安装了<code>udevadm</code>命令，否则这段代码将无法工作。</p>
<p>值得注意的是，硬盘序列号的获取方法可能因不同的Linux发行版或系统配置而有所不同。因此，你可能需要根据具体情况进行调整。</p>
<h2 id="linux-CPU-ID查询"><a href="#linux-CPU-ID查询" class="headerlink" title="linux CPU ID查询"></a>linux CPU ID查询</h2><p>在Linux系统上，要获取CPU ID通常需要从CPU信息文件中读取信息。在大多数系统中，这些信息位于<code>/proc/cpuinfo</code>文件中。CPU ID在这个文件中通常以<code>cpu_id</code>或<code>processor</code>字段的形式出现。</p>
<p>下面是一个示例代码，演示如何使用C++读取<code>/proc/cpuinfo</code>文件来获取CPU ID：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to read CPU IDs from /proc/cpuinfo</span></span><br><span class="line"><span class="function">std::unordered_set&lt;std::string&gt; <span class="title">GetCPUIDs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_set&lt;std::string&gt; cpuIDs;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">cpuinfoFile</span><span class="params">(<span class="string">&quot;/proc/cpuinfo&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (cpuinfoFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::string line;</span><br><span class="line">        <span class="function">std::regex <span class="title">idRegex</span><span class="params">(<span class="string">&quot;^processor\\s*:\\s*(\\d+)&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">getline</span>(cpuinfoFile, line)) &#123;</span><br><span class="line">            std::smatch match;</span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(line, match, idRegex) &amp;&amp; match.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                cpuIDs.<span class="built_in">insert</span>(match.<span class="built_in">str</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cpuinfoFile.<span class="built_in">close</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open /proc/cpuinfo&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cpuIDs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unordered_set&lt;std::string&gt; cpuIDs = <span class="built_in">GetCPUIDs</span>();</span><br><span class="line">    <span class="keyword">if</span> (!cpuIDs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;CPU IDs:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> std::string&amp; id : cpuIDs) &#123;</span><br><span class="line">            std::cout &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;No CPU IDs found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例代码打开<code>/proc/cpuinfo</code>文件并按行读取其中的内容。使用正则表达式匹配每一行，找到<code>processor</code>字段，然后提取其值作为CPU ID。CPU ID通常是一个数字，它表示CPU的逻辑核心。因此，这个示例代码将CPU ID存储在一个无序集合中，以确保每个CPU ID只出现一次。</p>
<p>请注意，这个示例代码假设<code>/proc/cpuinfo</code>文件的格式在不同的Linux系统中是相同的。如果你的系统上的文件格式与预期不同，你可能需要根据实际情况调整正则表达式以确保正确提取CPU ID。</p>
<h2 id="linux-主板序列号查询"><a href="#linux-主板序列号查询" class="headerlink" title="linux 主板序列号查询"></a>linux 主板序列号查询</h2><p>在Linux系统上，获取主板序列号的方法因系统和硬件而异。一种常见的方法是通过<code>dmidecode</code>命令来获取系统信息，包括主板信息。<code>dmidecode</code>命令可以解析DMI（Desktop Management Interface）信息，其中包含了主板的序列号等信息。</p>
<p>以下是一个示例代码，演示如何使用C++调用<code>dmidecode</code>命令来获取主板序列号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute a shell command and return the output as a string</span></span><br><span class="line"><span class="function">std::string <span class="title">exec</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cmd)</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">char</span>, 128&gt; buffer;</span><br><span class="line">    std::string result;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;FILE, <span class="title">decltype</span><span class="params">(&amp;pclose)</span>&gt; <span class="title">pipe</span><span class="params">(popen(cmd, <span class="string">&quot;r&quot;</span>), pclose)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!pipe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;popen() failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fgets</span>(buffer.<span class="built_in">data</span>(), buffer.<span class="built_in">size</span>(), pipe.<span class="built_in">get</span>()) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        result += buffer.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get motherboard serial number by executing dmidecode command</span></span><br><span class="line"><span class="function">std::string <span class="title">GetMotherboardSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::string output = <span class="built_in">exec</span>(<span class="string">&quot;dmidecode -t baseboard | grep &#x27;Serial Number&#x27;&quot;</span>);</span><br><span class="line">        <span class="function">std::regex <span class="title">regex</span><span class="params">(<span class="string">&quot;\\bSerial Number:\\s*(.*)\\b&quot;</span>)</span></span>;</span><br><span class="line">        std::smatch match;</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(output, match, regex) &amp;&amp; match.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> match.<span class="built_in">str</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string serialNumber = <span class="built_in">GetMotherboardSerialNumber</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Motherboard Serial Number: &quot;</span> &lt;&lt; serialNumber &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>exec</code>函数用于执行shell命令并返回输出。<code>GetMotherboardSerialNumber</code>函数调用<code>dmidecode</code>命令来获取主板的序列号，并使用正则表达式来提取序列号信息。请确保你的系统上已经安装了<code>dmidecode</code>命令，否则这段代码将无法工作。</p>
<p>需要注意的是，主板序列号的获取方法可能因不同的Linux发行版或系统配置而有所不同。因此，你可能需要根据具体情况进行调整。</p>
<h2 id="linux-操作系统生成的UUID"><a href="#linux-操作系统生成的UUID" class="headerlink" title="linux 操作系统生成的UUID"></a>linux 操作系统生成的UUID</h2><p>Linux操作系统通常会为每个安装的系统生成一个唯一的UUID（通用唯一标识符）。这个UUID通常存储在<code>/etc/machine-id</code>文件中。你可以通过读取这个文件来获取操作系统生成的UUID。</p>
<p>以下是一个示例代码，演示如何使用C++读取<code>/etc/machine-id</code>文件来获取操作系统生成的UUID：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to read UUID from /etc/machine-id</span></span><br><span class="line"><span class="function">std::string <span class="title">GetOSUUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">machineIdFile</span><span class="params">(<span class="string">&quot;/etc/machine-id&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!machineIdFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to open /etc/machine-id&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string uuid;</span><br><span class="line">    std::<span class="built_in">getline</span>(machineIdFile, uuid);</span><br><span class="line">    machineIdFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uuid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string osUUID = <span class="built_in">GetOSUUID</span>();</span><br><span class="line">    <span class="keyword">if</span> (osUUID != <span class="string">&quot;Error&quot;</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Operating System UUID: &quot;</span> &lt;&lt; osUUID &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to get Operating System UUID.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>GetOSUUID</code>函数用于读取<code>/etc/machine-id</code>文件并返回其中的UUID。如果文件不存在或读取失败，函数将返回字符串”Error”。</p>
<p>请注意，UUID的格式通常是一串32位的十六进制字符，可能带有连字符（破折号）。</p>
<h2 id="C-获取机器标识的方法"><a href="#C-获取机器标识的方法" class="headerlink" title="C++ 获取机器标识的方法"></a>C++ 获取机器标识的方法</h2><p>获取机器标识通常意味着获取一些唯一的硬件信息，以便能够在不同的机器之间进行区分。以下是一些常见的获取机器标识的方法：</p>
<ol>
<li><p><strong>MAC 地址</strong>：每个网络适配器（网卡）都有一个唯一的 MAC 地址，可以用来区分不同的机器。</p>
</li>
<li><p><strong>硬盘序列号</strong>：硬盘通常都有一个唯一的序列号。</p>
</li>
<li><p><strong>CPU ID</strong>：处理器也有一个唯一的标识符。</p>
</li>
<li><p><strong>主板序列号</strong>：主板上可能有一个唯一的序列号或者标识符。</p>
</li>
<li><p><strong>操作系统生成的 UUID</strong>：一些操作系统会为每台机器生成一个唯一的 UUID。</p>
</li>
</ol>
<p>下面是一个示例代码，演示如何获取 MAC 地址作为机器标识：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">GetMACAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;/sys/class/net/eth0/address&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to open MAC address file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::stringstream buffer;</span><br><span class="line">    buffer &lt;&lt; file.<span class="built_in">rdbuf</span>();</span><br><span class="line">    std::string macAddress = buffer.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove newline characters if present</span></span><br><span class="line">    macAddress.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(macAddress.<span class="built_in">begin</span>(), macAddress.<span class="built_in">end</span>(), <span class="string">&#x27;\n&#x27;</span>), macAddress.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> macAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::string macAddress = <span class="built_in">GetMACAddress</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MAC Address: &quot;</span> &lt;&lt; macAddress &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// You can use this MAC address as the machine identifier</span></span><br><span class="line">        <span class="comment">// Be sure to handle exceptions if the MAC address retrieval fails</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例代码假设了网卡的设备名称为eth0，并尝试从 <code>/sys/class/net/eth0/address</code> 文件中读取 MAC 地址。你可以根据需要修改设备名称或者尝试其他途径获取 MAC 地址，比如通过系统调用来获取网络接口信息。</p>
<h2 id="C-生成唯一且固定的标识"><a href="#C-生成唯一且固定的标识" class="headerlink" title="C++ 生成唯一且固定的标识"></a>C++ 生成唯一且固定的标识</h2><p>要在C++中生成唯一且固定的标识，你可以结合多种因素来生成唯一性，比如系统时间、硬件信息、随机数等。以下是一个简单的示例，结合了系统时间和随机数生成唯一的标识：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成唯一标识符</span></span><br><span class="line"><span class="function">std::string <span class="title">GenerateUniqueID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间戳</span></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> duration = now.<span class="built_in">time_since_epoch</span>();</span><br><span class="line">    <span class="keyword">auto</span> millis = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(duration).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成随机数</span></span><br><span class="line">    std::random_device rd;</span><br><span class="line">    <span class="function">std::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">dis</span>(<span class="number">0</span>, <span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> randomNum = <span class="built_in">dis</span>(gen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建唯一标识符</span></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    oss &lt;&lt; millis &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; randomNum;</span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string uniqueID = <span class="built_in">GenerateUniqueID</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Unique ID: &quot;</span> &lt;&lt; uniqueID &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用了当前系统时间的毫秒级别作为唯一标识的一部分，并结合了一个随机数。这样可以在很大程度上保证生成的标识是唯一且固定的。你也可以根据需要添加其他因素来增强唯一性，比如硬件信息、进程ID等。</p>
<h2 id="获取mac地址"><a href="#获取mac地址" class="headerlink" title="获取mac地址"></a>获取mac地址</h2><p>Boost 库本身并没有直接提供获取 MAC 地址的功能，但你可以使用操作系统提供的接口来获取。在 Linux 上，你可以通过读取 <code>/sys/class/net/&lt;interface&gt;/address</code> 文件来获取 MAC 地址，其中 <code>&lt;interface&gt;</code> 是你要获取 MAC 地址的网络接口名称。</p>
<p>以下是一个使用 Boost 库的示例代码，结合读取 MAC 地址的功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/algorithm/string.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fs = boost::filesystem;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">GetMacAddress</span><span class="params">(<span class="type">const</span> std::string&amp; interfaceName)</span> </span>&#123;</span><br><span class="line">    <span class="function">fs::path <span class="title">addressFile</span><span class="params">(<span class="string">&quot;/sys/class/net/&quot;</span> + interfaceName + <span class="string">&quot;/address&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fs::<span class="built_in">exists</span>(addressFile)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Interface &quot;</span> &lt;&lt; interfaceName &lt;&lt; <span class="string">&quot; does not exist.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(addressFile.c_str())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Failed to open address file for interface &quot;</span> &lt;&lt; interfaceName &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string macAddress;</span><br><span class="line">    std::<span class="built_in">getline</span>(file, macAddress);</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trim newline characters</span></span><br><span class="line">    boost::algorithm::<span class="built_in">trim</span>(macAddress);</span><br><span class="line">    <span class="keyword">return</span> macAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string interfaceName = <span class="string">&quot;eth0&quot;</span>; <span class="comment">// 修改为你要获取 MAC 地址的网络接口名称</span></span><br><span class="line">    std::string macAddress = <span class="built_in">GetMacAddress</span>(interfaceName);</span><br><span class="line">    <span class="keyword">if</span> (!macAddress.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MAC Address for interface &quot;</span> &lt;&lt; interfaceName &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; macAddress &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to get MAC Address for interface &quot;</span> &lt;&lt; interfaceName &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用 Boost 库来处理字符串，并使用 Boost.Filesystem 库来检查文件是否存在。然后，我们打开地址文件并读取其中的 MAC 地址。</p>
<p>需要注意的是，你需要确保在你的系统上安装了 Boost 库，并且添加了正确的编译链接选项。</p>
<h2 id="C-遍历enum-class数据类型的对象"><a href="#C-遍历enum-class数据类型的对象" class="headerlink" title="C++ 遍历enum class数据类型的对象"></a>C++ 遍历enum class数据类型的对象</h2><p>在C++中，要遍历<code>enum class</code>数据类型的对象，你可以使用基于范围的<code>for</code>循环（range-based for loop）或者迭代器。这里我提供两种方法的示例代码：</p>
<h3 id="方法一：基于范围的for循环"><a href="#方法一：基于范围的for循环" class="headerlink" title="方法一：基于范围的for循环"></a>方法一：基于范围的for循环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(Color::Red); i &lt;= <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(Color::Blue); ++i) &#123;</span><br><span class="line">        Color currentColor = <span class="built_in">static_cast</span>&lt;Color&gt;(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (currentColor) &#123;</span><br><span class="line">            <span class="keyword">case</span> Color::Red:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Red\n&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Color::Green:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Green\n&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Color::Blue:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Blue\n&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：使用迭代器"><a href="#方法二：使用迭代器" class="headerlink" title="方法二：使用迭代器"></a>方法二：使用迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Color currentColor = Color::Red; currentColor &lt;= Color::Blue; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(currentColor)++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (currentColor) &#123;</span><br><span class="line">            <span class="keyword">case</span> Color::Red:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Red\n&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Color::Green:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Green\n&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Color::Blue:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Blue\n&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，这两种方法都需要你知道<code>enum class</code>的底层类型，并使用<code>static_cast</code>将其转换为整数。在这两个示例中，底层类型是<code>int</code>。确保你的<code>enum class</code>中的值是按照顺序排列的，这样遍历才能按照期望进行。</p>
<h2 id="C-判断一个点xy是否在四个点围成的四边形中"><a href="#C-判断一个点xy是否在四个点围成的四边形中" class="headerlink" title="C++ 判断一个点xy是否在四个点围成的四边形中"></a>C++ 判断一个点xy是否在四个点围成的四边形中</h2><p>在C++中，可以使用以下方法判断一个点 <code>(x, y)</code> 是否在由四个点围成的四边形内。假设四个点的坐标分别为 <code>(x1, y1)</code>, <code>(x2, y2)</code>, <code>(x3, y3)</code>, <code>(x4, y4)</code>。</p>
<p>首先，你可以使用射线法（Ray Casting）或者叉积法（Cross Product）来进行判断。以下是使用叉积法的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个向量的叉积</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">crossProduct</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> x3, <span class="type">int</span> y3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断点是否在四边形内</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPointInsideQuadrilateral</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> x3, <span class="type">int</span> y3, <span class="type">int</span> x4, <span class="type">int</span> y4)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> isInside = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cross1 = <span class="built_in">crossProduct</span>(x1, y1, x2, y2, x, y);</span><br><span class="line">    <span class="type">int</span> cross2 = <span class="built_in">crossProduct</span>(x2, y2, x3, y3, x, y);</span><br><span class="line">    <span class="type">int</span> cross3 = <span class="built_in">crossProduct</span>(x3, y3, x4, y4, x, y);</span><br><span class="line">    <span class="type">int</span> cross4 = <span class="built_in">crossProduct</span>(x4, y4, x1, y1, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果四个叉积的符号都相同，则点在四边形内</span></span><br><span class="line">    <span class="keyword">if</span> ((cross1 &gt;= <span class="number">0</span> &amp;&amp; cross2 &gt;= <span class="number">0</span> &amp;&amp; cross3 &gt;= <span class="number">0</span> &amp;&amp; cross4 &gt;= <span class="number">0</span>) ||</span><br><span class="line">        (cross1 &lt;= <span class="number">0</span> &amp;&amp; cross2 &lt;= <span class="number">0</span> &amp;&amp; cross3 &lt;= <span class="number">0</span> &amp;&amp; cross4 &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line">        isInside = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isInside;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 示例坐标</span></span><br><span class="line">    <span class="type">int</span> x1 = <span class="number">0</span>, y1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x2 = <span class="number">2</span>, y2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x3 = <span class="number">2</span>, y3 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> x4 = <span class="number">0</span>, y4 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待判断的点坐标</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断点是否在四边形内</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isPointInsideQuadrilateral</span>(x, y, x1, y1, x2, y2, x3, y3, x4, y4)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在四边形内&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点不在四边形内&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序中，<code>crossProduct</code> 函数计算了两个向量的叉积，而 <code>isPointInsideQuadrilateral</code> 函数则使用了这个叉积来判断点是否在四边形内。程序中给出的示例是一个单位正方形，你可以根据实际需要修改坐标和点的位置。</p>
<h2 id="C-创建包含布尔值的数组"><a href="#C-创建包含布尔值的数组" class="headerlink" title="C++ 创建包含布尔值的数组"></a>C++ 创建包含布尔值的数组</h2><p>在C++中，你可以使用标准库的<code>std::vector</code>来创建包含布尔值的数组。以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建包含布尔值的数组</span></span><br><span class="line">    std::vector&lt;<span class="type">bool</span>&gt; boolArray = &#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组并打印每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">bool</span> value : boolArray) &#123;</span><br><span class="line">        std::cout &lt;&lt; std::boolalpha &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用<code>std::vector&lt;bool&gt;</code>来创建一个包含布尔值的数组 <code>boolArray</code>。在遍历数组时，我们使用 <code>std::boolalpha</code> 将布尔值打印为 <code>true</code> 或 <code>false</code>。</p>
<p>请注意，<code>std::vector&lt;bool&gt;</code> 在C++中的实现可能不同于其他类型的<code>std::vector</code>，因为它经过了优化以节省空间。如果你需要更一般的<code>std::vector</code>，可以使用<code>std::vector&lt;bool&gt;</code>的替代品，例如使用<code>std::vector&lt;char&gt;</code> 或 <code>std::vector&lt;int&gt;</code>。</p>
<h2 id="C-std-vector-通过迭代器获取当前元素的索引"><a href="#C-std-vector-通过迭代器获取当前元素的索引" class="headerlink" title="C++ std::vector  通过迭代器获取当前元素的索引"></a>C++ std::vector  通过迭代器获取当前元素的索引</h2><p>在C++中，<code>std::vector</code>的迭代器本身并不提供直接的索引访问功能。但你可以使用一些其他方法来获取当前迭代器指向元素的索引。</p>
<p>以下是一种使用<code>std::distance</code>函数的方法，该函数返回两个迭代器之间的距离：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = myVector.<span class="built_in">begin</span>(); it != myVector.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">// 使用 std::distance 获取迭代器之间的距离，即当前元素的索引</span></span><br><span class="line">        <span class="type">int</span> index = std::<span class="built_in">distance</span>(myVector.<span class="built_in">begin</span>(), it);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Index: &quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码使用了<code>std::distance</code>函数，该函数接受两个迭代器参数，并返回它们之间的距离（即元素的索引）。在上面的例子中，<code>std::distance(myVector.begin(), it)</code>返回迭代器<code>it</code>与<code>myVector.begin()</code>之间的距离，即当前元素的索引。</p>
<p>请注意，这种方法在一些情况下可能不是最有效的，因为<code>std::distance</code>的时间复杂度为O(N)，其中N是迭代器之间的距离。如果你需要频繁地获取索引并且性能很重要，可能需要考虑其他数据结构或方法。</p>
<h2 id="C-for范围循环-怎么判断当前元素是否是最后一个"><a href="#C-for范围循环-怎么判断当前元素是否是最后一个" class="headerlink" title="C++ for范围循环 怎么判断当前元素是否是最后一个"></a>C++ for范围循环 怎么判断当前元素是否是最后一个</h2><p>在C++中，使用范围循环（range-based for loop）时，判断当前元素是否是最后一个元素并不是直接支持的特性。范围循环是为了简化迭代过程，因此在标准语法中并没有提供直接的方式来检测是否是最后一个元素。</p>
<p>通常，可以通过以下几种方式来处理这个问题：</p>
<h3 id="1-使用迭代器"><a href="#1-使用迭代器" class="headerlink" title="1. 使用迭代器"></a>1. 使用迭代器</h3><p>使用迭代器，手动追踪当前位置，并判断是否是尾后迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">// 判断是否是最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (it == std::<span class="built_in">prev</span>(numbers.<span class="built_in">end</span>())) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Last element: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-使用索引"><a href="#2-使用索引" class="headerlink" title="2. 使用索引"></a>2. 使用索引</h3><p>使用索引来判断当前元素的位置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="comment">// 判断是否是最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (i == numbers.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Last element: &quot;</span> &lt;&lt; numbers[i] &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; numbers[i] &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-使用标志变量"><a href="#3-使用标志变量" class="headerlink" title="3. 使用标志变量"></a>3. 使用标志变量</h3><p>使用一个标志变量来标记是否是最后一个元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> lastElement = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastElement) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Last element: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastElement = (&amp;num == &amp;numbers.<span class="built_in">back</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些方法都可以用来判断当前元素是否是最后一个，选择合适的方式取决于具体情况和个人偏好。</p>
<h2 id="C-结构体里能够声明自身结构体变量吗"><a href="#C-结构体里能够声明自身结构体变量吗" class="headerlink" title="C++ 结构体里能够声明自身结构体变量吗"></a>C++ 结构体里能够声明自身结构体变量吗</h2><p>在 C++ 中，结构体是一种用户自定义的数据类型，它可以包含其他数据类型的成员，包括自身结构体类型的成员。这种结构体内部包含自身类型的成员通常被称为递归结构体。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个包含自身类型成员的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next; <span class="comment">// 指向下一个 Node 结构体的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node node1;</span><br><span class="line">    Node node2;</span><br><span class="line">    </span><br><span class="line">    node<span class="number">1.</span>data = <span class="number">10</span>;</span><br><span class="line">    node<span class="number">2.</span>data = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 node2 设置为 node1 的下一个节点</span></span><br><span class="line">    node<span class="number">1.</span>next = &amp;node2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问 node1 的下一个节点的数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Data in node1&#x27;s next node: &quot;</span> &lt;&lt; node<span class="number">1.</span>next-&gt;data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>Node</code> 结构体包含一个整型数据成员 <code>data</code> 和一个指向 <code>Node</code> 结构体类型的指针 <code>next</code>。这允许创建一个链表的结构，在其中一个结构体中包含指向另一个结构体的指针，从而形成节点之间的关联。</p>
<p>递归结构体的声明允许结构体类型包含自身类型的成员，但需要注意避免无限递归定义结构体，否则会导致编译器报错或程序陷入无限循环。</p>
<h2 id="C-递归结构体是什么"><a href="#C-递归结构体是什么" class="headerlink" title="C++ 递归结构体是什么"></a>C++ 递归结构体是什么</h2><p>在 C++ 中，递归结构体是指结构体类型内部包含自身类型的成员。这种设计常用于构建具有递归性质的数据结构，例如链表、树等数据结构。</p>
<p>举个例子，考虑一个简单的单向链表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个包含自身类型成员的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next; <span class="comment">// 指向下一个 Node 结构体的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node node1;</span><br><span class="line">    Node node2;</span><br><span class="line">    </span><br><span class="line">    node<span class="number">1.</span>data = <span class="number">10</span>;</span><br><span class="line">    node<span class="number">2.</span>data = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 node2 设置为 node1 的下一个节点</span></span><br><span class="line">    node<span class="number">1.</span>next = &amp;node2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问 node1 的下一个节点的数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Data in node1&#x27;s next node: &quot;</span> &lt;&lt; node<span class="number">1.</span>next-&gt;data &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Node</code> 结构体包含一个整型数据成员 <code>data</code> 和一个指向 <code>Node</code> 结构体类型的指针 <code>next</code>。这允许创建一个简单的链表结构，其中每个节点都包含指向下一个节点的指针，从而形成节点之间的链接。</p>
<p>递归结构体的使用有助于建立递归性质的数据结构，例如树形结构、图等，这些数据结构的定义通常会依赖于包含自身类型成员的结构体来构建节点或元素之间的关系。</p>
<h2 id="C-递归结构体-详解"><a href="#C-递归结构体-详解" class="headerlink" title="C++ 递归结构体 详解"></a>C++ 递归结构体 详解</h2><p>递归结构体在 C++ 中是指一个结构体内部包含自身类型的成员。这种结构体通常用于构建递归性质的数据结构，比如链表、树、图等。通过递归结构体，可以定义每个节点或元素，这些节点可以直接或间接地指向相同类型的节点，形成递归关系。</p>
<p>下面是一个关于递归结构体的更详细的解释和例子：</p>
<h3 id="递归结构体的特点："><a href="#递归结构体的特点：" class="headerlink" title="递归结构体的特点："></a>递归结构体的特点：</h3><ol>
<li><strong>自引用性质：</strong> 在结构体内部，结构体类型可以作为其自身的一个成员，即包含自身类型的成员。</li>
<li><strong>形成递归关系：</strong> 这种结构允许每个实例都能持有另一个相同类型的实例，或者持有指向另一个相同类型的实例的指针。</li>
</ol>
<h3 id="例子：单链表"><a href="#例子：单链表" class="headerlink" title="例子：单链表"></a>例子：单链表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义递归结构体 Node，表示链表节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next; <span class="comment">// 指向下一个 Node 结构体的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node node1, node2, node3;</span><br><span class="line"></span><br><span class="line">    node<span class="number">1.</span>data = <span class="number">10</span>;</span><br><span class="line">    node<span class="number">2.</span>data = <span class="number">20</span>;</span><br><span class="line">    node<span class="number">3.</span>data = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建链表</span></span><br><span class="line">    node<span class="number">1.</span>next = &amp;node2;</span><br><span class="line">    node<span class="number">2.</span>next = &amp;node3;</span><br><span class="line">    node<span class="number">3.</span>next = <span class="literal">nullptr</span>; <span class="comment">// 最后一个节点指向空指针，表示链表结束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表并输出节点的数据</span></span><br><span class="line">    Node* current = &amp;node1; <span class="comment">// 从第一个节点开始</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Node data: &quot;</span> &lt;&lt; current-&gt;data &lt;&lt; endl;</span><br><span class="line">        current = current-&gt;next; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>Node</code> 结构体代表链表的节点。每个节点都包含一个整型数据成员 <code>data</code> 和一个指向下一个 <code>Node</code> 结构体的指针 <code>next</code>。通过指针 <code>next</code>，可以将各个节点连接起来，形成一个链表结构。</p>
<p>递归结构体的使用使得链表的节点可以彼此连接，而且每个节点可以访问其下一个节点，从而形成了数据的递归结构。</p>
<p>递归结构体不仅仅局限于链表，它还可以用于树、图等更复杂的数据结构的构建。这种方式能够清晰地描述节点之间的层次或关系，使得对数据结构的操作更为灵活和便捷。</p>
<h2 id="OpenSSL库中有base64编码示例-详解"><a href="#OpenSSL库中有base64编码示例-详解" class="headerlink" title="OpenSSL库中有base64编码示例  详解"></a>OpenSSL库中有base64编码示例  详解</h2><p>在 OpenSSL 库中，base64 编码和解码可以使用其提供的函数进行操作。下面是一个简单的示例，展示了如何使用 OpenSSL 库进行 base64 编码和解码。</p>
<p>请注意，以下示例代码主要用于说明如何使用 OpenSSL 进行 base64 编码和解码。在实际应用中，应考虑错误处理、内存管理和其他安全性方面的注意事项。</p>
<h3 id="Base64-编码示例："><a href="#Base64-编码示例：" class="headerlink" title="Base64 编码示例："></a>Base64 编码示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/buffer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用于进行 base64 编码</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">base64_encode</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *input, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    BIO *bio, *b64;</span><br><span class="line">    BUF_MEM *bufferPtr;</span><br><span class="line"></span><br><span class="line">    b64 = BIO_new(BIO_f_base64());</span><br><span class="line">    BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);</span><br><span class="line">    bio = BIO_new(BIO_s_mem());</span><br><span class="line">    bio = BIO_push(b64, bio);</span><br><span class="line"></span><br><span class="line">    BIO_write(bio, input, length);</span><br><span class="line">    BIO_flush(bio);</span><br><span class="line">    BIO_get_mem_ptr(bio, &amp;bufferPtr);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *encoded = (<span class="type">char</span> *)<span class="built_in">malloc</span>(bufferPtr-&gt;length);</span><br><span class="line">    <span class="built_in">memcpy</span>(encoded, bufferPtr-&gt;data, bufferPtr-&gt;length - <span class="number">1</span>);</span><br><span class="line">    encoded[bufferPtr-&gt;length - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    BIO_free_all(bio);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> encoded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *text = <span class="string">&quot;Hello, this is a message to be encoded in Base64!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">strlen</span>(text);</span><br><span class="line">    <span class="type">char</span> *encoded = base64_encode((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)text, length);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Base64 Encoded: %s\n&quot;</span>, encoded);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(encoded);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Base64-解码示例："><a href="#Base64-解码示例：" class="headerlink" title="Base64 解码示例："></a>Base64 解码示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/buffer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用于进行 base64 解码</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">base64_decode</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *input, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    BIO *bio, *b64;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buffer = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(length);</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">    b64 = BIO_new(BIO_f_base64());</span><br><span class="line">    BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);</span><br><span class="line">    bio = BIO_new_mem_buf((<span class="type">void</span> *)input, length);</span><br><span class="line">    bio = BIO_push(b64, bio);</span><br><span class="line"></span><br><span class="line">    BIO_read(bio, buffer, length);</span><br><span class="line"></span><br><span class="line">    BIO_free_all(bio);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *encoded_text = <span class="string">&quot;SGVsbG8sIHRoaXMgaXMgYSBtZXNzYWdlIHRvIGJlIGVuY29kZWQgaW4gQmFzZTY0IQ==&quot;</span>;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">strlen</span>(encoded_text);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *decoded = base64_decode(encoded_text, length);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Base64 Decoded: %s\n&quot;</span>, decoded);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(decoded);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，这些示例仅包含了基本的错误处理和内存管理。在实际应用中，您可能需要更全面地处理错误情况和内存分配释放，以确保安全性和稳定性。此外，在解码时，请记得释放解码后的内存。</p>
<p>在实际应用中使用 OpenSSL 库进行 base64 编码和解码时，请仔细查阅 OpenSSL 的官方文档以获取更多信息，并遵循最佳实践。</p>
<h2 id="C-std-string转为小写"><a href="#C-std-string转为小写" class="headerlink" title="C++ std::string转为小写"></a>C++ std::string转为小写</h2><p>在 C++ 中，将 <code>std::string</code> 转换为小写可以通过不同的方法实现。以下是一种常见的方法，使用标准库的 <code>std::transform</code> 函数和 <code>std::tolower</code> 函数来实现这个转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// 包含 transform 函数所需的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span>    <span class="comment">// 包含 std::tolower 所需的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::transform 将字符串转换为小写</span></span><br><span class="line">    std::<span class="built_in">transform</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), str.<span class="built_in">begin</span>(),</span><br><span class="line">                   [](<span class="type">unsigned</span> <span class="type">char</span> c) &#123; <span class="keyword">return</span> std::<span class="built_in">tolower</span>(c); &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;转换为小写后的字符串：&quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码将字符串 <code>str</code> 转换为小写形式并打印输出。<code>std::transform</code> 函数遍历字符串中的每个字符，并将其作为参数传递给 lambda 表达式，lambda 表达式调用 <code>std::tolower</code> 将字符转换为小写形式。</p>
<p>另外，这段代码中使用了 <code>std::transform</code> 函数，它是标准库中的一个通用算法，能够将指定范围内的元素应用给定的操作，并将结果存储到另一个范围中。在这里，它接受了字符串的起始和结束迭代器作为参数，然后通过 lambda 表达式实现了每个字符的小写转换操作。</p>
<p>请注意，在进行字符大小写转换时，使用 <code>std::tolower</code> 函数时要格外小心。这个函数在处理字符之前将其转换为 <code>unsigned char</code>，以避免出现负数值（<code>EOF</code>）导致的问题。</p>
<h2 id="C-避免重复定义问题"><a href="#C-避免重复定义问题" class="headerlink" title="C++ 避免重复定义问题"></a>C++ 避免重复定义问题</h2><p>在 C++ 中，重复定义问题通常是因为同一个变量、函数或者类在多个源文件中被定义而引起的。为了避免这种问题，可以使用以下方法：</p>
<h3 id="使用头文件保护"><a href="#使用头文件保护" class="headerlink" title="使用头文件保护"></a>使用头文件保护</h3><p>在头文件中使用预处理器指令 <code>#ifndef</code>, <code>#define</code>, <code>#endif</code> 来防止头文件被多次包含。</p>
<p>例如，创建一个头文件 <code>example.h</code>，在文件开头加上如下内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXAMPLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处放置头文件的内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// EXAMPLE_H</span></span></span><br></pre></td></tr></table></figure>

<p>这样，在包含 <code>example.h</code> 的源文件中，预处理器会检查 <code>EXAMPLE_H</code> 是否已经被定义，避免头文件被多次包含。</p>
<h3 id="使用-extern-关键字声明外部链接"><a href="#使用-extern-关键字声明外部链接" class="headerlink" title="使用 extern 关键字声明外部链接"></a>使用 <code>extern</code> 关键字声明外部链接</h3><p>如果需要在多个源文件中使用全局变量或函数，可以在声明时使用 <code>extern</code> 关键字，而在定义时不要重复定义。</p>
<p>示例：</p>
<p>在头文件 <code>example.h</code> 中声明全局变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXAMPLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> globalVariable; <span class="comment">// 声明全局变量，不要在头文件中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exampleFunction</span><span class="params">()</span></span>; <span class="comment">// 函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// EXAMPLE_H</span></span></span><br></pre></td></tr></table></figure>

<p>在一个源文件中定义全局变量 <code>globalVariable</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVariable = <span class="number">0</span>; <span class="comment">// 定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exampleFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h3><p>将代码放入命名空间中有助于避免全局命名冲突。将相关的变量、函数和类放入命名空间，以确保命名唯一性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXAMPLE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Example &#123;</span><br><span class="line">    <span class="comment">// 在命名空间中声明变量、函数和类</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> globalVariable;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">exampleFunction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// EXAMPLE_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Example &#123;</span><br><span class="line">    <span class="type">int</span> globalVariable = <span class="number">0</span>; <span class="comment">// 定义全局变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">exampleFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 函数定义</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些方法可以帮助你在 C++ 中避免重复定义的问题，保持代码的可维护性和可扩展性。</p>
<h2 id="在for循环内部使用std-vector-erase-函数-需要注意什么"><a href="#在for循环内部使用std-vector-erase-函数-需要注意什么" class="headerlink" title="在for循环内部使用std::vector::erase()函数 需要注意什么"></a>在for循环内部使用std::vector::erase()函数 需要注意什么</h2><p>在使用 <code>std::vector::erase()</code> 函数时，尤其是在循环中，在迭代器失效和容器大小改变的情况下需要特别注意。</p>
<ol>
<li><p><strong>迭代器失效：</strong> 当使用 <code>std::vector::erase()</code> 删除元素时，被删除元素之后的所有迭代器都会失效。这意味着，如果在循环中直接使用迭代器来遍历元素，并在循环内部调用了 <code>erase()</code> 函数，会导致迭代器失效，进而可能引发未定义行为或程序崩溃。</p>
</li>
<li><p><strong>循环范围：</strong> 如果在循环中调用了 <code>std::vector::erase()</code>，需要注意循环范围。因为删除元素后，容器的大小会发生改变，循环的终止条件可能会受到影响。这可能导致某些元素被跳过，或者在循环结束后尝试访问不存在的元素，产生未定义行为。</p>
</li>
</ol>
<p>为了避免这些问题，有几种常见的方法：</p>
<ul>
<li><p><strong>使用迭代器进行循环：</strong> 如果确实需要在循环内部删除元素，可以使用迭代器进行循环遍历，并在删除元素后更新迭代器。这样可以确保在每次删除操作后正确调整迭代器位置。</p>
</li>
<li><p><strong>反向循环：</strong> 从容器的末尾向前循环，这样在删除元素后，不会影响前面元素的位置，可以减少迭代器失效的可能性。</p>
</li>
</ul>
<p>以下是一个使用迭代器进行循环并删除元素的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器进行循环，并在循环内部删除偶数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = numbers.<span class="built_in">begin</span>(); it != numbers.<span class="built_in">end</span>();) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            it = numbers.<span class="built_in">erase</span>(it); <span class="comment">// 删除偶数并更新迭代器</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++it; <span class="comment">// 指向下一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出删除后的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例中，使用迭代器进行循环遍历 <code>numbers</code> 向量，并在循环内部删除偶数。在删除操作后，根据删除是否发生，更新迭代器的位置。这样可以避免迭代器失效，并确保正确地删除元素。</p>
<h2 id="C-字符串格式化的常用方式-详解"><a href="#C-字符串格式化的常用方式-详解" class="headerlink" title="C++ 字符串格式化的常用方式 详解"></a>C++ 字符串格式化的常用方式 详解</h2><p>在C++中，有几种常用的方式可以进行字符串格式化，以将不同类型的数据插入到字符串中或按特定格式呈现字符串。下面是一些常见的字符串格式化方式的详解：</p>
<ol>
<li><p><strong>C-风格字符串格式化</strong>：</p>
<p>在C++中，你可以使用类似C的<code>printf</code>函数或<code>sprintf</code>函数来进行字符串格式化。这些函数使用格式化字符串，其中包含占位符，然后用实际的值替换这些占位符。占位符以百分号（%）开头，后面跟着一个格式规范字符，指示如何格式化数据。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;The answer is: %d&quot;</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Formatted string: %s\n&quot;</span>, buffer);</span><br></pre></td></tr></table></figure>

<p>这种方式非常灵活，但要小心，因为它不提供类型安全，可能会导致安全漏洞。</p>
</li>
<li><p><strong>C++11 标准的字符串流</strong>：</p>
<p>C++11引入了<code>std::stringstream</code>，它提供了一种更安全和类型安全的字符串格式化方式。你可以像向流中写入数据一样向<code>std::stringstream</code>写入数据，然后从中提取一个字符串。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot;The answer is: &quot;</span> &lt;&lt; num;</span><br><span class="line">std::string formattedString = ss.<span class="built_in">str</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Formatted string: &quot;</span> &lt;&lt; formattedString &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>这种方式提供了类型安全，允许你将不同类型的数据混合到同一个字符串中。</p>
</li>
<li><p><strong>C++11 及更高版本的字符串插值</strong>：</p>
<p>在C++11及更高版本中，你还可以使用字符串插值，这是一种更方便的字符串格式化方式。你可以在字符串字面值前加上<code>R</code>，然后在字符串中使用<code>$&#123;&#125;</code>来插入变量或表达式。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line">std::string formattedString = <span class="string">R&quot;(The answer is: )&quot;</span> + std::<span class="built_in">to_string</span>(num);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Formatted string: &quot;</span> &lt;&lt; formattedString &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>这种方式非常简洁，但只能在支持C++11及更高版本的编译器中使用。</p>
</li>
<li><p><strong>使用格式化库</strong>：</p>
<p>如果需要更复杂的字符串格式化，例如支持日期、时间、货币等多种格式，你可以考虑使用C++中的格式化库，如Boost.Format或fmtlib。这些库提供了丰富的格式化选项，使你能够以更高级的方式进行字符串格式化。</p>
</li>
</ol>
<p>每种方法都有其优缺点，选择哪种方法取决于具体的需求和项目要求。如果只需要进行简单的格式化，使用C++标准库的方法通常足够，而对于更复杂的需求，可能需要考虑使用格式化库或其他自定义解决方案。</p>
<h2 id="255-255-255-0-删除”-”-C"><a href="#255-255-255-0-删除”-”-C" class="headerlink" title="255.255.255.0 删除”.” C++"></a>255.255.255.0 删除”.” C++</h2><p>要从字符串 “255.255.255.0” 中删除点号（”.”），你可以使用 C++ 中的字符串操作。下面是一个示例代码，演示如何删除点号：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string subnetMask = <span class="string">&quot;255.255.255.0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除字符串中的点号</span></span><br><span class="line">    subnetMask.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(subnetMask.<span class="built_in">begin</span>(), subnetMask.<span class="built_in">end</span>(), <span class="string">&#x27;.&#x27;</span>), subnetMask.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除点号后的字符串为: &quot;</span> &lt;&lt; subnetMask &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码使用了 <code>std::remove</code> 和 <code>std::string::erase</code> 函数。<code>std::remove</code> 函数会将要删除的字符移动到字符串的末尾，并返回一个指向新末尾之后第一个元素的迭代器。然后，<code>std::string::erase</code> 函数用于擦除这些元素，实现了从字符串中删除点号的操作。</p>
<p>运行此代码会输出：<code>删除点号后的字符串为: 2552552550</code>。</p>
<h2 id="获取目录下所有文件名-C-11-linux"><a href="#获取目录下所有文件名-C-11-linux" class="headerlink" title="获取目录下所有文件名 C++11 linux"></a>获取目录下所有文件名 C++11 linux</h2><p>您好！以下是在Linux系统下使用C++11获取目录下所有文件名的代码示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">get_files</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *src_dir)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; result;</span><br><span class="line">    DIR *dir = <span class="built_in">opendir</span>(src_dir);</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; src_dir &lt;&lt; <span class="string">&quot; is not a directory or not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span> *d_ent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> ((d_ent = <span class="built_in">readdir</span>(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d_ent-&gt;d_type != DT_DIR) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(d_ent-&gt;d_name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">closedir</span>(dir);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::string&gt; files = <span class="built_in">get_files</span>(<span class="string">&quot;/path/to/directory&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;file : files) &#123;</span><br><span class="line">        std::cout &lt;&lt; file &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码使用了<code>opendir()</code>和<code>readdir()</code>函数来打开和读取目录。<code>opendir()</code>函数打开一个目录，返回一个指向<code>DIR</code>类型的指针。<code>readdir()</code>函数读取目录中的下一个条目，返回一个指向<code>dirent</code>类型的指针。<code>d_type</code>成员变量可以用来判断当前条目是文件还是目录。如果是文件，则将文件名存储到<code>std::vector&lt;std::string&gt;</code>类型的容器中。</p>
<p>希望这可以帮助到您！</p>
<p>源: 与必应的对话， 12&#x2F;19&#x2F;2023<br>(1) c++在linux系统下实现获取目录下所有文件名操作 - nickeman - 博客园. <a target="_blank" rel="noopener" href="https://www.cnblogs.com/nickman/p/14029064.html">https://www.cnblogs.com/nickman/p/14029064.html</a>.<br>(2) c++在linux系统下实现获取目录下所有文件名操作 - nickeman - 博客园. <a target="_blank" rel="noopener" href="https://bing.com/search?q=%E8%8E%B7%E5%8F%96%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%90%8D+C++11+linux">https://bing.com/search?q=%e8%8e%b7%e5%8f%96%e7%9b%ae%e5%bd%95%e4%b8%8b%e6%89%80%e6%9c%89%e6%96%87%e4%bb%b6%e5%90%8d+C%2b%2b11+linux</a>.<br>(3) 【Linux编程】C&#x2F;C++获取目录下文件或目录 | 神奕的博客. <a target="_blank" rel="noopener" href="http://songlee24.github.io/2014/09/20/linux-get-directory/">http://songlee24.github.io/2014/09/20/linux-get-directory/</a>.<br>(4) 如何在 C++ 中获取目录中的文件列表 | D栈 - Delft Stack. <a target="_blank" rel="noopener" href="https://www.delftstack.com/zh/howto/cpp/how-to-get-list-of-files-in-a-directory-cpp/">https://www.delftstack.com/zh/howto/cpp/how-to-get-list-of-files-in-a-directory-cpp/</a>.<br>(5) undefined. <a target="_blank" rel="noopener" href="https://bing.com/search?q=">https://bing.com/search?q=</a>.</p>
<h2 id="HTTP-请求路径使用递归的方法取出字段-C"><a href="#HTTP-请求路径使用递归的方法取出字段-C" class="headerlink" title="HTTP 请求路径使用递归的方法取出字段 C++"></a>HTTP 请求路径使用递归的方法取出字段 C++</h2><p>使用递归方法从 HTTP 请求路径中提取字段的示例代码如下（C++）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extractFields</span><span class="params">(<span class="type">const</span> std::string&amp; path, std::vector&lt;std::string&gt;&amp; fields)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到路径中第一个斜杠的位置</span></span><br><span class="line">    <span class="type">size_t</span> pos = path.<span class="built_in">find</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos != std::string::npos) &#123;</span><br><span class="line">        <span class="comment">// 获取斜杠之前的字段</span></span><br><span class="line">        std::string field = path.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">        fields.<span class="built_in">push_back</span>(field);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用以提取下一个字段</span></span><br><span class="line">        <span class="built_in">extractFields</span>(path.<span class="built_in">substr</span>(pos + <span class="number">1</span>), fields);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有斜杠，则将路径中剩余部分作为最后一个字段添加到列表中</span></span><br><span class="line">        fields.<span class="built_in">push_back</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string httpPath = <span class="string">&quot;/api/user/profile&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; extractedFields;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取字段</span></span><br><span class="line">    <span class="built_in">extractFields</span>(httpPath, extractedFields);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出提取的字段</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Extracted fields:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> std::string&amp; field : extractedFields) &#123;</span><br><span class="line">        std::cout &lt;&lt; field &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码将以递归方式解析 HTTP 请求路径，并将提取的字段存储在字符串向量中。你可以替换 <code>httpPath</code> 变量的内容来测试不同的路径。</p>
<h2 id="C-std-find-if-在std-map容器中查找"><a href="#C-std-find-if-在std-map容器中查找" class="headerlink" title="C++ std::find_if()在std::map容器中查找"></a>C++ std::find_if()在std::map容器中查找</h2><p>当使用 <code>std::map</code> 容器时，可以使用 <code>std::find_if</code> 来查找满足特定条件的元素。请注意，<code>std::map</code> 是一个关联容器，其中元素以键值对的形式存储。</p>
<p>假设我们有一个 <code>std::map</code> 容器，我们想根据某些条件查找其中的元素。下面是一个例子，展示了如何使用 <code>std::find_if</code> 在 <code>std::map</code> 中查找满足特定条件的元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向map中添加一些元素</span></span><br><span class="line">    myMap[<span class="number">1</span>] = <span class="string">&quot;One&quot;</span>;</span><br><span class="line">    myMap[<span class="number">2</span>] = <span class="string">&quot;Two&quot;</span>;</span><br><span class="line">    myMap[<span class="number">3</span>] = <span class="string">&quot;Three&quot;</span>;</span><br><span class="line">    myMap[<span class="number">4</span>] = <span class="string">&quot;Four&quot;</span>;</span><br><span class="line">    myMap[<span class="number">5</span>] = <span class="string">&quot;Five&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个lambda表达式作为查找条件</span></span><br><span class="line">    <span class="keyword">auto</span> findCondition = [](<span class="type">const</span> std::pair&lt;<span class="type">int</span>, std::string&gt;&amp; element) &#123;</span><br><span class="line">        <span class="keyword">return</span> element.second == <span class="string">&quot;Three&quot;</span>; <span class="comment">// 查找值为 &quot;Three&quot; 的元素</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::find_if 查找满足条件的元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(myMap.<span class="built_in">begin</span>(), myMap.<span class="built_in">end</span>(), findCondition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否找到了元素</span></span><br><span class="line">    <span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found: Key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, Value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element not found.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用了一个 lambda 表达式 <code>findCondition</code>，它检查 <code>std::pair&lt;int, std::string&gt;</code> 类型的元素中的第二个值是否为 “Three”。然后，我们使用 <code>std::find_if</code> 在 <code>std::map</code> 中查找满足条件的元素。</p>
<p>请注意，这个示例中的查找条件是基于值来进行匹配的。您可以根据需要调整 lambda 表达式中的条件来进行不同的查找操作，比如基于键来查找等。</p>
<h2 id="C-中的类成员函数当线程函数"><a href="#C-中的类成员函数当线程函数" class="headerlink" title="C++中的类成员函数当线程函数"></a>C++中的类成员函数当线程函数</h2><ul>
<li>C++类成员函数使用时，都会隐式传递一个this指针给该函数，this指针指向该类的对象。函数体可以通过显示调用该指针或直接访问类内成员。</li>
<li>回调函数是通过指针调用的函数，最常使用的回调函数就是在创建线程时，以一个函数指针以及传递给这个函数多个参数来调用线程函数来创建线程。</li>
<li>那么一般的类成员函数是不能用作回调函数的，因为库函数在使用回调函数时，都会传递指定的符合回调函数声明的的参数给回调函数，而类成员函数隐式包含一个this指针参数，所以把类成员函数当作回调函数编译时因为参数不匹配会出错。</li>
<li>std::thread，它的第一个参数为函数指针，在c++中这样是获取不到其成员函数的指针，所以会报错。</li>
</ul>
<h3 id="解决方法一"><a href="#解决方法一" class="headerlink" title="解决方法一"></a>解决方法一</h3><ul>
<li>把成员函数设成静态成员函数，不属于某个对象，属于整个类，没有this指针。但是静态成员函数并不能使用非静态的成员变量（因为它没有某个具体对象的this指针），可通过对象或者类指针调用。</li>
</ul>
<h3 id="解决方法二"><a href="#解决方法二" class="headerlink" title="解决方法二"></a>解决方法二</h3><ul>
<li>把成员函数声明为友元函数，没有this指针，但是能够访问类的成员变量<br>在C++中，友元函数是一个能够访问类的私有成员的非成员函数。如果你想要将一个友元函数作为线程函数，你可以使用C++11引入的线程库来实现。以下是一个简单的例子，演示了如何将友元函数作为线程函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateData;</span><br><span class="line">    std::mutex dataMutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> data) : <span class="built_in">privateData</span>(data) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">friendThreadFunction</span><span class="params">(MyClass&amp; obj)</span></span>; <span class="comment">// 友元函数声明</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(dataMutex)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Private data: &quot;</span> &lt;&lt; privateData &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">friendThreadFunction</span><span class="params">(MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(obj.dataMutex)</span></span>;</span><br><span class="line">    obj.privateData += <span class="number">10</span>;</span><br><span class="line">    obj.<span class="built_in">displayData</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">myObject</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程并将友元函数作为线程函数</span></span><br><span class="line">    <span class="function">std::thread <span class="title">myThread</span><span class="params">(friendThreadFunction, std::ref(myObject))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程执行其他任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        myObject.<span class="built_in">displayData</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    myThread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>MyClass</code>包含一个私有成员<code>privateData</code>，并有一个友元函数<code>friendThreadFunction</code>，该函数可以访问<code>MyClass</code>的私有成员。在<code>main</code>函数中，创建了一个<code>MyClass</code>对象，并启动了一个新线程，将<code>friendThreadFunction</code>作为线程函数，并传递了<code>myObject</code>的引用。主线程执行一些任务，而新线程在后台修改了<code>privateData</code>的值，然后通过调用<code>displayData</code>函数显示了修改后的数据。</p>
<p>请注意，在使用线程时，确保在访问共享数据时使用适当的同步机制，如互斥锁（<code>std::mutex</code>）以防止竞态条件。在上述例子中，使用了<code>std::lock_guard</code>来确保对<code>privateData</code>的访问是线程安全的。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>感谢老板支持！敬礼(^^ゞ</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="zhang junyi WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="zhang junyi Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CppTechnique/" rel="tag"># CppTechnique</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_04_libmagic/" rel="prev" title="C++_04_04_libmagic">
      <i class="fa fa-chevron-left"></i> C++_04_04_libmagic
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/05/22/notebook/C++/C++_04_%E5%B8%B8%E7%94%A8%E5%BA%93/2024-05-22-C++_04_09_libssl-dev/" rel="next" title="C++_04_09_libssl-dev">
      C++_04_09_libssl-dev <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%B0%86uchar%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.</span> <span class="nav-text">C++ 将uchar数组转为字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%88%B6%E7%B1%BB%E8%B0%83%E7%94%A8%E5%AD%90%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">C++ 父类调用子类的成员函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">C++ 子类对象调用父类函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-linux-%E8%8E%B7%E5%8F%96%E7%A1%AC%E7%9B%98%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="nav-number">5.</span> <span class="nav-text">C++ linux 获取硬盘序列号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux-CPU-ID%E6%9F%A5%E8%AF%A2"><span class="nav-number">6.</span> <span class="nav-text">linux CPU ID查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux-%E4%B8%BB%E6%9D%BF%E5%BA%8F%E5%88%97%E5%8F%B7%E6%9F%A5%E8%AF%A2"><span class="nav-number">7.</span> <span class="nav-text">linux 主板序列号查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%94%9F%E6%88%90%E7%9A%84UUID"><span class="nav-number">8.</span> <span class="nav-text">linux 操作系统生成的UUID</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E8%8E%B7%E5%8F%96%E6%9C%BA%E5%99%A8%E6%A0%87%E8%AF%86%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">9.</span> <span class="nav-text">C++ 获取机器标识的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80%E4%B8%94%E5%9B%BA%E5%AE%9A%E7%9A%84%E6%A0%87%E8%AF%86"><span class="nav-number">10.</span> <span class="nav-text">C++ 生成唯一且固定的标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96mac%E5%9C%B0%E5%9D%80"><span class="nav-number">11.</span> <span class="nav-text">获取mac地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E9%81%8D%E5%8E%86enum-class%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">12.</span> <span class="nav-text">C++ 遍历enum class数据类型的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="nav-number">12.1.</span> <span class="nav-text">方法一：基于范围的for循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">12.2.</span> <span class="nav-text">方法二：使用迭代器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9xy%E6%98%AF%E5%90%A6%E5%9C%A8%E5%9B%9B%E4%B8%AA%E7%82%B9%E5%9B%B4%E6%88%90%E7%9A%84%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%AD"><span class="nav-number">13.</span> <span class="nav-text">C++ 判断一个点xy是否在四个点围成的四边形中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%88%9B%E5%BB%BA%E5%8C%85%E5%90%AB%E5%B8%83%E5%B0%94%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">14.</span> <span class="nav-text">C++ 创建包含布尔值的数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-std-vector-%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="nav-number">15.</span> <span class="nav-text">C++ std::vector  通过迭代器获取当前元素的索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-for%E8%8C%83%E5%9B%B4%E5%BE%AA%E7%8E%AF-%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E6%98%AF%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA"><span class="nav-number">16.</span> <span class="nav-text">C++ for范围循环 怎么判断当前元素是否是最后一个</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">16.1.</span> <span class="nav-text">1. 使用迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">16.2.</span> <span class="nav-text">2. 使用索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8%E6%A0%87%E5%BF%97%E5%8F%98%E9%87%8F"><span class="nav-number">16.3.</span> <span class="nav-text">3. 使用标志变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%BB%93%E6%9E%84%E4%BD%93%E9%87%8C%E8%83%BD%E5%A4%9F%E5%A3%B0%E6%98%8E%E8%87%AA%E8%BA%AB%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E5%90%97"><span class="nav-number">17.</span> <span class="nav-text">C++ 结构体里能够声明自身结构体变量吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84%E4%BD%93%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">18.</span> <span class="nav-text">C++ 递归结构体是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84%E4%BD%93-%E8%AF%A6%E8%A7%A3"><span class="nav-number">19.</span> <span class="nav-text">C++ 递归结构体 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="nav-number">19.1.</span> <span class="nav-text">递归结构体的特点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">19.2.</span> <span class="nav-text">例子：单链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenSSL%E5%BA%93%E4%B8%AD%E6%9C%89base64%E7%BC%96%E7%A0%81%E7%A4%BA%E4%BE%8B-%E8%AF%A6%E8%A7%A3"><span class="nav-number">20.</span> <span class="nav-text">OpenSSL库中有base64编码示例  详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Base64-%E7%BC%96%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="nav-number">20.1.</span> <span class="nav-text">Base64 编码示例：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Base64-%E8%A7%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="nav-number">20.2.</span> <span class="nav-text">Base64 解码示例：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-std-string%E8%BD%AC%E4%B8%BA%E5%B0%8F%E5%86%99"><span class="nav-number">21.</span> <span class="nav-text">C++ std::string转为小写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98"><span class="nav-number">22.</span> <span class="nav-text">C++ 避免重复定义问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="nav-number">22.1.</span> <span class="nav-text">使用头文件保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-extern-%E5%85%B3%E9%94%AE%E5%AD%97%E5%A3%B0%E6%98%8E%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5"><span class="nav-number">22.2.</span> <span class="nav-text">使用 extern 关键字声明外部链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">22.3.</span> <span class="nav-text">使用命名空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8std-vector-erase-%E5%87%BD%E6%95%B0-%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88"><span class="nav-number">23.</span> <span class="nav-text">在for循环内部使用std::vector::erase()函数 需要注意什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F-%E8%AF%A6%E8%A7%A3"><span class="nav-number">24.</span> <span class="nav-text">C++ 字符串格式化的常用方式 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#255-255-255-0-%E5%88%A0%E9%99%A4%E2%80%9D-%E2%80%9D-C"><span class="nav-number">25.</span> <span class="nav-text">255.255.255.0 删除”.” C++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%90%8D-C-11-linux"><span class="nav-number">26.</span> <span class="nav-text">获取目录下所有文件名 C++11 linux</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%96%E5%87%BA%E5%AD%97%E6%AE%B5-C"><span class="nav-number">27.</span> <span class="nav-text">HTTP 请求路径使用递归的方法取出字段 C++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-std-find-if-%E5%9C%A8std-map%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%9F%A5%E6%89%BE"><span class="nav-number">28.</span> <span class="nav-text">C++ std::find_if()在std::map容器中查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%BD%93%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0"><span class="nav-number">29.</span> <span class="nav-text">C++中的类成员函数当线程函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%B8%80"><span class="nav-number">29.1.</span> <span class="nav-text">解决方法一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="nav-number">29.2.</span> <span class="nav-text">解决方法二</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
