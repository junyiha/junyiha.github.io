<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="简介 C++编程技巧">
<meta property="og:type" content="article">
<meta property="og:title" content="C++_06_3_编程技巧">
<meta property="og:url" content="https://junyiha.github.io/2024/05/22/notebook/C++/C++_06_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-C++_06_3_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="简介 C++编程技巧">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-05-22T01:00:00.000Z">
<meta property="article:modified_time" content="2025-04-28T08:08:39.176Z">
<meta property="article:author" content="zhang junyi">
<meta property="article:tag" content="CppTechnique">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_06_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-C++_06_3_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>C++_06_3_编程技巧 | junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/C++/C++_06_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-C++_06_3_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++_06_3_编程技巧
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>C++编程技巧</li>
</ul>
<span id="more"></span>

<h2 id="windows-C-链接dll无法调试-链接lib就可以调试-原因是什么"><a href="#windows-C-链接dll无法调试-链接lib就可以调试-原因是什么" class="headerlink" title="windows C++ 链接dll无法调试 链接lib就可以调试 原因是什么"></a>windows C++ 链接dll无法调试 链接lib就可以调试 原因是什么</h2><p>在 Windows 开发环境中，使用动态链接库（DLL）和静态链接库（LIB）时，调试行为可能有所不同。如果使用 DLL 无法调试，而静态链接可以调试，可能涉及以下原因：</p>
<hr>
<h3 id="1-符号信息缺失"><a href="#1-符号信息缺失" class="headerlink" title="1. 符号信息缺失"></a>1. <strong>符号信息缺失</strong></h3><ul>
<li>静态链接库包含了完整的符号信息，编译器和调试器可以直接使用这些信息定位代码。</li>
<li>DLL 通常由两个部分组成：<ul>
<li>DLL 文件：包含实际的代码实现。</li>
<li>对应的 Import Library（<code>.lib</code> 文件）：用于链接器识别函数入口点。</li>
</ul>
</li>
<li>如果 DLL 没有提供调试符号文件（如 <code>.pdb</code> 文件），调试器无法正确映射函数调用和代码。</li>
</ul>
<p>   <strong>解决方法</strong>：</p>
<ul>
<li>确保 DLL 的构建是在调试模式下完成的，生成 <code>.pdb</code> 文件。</li>
<li>将生成的 <code>.pdb</code> 文件放在调试器可以找到的路径中（通常与 DLL 位于同一目录下）。</li>
</ul>
<hr>
<h3 id="2-代码路径不可见"><a href="#2-代码路径不可见" class="headerlink" title="2. 代码路径不可见"></a>2. <strong>代码路径不可见</strong></h3><ul>
<li>静态库的代码会直接嵌入到可执行文件中，调试器可以轻松定位代码。</li>
<li>DLL 的实现代码不在主程序中，调试器需要额外信息（如 <code>.pdb</code> 文件）来关联源代码。</li>
</ul>
<p>   <strong>解决方法</strong>：</p>
<ul>
<li>配置调试器，添加源代码路径。</li>
<li>在 Visual Studio 中，打开 <code>Tools -&gt; Options -&gt; Debugging -&gt; Symbols</code>，添加符号文件路径。</li>
</ul>
<hr>
<h3 id="3-优化设置问题"><a href="#3-优化设置问题" class="headerlink" title="3. 优化设置问题"></a>3. <strong>优化设置问题</strong></h3><ul>
<li>DLL 通常可能会启用优化，即使在调试模式下，部分代码可能被内联或优化掉，导致调试器无法准确跟踪。</li>
<li>静态库在调试模式下通常关闭优化，因此可以更轻松地调试。</li>
</ul>
<p>   <strong>解决方法</strong>：</p>
<ul>
<li>确保 DLL 的构建配置中关闭了优化选项（<code>/Od</code>）。</li>
<li>在生成 DLL 时启用调试信息选项（<code>/Zi</code> 或 <code>/Z7</code>）。</li>
</ul>
<hr>
<h3 id="4-导出函数的方式"><a href="#4-导出函数的方式" class="headerlink" title="4. 导出函数的方式"></a>4. <strong>导出函数的方式</strong></h3><ul>
<li>静态库的函数直接链接到目标代码，调用没有问题。</li>
<li>对于 DLL，需要通过导出函数表来访问函数。如果导出函数声明不正确，可能导致链接或调试问题。</li>
</ul>
<p>   <strong>解决方法</strong>：</p>
<ul>
<li>确保使用正确的导出宏定义。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MYLIB_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYLIB_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYLIB_API __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="5-调试器未加载-DLL-符号"><a href="#5-调试器未加载-DLL-符号" class="headerlink" title="5. 调试器未加载 DLL 符号"></a>5. <strong>调试器未加载 DLL 符号</strong></h3><ul>
<li>调试器可能没有正确加载 DLL 的符号，导致无法定位调试信息。</li>
</ul>
<p>   <strong>解决方法</strong>：</p>
<ul>
<li>在 Visual Studio 中，调试运行程序后，进入 <code>Debug -&gt; Windows -&gt; Modules</code>，检查目标 DLL 是否加载。</li>
<li>如果未加载符号，右键选择 <code>Load Symbols</code>，并指定符号文件路径。</li>
</ul>
<hr>
<h3 id="6-运行时不一致"><a href="#6-运行时不一致" class="headerlink" title="6. 运行时不一致"></a>6. <strong>运行时不一致</strong></h3><ul>
<li>静态库和主程序共享相同的运行时库，但动态链接库可能使用不同的运行时（如多线程 DLL 或单线程）。</li>
<li>如果运行时库不匹配，可能导致调试器行为异常。</li>
</ul>
<p>   <strong>解决方法</strong>：</p>
<ul>
<li>确保主程序和 DLL 使用相同的运行时配置（如 <code>/MDd</code> 或 <code>/MTd</code>）。</li>
</ul>
<hr>
<h3 id="7-DLL-加载路径问题"><a href="#7-DLL-加载路径问题" class="headerlink" title="7. DLL 加载路径问题"></a>7. <strong>DLL 加载路径问题</strong></h3><ul>
<li>如果调试器无法正确加载 DLL（例如，使用了错误版本的 DLL），可能无法调试。</li>
</ul>
<p>   <strong>解决方法</strong>：</p>
<ul>
<li>检查环境变量 <code>PATH</code> 是否包含目标 DLL 的路径。</li>
<li>使用绝对路径加载 DLL 或将 DLL 放在可执行文件目录中。</li>
</ul>
<hr>
<p>通过逐步排查以上问题，通常可以解决 DLL 无法调试的问题。如果需要更具体的帮助，请提供详细的环境信息（如使用的 IDE、编译器版本、DLL 的生成方式等）。</p>
<h2 id="C-字符串字面值-详解"><a href="#C-字符串字面值-详解" class="headerlink" title="C++ 字符串字面值 详解"></a>C++ 字符串字面值 详解</h2><p>C++ 中的<strong>字符串字面值</strong>是程序中直接写出的字符串常量，如 <code>&quot;Hello, World!&quot;</code>。字符串字面值是不可变的，并具有特定的类型和存储形式。C++ 支持多种类型的字符串字面值，包括普通字符串、宽字符字符串、UTF 编码字符串以及原始字符串。</p>
<hr>
<h3 id="字符串字面值的种类"><a href="#字符串字面值的种类" class="headerlink" title="字符串字面值的种类"></a><strong>字符串字面值的种类</strong></h3><ol>
<li><p><strong>普通字符串字面值</strong></p>
<ul>
<li>使用双引号括起来的字符串。</li>
<li>类型：<code>const char*</code>。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>宽字符字符串字面值</strong></p>
<ul>
<li>使用 <code>L</code> 前缀的字符串，表示宽字符字符串。</li>
<li>类型：<code>const wchar_t*</code>。</li>
<li>用于支持更大的字符集（如 Unicode）。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* wstr = <span class="string">L&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>UTF-8 字符串字面值</strong></p>
<ul>
<li>使用 <code>u8</code> 前缀的字符串，表示 UTF-8 编码的字符串。</li>
<li>类型：<code>const char*</code>（从 C++20 起为 <code>const char8_t*</code>）。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* utf8_str = <span class="string">u8&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>UTF-16 字符串字面值</strong></p>
<ul>
<li>使用 <code>u</code> 前缀的字符串，表示 UTF-16 编码的字符串。</li>
<li>类型：<code>const char16_t*</code>。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char16_t</span>* utf16_str = <span class="string">u&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>UTF-32 字符串字面值</strong></p>
<ul>
<li>使用 <code>U</code> 前缀的字符串，表示 UTF-32 编码的字符串。</li>
<li>类型：<code>const char32_t*</code>。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char32_t</span>* utf32_str = <span class="string">U&quot;Hello, World!&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>原始字符串字面值</strong></p>
<ul>
<li>使用 <code>R</code> 前缀的字符串，表示原始字符串，不会对转义字符（如 <code>\n</code>）进行处理。</li>
<li>类型：根据前缀决定。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* raw_str = <span class="string">R&quot;(This is a &quot;raw&quot; string\n)&quot;</span>; <span class="comment">// 输出中保留 \n</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="字符串字面值的特性"><a href="#字符串字面值的特性" class="headerlink" title="字符串字面值的特性"></a><strong>字符串字面值的特性</strong></h3><ol>
<li><p><strong>不可变性</strong></p>
<ul>
<li>字符串字面值是常量，不能直接修改。</li>
<li>修改尝试会导致未定义行为：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* str = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 不建议！</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>; <span class="comment">// 未定义行为</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>存储位置</strong></p>
<ul>
<li>通常存储在只读的内存段中（如 <code>.rodata</code>）。</li>
<li>在大多数编译器中，多个相同的字符串字面值可能被优化为共享同一块内存。</li>
</ul>
</li>
<li><p><strong>自动添加空字符</strong></p>
<ul>
<li>字符串字面值的末尾会自动添加空字符 <code>\0</code>。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment">// 实际内存中为 &#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>可以与 <code>std::string</code> 和 <code>std::wstring</code> 兼容</strong></p>
<ul>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::wstring ws = <span class="string">L&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="字符串字面值的常见操作"><a href="#字符串字面值的常见操作" class="headerlink" title="字符串字面值的常见操作"></a><strong>字符串字面值的常见操作</strong></h3><h4 id="拼接字符串字面值"><a href="#拼接字符串字面值" class="headerlink" title="拼接字符串字面值"></a><strong>拼接字符串字面值</strong></h4><ul>
<li>相邻的字符串字面值会自动拼接为一个整体。</li>
<li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, &quot;</span></span><br><span class="line">                  <span class="string">&quot;World!&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; str; <span class="comment">// 输出 &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a><strong>字符串长度</strong></h4><ul>
<li>使用 <code>sizeof</code> 或 <code>strlen</code> 获取字符串长度：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(str) &lt;&lt; std::endl; <span class="comment">// 指针大小</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">strlen</span>(str) &lt;&lt; std::endl; <span class="comment">// 实际字符串长度</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="使用原始字符串"><a href="#使用原始字符串" class="headerlink" title="使用原始字符串"></a><strong>使用原始字符串</strong></h4><ul>
<li>处理包含特殊字符的字符串更加方便：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* raw = <span class="string">R&quot;(Line1\nLine2)&quot;</span>; <span class="comment">// 不处理 \n</span></span><br><span class="line">std::cout &lt;&lt; raw;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="与-Unicode-的结合"><a href="#与-Unicode-的结合" class="headerlink" title="与 Unicode 的结合"></a><strong>与 Unicode 的结合</strong></h4><ul>
<li>使用 UTF-8、UTF-16 或 UTF-32：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char32_t</span>* u32_str = <span class="string">U&quot;你好，世界&quot;</span>; <span class="comment">// UTF-32 编码</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="字符串字面值的类型对比"><a href="#字符串字面值的类型对比" class="headerlink" title="字符串字面值的类型对比"></a><strong>字符串字面值的类型对比</strong></h3><table>
<thead>
<tr>
<th><strong>前缀</strong></th>
<th><strong>类型</strong></th>
<th><strong>编码</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>无前缀</td>
<td><code>const char*</code></td>
<td>ASCII&#x2F;UTF-8</td>
<td><code>&quot;Hello&quot;</code></td>
</tr>
<tr>
<td><code>L</code></td>
<td><code>const wchar_t*</code></td>
<td>宽字符</td>
<td><code>L&quot;Hello&quot;</code></td>
</tr>
<tr>
<td><code>u8</code></td>
<td><code>const char*</code> (C++20: <code>const char8_t*</code>)</td>
<td>UTF-8</td>
<td><code>u8&quot;Hello&quot;</code></td>
</tr>
<tr>
<td><code>u</code></td>
<td><code>const char16_t*</code></td>
<td>UTF-16</td>
<td><code>u&quot;Hello&quot;</code></td>
</tr>
<tr>
<td><code>U</code></td>
<td><code>const char32_t*</code></td>
<td>UTF-32</td>
<td><code>U&quot;Hello&quot;</code></td>
</tr>
<tr>
<td><code>R</code></td>
<td>根据前缀决定</td>
<td>原始字符串</td>
<td><code>R&quot;(Raw string \n)&quot;</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a><strong>完整示例</strong></h3><p>以下代码演示了多种字符串字面值的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* normal_str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span>* wide_str = <span class="string">L&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char16_t</span>* utf16_str = <span class="string">u&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char32_t</span>* utf32_str = <span class="string">U&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* raw_str = <span class="string">R&quot;(C:\Program Files\MyApp)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Normal String: &quot;</span> &lt;&lt; normal_str &lt;&lt; std::endl;</span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;Wide String: &quot;</span> &lt;&lt; wide_str &lt;&lt; std::endl;</span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;Raw String: &quot;</span> &lt;&lt; raw_str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Normal String: Hello, World!</span><br><span class="line">Wide String: Hello, World!</span><br><span class="line">Raw String: C:\Program Files\MyApp</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>多字节编码问题</strong>：</p>
<ul>
<li>如果需要支持多语言，建议使用 UTF 编码字符串（如 <code>u8</code> 或 <code>u</code> 前缀）。</li>
</ul>
</li>
<li><p><strong>C++20 变化</strong>：</p>
<ul>
<li>UTF-8 字符串的类型从 <code>const char*</code> 改为 <code>const char8_t*</code>，需要特别注意兼容性。</li>
</ul>
</li>
<li><p>**使用 <code>std::string</code> 和 <code>std::wstring</code>**：</p>
<ul>
<li>字符串字面值通常会转换为 <code>std::string</code> 或 <code>std::wstring</code> 以便操作：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">std::wstring wstr = <span class="string">L&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>如果你有更具体的疑问或需要深入解析某个点，可以继续提问！</p>
<h2 id="C-L”model-onnx”-是什么意思"><a href="#C-L”model-onnx”-是什么意思" class="headerlink" title="C++ L”model.onnx” 是什么意思"></a>C++ L”model.onnx” 是什么意思</h2><p>在 C++ 中，<code>L&quot;model.onnx&quot;</code> 是一种 <strong>宽字符（wide character）字符串字面值</strong>。它表示一个宽字符类型的字符串，其元素类型是 <code>wchar_t</code>。宽字符字符串支持更广泛的字符集，特别是在需要支持 Unicode 字符时非常有用。</p>
<hr>
<h3 id="详细解析"><a href="#详细解析" class="headerlink" title="详细解析"></a><strong>详细解析</strong></h3><ol>
<li><p><strong><code>L</code> 前缀</strong>：</p>
<ul>
<li><code>L</code> 是宽字符字符串的前缀，用于告诉编译器该字符串是宽字符类型。</li>
<li>它将字符串字面值的每个字符存储为 <code>wchar_t</code> 类型，而不是普通的 <code>char</code> 类型。</li>
</ul>
</li>
<li><p><strong>存储方式</strong>：</p>
<ul>
<li>常规字符串（没有 <code>L</code> 的字面值，例如 <code>&quot;model.onnx&quot;</code>）使用 <code>char</code> 类型存储，每个字符占 1 个字节（在 ASCII 或 UTF-8 编码下）。</li>
<li>带有 <code>L</code> 前缀的宽字符字符串使用 <code>wchar_t</code> 类型存储，通常每个字符占 <strong>2 个字节（UTF-16）</strong> 或 <strong>4 个字节（UTF-32）</strong>，具体取决于平台和编译器。</li>
</ul>
</li>
<li><p><strong>类型</strong>：</p>
<ul>
<li>字符串字面值 <code>L&quot;model.onnx&quot;</code> 的类型是 <code>const wchar_t*</code>，而非 <code>const char*</code>。</li>
<li>每个字符都是宽字符。</li>
</ul>
</li>
<li><p><strong>用途</strong>：</p>
<ul>
<li>宽字符字符串在需要支持多语言字符集（如中文、日文、韩文等）时使用。</li>
<li>通常与 Unicode 编码（如 UTF-16 或 UTF-32）结合，用于跨平台和国际化程序。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="对比示例"><a href="#对比示例" class="headerlink" title="对比示例"></a><strong>对比示例</strong></h3><h4 id="普通字符串（char-）"><a href="#普通字符串（char-）" class="headerlink" title="普通字符串（char*）"></a><strong>普通字符串（<code>char*</code>）</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;model.onnx&quot;</span>; <span class="comment">// 普通字符串，类型为 const char*</span></span><br></pre></td></tr></table></figure>
<ul>
<li>每个字符是 <code>char</code> 类型，占 1 个字节。</li>
</ul>
<h4 id="宽字符字符串（wchar-t-）"><a href="#宽字符字符串（wchar-t-）" class="headerlink" title="宽字符字符串（wchar_t*）"></a><strong>宽字符字符串（<code>wchar_t*</code>）</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* wstr = <span class="string">L&quot;model.onnx&quot;</span>; <span class="comment">// 宽字符字符串，类型为 const wchar_t*</span></span><br></pre></td></tr></table></figure>
<ul>
<li>每个字符是 <code>wchar_t</code> 类型，占 2 或 4 个字节（根据平台）。</li>
</ul>
<hr>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a><strong>常见场景</strong></h3><ol>
<li><p><strong>文件路径处理（Windows）</strong>：</p>
<ul>
<li>在 Windows API 中，许多函数要求使用宽字符字符串（如 <code>CreateFileW</code>）。</li>
<li>例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* file_path = <span class="string">L&quot;model.onnx&quot;</span>;</span><br><span class="line">HANDLE file = <span class="built_in">CreateFileW</span>(file_path, ...);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>多语言支持</strong>：</p>
<ul>
<li>程序需要处理非 ASCII 字符时（如中文文件名）：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* greeting = <span class="string">L&quot;你好，世界&quot;</span>;</span><br><span class="line"><span class="built_in">wprintf</span>(<span class="string">L&quot;%ls\n&quot;</span>, greeting); <span class="comment">// 输出宽字符字符串</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>与 Unicode 编码配合</strong>：</p>
<ul>
<li>宽字符字符串常与 <code>std::wstring</code> 一起使用，表示宽字符字符串对象：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::wstring wstr = <span class="string">L&quot;model.onnx&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>平台差异</strong>：</p>
<ul>
<li>在 Windows 上，<code>wchar_t</code> 通常是 <strong>2 字节</strong>（UTF-16）。</li>
<li>在 Linux 和 macOS 上，<code>wchar_t</code> 通常是 <strong>4 字节</strong>（UTF-32）。</li>
</ul>
</li>
<li><p><strong>编码问题</strong>：</p>
<ul>
<li>宽字符本身不指定具体的编码，可能是 UTF-16 或 UTF-32。</li>
<li>如果需要与外部库交互，确保使用的编码一致。</li>
</ul>
</li>
<li><p><strong>与普通字符串转换</strong>：</p>
<ul>
<li>如果需要在宽字符和普通字符之间转换，可以使用库函数（如 <code>std::mbstowcs</code> 和 <code>std::wcstombs</code>）或更现代的方式（如 <code>std::codecvt</code> 或 ICU 库）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="完整示例-1"><a href="#完整示例-1" class="headerlink" title="完整示例"></a><strong>完整示例</strong></h3><p>以下代码展示了宽字符字符串的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 宽字符字符串</span></span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span>* wstr = <span class="string">L&quot;model.onnx&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出宽字符字符串</span></span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;宽字符字符串内容: &quot;</span> &lt;&lt; wstr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为 std::wstring</span></span><br><span class="line">    <span class="function">std::wstring <span class="title">ws</span><span class="params">(wstr)</span></span>;</span><br><span class="line">    std::wcout &lt;&lt; <span class="string">L&quot;std::wstring 内容: &quot;</span> &lt;&lt; ws &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行输出（假设 UTF-16 编码）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">宽字符字符串内容: model.onnx</span><br><span class="line">std::wstring 内容: model.onnx</span><br></pre></td></tr></table></figure>

<p>如果你还有更深入的问题，比如如何转换宽字符字符串或在实际工程中如何应用，可以进一步讨论！</p>
<h2 id="C-将布尔值取反"><a href="#C-将布尔值取反" class="headerlink" title="C++ 将布尔值取反"></a>C++ 将布尔值取反</h2><p>在 C++ 中，可以使用逻辑取反运算符 <code>!</code> 来将布尔值取反。该运算符会将 <code>true</code> 转换为 <code>false</code>，将 <code>false</code> 转换为 <code>true</code>。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;  <span class="comment">// 输出 1（true）</span></span><br><span class="line">    </span><br><span class="line">    value = !value;  <span class="comment">// 取反操作</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Negated value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;  <span class="comment">// 输出 0（false）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Original value: 1</span><br><span class="line">Negated value: 0</span><br></pre></td></tr></table></figure>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>在条件语句中切换逻辑：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!condition) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Condition is false&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在循环中反转标志位：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">flag = !flag;  <span class="comment">// 切换 flag 的状态</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>如果将非布尔类型与 <code>!</code> 一起使用，会隐式转换为布尔值：0 转为 <code>false</code>，非 0 转为 <code>true</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">std::cout &lt;&lt; !num &lt;&lt; std::endl;  <span class="comment">// 输出 0（因为 5 为 true，取反为 false）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="C-位操作-获取比特位中指定位置的值"><a href="#C-位操作-获取比特位中指定位置的值" class="headerlink" title="C 位操作 获取比特位中指定位置的值"></a>C 位操作 获取比特位中指定位置的值</h2><p>在 C 语言中，你可以使用位操作来获取整数中特定位的值。假设你有一个整数（<code>int</code> 或 <code>unsigned int</code>），并且你想要获取它的第 <code>n</code> 个比特位（从0开始计数，最低位为第0位）的值，可以使用以下步骤：</p>
<h3 id="获取指定比特位的值"><a href="#获取指定比特位的值" class="headerlink" title="获取指定比特位的值"></a>获取指定比特位的值</h3><p>假设我们有一个整数 <code>num</code>，想要获取它的第 <code>n</code> 位的值。我们可以通过以下步骤实现：</p>
<ol>
<li><strong>右移</strong>：将整数右移 <code>n</code> 位，使得我们感兴趣的位移动到最低位。</li>
<li><strong>按位与</strong>：对右移后的结果与 <code>1</code> 进行按位与操作，提取最低位的值（即我们需要的第 <code>n</code> 位的值）。</li>
</ol>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0b10101100</span>; <span class="comment">// 示例整数</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>; <span class="comment">// 要获取的比特位位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第 n 位的值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bit_value = (num &gt;&gt; n) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The value of bit %d is: %u\n&quot;</span>, n, bit_value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ul>
<li><code>num &gt;&gt; n</code>：将 <code>num</code> 右移 <code>n</code> 位。这样，第 <code>n</code> 位就移动到了最低位。</li>
<li><code>(num &gt;&gt; n) &amp; 1</code>：使用按位与操作符 <code>&amp;</code> 来提取最低位的值。如果最低位是 <code>1</code>，结果是 <code>1</code>；如果是 <code>0</code>，结果是 <code>0</code>。</li>
</ul>
<h3 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a>示例输出</h3><p>如果 <code>num = 0b10101100</code>，并且 <code>n = 5</code>，那么第 <code>5</code> 位是 <code>1</code>，因此输出将是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The value of bit 5 is: 1</span><br></pre></td></tr></table></figure>

<p>通过这种方式，你可以获取整数中任意比特位的值。</p>
<h2 id="C-将两个uint8-t的数据拼接成一个uint16-t的数据"><a href="#C-将两个uint8-t的数据拼接成一个uint16-t的数据" class="headerlink" title="C++ 将两个uint8_t的数据拼接成一个uint16_t的数据"></a>C++ 将两个uint8_t的数据拼接成一个uint16_t的数据</h2><p>在C++中，如果你有两个 <code>uint8_t</code> 类型的数据，并且你想将它们拼接成一个 <code>uint16_t</code> 类型的数据，可以通过位移和按位或操作来实现。通常，这两个 <code>uint8_t</code> 数据分别作为拼接后的高位和低位。</p>
<h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><p>假设你有两个 <code>uint8_t</code> 类型的变量 <code>high_byte</code> 和 <code>low_byte</code>，你可以将它们拼接成一个 <code>uint16_t</code> 类型的变量 <code>result</code>，其中 <code>high_byte</code> 是高 8 位，<code>low_byte</code> 是低 8 位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint8_t</span> high_byte = <span class="number">0xAB</span>;  <span class="comment">// 高位字节，例如 0xAB</span></span><br><span class="line">    <span class="type">uint8_t</span> low_byte = <span class="number">0xCD</span>;   <span class="comment">// 低位字节，例如 0xCD</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接成一个uint16_t</span></span><br><span class="line">    <span class="type">uint16_t</span> result = (<span class="built_in">static_cast</span>&lt;<span class="type">uint16_t</span>&gt;(high_byte) &lt;&lt; <span class="number">8</span>) | low_byte;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::hex &lt;&lt; <span class="string">&quot;Result: 0x&quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><ul>
<li><code>static_cast&lt;uint16_t&gt;(high_byte) &lt;&lt; 8</code>：首先，将 <code>high_byte</code> 转换为 <code>uint16_t</code> 类型，然后将它左移 8 位，使其成为 <code>result</code> 的高位。</li>
<li><code>| low_byte</code>：使用按位或操作符 <code>|</code> 将 <code>low_byte</code> 添加到 <code>result</code> 的低 8 位。</li>
</ul>
<h3 id="示例输出-1"><a href="#示例输出-1" class="headerlink" title="示例输出"></a>示例输出</h3><p>如果 <code>high_byte = 0xAB</code> 且 <code>low_byte = 0xCD</code>，那么拼接后的 <code>result</code> 是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result: 0xABCD</span><br></pre></td></tr></table></figure>

<p>这个结果表示 <code>high_byte</code> 成为 <code>result</code> 的高 8 位，而 <code>low_byte</code> 成为 <code>result</code> 的低 8 位。</p>
<h2 id="C-将整数输出二进制"><a href="#C-将整数输出二进制" class="headerlink" title="C++ 将整数输出二进制"></a>C++ 将整数输出二进制</h2><p>在C++中，将整数以二进制格式输出有多种方法。可以使用手动位操作实现，也可以利用标准库中的函数来完成。下面是几种方法来实现这一功能。</p>
<h3 id="方法1：使用位操作手动输出二进制"><a href="#方法1：使用位操作手动输出二进制" class="headerlink" title="方法1：使用位操作手动输出二进制"></a>方法1：使用位操作手动输出二进制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">29</span>; <span class="comment">// 示例整数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Binary representation of &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; is: &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        std::cout &lt;&lt; ((num &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码解释-2"><a href="#代码解释-2" class="headerlink" title="代码解释"></a>代码解释</h3><ul>
<li><code>num &gt;&gt; i</code>：将 <code>num</code> 右移 <code>i</code> 位，使得我们感兴趣的位移动到最低位。</li>
<li><code>((num &gt;&gt; i) &amp; 1)</code>：提取最低位的值，并将其输出。</li>
</ul>
<p>在这个例子中，假设 <code>num = 29</code>，二进制输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Binary representation of 29 is: 00000000000000000000000000011101</span><br></pre></td></tr></table></figure>

<h3 id="方法2：使用-bitset"><a href="#方法2：使用-bitset" class="headerlink" title="方法2：使用 bitset"></a>方法2：使用 <code>bitset</code></h3><p>C++ 标准库提供了 <code>std::bitset</code>，可以方便地将整数转换为二进制表示并输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">29</span>; <span class="comment">// 示例整数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::bitset&lt;32&gt; <span class="title">binary</span><span class="params">(num)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Binary representation of &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; binary &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码解释-3"><a href="#代码解释-3" class="headerlink" title="代码解释"></a>代码解释</h3><ul>
<li><code>std::bitset&lt;32&gt;</code>：创建一个大小为32位的 <code>bitset</code>，并用 <code>num</code> 的值来初始化它。</li>
<li><code>binary</code>：<code>bitset</code> 会自动将整数转换为二进制格式并存储。</li>
</ul>
<p>输出结果同样会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Binary representation of 29 is: 00000000000000000000000000011101</span><br></pre></td></tr></table></figure>

<h3 id="方法3：模板实现支持不同位数"><a href="#方法3：模板实现支持不同位数" class="headerlink" title="方法3：模板实现支持不同位数"></a>方法3：模板实现支持不同位数</h3><p>如果你想实现一个可以处理任意位数的模板函数，可以使用以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBinary</span><span class="params">(T num)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::bitset&lt;<span class="title">sizeof</span><span class="params">(T)</span> * 8&gt; <span class="title">binary</span><span class="params">(num)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Binary representation: &quot;</span> &lt;&lt; binary &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">29</span>; <span class="comment">// 示例整数</span></span><br><span class="line">    <span class="built_in">printBinary</span>(num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码解释-4"><a href="#代码解释-4" class="headerlink" title="代码解释"></a>代码解释</h3><ul>
<li><code>sizeof(T) * 8</code>：计算类型 <code>T</code> 的位数，并用 <code>bitset</code> 表示。</li>
<li><code>printBinary</code>：模板函数可以处理不同类型的整数（<code>uint8_t</code>, <code>uint16_t</code>, <code>int</code>, 等）。</li>
</ul>
<p>这会自动根据输入的整数类型调整输出的二进制位数。对于 <code>num = 29</code>，输出将是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Binary representation: 00000000000000000000000000011101</span><br></pre></td></tr></table></figure>

<p>这些方法都能有效地将整数转换为二进制并输出。你可以根据需求选择最适合你的方法。</p>
<h2 id="const-constexpr"><a href="#const-constexpr" class="headerlink" title="const&#x2F;constexpr"></a>const&#x2F;constexpr</h2><ul>
<li><p>const一般的用法就是修饰变量、引用、指针，修饰之后它们就变成了常量，需要注意的是const并未区分出编译期常量和运行期常量，并且const只保证了运行时不直接被修改。</p>
</li>
<li><p>一般的情况，const 也就简单这么用一下，const 放在左边，表示常量：</p>
<ul>
<li>const int x &#x3D; 100; &#x2F;&#x2F; 常量</li>
<li>const int&amp; rx &#x3D; x; &#x2F;&#x2F; 常量引用</li>
<li>const int* px &#x3D; &x; &#x2F;&#x2F; 常量指针</li>
</ul>
</li>
<li><p>给变量加上const之后就成了“常量”，只能读、不能修改，编译器会检查出所有对它的修改操作，发出警告，在编译阶段防止有意或者无意的修改。这样一来，const常量用起来就相对安全一点。在设计函数的时候，将参数用 const 修饰的话，可以保证效率和安全。</p>
</li>
<li><p>除此之外，const 还能声明在成员函数上，const 被放在了函数的后面，表示这个函数是一个“常量”，函数的执行过程是 const 的，不会修改成员变量。</p>
</li>
<li><p>此外，const还有下面这种与指针结合的比较绕的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* p1 = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *p = 2; // error C3892: “p”: 不能给常量赋值</span></span><br><span class="line">p = &amp;b;</span><br><span class="line"><span class="comment">// *p1 = 3; // error C3892: “p1”: 不能给常量赋值</span></span><br><span class="line">p1 = &amp;b;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p2 = &amp;a;</span><br><span class="line"><span class="comment">//p2 = &amp;b; // error C2440: “=”: 无法从“const int *”转换为“int *const ”</span></span><br><span class="line">*p2 = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p3 = &amp;a;</span><br></pre></td></tr></table></figure></li>
<li><p>const int 与 int const并无很大区别，都表示： 指向常量的指针，可以修改指针本身，但不能通过指针修改所指向的值。</p>
</li>
<li><p>而对于int *const，则是表示：一个常量指针，可以修改所指向的值，但不能修改指针本身。</p>
</li>
<li><p>const int* const 表示一个不可修改的指针，既不能修改指针本身，也不能通过指针修改所指向的值。</p>
</li>
<li><p>总之，const默认与其左边结合，当左边没有任何东西则与右边结合。</p>
</li>
<li><p>constexpr,表面上看，constexpr不仅是const，而且在编译期间就已知，这种说法并不全面，当它应用在函数上时，就跟它名字有点不一样了。使用constexpr关键字可以将对象或函数定义为在编译期间可求值的常量，这样可以在编译期间进行计算，避免了运行时的开销</p>
</li>
<li><p>constexpr对象 必须在编译时就能确定其值，并且通常用于基本数据类型。例如：</p>
<ul>
<li>constexpr int MAX_SIZE &#x3D; 100; &#x2F;&#x2F; 定义一个编译时整型常量</li>
<li>constexpr double PI &#x3D; 3.14159; &#x2F;&#x2F; 定义一个编译时双精度浮点型常量</li>
</ul>
</li>
<li><p>const和constexpr变量之间的主要区别在于变量的初始化，const可以推迟到运行时，constexpr变量必须在编译时初始化。const 并未区分出编译期常量和运行期常量，并且const只保证了运行时不直接被修改，而constexpr是限定在了编译期常量。简而言之，所有constexpr对象都是const对象，而并非所有的const对象都是constexpr对象。</p>
</li>
<li><p>当变量具有字面型别(literal type)(这样的型别能够持有编译期可以决议的值)并已初始化时，可以使用constexpr来声明该变量。如果初始化由构造函数执行，则必须将构造函数声明为constexpr.</p>
</li>
<li><p>当满足这两个条件时，可以声明引用constexpr：引用的对象由常量表达式初始化，并且在初始化期间调用的任何隐式转换也是常量表达式。</p>
</li>
<li><p>constexpr变量或函数的所有声明都必须具有constexpr说明符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">float</span> x = <span class="number">42.0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">float</span> y&#123;<span class="number">108</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">float</span> z = <span class="built_in">exp</span>(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i; <span class="comment">// Error! Not initialized</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> k = j + <span class="number">1</span>; <span class="comment">//Error! j not a constant expression</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>constexpr函数 是指能够在编译期间计算结果的函数。它们的参数和返回值类型必须是字面值类型，并且函数体必须由单个返回语句组成。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x * x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>constexpr int result &#x3D; square(5); &#x2F;&#x2F; 在编译期间计算结果，result 的值为 25</p>
</li>
<li><p>使用 constexpr 可以提高程序的性能和效率，因为它允许在编译期间进行计算，避免了运行时的计算开销。同时，constexpr 还可以用于指定数组的大小、模板参数等场景，提供更灵活的编程方式。</p>
</li>
<li><p>对constexpr函数的理解：</p>
<ul>
<li>constexpr函数可以用在要求编译器常量的语境中。在这样的语境中，如果你传给constexpr函数的实参值是在编译期已知的，则结果也会在编译期间计算出来。如果任何一个实参值在编译期间未知，则代码将无法通过编译。</li>
<li>在调用constexpr函数时，若传入的值有一个或多个在编译期间未知，则它的运作方式和普通函数无异，也就是它也是在运行期执行结果的计算。也就是说，如果一个函数执行的是同样的操作，仅仅应用语境一个是要求编译期常量，一个是用于所有其他值的话，那就不必写两个函数。constexpr函数就可以同时满足需求。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">float</span> <span class="title">exp</span><span class="params">(<span class="type">float</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> :</span><br><span class="line">        n % <span class="number">2</span> == <span class="number">0</span> ? <span class="built_in">exp</span>(x * x, n / <span class="number">2</span>) :</span><br><span class="line">        <span class="built_in">exp</span>(x * x, (n - <span class="number">1</span>) / <span class="number">2</span>) * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> n = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> result = <span class="built_in">exp</span>(x, n); <span class="comment">// ok, 前面加上constexpr，进行编译期间求值，单步调试根本进不去</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> xx = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> nn = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//constexpr int result2 = exp(xx, nn); // error C2131: 表达式的计算结果不是常数</span></span><br><span class="line"><span class="type">int</span> result3 = <span class="built_in">exp</span>(xx, nn); <span class="comment">// ok, 这里作为普通函数来使用</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>比起非constexpr对象或constexpr函数而言，constexpr对象或是constexpr函数可以用在一个作用域更广的语境中。只要有可能使用constexpr，就使用它吧。</p>
</li>
</ul>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><ul>
<li>尤其是在跨平台开发的时候更加要注意这类隐晦的异常问题，Effective C++中也提到了，要以独立语句将new对象存储于智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的内存泄漏。</li>
</ul>
<h2 id="std-async真的异步吗"><a href="#std-async真的异步吗" class="headerlink" title="std::async真的异步吗"></a>std::async真的异步吗</h2><ul>
<li><p>std::async是C++11开始支持多线程时加入的同步多线程构造函数，其弥补了std::thread没有返回值的问题，并加入了更多的特性，使得多线程更加灵活</p>
</li>
<li><p>顾名思义，std::async是一个函数模板，它将函数或函数对象作为参数(称为回调)并异步运行它们，最终返回一个std::future，它存储std::async()执行的函数对象返回的值，为了从中获取值，程序员需要调用其成员 future::get.</p>
</li>
<li><p>那std::async一定是异步执行吗？先来看段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate_sum</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Start Calculate...&quot;</span> &lt;&lt; std::endl; <span class="comment">// (4)</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123; <span class="number">88</span>, <span class="number">101</span>, <span class="number">56</span>, <span class="number">203</span>, <span class="number">72</span>, <span class="number">135</span> &#125;;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; future_sum = std::<span class="built_in">async</span>(calculate_sum, numbers);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Other operations are in progress...&quot;</span> &lt;&lt; std::endl; <span class="comment">// (1)</span></span><br><span class="line">    <span class="type">int</span> counter = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (counter &lt;= <span class="number">1000000000</span>) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Other operations are completed.&quot;</span> &lt;&lt; std::endl; <span class="comment">// (2)</span></span><br><span class="line">    <span class="comment">// 等待异步任务完成并获取结果</span></span><br><span class="line">    <span class="type">int</span> sum = future_sum.<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The calculation result is:&quot;</span> &lt;&lt; sum &lt;&lt; std::endl; <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行完(1) (2), 然后再(4)(3), 说明是真正调用std::future&lt;&gt;::get()才去执行的，如果没有调用get，那么就一直不会执行。</p>
</li>
<li><p>std::async是否异步受参数控制的，其第一个参数是启动策略，它控制 std::async 的异步行为。可以使用 3 种不同的启动策略创建 std::async ，即：</p>
<ul>
<li>std::launch::async 它保证异步行为，即传递的函数将在单独的线程中执行</li>
<li>std::launch::deferred 非异步行为，即当其他线程将来调用get()来访问共享状态时，将调用函数</li>
<li>std::launch::async | std::launch::deferred 它是默认行为。使用此启动策略，它可以异步运行或不异步运行，具体取决于系统上的负载，但我们无法控制它</li>
</ul>
</li>
<li><p>如果我们不指定启动策略，其行为类似于std::launch::async | std::launch::deferred. 也就是不一定是异步的。</p>
</li>
<li><p>Effective Modern C++ 里面也提到了，如果异步执行是必须的，则指定std::launch::async策略。</p>
</li>
</ul>
<h2 id="sizeof-strlen"><a href="#sizeof-strlen" class="headerlink" title="sizeof &amp; strlen"></a>sizeof &amp; strlen</h2><ul>
<li><p>相信大家都有过这样的经历，在项目中使用系统API或者与某些公共库编写逻辑时，需要C++与C 字符串混写甚至转换，在处理字符串结构体的时候就免不了使用sizeof和strlen，这俩看着都有计算size的能力，有时候很容易搞混淆或者出错。</p>
</li>
<li><p>sizeof 是个操作符，可用于任何类型或变量，包括数组、结构体、指针等, 返回的是一个类型或变量所占用的字节数; 在编译时求值，不会对表达式进行求值。</p>
</li>
<li><p>strlen 是个函数，只能用于以 null 字符结尾的字符串，返回的是一个以 null 字符（’\0’）结尾的字符串的长度(不包括 null 字符本身)，且在运行时才会计算字符串的长度。</p>
</li>
<li><p>需要注意的是，使用 sizeof 操作符计算数组长度时需要注意数组元素类型的大小。例如，对于一个 int 类型的数组，使用 sizeof 操作符计算其长度应该为 sizeof(array) &#x2F; sizeof(int)。而对于一个字符数组，使用strlen函数计算其长度应该为 strlen(array)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = str;</span><br></pre></td></tr></table></figure></li>
<li><p>此时，用sizeof(str)得到的是6，因为hello是5个字符，系统储存的时候会在hello的末尾加上结束标识\0，一共为6个字符；</p>
</li>
<li><p>而sizeof(p)得到的却是4，它求得的是指针变量p的长度，在32位机器上，一个地址都是32位，即4个字节。</p>
<ul>
<li>用sizeof(p)得到的是1，因为p定义为char,相当于一个字符，所以只占一个字节</li>
<li>用strlen(str)，得到的会是5，因为strlen求得的长度不包括最后的\0。</li>
<li>用strlen(p)，得到的是5，与strlen(str)等价。</li>
</ul>
</li>
<li><p>上面的是sizeof和strlen的区别，也是指针字符串和数组字符串的区别。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* src = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span>* dest = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(src); <span class="comment">// 这里很容易出错，写成sizeof(src)就是求指针的长度，即4</span></span><br><span class="line">dest = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len + <span class="number">1</span>); <span class="comment">// 这里很容易出错，写成len</span></span><br><span class="line"><span class="type">char</span>* d = dest;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* s = &amp;src[len - <span class="number">1</span>]; <span class="comment">// 这里很容易出错，写成len</span></span><br><span class="line"><span class="keyword">while</span> (len-- != <span class="number">0</span>) &#123;</span><br><span class="line">     *d++ = *s--;</span><br><span class="line">&#125;</span><br><span class="line">*d = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 这句很容易漏写</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%sIn&quot;</span>, dest);</span><br><span class="line"><span class="built_in">free</span>(dest);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="std-shared-ptr线程安全"><a href="#std-shared-ptr线程安全" class="headerlink" title="std::shared_ptr线程安全"></a>std::shared_ptr线程安全</h2><ul>
<li><p>对shared_ptr相信大家都很熟悉，但是一提到是否线程安全，可能很多人心里就没底了，借助本节，对shared_ptr线程安全方面的问题进行分析和解释。shared_ptr的线程安全问题主要有两种：</p>
<ol>
<li>引用计数的加减操作是否线程安全; </li>
<li>shared_ptr修改指向时是否线程安全</li>
</ol>
</li>
<li><p>引用计数</p>
<ul>
<li>shared_ptr中有两个指针，一个指向所管理数据的地址，另一个指向执行控制块的地址。</li>
<li>执行控制块包括对关联资源的引用计数以及弱引用计数等。在前面我们提到shared_ptr支持跨线程操作，引用计数变量是存储在堆上的，那么在多线程的情况下，指向同一数据的多个shared_ptr在进行计数的++或–时是否线程安全呢？</li>
<li>引用计数在STL中的定义如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_Atomic_word _M_use_count;   <span class="comment">// #shared</span></span><br><span class="line">_Atomic_word _M_weak_count;  <span class="comment">// #weak + (#shared != 0)</span></span><br></pre></td></tr></table></figure></li>
<li>当对shared_ptr进行拷贝时，引入计数增加，实现如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> _Sp_counted_base&lt;_S_atomic&gt;::_M_add_ref_lock_nothrow() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="comment">// Perform lock-free add-if-not-zero operation.</span></span><br><span class="line">    _Atomic_word __count = _M_get_use_count();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (__count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// Replace the current counter value with the old value + 1, as</span></span><br><span class="line">        <span class="comment">// long as it&#x27;s not changed meanwhile.</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!__atomic_compare_exchange_n(&amp;_M_use_count, &amp;__count, __count + <span class="number">1</span>, <span class="literal">true</span>, __ATOMIC_ACQ_REL,</span><br><span class="line">                                          __ATOMIC_RELAXED));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _Sp_counted_base&lt;_S_single&gt;::_M_add_ref_copy() &#123;</span><br><span class="line">    ++_M_use_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对引用计数的增加主要有以下2种方法：_M_add_ref_copy函数，对_M_use_count + 1，是原子操作。_M_add_ref_lock函数，是调用__atomic_compare_exchange_n<code>实现的</code>，主要逻辑仍然是_M_use_count + 1，而该函数是线程安全的，和_M_add_ref_copy的区别是对不同_Lock_policy有不同的实现，包含直接加、原子操作加、加锁。</li>
<li>因此我们可以得出结论：在多线程环境下，管理同一个数据的shared_ptr在进行计数的增加或减少的时候是线程安全的，这是一波原子操作。</li>
</ul>
</li>
<li><p>修改指向</p>
<ul>
<li>修改指向分为操作同一个shared_ptr对象和操作不同的shared_ptr对象两种</li>
</ul>
</li>
<li><p>多线程代码操作的是同一个shared_ptr的对象</p>
<ul>
<li>比如std::thread的回调函数，是一个lambda表达式，其中引用捕获了一个shared_ptr对象<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;A&gt; sp1 = <span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line"><span class="function">std::thread <span class="title">td</span><span class="params">([&amp;sp1] () &#123;....&#125;)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>又或者通过回调函数的参数传入的shared_ptr对象，参数类型是指针或引用:<ul>
<li><code>指针类型：void fn(shared_ptr&lt;A&gt;* sp) &#123; ... &#125;std::thread td(fn, &amp;sp1);引用类型：void fn(shared_ptr&lt;A&gt;&amp; sp) &#123; ... &#125;std::thread td(fn, std::ref(sp1));</code></li>
</ul>
</li>
<li>当你在多线程回调中修改shared_ptr指向的时候，这时候确实不是线程安全的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(shared_ptr&lt;A&gt;&amp; sp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (..) &#123;</span><br><span class="line">        sp = other_sp;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        sp = other_sp2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>shared _ptr内数据指针要修改指向，sp原先指向的引用计数的值要减去1，other_sp指向的引用计数值要加1。然而这几步操作加起来并不是一个原子操作，如果多个线程都在修改sp的指向的时候，那么有可能会出问题。比如在导致计数在操作-1的时候，其内部的指向已经被其他线程修改过了，引用计数的异常会导致某个管理的对象被提前析构，后续在使用到该数据的时候触发coredump。当然如果你没有修改指向的时候，是没有问题的。也就是：<ul>
<li>同一个shared_ptr对象被多个线程同时读是安全的</li>
<li>同一个shared_ptr对象被多个线程同时读写是不安全的</li>
</ul>
</li>
</ul>
</li>
<li><p>多线程代码操作的不是同一个shared_ptr的对象</p>
<ul>
<li>这里指的是管理的数据是同一份，而shared_ptr不是同一个对象，比如多线程回调的lambda是按值捕获的对象。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">td</span><span class="params">([sp1] () &#123;....&#125;)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>或者参数传递的shared_ptr是值传递，而非引用：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(shared_ptr&lt;A&gt; sp)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">td</span><span class="params">(fn, sp1)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>这时候每个线程内看到的sp，他们所管理的是同一份数据，用的是同一个引用计数。但是各自是不同的对象，当发生多线程中修改sp指向的操作的时候，是不会出现非预期的异常行为的。也就是说，如下操作是安全的：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">(shared_ptr&lt;A&gt; sp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (..) &#123;</span><br><span class="line">        sp = other_sp;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        sp = other_sp2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>尽管前面我们提到了如果是按值捕获(或传参)的shared_ptr对象，那么该对象是线程安全的，然而话虽如此，但却可能让人误入歧途。因为我们使用shared_ptr更多的是操作其中的数据，对齐管理的数据进行读写，尽管在按值捕获的时候shared_ptr是线程安全的，我们不需要对此施加额外的同步操作(比如加解锁），但是这并不意味着shared_ptr所管理的对象是线程安全的！请注意这是两回事。</li>
<li>最后再来看下std官方手册是怎么讲的：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">All member functions (including copy constructor and copy assignment) can be called by multiple threads on different instances of shared_ptr without additional synchronization even if these instances are copies and share ownership of the same object. If multiple threads of execution access the same instance of shared_ptr without synchronization and any of those accesses uses a non-const member function of shared_ptr then a data race will occur; the shared_ptr overloads of atomic functions can be used to prevent the data race.</span><br></pre></td></tr></table></figure></li>
<li>这段话的意思是，shared_ptr 的所有成员函数(包括复制构造函数和复制赋值运算符)都可以由多个线程在不同的 shared_ptr 实例上调用，即使这些实例是副本并且共享同一个对象的所有权。如果多个执行线程在没有同步的情况下访问同一个 shared_ptr 实例，并且这些访问中的任何一个使用了 shared_ptr 的非 const 成员函数，则会发生数据竞争；可以使用shared_ptr的原子函数重载来防止数据竞争。</li>
<li>我们可以得到下面的结论：<ul>
<li>多线程环境中，对于持有相同裸指针的std::shared_ptr实例，所有成员函数的调用都是线程安全的。<ul>
<li>当然，对于不同的裸指针的 std::shared_ptr 实例，更是线程安全的</li>
<li>这里的 “成员函数” 指的是 std::shared_ptr 的成员函数，比如 get ()、reset ()、operrator-&gt;()等</li>
</ul>
</li>
</ul>
</li>
<li>多线程环境中，对于同一个std::shared_ptr实例，只有访问const的成员函数，才是线程安全的，对于非const成员函数，是非线程安全的，需要加锁访问。</li>
</ul>
</li>
</ul>
<h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><ul>
<li><p>在众多编程语言中C++的优势之一便是其高性能，可是开发者代码写得不好(比如：很多不必要的对象拷贝)，直接会影响到代码性能，接下来就讲几个常见的会引起无意义拷贝的场景</p>
</li>
<li><p>for循环</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vec;</span><br><span class="line"><span class="keyword">for</span>(std::string s: vec) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> s: vec) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这里每个string都会被拷贝一次，为避免无意义拷贝可以将其改成：</p>
</li>
<li><p>for(const auto&amp; s: vec) 或者 for (const std::string&amp; s: vec)</p>
</li>
<li><p>lambda捕获</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对应消息类型的内容</span></span><br><span class="line"><span class="function">std::string <span class="title">GetRichTextMessageXxxContent</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;model::Message&gt;&amp; message,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">const</span> std::map&lt;model::MessageId, std::map&lt;model::UserId, std::string&gt;&gt;&amp; related_user_names,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">const</span> model::UserId&amp; login_userid,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">bool</span> for_message_index)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="comment">// 解析RichText内容</span></span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">DecodeRichTextMessage</span>(message, [=](<span class="type">uint32_t</span> item_type, <span class="type">const</span> std::string&amp; data) &#123;</span><br><span class="line">  std::string output_text;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> output_text;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>上述代码用于解析获取文本消息内容，涉及到富文本消息的解析和一些逻辑的计算，高频调用，他在解析RichText内容的callback中直接简单粗暴的按值捕获了所有变量，将所有变量都拷贝了一份，这里造成不必要的性能损耗，尤其上面那个std::map。这里可以改成按引用来捕获，规避不必要的拷贝。</p>
</li>
<li><p>lambda函数在捕获时会将被捕获对象拷贝，如果捕获的对象很多或者很占内存，将会影响整体的性能，可以根据需求使用引用捕获或者按需捕获：</p>
<ul>
<li>auto func &#x3D; &amp;a{};</li>
<li>auto func &#x3D; a &#x3D; std::move(a){}; (限C++14以后)</li>
</ul>
</li>
<li><p>隐式类型转换</p>
</li>
<li><p>这里在遍历关联容器时，看着是const引用的，心想着不会发生拷贝，但是因为类型错了还是会发生拷贝，std::map 中的键值对是以 std::pair&lt;const Key, T&gt; 的形式存储的，其中key是常量。因此，在每次迭代时，会将当前键值对拷贝到临时变量中。在处理大型容器或频繁遍历时，这种拷贝操作可能会产生一些性能开销，所以在遍历时推荐使用const auto&amp;，也可以使用结构化绑定：for(const auto&amp; [key, value]: map){} (限C++17后)</p>
</li>
<li><p>返回值优化</p>
<ul>
<li>RVO是Return Value Optimization的缩写，即返回值优化，NRVO就是具名的返回值优化，为RVO的一个变种，此特性从C++11开始支持。为了更清晰的了解编译器的行为，这里实现了构造&#x2F;析构及拷贝构造、赋值操作函数，如下:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Widget</span>() &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Widget: Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; other) &#123;</span><br><span class="line">        name = other.name;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Widget: Copy construct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Widget: Assignment construct&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        name = other.name;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Widget</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Widget: Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">GetMyWidget</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="keyword">if</span> (v % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        w.name = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> Widget&amp; w = <span class="built_in">GetMyWidget</span>(<span class="number">2</span>); <span class="comment">// (1)</span></span><br><span class="line">    Widget w = <span class="built_in">GetMyWidget</span>(<span class="number">2</span>); <span class="comment">// (2)</span></span><br><span class="line">    <span class="built_in">GetMyWidget</span>(<span class="number">2</span>); <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>针对上面(1)(2)(3)的调用，我之前也是有点迷惑，以为要减少拷贝必须得用常引用来接，但是发现编译器进行返回值优化后(1)(2)(3)运行结果都是一样的，也就是日常开发中，针对函数中返回的临时对象，可以用对象的常引用或者新的一个对象来接，最后的影响其实可以忽略不计的。不过个人还是倾向于对象的常引用来接，一是出于没有优化时(编译器不支持或者不满足RVO条件)可以减少一次拷贝，二是如果返回的是对象的引用时可以避免拷贝。但是也要注意不要返回临时对象的引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pb协议接口实现</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">const</span> ::<span class="function">PB::XXXConfig&amp; <span class="title">XXConfigRsp::config</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XXSettingView::SetSettingInfo</span><span class="params">(<span class="type">const</span> PB::XXConfigRsp&amp; rsp)</span></span>&#123;</span><br><span class="line"> <span class="type">const</span> <span class="keyword">auto</span> config = rsp.<span class="built_in">config</span>(); <span class="comment">// 内部返回的是对象的引用，这里没有引用来接导致不必要的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当遇到上面这种返回对象的引用时，外部最好也是用对象的引用来接，减少不必要的拷贝。</p>
</li>
<li><p>此外，如果Widget的拷贝赋值操作比较耗时，通常在使用函数返回这个类的一个对象时也是会有一定的讲究的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// style 1</span></span><br><span class="line"><span class="function">Widget <span class="title">func</span><span class="params">(Args param)</span></span>;</span><br><span class="line"><span class="comment">// style 2</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(Widget* ptr, Args param)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>上面的两种方式都能达到同样的目的，但直观上的使用体验的差别也是非常明显的：</p>
<ul>
<li>style 1只需要一行代码，而style 2需要两行代码，可能大多数人直接无脑style 1<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// style 1</span></span><br><span class="line">Widget obj = <span class="built_in">func</span>(params);</span><br><span class="line"><span class="comment">// style 2</span></span><br><span class="line">Widget obj;</span><br><span class="line"><span class="built_in">func</span>(&amp;obj, params);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>但是，能达到同样的目的，消耗的成本却未必是一样的，这取决于多个因素，比如编译器支持的特性、C++语言标准的规范强制性等等。</p>
</li>
<li><p>看起来style 2虽然需要写两行代码，但函数内部的成本却是确定的，只会取决于你当前的编译器，外部即使采用不同的编译器进行函数调用，也并不会有多余的时间开销和稳定性问题。使用style 1时，较复杂的函数实现可能并不会如你期望的使用RVO优化，如果编译器进行RVO优化，使用style 1无疑是比较好的选择。利用好编译器RVO特性，也是能为程序带来一定的性能提升。</p>
</li>
</ul>
<h2 id="迭代器删除"><a href="#迭代器删除" class="headerlink" title="迭代器删除"></a>迭代器删除</h2><ul>
<li><p>在处理缓存时，容器元素的增删查改是很常见的，通过迭代器去删除容器(vector&#x2F;map&#x2F;set&#x2F;unordered_map&#x2F;list)元素也是常有的，但这其中使用不当也会存在很多坑</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; numbers = &#123; <span class="number">88</span>, <span class="number">101</span>, <span class="number">56</span>, <span class="number">203</span>, <span class="number">72</span>, <span class="number">135</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), [](<span class="type">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">return</span> num &gt; <span class="number">100</span> &amp;&amp; num % <span class="number">2</span> != <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">vec.<span class="built_in">erase</span>(it);</span><br></pre></td></tr></table></figure></li>
<li><p>上面代码，查找std::vector中大于 100 并且为奇数的整数并将其删除。std::find_if 将从容器的开头开始查找，直到找到满足条件的元素或者遍历完整个容器，并返回迭代器it，然后去删除该元素。但是这里没有判断it为空的情况，直接就erase了，如果erase一个空的迭代器会引发crash。很多新手程序员会犯这样的错误，随时判空是个不错的习惯</p>
</li>
<li><p>删除元素不得不讲下std::remove 和 std::remove_if，用于从容器中移除指定的元素， 函数会将符合条件的元素移动到容器的末尾，并返回指向新的末尾位置之后的迭代器，最后使用容器的erase来擦除从新的末尾位置开始的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vecs = &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;hhhhh&quot;</span>, <span class="string">&quot;D&quot;</span> &#125;;</span><br><span class="line">vecs.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(vecs.<span class="built_in">begin</span>(), vecs.<span class="built_in">end</span>(), <span class="string">&quot;&quot;</span>), vecs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除所有偶数元素</span></span><br><span class="line">vec.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li>
<li><p>这里的erase不用判空，其内部实现已经有判空处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_CONSTEXPR20 iterator <span class="title">erase</span><span class="params">(const_iterator _First, const_iterator _Last)</span> <span class="title">noexcept</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        is_nothrow_move_assignable_v&lt;value_type&gt;)</span> <span class="comment">/* strengthened */</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> pointer _Firstptr = _First._Ptr;</span><br><span class="line">    <span class="type">const</span> pointer _Lastptr  = _Last._Ptr;</span><br><span class="line">    <span class="keyword">auto</span>&amp; _My_data          = _Mypair._Myval2;</span><br><span class="line">    pointer&amp; _Mylast        = _My_data._Mylast;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="keyword">if</span> (_Firstptr != _Lastptr) &#123; <span class="comment">// something to do, invalidate iterators</span></span><br><span class="line">        _Orphan_range(_Firstptr, _Mylast);</span><br><span class="line">        <span class="type">const</span> pointer _Newlast = _Move_unchecked(_Lastptr, _Mylast, _Firstptr);</span><br><span class="line">        _Destroy_range(_Newlast, _Mylast, _Getal());</span><br><span class="line">        _Mylast = _Newlast;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(_Firstptr, _STD <span class="built_in">addressof</span>(_My_data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>此外，STL容器的删除也要小心迭代器失效，先来看个vector、list、map删除的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector、list、map遍历并删除偶数元素</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; elements = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = elements.<span class="built_in">begin</span>(); it != elements.<span class="built_in">end</span>();) &#123;</span><br><span class="line"> <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        elements.<span class="built_in">erase</span>(it++);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; cont&#123; <span class="number">88</span>, <span class="number">101</span>, <span class="number">56</span>, <span class="number">203</span>, <span class="number">72</span>, <span class="number">135</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = cont.<span class="built_in">begin</span>(); it != cont.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        cont.<span class="built_in">erase</span>(it++);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Ok</span></span><br><span class="line"> std::map&lt;<span class="type">int</span>, std::string&gt; myMap = &#123; &#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;, &#123;<span class="number">4</span>, <span class="string">&quot;four&quot;</span>&#125;, &#123;<span class="number">5</span>, <span class="string">&quot;five&quot;</span>&#125; &#125;;</span><br><span class="line"><span class="comment">// 遍历并删除键值对，删除键为偶数的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;first % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        myMap.<span class="built_in">erase</span>(it++);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Ok</span></span><br></pre></td></tr></table></figure></li>
<li><p>上面几类容器同样的遍历删除元素，只有vector报错crash了，map和list都能正常运行。其实vector调用erase()方法后，当前位置到容器末尾元素的所有迭代器全部失效了，以至于不能再使用。</p>
</li>
<li><p>迭代器的失效问题：对容器的操作影响了元素的存放位置，称为迭代器失效。迭代器失效的情况：</p>
<ul>
<li>当容器调用erase()方法后，当前位置到容器末尾元素的所有迭代器全部失效。</li>
<li>当容器调用insert()方法后，当前位置到容器末尾元素的所有迭代器全部失效。</li>
<li>如果容器扩容，在其他地方重新又开辟了一块内存，原来容器底层的内存上所保存的迭代器全都失效。</li>
</ul>
</li>
<li><p>迭代器失效有三种情况，由于底层的存储数据结构，分三种情况：</p>
<ul>
<li><strong>序列式迭代器失效</strong>，序列式容器(std::vector和std::deque)，其对应的数据结构分配在连续的内存中，对其中的迭代器进行insert和erase操作都会使得删除点和插入点之后的元素挪位置，进而导致插入点和删除掉之后的迭代器全部失效。可以利用erase迭代器接口返回的是下一个有效的迭代器。</li>
<li><strong>链表式迭代器失效</strong>，链表式容器(std::list)使用链表进行数据存储，插入或者删除只会对当前的节点造成影响，不会影响其他的迭代器。可以利用erase迭代器接口返回的是下一个有效的迭代器，或者将当前的迭代器指向下一个erase(iter++)。</li>
<li><strong>关联式迭代器失效</strong>，关联式容器，如map, set,multimap,multiset等，使用红黑树进行数据存储，删除当前的迭代器，仅会使当前的迭代器失效。erase迭代器的返回值为 void(C++11之前)，可以采用erase(iter++)的方式进行删除。值得一提的是，在最新的C++11标准中，已经新增了一个map::erase函数执行后会返回下一个元素的iterator，因此可以使用erase的返回值获取下一个有效的迭代器。</li>
</ul>
</li>
<li><p>在实现上有两种模板，其一是通过 erase 获得下一个有效的 iterator，使用于序列式迭代器和链表式迭代器(C++11开始关联式迭代器也可以使用)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = elements.<span class="built_in">begin</span>(); it != elements.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ShouldDelete</span>(*it)) &#123;</span><br><span class="line">        it = elements.<span class="built_in">erase</span>(it); <span class="comment">// erase删除元素，返回下一个迭代器</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其二是，递增当前迭代器，适用于链表式迭代器和关联式迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = elements.<span class="built_in">begin</span>(); it != elements.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ShouldDelete</span>(*it)) &#123;</span><br><span class="line">        elements.<span class="built_in">erase</span>(it++); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="c-获取当前时间戳-毫秒"><a href="#c-获取当前时间戳-毫秒" class="headerlink" title="c++ 获取当前时间戳 毫秒"></a>c++ 获取当前时间戳 毫秒</h2><p>在C++中获取当前时间戳（以毫秒为单位）通常需要使用操作系统提供的时间函数。以下是一个使用C++标准库的例子，可以获取当前时间戳（以毫秒为单位）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间点</span></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前时间点转换为毫秒</span></span><br><span class="line">    <span class="keyword">auto</span> ms = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::milliseconds&gt;(now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取时间戳</span></span><br><span class="line">    <span class="keyword">auto</span> timestamp = ms.<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current timestamp in milliseconds: &quot;</span> &lt;&lt; timestamp &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码使用了 <code>&lt;chrono&gt;</code> 头文件中的时间库，以及 <code>std::chrono::system_clock</code> 类和 <code>std::chrono::milliseconds</code> 类。它获取当前时间点，然后将其转换为毫秒，并输出时间戳。</p>
<h2 id="C-std-this-thread-yield-函数后面的语句还会执行吗"><a href="#C-std-this-thread-yield-函数后面的语句还会执行吗" class="headerlink" title="C++ std::this_thread::yield()函数后面的语句还会执行吗"></a>C++ std::this_thread::yield()函数后面的语句还会执行吗</h2><p><code>std::this_thread::yield()</code> 函数是一个线程库提供的函数，用于提示调度器让出当前线程的执行权，以便其他线程有机会执行。调用 <code>std::this_thread::yield()</code> 后，当前线程会主动让出 CPU 的执行时间片，但它的执行权并不会立即转移到其他线程上。相反，操作系统调度器会在合适的时机（通常是在同一线程队列中的其他线程都执行完毕后）再次调度当前线程。因此，<code>std::this_thread::yield()</code> 后面的语句仍然会执行，只是在稍后的时间点。</p>
<p>考虑以下示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before yield&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After yield&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(foo)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>foo()</code> 函数中的 <code>std::cout &lt;&lt; &quot;Before yield&quot; &lt;&lt; std::endl;</code> 和 <code>std::cout &lt;&lt; &quot;After yield&quot; &lt;&lt; std::endl;</code> 语句都会执行，即使在 <code>std::this_thread::yield();</code> 被调用后。<code>std::this_thread::yield()</code> 只是提示调度器让出 CPU 的执行时间片，而不是中断线程的执行。</p>
<h2 id="C-使用原子操作通知指定线程退出-示例-详解"><a href="#C-使用原子操作通知指定线程退出-示例-详解" class="headerlink" title="C++ 使用原子操作通知指定线程退出 示例 详解"></a>C++ 使用原子操作通知指定线程退出 示例 详解</h2><p>使用原子操作通知指定线程退出的示例需要借助原子布尔标志（<code>std::atomic&lt;bool&gt;</code>）来控制线程的执行状态。下面是一个详细的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">shouldExit</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!shouldExit.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// Simulate some work</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; exiting.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(worker, <span class="number">2</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Simulate some work</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Set shouldExit to true</span></span><br><span class="line">    shouldExit.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>shouldExit</code> 是一个原子布尔变量，用来控制线程是否应该退出。在 <code>worker</code> 函数中，线程会在循环中检查 <code>shouldExit</code> 变量的值，如果值为 <code>false</code>，则继续执行工作，否则退出循环并退出线程。</p>
<p>在 <code>main</code> 函数中，首先创建了两个工作线程 <code>t1</code> 和 <code>t2</code>，然后模拟了一些工作。随后，<code>shouldExit</code> 被设置为 <code>true</code>，通知工作线程退出。最后，<code>main</code> 函数等待两个工作线程退出。</p>
<p>通过使用原子操作，我们可以避免使用额外的同步机制（如互斥锁、条件变量等），从而更加高效地控制线程的退出。</p>
<h2 id="C-使用条件变量通知指定线程退出-示例-详解"><a href="#C-使用条件变量通知指定线程退出-示例-详解" class="headerlink" title="C++ 使用条件变量通知指定线程退出 示例 详解"></a>C++ 使用条件变量通知指定线程退出 示例 详解</h2><p>使用条件变量（<code>std::condition_variable</code>）通知指定线程退出的示例可以通过以下步骤实现：</p>
<ol>
<li>创建一个标志变量来指示线程是否应该退出。</li>
<li>使用条件变量来等待通知。</li>
<li>当需要退出线程时，设置标志变量，并通知等待线程退出。</li>
<li>等待线程收到通知后退出。</li>
</ol>
<p>让我们通过一个简单的示例来详细说明这个过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> shouldExit = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!shouldExit) &#123;</span><br><span class="line">        <span class="comment">// Wait until notified or the timeout expires</span></span><br><span class="line">        cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; is working...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// Simulate some work</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; exiting.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(worker, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(worker, <span class="number">2</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Simulate some work</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Set shouldExit to true and notify the worker threads to exit</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        shouldExit = <span class="literal">true</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，有两个工作线程（<code>t1</code> 和 <code>t2</code>），它们会等待条件变量 <code>cv</code> 的通知。<code>shouldExit</code> 是一个标志变量，用于指示线程是否应该退出。</p>
<p>在 <code>main()</code> 函数中，首先创建了两个工作线程，然后模拟了一些工作。随后，<code>shouldExit</code> 被设置为 <code>true</code>，并且通过 <code>cv.notify_all()</code> 通知所有等待的线程退出。最后，<code>main()</code> 函数等待两个工作线程退出。</p>
<p>这样，通过条件变量和标志变量，我们可以控制线程的退出。当需要退出线程时，只需设置标志变量并通知等待的线程即可。</p>
<h2 id="C-std-thread-线程间通信的几种方式-详解"><a href="#C-std-thread-线程间通信的几种方式-详解" class="headerlink" title="C++ std::thread 线程间通信的几种方式 详解"></a>C++ std::thread 线程间通信的几种方式 详解</h2><p>在线程间通信时，C++ 的 <code>std::thread</code> 提供了几种常用的方式：</p>
<ol>
<li><p><strong>共享内存（Shared Memory）</strong>：</p>
<ul>
<li>这是最简单和直接的方法之一，多个线程可以访问同一块内存区域。但要小心并发访问的问题，需要使用诸如互斥锁（mutex）或原子操作等机制来确保线程安全。</li>
</ul>
</li>
<li><p><strong>互斥锁（Mutex）</strong>：</p>
<ul>
<li>使用 <code>std::mutex</code> 来确保一次只有一个线程可以访问共享资源。线程在访问共享资源之前先锁定互斥锁，访问完毕后再解锁。这确保了对共享资源的排他性访问，防止数据竞争。</li>
</ul>
</li>
<li><p><strong>条件变量（Condition Variable）</strong>：</p>
<ul>
<li><code>std::condition_variable</code> 可以在多线程间进行通信，一般与互斥锁一起使用。一个线程等待条件变量的某个条件为真，而另一个线程在适当的时候发出通知，告诉等待线程条件已经满足。</li>
</ul>
</li>
<li><p><strong>原子操作（Atomic Operations）</strong>：</p>
<ul>
<li><code>std::atomic</code> 类型提供了一种线程安全的方式来访问共享数据，它们确保在没有互斥锁的情况下执行单个操作时的线程安全性。原子操作通常用于简单的数据类型（如整数、布尔值等）。</li>
</ul>
</li>
<li><p><strong>消息队列（Message Queue）</strong>：</p>
<ul>
<li>使用 <code>std::queue</code> 或其他自定义队列结构，不同线程可以通过向队列发送消息来进行通信。这种方式一般需要配合互斥锁或原子操作来确保队列操作的线程安全。</li>
</ul>
</li>
<li><p><strong>管道（Pipe）</strong>：</p>
<ul>
<li>如果是在不同进程之间进行通信，可以使用管道。在C++中，可以使用 <code>popen()</code> 或者在POSIX环境下使用 <code>pipe()</code> 函数。</li>
</ul>
</li>
<li><p><strong>信号量（Semaphore）</strong>：</p>
<ul>
<li><code>std::semaphore</code> 或者第三方库提供的信号量机制可以用于控制同时访问某个共享资源的线程数量。</li>
</ul>
</li>
<li><p><strong>屏障（Barrier）</strong>：</p>
<ul>
<li>屏障允许多个线程在某一点上相互等待，直到所有线程都到达后才继续执行。C++中可以使用 <code>std::barrier</code>（C++20 引入）或者其他第三方库提供的屏障机制。</li>
</ul>
</li>
</ol>
<p>选择哪种通信方式取决于具体情况，包括线程之间的关系、共享资源的类型、性能需求等。</p>
<h2 id="C-std-for-each-函数中lambda捕获局部变量是以什么规则捕获的"><a href="#C-std-for-each-函数中lambda捕获局部变量是以什么规则捕获的" class="headerlink" title="C++ std::for_each() 函数中lambda捕获局部变量是以什么规则捕获的"></a>C++ std::for_each() 函数中lambda捕获局部变量是以什么规则捕获的</h2><p>在 C++ 中，<code>std::for_each()</code> 函数通常与 lambda 表达式一起使用。当你在 lambda 表达式中捕获局部变量时，捕获方式是由捕获列表来确定的。捕获列表控制了 lambda 表达式访问外部变量的方式。</p>
<p>捕获列表有两种方式：按值捕获和按引用捕获。</p>
<ol>
<li><strong>按值捕获：</strong> 按值捕获会在 lambda 表达式内部创建外部变量的副本，这样 lambda 表达式内部的代码就可以使用该副本。即使外部变量的值发生变化，lambda 表达式内部也不会受到影响。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Lambda 按值捕获 x</span></span><br><span class="line">    std::for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [x](<span class="type">int</span> n) &#123;</span><br><span class="line">        std::cout &lt;&lt; n + x &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>按引用捕获：</strong> 按引用捕获不会创建变量的副本，而是直接引用外部变量。这意味着 lambda 表达式内部的代码可以访问并修改外部变量的值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Lambda 按引用捕获 x</span></span><br><span class="line">    std::for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [&amp;x](<span class="type">int</span> n) &#123;</span><br><span class="line">        x += n;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 输出：x: 57</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用 <code>std::for_each()</code> 函数时，你可以根据需要选择按值捕获还是按引用捕获，以确保 lambda 表达式的行为符合预期。</p>
<h2 id="C-std-vector-指定被赋值容器的范围进行赋值"><a href="#C-std-vector-指定被赋值容器的范围进行赋值" class="headerlink" title="C++ std::vector 指定被赋值容器的范围进行赋值"></a>C++ std::vector 指定被赋值容器的范围进行赋值</h2><p>如果你想要在C++中使用<code>std::vector</code>，并且想要将一个vector的内容赋值给另一个vector的特定范围，你可以使用<code>std::copy</code>算法或者<code>std::vector</code>的迭代器来实现。</p>
<p>下面是使用<code>std::copy</code>算法的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">destination</span><span class="params">(<span class="number">7</span>)</span></span>; <span class="comment">// 创建一个有7个元素的目标vector</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将source的第2到第4个元素（不包括第4个元素）赋值给destination的第3个位置开始</span></span><br><span class="line">    std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>() + <span class="number">1</span>, source.<span class="built_in">begin</span>() + <span class="number">4</span>, destination.<span class="built_in">begin</span>() + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印destination vector的内容</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;destination contains:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : destination) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; elem;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">destination contains: 0 0 2 3 4 0 0</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>std::copy</code>算法从源vector的第2到第4个元素（不包括第4个元素）复制到目标vector的第3个位置开始。</p>
<p>另一种方法是使用<code>std::vector</code>的迭代器来实现。你可以使用<code>std::vector</code>的<code>assign</code>函数，结合迭代器来指定赋值的范围。</p>
<h2 id="C-std-thread-和-std-move"><a href="#C-std-thread-和-std-move" class="headerlink" title="C++ std::thread 和 std::move"></a>C++ std::thread 和 std::move</h2><p>在 C++ 中，<code>std::thread</code> 是一个用于创建和管理线程的类，而 <code>std::move</code> 是一个用于移动语义的函数。这两者通常可以结合使用来传递线程的所有权。</p>
<p>在使用 <code>std::thread</code> 时，通常需要注意线程对象的所有权问题。当你想要将一个线程对象所有权从一个变量转移给另一个变量时，你可以使用 <code>std::move</code> 来实现移动语义，而不是复制线程对象。</p>
<p>以下是一个简单的示例，演示了如何使用 <code>std::move</code> 来传递 <code>std::thread</code> 对象的所有权：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside thread function\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将线程对象的所有权移动给新的变量 t2</span></span><br><span class="line">    std::thread t2 = std::<span class="built_in">move</span>(t1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// t1 不再拥有线程，因此在这里无法join</span></span><br><span class="line">    <span class="comment">// 如果尝试 join t1，则会导致程序崩溃或未定义行为</span></span><br><span class="line">    <span class="comment">// t1.join(); </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// t2 拥有线程，因此可以 join</span></span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>t1</code> 在创建时拥有线程，然后通过 <code>std::move</code> 将其所有权转移到了 <code>t2</code>。现在 <code>t1</code> 不再拥有线程，因此不能调用 <code>join()</code> 方法。相反，<code>t2</code> 现在拥有线程，可以调用 <code>join()</code> 方法。</p>
<p>使用 <code>std::move</code> 可以有效地避免资源的复制，而是直接转移资源的所有权，从而提高了性能并避免不必要的资源浪费。</p>
<h2 id="C-表示一个函数不应该出现异常"><a href="#C-表示一个函数不应该出现异常" class="headerlink" title="C++ 表示一个函数不应该出现异常"></a>C++ 表示一个函数不应该出现异常</h2><p>在C++中，表示一个函数不应该出现异常通常可以通过以下方式来实现：</p>
<ol>
<li><strong>使用异常说明（Exception Specification）</strong>：C++语言允许在函数声明中使用异常说明，指明函数不会抛出任何异常。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// 表示 myFunction 不会抛出任何异常</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用 noexcept 关键字</strong>：C++11 引入了 noexcept 关键字，用于指示函数是否抛出异常。如果函数确实不会抛出异常，应该使用 noexcept 关键字来声明。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 表示 myFunction 不会抛出异常</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>编写良好的代码并避免抛出异常</strong>：在编写代码时，可以通过良好的设计和编码实践来避免抛出异常。这可能涉及到使用异常安全的编程技术，如RAII（资源获取即初始化）等。</li>
</ol>
<p>需要注意的是，尽管可以使用这些方法来表示函数不应该抛出异常，但并不能完全保证函数不会抛出异常。例如，如果函数调用了不受控制的外部库或操作系统函数，它们可能会引发异常。因此，在编写代码时，应该仔细考虑异常安全性，并尽量避免或者明确处理异常。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>感谢老板支持！敬礼(^^ゞ</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="zhang junyi WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="zhang junyi Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CppTechnique/" rel="tag"># CppTechnique</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/22/notebook/C++/C++_10_%E6%A0%87%E5%87%86%E5%BA%93/2024-05-22-C++_10_0_readme/" rel="prev" title="C++_10_0_readme">
      <i class="fa fa-chevron-left"></i> C++_10_0_readme
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/05/22/notebook/C++/C++_06_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/2024-05-22-C++_06_1_%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" rel="next" title="C++_06_1_编程技巧">
      C++_06_1_编程技巧 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#windows-C-%E9%93%BE%E6%8E%A5dll%E6%97%A0%E6%B3%95%E8%B0%83%E8%AF%95-%E9%93%BE%E6%8E%A5lib%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%B0%83%E8%AF%95-%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.</span> <span class="nav-text">windows C++ 链接dll无法调试 链接lib就可以调试 原因是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%AC%A6%E5%8F%B7%E4%BF%A1%E6%81%AF%E7%BC%BA%E5%A4%B1"><span class="nav-number">2.1.</span> <span class="nav-text">1. 符号信息缺失</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BB%A3%E7%A0%81%E8%B7%AF%E5%BE%84%E4%B8%8D%E5%8F%AF%E8%A7%81"><span class="nav-number">2.2.</span> <span class="nav-text">2. 代码路径不可见</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BC%98%E5%8C%96%E8%AE%BE%E7%BD%AE%E9%97%AE%E9%A2%98"><span class="nav-number">2.3.</span> <span class="nav-text">3. 优化设置问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">2.4.</span> <span class="nav-text">4. 导出函数的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%B0%83%E8%AF%95%E5%99%A8%E6%9C%AA%E5%8A%A0%E8%BD%BD-DLL-%E7%AC%A6%E5%8F%B7"><span class="nav-number">2.5.</span> <span class="nav-text">5. 调试器未加载 DLL 符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="nav-number">2.6.</span> <span class="nav-text">6. 运行时不一致</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-DLL-%E5%8A%A0%E8%BD%BD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.7.</span> <span class="nav-text">7. DLL 加载路径问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC-%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.</span> <span class="nav-text">C++ 字符串字面值 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">3.1.</span> <span class="nav-text">字符串字面值的种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">3.2.</span> <span class="nav-text">字符串字面值的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.</span> <span class="nav-text">字符串字面值的常见操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="nav-number">3.3.1.</span> <span class="nav-text">拼接字符串字面值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="nav-number">3.3.2.</span> <span class="nav-text">字符串长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.3.3.</span> <span class="nav-text">使用原始字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E-Unicode-%E7%9A%84%E7%BB%93%E5%90%88"><span class="nav-number">3.3.4.</span> <span class="nav-text">与 Unicode 的结合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AF%B9%E6%AF%94"><span class="nav-number">3.4.</span> <span class="nav-text">字符串字面值的类型对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.5.</span> <span class="nav-text">完整示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.6.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-L%E2%80%9Dmodel-onnx%E2%80%9D-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="nav-number">4.</span> <span class="nav-text">C++ L”model.onnx” 是什么意思</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90"><span class="nav-number">4.1.</span> <span class="nav-text">详细解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.2.</span> <span class="nav-text">对比示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88char-%EF%BC%89"><span class="nav-number">4.2.1.</span> <span class="nav-text">普通字符串（char*）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%BD%E5%AD%97%E7%AC%A6%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88wchar-t-%EF%BC%89"><span class="nav-number">4.2.2.</span> <span class="nav-text">宽字符字符串（wchar_t*）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF"><span class="nav-number">4.3.</span> <span class="nav-text">常见场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="nav-number">4.4.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">4.5.</span> <span class="nav-text">完整示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%B0%86%E5%B8%83%E5%B0%94%E5%80%BC%E5%8F%96%E5%8F%8D"><span class="nav-number">5.</span> <span class="nav-text">C++ 将布尔值取反</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">5.1.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="nav-number">5.2.</span> <span class="nav-text">运行结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.3.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="nav-number">5.4.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%BD%8D%E6%93%8D%E4%BD%9C-%E8%8E%B7%E5%8F%96%E6%AF%94%E7%89%B9%E4%BD%8D%E4%B8%AD%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%80%BC"><span class="nav-number">6.</span> <span class="nav-text">C 位操作 获取比特位中指定位置的值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E6%AF%94%E7%89%B9%E4%BD%8D%E7%9A%84%E5%80%BC"><span class="nav-number">6.1.</span> <span class="nav-text">获取指定比特位的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="nav-number">6.2.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="nav-number">6.3.</span> <span class="nav-text">代码解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E8%BE%93%E5%87%BA"><span class="nav-number">6.4.</span> <span class="nav-text">示例输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%B0%86%E4%B8%A4%E4%B8%AAuint8-t%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8B%BC%E6%8E%A5%E6%88%90%E4%B8%80%E4%B8%AAuint16-t%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">7.</span> <span class="nav-text">C++ 将两个uint8_t的数据拼接成一个uint16_t的数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="nav-number">7.1.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-1"><span class="nav-number">7.2.</span> <span class="nav-text">代码解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E8%BE%93%E5%87%BA-1"><span class="nav-number">7.3.</span> <span class="nav-text">示例输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%B0%86%E6%95%B4%E6%95%B0%E8%BE%93%E5%87%BA%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="nav-number">8.</span> <span class="nav-text">C++ 将整数输出二进制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%89%8B%E5%8A%A8%E8%BE%93%E5%87%BA%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="nav-number">8.1.</span> <span class="nav-text">方法1：使用位操作手动输出二进制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-2"><span class="nav-number">8.2.</span> <span class="nav-text">代码解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E4%BD%BF%E7%94%A8-bitset"><span class="nav-number">8.3.</span> <span class="nav-text">方法2：使用 bitset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-3"><span class="nav-number">8.4.</span> <span class="nav-text">代码解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81%E4%B8%8D%E5%90%8C%E4%BD%8D%E6%95%B0"><span class="nav-number">8.5.</span> <span class="nav-text">方法3：模板实现支持不同位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-4"><span class="nav-number">8.6.</span> <span class="nav-text">代码解释</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const-constexpr"><span class="nav-number">9.</span> <span class="nav-text">const&#x2F;constexpr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">10.</span> <span class="nav-text">内存泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-async%E7%9C%9F%E7%9A%84%E5%BC%82%E6%AD%A5%E5%90%97"><span class="nav-number">11.</span> <span class="nav-text">std::async真的异步吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sizeof-strlen"><span class="nav-number">12.</span> <span class="nav-text">sizeof &amp; strlen</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-shared-ptr%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">13.</span> <span class="nav-text">std::shared_ptr线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D"><span class="nav-number">14.</span> <span class="nav-text">对象拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4"><span class="nav-number">15.</span> <span class="nav-text">迭代器删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E6%88%B3-%E6%AF%AB%E7%A7%92"><span class="nav-number">16.</span> <span class="nav-text">c++ 获取当前时间戳 毫秒</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-std-this-thread-yield-%E5%87%BD%E6%95%B0%E5%90%8E%E9%9D%A2%E7%9A%84%E8%AF%AD%E5%8F%A5%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97"><span class="nav-number">17.</span> <span class="nav-text">C++ std::this_thread::yield()函数后面的语句还会执行吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E9%80%9A%E7%9F%A5%E6%8C%87%E5%AE%9A%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA-%E7%A4%BA%E4%BE%8B-%E8%AF%A6%E8%A7%A3"><span class="nav-number">18.</span> <span class="nav-text">C++ 使用原子操作通知指定线程退出 示例 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E9%80%9A%E7%9F%A5%E6%8C%87%E5%AE%9A%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA-%E7%A4%BA%E4%BE%8B-%E8%AF%A6%E8%A7%A3"><span class="nav-number">19.</span> <span class="nav-text">C++ 使用条件变量通知指定线程退出 示例 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-std-thread-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-%E8%AF%A6%E8%A7%A3"><span class="nav-number">20.</span> <span class="nav-text">C++ std::thread 线程间通信的几种方式 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-std-for-each-%E5%87%BD%E6%95%B0%E4%B8%ADlambda%E6%8D%95%E8%8E%B7%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E4%BB%A5%E4%BB%80%E4%B9%88%E8%A7%84%E5%88%99%E6%8D%95%E8%8E%B7%E7%9A%84"><span class="nav-number">21.</span> <span class="nav-text">C++ std::for_each() 函数中lambda捕获局部变量是以什么规则捕获的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-std-vector-%E6%8C%87%E5%AE%9A%E8%A2%AB%E8%B5%8B%E5%80%BC%E5%AE%B9%E5%99%A8%E7%9A%84%E8%8C%83%E5%9B%B4%E8%BF%9B%E8%A1%8C%E8%B5%8B%E5%80%BC"><span class="nav-number">22.</span> <span class="nav-text">C++ std::vector 指定被赋值容器的范围进行赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-std-thread-%E5%92%8C-std-move"><span class="nav-number">23.</span> <span class="nav-text">C++ std::thread 和 std::move</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E8%A1%A8%E7%A4%BA%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E4%B8%8D%E5%BA%94%E8%AF%A5%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8"><span class="nav-number">24.</span> <span class="nav-text">C++ 表示一个函数不应该出现异常</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
