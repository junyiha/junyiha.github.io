<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="简介 ethercat的理论基础知识  可能出现从站依次松闸现象的原因有哪些EtherCAT 从站依次松闸（即从站的执行机构或电机控制器按顺序解锁&#x2F;启动，而不是同时执行）可能由以下原因引起：  1. 主站状态机控制问题 EtherCAT 从站需要经过 Init → Pre-Op → Safe-Op → OP 状态转换才能正式运行。 如果主站没有同时对所有从站发送 状态切换命令，可能导致从">
<meta property="og:type" content="article">
<meta property="og:title" content="EtherCat 理论基础">
<meta property="og:url" content="https://junyiha.github.io/2024/05/22/notebook/EtherCat/2024-05-22-ethercat_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="简介 ethercat的理论基础知识  可能出现从站依次松闸现象的原因有哪些EtherCAT 从站依次松闸（即从站的执行机构或电机控制器按顺序解锁&#x2F;启动，而不是同时执行）可能由以下原因引起：  1. 主站状态机控制问题 EtherCAT 从站需要经过 Init → Pre-Op → Safe-Op → OP 状态转换才能正式运行。 如果主站没有同时对所有从站发送 状态切换命令，可能导致从">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://www.ethercat.org/download/press/ethercat_state_machine.png">
<meta property="article:published_time" content="2024-05-22T01:00:00.000Z">
<meta property="article:modified_time" content="2025-04-28T08:08:39.291Z">
<meta property="article:author" content="zhang junyi">
<meta property="article:tag" content="EtherCat">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.ethercat.org/download/press/ethercat_state_machine.png">

<link rel="canonical" href="https://junyiha.github.io/2024/05/22/notebook/EtherCat/2024-05-22-ethercat_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>EtherCat 理论基础 | junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/EtherCat/2024-05-22-ethercat_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          EtherCat 理论基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/EtherCat/" itemprop="url" rel="index"><span itemprop="name">EtherCat</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>ethercat的理论基础知识</li>
</ul>
<h2 id="可能出现从站依次松闸现象的原因有哪些"><a href="#可能出现从站依次松闸现象的原因有哪些" class="headerlink" title="可能出现从站依次松闸现象的原因有哪些"></a>可能出现从站依次松闸现象的原因有哪些</h2><p>EtherCAT 从站<strong>依次松闸</strong>（即从站的执行机构或电机控制器按顺序解锁&#x2F;启动，而不是同时执行）可能由以下原因引起：</p>
<hr>
<h2 id="1-主站状态机控制问题"><a href="#1-主站状态机控制问题" class="headerlink" title="1. 主站状态机控制问题"></a><strong>1. 主站状态机控制问题</strong></h2><ul>
<li>EtherCAT 从站需要经过 <strong>Init → Pre-Op → Safe-Op → OP</strong> 状态转换才能正式运行。</li>
<li>如果主站没有同时对所有从站发送 <strong>状态切换命令</strong>，可能导致<strong>从站依次进入 OP 状态</strong>，从而导致依次松闸。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 在主站程序中，确保所有从站在<strong>同一周期</strong>内切换到 OP 状态，而不是顺序执行。</p>
<hr>
<h2 id="2-同步机制（Distributed-Clocks-DC）问题"><a href="#2-同步机制（Distributed-Clocks-DC）问题" class="headerlink" title="2. 同步机制（Distributed Clocks, DC）问题"></a><strong>2. 同步机制（Distributed Clocks, DC）问题</strong></h2><ul>
<li><strong>从站时钟不同步</strong>：如果使用 <strong>DC（分布式时钟）模式</strong>，但从站的时钟没有正确同步，不同从站可能会在不同的时间点进入 OP 状态。</li>
<li><strong>时钟漂移</strong>：某些从站可能会<strong>比其他从站慢</strong>进入 OP 状态，导致松闸的时间差异。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 在主站配置中检查 DC 设置，确保所有从站的时钟同步。<br>✅ 通过 <code>dcOffset</code> 进行时钟补偿，使所有从站的启动时间一致。</p>
<hr>
<h2 id="3-PDO-映射或过程数据更新问题"><a href="#3-PDO-映射或过程数据更新问题" class="headerlink" title="3. PDO 映射或过程数据更新问题"></a><strong>3. PDO 映射或过程数据更新问题</strong></h2><ul>
<li>EtherCAT 采用 <strong>PDO（过程数据对象）</strong> 进行输入&#x2F;输出数据交换。</li>
<li>如果 <strong>PDO 更新不一致</strong> 或者 <strong>某些从站的数据没有及时刷新</strong>，会导致<strong>某些从站较晚接收到松闸指令</strong>。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 在主站配置中，确保所有从站的 PDO <strong>在同一周期内更新</strong>。<br>✅ 使用 <strong>周期同步模式（Cyclic Synchronous Mode）</strong> 以确保所有从站同时执行操作。</p>
<hr>
<h2 id="4-设备响应时间差异"><a href="#4-设备响应时间差异" class="headerlink" title="4. 设备响应时间差异"></a><strong>4. 设备响应时间差异</strong></h2><ul>
<li>不同从站的<strong>硬件响应时间不同</strong>（如伺服驱动器、电磁阀、继电器等）。</li>
<li>某些从站可能需要<strong>更长的初始化时间</strong>，导致它们比其他从站<strong>晚进入 OP 状态</strong>。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 在主站程序中，<strong>等待所有从站进入 OP 状态后再统一发送松闸指令</strong>。<br>✅ 使用 <strong>EtherCAT 总线诊断工具</strong> 检查从站进入 OP 状态的时间是否一致。</p>
<hr>
<h2 id="5-网络拓扑和通信延迟"><a href="#5-网络拓扑和通信延迟" class="headerlink" title="5. 网络拓扑和通信延迟"></a><strong>5. 网络拓扑和通信延迟</strong></h2><ul>
<li>EtherCAT 采用<strong>菊花链结构</strong>，如果<strong>总线负载过高</strong>或<strong>链路有异常</strong>，可能导致数据包在不同从站之间传输时间不同。</li>
<li>这种情况下，<strong>靠近主站的从站可能会比远离主站的从站更早收到指令</strong>，导致依次松闸。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 使用 EtherCAT 网络分析工具（如 Wireshark + EtherCAT 插件）检查数据包延迟。<br>✅ 在<strong>高负载场景下</strong>，优化 PDO 更新频率，避免总线数据阻塞。  </p>
<hr>
<h2 id="6-设备上电顺序不一致"><a href="#6-设备上电顺序不一致" class="headerlink" title="6. 设备上电顺序不一致"></a><strong>6. 设备上电顺序不一致</strong></h2><ul>
<li>如果<strong>从站上电时间不同</strong>，即某些设备比其他设备<strong>晚启动</strong>，则可能导致它们进入 OP 状态的时间不同。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 确保所有从站<strong>同时上电</strong>，或者在主站程序中<strong>等待所有设备启动后再进入 OP 状态</strong>。</p>
<hr>
<h2 id="7-触发信号或启动命令不同步"><a href="#7-触发信号或启动命令不同步" class="headerlink" title="7. 触发信号或启动命令不同步"></a><strong>7. 触发信号或启动命令不同步</strong></h2><ul>
<li>如果松闸依赖于<strong>外部触发信号</strong>（如数字输入 DI、PLC 触发），而该信号的传播或执行时间不同，也会导致从站<strong>依次解锁</strong>。</li>
</ul>
<p><strong>解决方案：</strong><br>✅ 检查<strong>触发信号</strong>是否<strong>同步</strong>发送到所有从站。<br>✅ 在主站逻辑中，使用 <strong>全局触发信号</strong> 或 <strong>基于 DC 的同步触发</strong> 来确保所有设备同时执行动作。</p>
<hr>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h2><p>EtherCAT 从站依次松闸的常见原因包括：</p>
<table>
<thead>
<tr>
<th><strong>原因类别</strong></th>
<th><strong>可能问题</strong></th>
<th><strong>解决方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>主站状态机</strong></td>
<td>主站未同步切换 OP</td>
<td>在主站程序中确保所有从站同步进入 OP</td>
</tr>
<tr>
<td><strong>DC 时钟同步</strong></td>
<td>时钟未同步、漂移</td>
<td>确保所有从站 DC 同步</td>
</tr>
<tr>
<td><strong>PDO 更新</strong></td>
<td>数据未及时刷新</td>
<td>确保所有从站的 PDO 在同一周期内更新</td>
</tr>
<tr>
<td><strong>设备响应时间</strong></td>
<td>设备处理速度不同</td>
<td>统一等待所有设备进入 OP</td>
</tr>
<tr>
<td><strong>网络拓扑</strong></td>
<td>总线负载高，数据延迟</td>
<td>优化数据更新频率，检查总线健康状态</td>
</tr>
<tr>
<td><strong>上电顺序</strong></td>
<td>设备启动时间不同</td>
<td>确保所有从站同时上电</td>
</tr>
<tr>
<td><strong>触发信号不同步</strong></td>
<td>触发时间不同</td>
<td>使用 DC 触发或全局信号同步</td>
</tr>
</tbody></table>
<p>如果 EtherCAT 从站出现 <strong>依次松闸</strong> 现象，可以从 <strong>主站状态机、DC 时钟、PDO 更新、网络拓扑、设备响应、触发信号</strong> 等方面进行检查和优化。</p>
<h2 id="EtherCAT-从站有几种状态"><a href="#EtherCAT-从站有几种状态" class="headerlink" title="EtherCAT 从站有几种状态"></a>EtherCAT 从站有几种状态</h2><p>在 EtherCAT（Ethernet for Control Automation Technology）协议中，<strong>从站（Slave）</strong> 具有 <strong>四种状态（State Machine）</strong>，每个状态代表不同的操作模式。  </p>
<hr>
<h2 id="EtherCAT-从站的-4-种状态"><a href="#EtherCAT-从站的-4-种状态" class="headerlink" title="EtherCAT 从站的 4 种状态"></a><strong>EtherCAT 从站的 4 种状态</strong></h2><p>从站状态由 <strong>AL 状态机（Application Layer State Machine）</strong> 控制，状态包括：</p>
<ol>
<li><strong>初始化（Init）</strong></li>
<li><strong>预操作（Pre-Operational, Pre-Op）</strong></li>
<li><strong>安全操作（Safe-Operational, Safe-Op）</strong></li>
<li><strong>操作（Operational, OP）</strong></li>
</ol>
<p>EtherCAT <strong>主站（Master）</strong> 通过 <strong>AL 控制寄存器</strong> 控制从站的状态转换。</p>
<hr>
<h3 id="1-初始化（Init）"><a href="#1-初始化（Init）" class="headerlink" title="1. 初始化（Init）"></a><strong>1. 初始化（Init）</strong></h3><ul>
<li><strong>功能</strong>：从站上电后进入 <strong>初始状态</strong>，此时只进行 <strong>基础通信配置</strong>，还不能进行过程数据（Process Data）交换。</li>
<li><strong>特性</strong>：<ul>
<li>只能访问 <strong>物理层和链路层</strong>（EtherCAT 层）。</li>
<li>仅支持 <strong>CoE&#x2F;SDO</strong>（对象字典）等<strong>配置数据通信</strong>。</li>
<li>从站必须完成 <strong>寄存器初始化</strong> 和 <strong>EEPROM 读取</strong>。</li>
</ul>
</li>
<li><strong>状态转换</strong>：<ul>
<li><strong>进入 Pre-Op</strong>：主站发送 <code>Init → Pre-Op</code> 命令。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-预操作（Pre-Operational-Pre-Op）"><a href="#2-预操作（Pre-Operational-Pre-Op）" class="headerlink" title="2. 预操作（Pre-Operational, Pre-Op）"></a><strong>2. 预操作（Pre-Operational, Pre-Op）</strong></h3><ul>
<li><strong>功能</strong>：在该状态下，从站允许主站访问<strong>对象字典（Object Dictionary）</strong> 进行参数配置，但仍不能交换过程数据。</li>
<li><strong>特性</strong>：<ul>
<li>允许<strong>CoE（CANopen over EtherCAT）</strong> 进行<strong>SDO 参数传输</strong>。</li>
<li>不能进行实时过程数据交换（PDO 无效）。</li>
<li>适用于 <strong>参数下载、设备初始化</strong> 等任务。</li>
</ul>
</li>
<li><strong>状态转换</strong>：<ul>
<li><strong>进入 Safe-Op</strong>：主站配置完成后，发送 <code>Pre-Op → Safe-Op</code> 命令。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-安全操作（Safe-Operational-Safe-Op）"><a href="#3-安全操作（Safe-Operational-Safe-Op）" class="headerlink" title="3. 安全操作（Safe-Operational, Safe-Op）"></a><strong>3. 安全操作（Safe-Operational, Safe-Op）</strong></h3><ul>
<li><strong>功能</strong>：从站可以进行<strong>输入数据的读取</strong>，但不能修改输出数据（即，不能改变执行机构的状态）。</li>
<li><strong>特性</strong>：<ul>
<li>允许主站<strong>读取</strong>从站的输入数据。</li>
<li>但不允许主站<strong>写入</strong>从站的输出数据（防止设备误动作）。</li>
<li>适用于<strong>调试过程</strong>，确保系统在操作前数据正确。</li>
</ul>
</li>
<li><strong>状态转换</strong>：<ul>
<li><strong>进入 OP（Operational）</strong>：主站确认输入数据正确后，发送 <code>Safe-Op → OP</code> 命令。</li>
<li><strong>返回 Pre-Op</strong>：如果数据异常，主站可发送 <code>Safe-Op → Pre-Op</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-操作（Operational-OP）"><a href="#4-操作（Operational-OP）" class="headerlink" title="4. 操作（Operational, OP）"></a><strong>4. 操作（Operational, OP）</strong></h3><ul>
<li><strong>功能</strong>：从站进入<strong>全功能状态</strong>，主站可以<strong>读取输入数据、写入输出数据</strong>，正式运行 EtherCAT 过程数据（PDO）。</li>
<li><strong>特性</strong>：<ul>
<li>允许<strong>完整过程数据通信</strong>（输入&#x2F;输出）。</li>
<li>适用于<strong>正常生产、设备运行</strong>。</li>
</ul>
</li>
<li><strong>状态转换</strong>：<ul>
<li><strong>返回 Safe-Op</strong>：如果出现紧急情况（如数据错误），主站可发送 <code>OP → Safe-Op</code> 命令。</li>
<li><strong>返回 Pre-Op</strong>：如果主站要修改配置，主站可发送 <code>OP → Pre-Op</code> 命令。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="状态转换流程"><a href="#状态转换流程" class="headerlink" title="状态转换流程"></a><strong>状态转换流程</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. Init → Pre-Op（初始化完成，进入参数配置）</span><br><span class="line">2. Pre-Op → Safe-Op（参数配置完成，输入数据可用）</span><br><span class="line">3. Safe-Op → OP（进入全功能模式，允许数据输入/输出）</span><br><span class="line">4. OP → Safe-Op/Pre-Op/Init（错误或主站请求降级）</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ethercat.org/download/press/ethercat_state_machine.png"></p>
<hr>
<h2 id="异常状态处理"><a href="#异常状态处理" class="headerlink" title="异常状态处理"></a><strong>异常状态处理</strong></h2><p>如果从站发生错误，它可能：</p>
<ul>
<li><strong>进入 “错误状态”（Error）</strong>（通常表现为 Safe-Op 或 Init）。</li>
<li><strong>重启后回到 Init 状态</strong>，等待重新进入 OP。</li>
</ul>
<p>主站可以通过：</p>
<ul>
<li><strong>检查 AL 状态寄存器</strong></li>
<li><strong>读取诊断信息</strong></li>
<li><strong>尝试重新配置</strong></li>
</ul>
<p>来判断从站的状态并进行恢复。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>EtherCAT 从站有 4 种状态：</p>
<table>
<thead>
<tr>
<th><strong>状态</strong></th>
<th><strong>能否进行 PDO 通信？</strong></th>
<th><strong>应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Init</strong></td>
<td>❌ 不能</td>
<td>上电、基础通信</td>
</tr>
<tr>
<td><strong>Pre-Op</strong></td>
<td>❌ 不能</td>
<td>参数配置</td>
</tr>
<tr>
<td><strong>Safe-Op</strong></td>
<td>✅ 只能读取输入</td>
<td>调试、验证</td>
</tr>
<tr>
<td><strong>OP（Operational）</strong></td>
<td>✅ 允许输入&#x2F;输出</td>
<td>正常运行</td>
</tr>
</tbody></table>
<p>EtherCAT 主站通过 <strong>状态机控制</strong> 从站，确保从 <strong>初始化 → 预操作 → 安全操作 → 运行</strong> 的<strong>安全平稳过渡</strong>。</p>
<h2 id="ethercat-主站与从站通讯协议"><a href="#ethercat-主站与从站通讯协议" class="headerlink" title="ethercat 主站与从站通讯协议"></a>ethercat 主站与从站通讯协议</h2><p>EtherCAT（<strong>Ethernet for Control Automation Technology</strong>）是一种基于<strong>以太网</strong>的实时工业网络协议，广泛用于<strong>运动控制、I&#x2F;O、传感器、机器人</strong>等领域。EtherCAT 的核心是<strong>主站（Master）</strong>和<strong>从站（Slave）</strong>之间的高速数据交换，采用<strong>主从架构</strong>。  </p>
<hr>
<h2 id="1-EtherCAT-通讯协议架构"><a href="#1-EtherCAT-通讯协议架构" class="headerlink" title="1. EtherCAT 通讯协议架构"></a><strong>1. EtherCAT 通讯协议架构</strong></h2><p>EtherCAT 采用<strong>以太网帧</strong>进行通信，但与标准以太网不同，EtherCAT 具有以下特点：</p>
<ul>
<li><strong>主站（Master）</strong> 负责发送和处理EtherCAT 数据包，不需要专用芯片，可由普通网卡或专用控制器实现。</li>
<li><strong>从站（Slave）</strong> 设备按照帧数据处理规则响应主站请求，通常使用<strong>EtherCAT专用芯片</strong>（如<strong>ET1100</strong>）。</li>
<li><strong>循环拓扑</strong> 方式（支持菊花链、环形、树形等），数据帧沿<strong>单向传输</strong>。</li>
<li><strong>帧穿透</strong> 机制：数据包在传输时直接在从站设备间传递，无需存储转发。</li>
</ul>
<hr>
<h2 id="2-EtherCAT-通讯流程"><a href="#2-EtherCAT-通讯流程" class="headerlink" title="2. EtherCAT 通讯流程"></a><strong>2. EtherCAT 通讯流程</strong></h2><p>EtherCAT 通讯采用主站主动轮询方式：</p>
<ol>
<li><p><strong>主站发送EtherCAT帧</strong></p>
<ul>
<li>主站生成数据帧，并包含多个<strong>过程数据对象（PDO）</strong>。</li>
<li>帧内携带多个从站的数据请求&#x2F;指令。</li>
</ul>
</li>
<li><p><strong>从站解析和处理帧</strong></p>
<ul>
<li>帧经过从站时，<strong>从站在数据帧上直接读写相关数据区域</strong>，而不是接收整个帧再处理。</li>
<li>这极大提升了通信效率，避免了传统以太网的<strong>存储转发</strong>延迟。</li>
</ul>
</li>
<li><p><strong>主站接收并解析返回数据</strong></p>
<ul>
<li>当帧经过所有从站后，数据会返回给主站，主站读取修改后的数据。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-EtherCAT-帧结构"><a href="#3-EtherCAT-帧结构" class="headerlink" title="3. EtherCAT 帧结构"></a><strong>3. EtherCAT 帧结构</strong></h2><p>EtherCAT 帧基于标准<strong>IEEE 802.3 以太网帧</strong>，但采用特殊的<strong>EtherType &#x3D; 0x88A4</strong>，表示是EtherCAT数据帧。</p>
<p>EtherCAT 数据帧结构如下：</p>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>长度（字节）</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>目标MAC地址</td>
<td>6</td>
<td>目的设备MAC</td>
</tr>
<tr>
<td>源MAC地址</td>
<td>6</td>
<td>发送设备MAC</td>
</tr>
<tr>
<td>EtherType</td>
<td>2</td>
<td>固定为 0x88A4</td>
</tr>
<tr>
<td>EtherCAT数据</td>
<td>46-1500</td>
<td>实际数据，包含多个命令</td>
</tr>
<tr>
<td>CRC校验</td>
<td>4</td>
<td>以太网帧校验</td>
</tr>
</tbody></table>
<p>EtherCAT数据部分主要包含：</p>
<ul>
<li><strong>命令头（CMD Header）</strong><ul>
<li>包含<strong>命令类型（LRW、APRD、APWR、BRD等）</strong>，目标<strong>从站地址</strong>，数据长度等信息。</li>
</ul>
</li>
<li><strong>过程数据（Process Data）</strong><ul>
<li>具体的输入&#x2F;输出数据内容。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-主要EtherCAT通信命令"><a href="#4-主要EtherCAT通信命令" class="headerlink" title="4. 主要EtherCAT通信命令"></a><strong>4. 主要EtherCAT通信命令</strong></h2><p>EtherCAT 主站与从站的通讯主要基于以下<strong>命令类型</strong>：</p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>缩写</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>逻辑读取</td>
<td><strong>LRD</strong></td>
<td>读取过程数据</td>
</tr>
<tr>
<td>逻辑写入</td>
<td><strong>LWR</strong></td>
<td>写入过程数据</td>
</tr>
<tr>
<td>逻辑读写</td>
<td><strong>LRW</strong></td>
<td>读写数据，最常用</td>
</tr>
<tr>
<td>自动增量读取</td>
<td><strong>APRD</strong></td>
<td>按自动增量地址读取</td>
</tr>
<tr>
<td>自动增量写入</td>
<td><strong>APWR</strong></td>
<td>按自动增量地址写入</td>
</tr>
<tr>
<td>自动增量读写</td>
<td><strong>APRW</strong></td>
<td>读写数据，并自动增量</td>
</tr>
<tr>
<td>广播读取</td>
<td><strong>BRD</strong></td>
<td>读取所有从站数据</td>
</tr>
<tr>
<td>广播写入</td>
<td><strong>BWR</strong></td>
<td>写入所有从站数据</td>
</tr>
</tbody></table>
<hr>
<h2 id="5-EtherCAT-工作模式"><a href="#5-EtherCAT-工作模式" class="headerlink" title="5. EtherCAT 工作模式"></a><strong>5. EtherCAT 工作模式</strong></h2><p>EtherCAT 主要有以下<strong>4种工作模式</strong>：</p>
<h3 id="1）自由运行模式（Free-Run-Mode）"><a href="#1）自由运行模式（Free-Run-Mode）" class="headerlink" title="1）自由运行模式（Free Run Mode）"></a><strong>1）自由运行模式（Free Run Mode）</strong></h3><ul>
<li>主站<strong>不停发送数据</strong>，不依赖同步时钟。</li>
<li>适用于简单IO控制，不需要高精度同步。</li>
</ul>
<h3 id="2）同步管理模式（SM-Sync-Mode）"><a href="#2）同步管理模式（SM-Sync-Mode）" class="headerlink" title="2）同步管理模式（SM Sync Mode）"></a><strong>2）同步管理模式（SM Sync Mode）</strong></h3><ul>
<li>通过<strong>同步管理器（Sync Manager）</strong>控制数据交换。</li>
<li>适用于<strong>离散IO</strong>，但同步性较低。</li>
</ul>
<h3 id="3）分布式时钟模式（DC-Mode）"><a href="#3）分布式时钟模式（DC-Mode）" class="headerlink" title="3）分布式时钟模式（DC Mode）"></a><strong>3）分布式时钟模式（DC Mode）</strong></h3><ul>
<li>采用<strong>从站时钟同步机制</strong>，主站下发时间戳，从站调整本地时钟。</li>
<li>适用于<strong>高精度运动控制</strong>，同步精度可达<strong>纳秒级</strong>。</li>
</ul>
<h3 id="4）周期同步模式（Cyclic-Sync-Mode）"><a href="#4）周期同步模式（Cyclic-Sync-Mode）" class="headerlink" title="4）周期同步模式（Cyclic Sync Mode）"></a><strong>4）周期同步模式（Cyclic Sync Mode）</strong></h3><ul>
<li>类似DC模式，但主站以<strong>固定周期</strong>发送数据。</li>
<li>适用于<strong>实时性要求高的应用</strong>（如伺服驱动）。</li>
</ul>
<hr>
<h2 id="6-EtherCAT与其他工业总线对比"><a href="#6-EtherCAT与其他工业总线对比" class="headerlink" title="6. EtherCAT与其他工业总线对比"></a><strong>6. EtherCAT与其他工业总线对比</strong></h2><table>
<thead>
<tr>
<th><strong>总线类型</strong></th>
<th><strong>通信方式</strong></th>
<th><strong>同步精度</strong></th>
<th><strong>通信速率</strong></th>
<th><strong>优点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CANopen</td>
<td>轮询+事件触发</td>
<td>毫秒级</td>
<td>1Mbps</td>
<td>成熟稳定，成本低</td>
</tr>
<tr>
<td>PROFINET</td>
<td>以太网+RT&#x2F;IRT</td>
<td>微秒级</td>
<td>100Mbps</td>
<td>兼容性好，普及广</td>
</tr>
<tr>
<td>EtherCAT</td>
<td>主站轮询</td>
<td>纳秒级</td>
<td>100Mbps</td>
<td>高速、低延迟</td>
</tr>
</tbody></table>
<hr>
<h2 id="7-EtherCAT-应用场景"><a href="#7-EtherCAT-应用场景" class="headerlink" title="7. EtherCAT 应用场景"></a><strong>7. EtherCAT 应用场景</strong></h2><ul>
<li><strong>运动控制</strong><ul>
<li>伺服驱动、电机控制</li>
<li>CNC机床、机器人控制</li>
</ul>
</li>
<li><strong>工业自动化</strong><ul>
<li>PLC与IO模块连接</li>
<li>传感器数据采集</li>
</ul>
</li>
<li><strong>半导体制造</strong><ul>
<li>高精度同步传输</li>
</ul>
</li>
<li><strong>汽车测试</strong><ul>
<li>车辆HIL仿真测试系统</li>
</ul>
</li>
</ul>
<hr>
<h2 id="8-结论"><a href="#8-结论" class="headerlink" title="8. 结论"></a><strong>8. 结论</strong></h2><p>EtherCAT 作为高性能工业以太网协议，具有<strong>低延迟、高同步精度</strong>的特点，广泛应用于<strong>实时控制领域</strong>。主站通过<strong>轮询</strong>与从站通信，从站在<strong>数据帧穿透</strong>机制下直接修改数据，提高了通信效率，是目前<strong>工业4.0和智能制造</strong>的核心技术之一。</p>
<h2 id="ethercat-是什么-详细解释"><a href="#ethercat-是什么-详细解释" class="headerlink" title="ethercat 是什么 详细解释"></a>ethercat 是什么 详细解释</h2><h3 id="EtherCAT-详解"><a href="#EtherCAT-详解" class="headerlink" title="EtherCAT 详解"></a>EtherCAT 详解</h3><p><strong>EtherCAT</strong>（<strong>以太网控制自动化技术</strong>）是一种基于以太网的高性能实时工业通信协议，专为工业自动化系统设计。它由德国Beckhoff公司于2003年开发，现已成为工业自动化领域的重要标准（IEC 61158）。</p>
<hr>
<h4 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a><strong>核心特点</strong></h4><ol>
<li><p><strong>实时性与高效性</strong>  </p>
<ul>
<li><strong>数据帧“飞行处理”机制</strong>：主站发送的以太网帧依次经过每个从站设备，各从站实时提取或插入数据（类似“快递包裹”在传输过程中被动态处理），大幅减少通信延迟，典型周期低至100 μs。</li>
<li><strong>带宽利用率高</strong>：单个帧可携带多个设备的数据，支持最大1486字节的有效载荷。</li>
</ul>
</li>
<li><p><strong>主从架构</strong>  </p>
<ul>
<li><strong>主站（Master）</strong>：控制网络，生成和解析数据帧（如PLC、IPC）。</li>
<li><strong>从站（Slave）</strong>：执行具体任务（如伺服驱动器、I&#x2F;O模块），每个从站有唯一地址，支持热插拔。</li>
</ul>
</li>
<li><p><strong>分布式时钟同步</strong>  </p>
<ul>
<li>主站与从站通过精确的时间戳同步，实现<strong>纳秒级时钟偏差</strong>，确保多设备协同（如机器人多轴同步）。</li>
</ul>
</li>
<li><p><strong>灵活拓扑结构</strong>  </p>
<ul>
<li>支持线型、树型、星型拓扑，并可混合使用，适应复杂工业环境布线需求。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a><strong>技术细节</strong></h4><ul>
<li><p><strong>协议结构</strong><br>EtherCAT帧嵌入标准以太网帧（类型字段<code>0x88A4</code>），兼容常规以太网硬件（需从站支持EtherCAT专用芯片如ESC）。</p>
</li>
<li><p><strong>通信模式</strong>  </p>
<ul>
<li><strong>过程数据通信（PDO）</strong>：实时传输控制信号（如电机位置）。</li>
<li><strong>邮箱数据通信（SDO）</strong>：非实时配置参数或传输文件。</li>
</ul>
</li>
<li><p><strong>分布式时钟（DC）机制</strong><br>主站选定参考时钟，从站测量链路延迟并动态调整本地时钟，确保全网络时间同步。</p>
</li>
</ul>
<hr>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h4><ul>
<li><strong>性能</strong>：支持≤1000节点，循环周期低至微秒级。</li>
<li><strong>成本效益</strong>：基于标准以太网硬件，无需专用交换机。</li>
<li><strong>兼容性</strong>：支持CoE（CANopen over EtherCAT）、FoE（文件传输）等应用层协议。</li>
<li><strong>扩展性</strong>：通过EtherCAT分支器（如EBUS）可扩展复杂网络。</li>
</ul>
<hr>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ol>
<li><strong>工业机器人</strong>：多关节同步控制，路径精度优化。</li>
<li><strong>数控机床</strong>：高精度加工，实时反馈刀具状态。</li>
<li><strong>包装机械</strong>：高速生产线上的同步启停与张力控制。</li>
<li><strong>能源管理</strong>：分布式光伏逆变器的实时监控。</li>
</ol>
<hr>
<h4 id="标准化与生态"><a href="#标准化与生态" class="headerlink" title="标准化与生态"></a><strong>标准化与生态</strong></h4><ul>
<li><strong>ETG（EtherCAT技术协会）</strong>：全球拥有7,000+会员，推动协议标准化。</li>
<li><strong>开发工具</strong>：如Beckhoff TwinCAT、CODESYS，支持PLC编程与网络配置。</li>
<li><strong>硬件支持</strong>：TI、Infineon等提供ESC芯片，多家厂商推出兼容I&#x2F;O模块、驱动器。</li>
</ul>
<hr>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>EtherCAT凭借其实时性、灵活性和高性价比，成为工业4.0的核心通信技术之一，尤其适用于需要高速同步和复杂控制的场景。随着边缘计算和TSN（时间敏感网络）的融合，其未来在智能制造中的应用将更加广泛。</p>
<h2 id="ethercat-和-xenomai-分别是什么-详细解释"><a href="#ethercat-和-xenomai-分别是什么-详细解释" class="headerlink" title="ethercat 和 xenomai 分别是什么 详细解释"></a>ethercat 和 xenomai 分别是什么 详细解释</h2><p>EtherCAT 和 Xenomai 是两个在工业自动化和实时系统中广泛应用的关键技术，但它们的功能和应用领域不同。以下是详细解释：</p>
<hr>
<h3 id="1-EtherCAT"><a href="#1-EtherCAT" class="headerlink" title="1. EtherCAT"></a><strong>1. EtherCAT</strong></h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p><strong>EtherCAT</strong>（Ethernet for Control Automation Technology）是一种基于以太网的<strong>实时工业通信协议</strong>，专为工业自动化中的高速、高精度控制设计。它由德国 Beckhoff 公司开发，现已成为国际标准（IEC 61158）。</p>
<h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a><strong>核心特性</strong></h4><ol>
<li><p><strong>实时性</strong>  </p>
<ul>
<li>数据帧在传输过程中被从站设备（Slave）<strong>“实时处理”</strong>，而非存储转发，显著降低通信延迟（典型周期低至 100 μs）。</li>
<li>支持分布式时钟（Distributed Clocks, DC），实现全系统的时间同步（精度可达纳秒级）。</li>
</ul>
</li>
<li><p><strong>高效带宽利用</strong>  </p>
<ul>
<li>数据帧在传输过程中被多个从站设备依次读取和写入，单帧可完成对所有设备的读写操作，减少带宽占用。</li>
</ul>
</li>
<li><p><strong>灵活拓扑结构</strong>  </p>
<ul>
<li>支持线型、树型、星型等多种拓扑，无需专用交换机，降低成本。</li>
</ul>
</li>
<li><p><strong>主从架构</strong>  </p>
<ul>
<li><strong>主站（Master）</strong>：控制通信周期，发起数据交换（如 PLC、工业 PC）。</li>
<li><strong>从站（Slave）</strong>：执行具体任务（如伺服驱动器、I&#x2F;O模块）。</li>
</ul>
</li>
</ol>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h4><ul>
<li>主站发送一个以太网帧，从站设备在帧通过时<strong>直接提取或插入数据</strong>，无需等待完整帧传输完毕。</li>
<li>数据帧在环型或线型拓扑中依次传递，最终由主站回收并处理。</li>
</ul>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ul>
<li>运动控制（如多轴伺服驱动）</li>
<li>分布式 I&#x2F;O 系统</li>
<li>可编程逻辑控制器（PLC）</li>
<li>机器人控制系统</li>
</ul>
<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a><strong>优势</strong></h4><ul>
<li>高性价比（基于标准以太网硬件）</li>
<li>低延迟、高同步精度</li>
<li>适用于大规模分布式系统</li>
</ul>
<hr>
<h3 id="2-Xenomai"><a href="#2-Xenomai" class="headerlink" title="2. Xenomai"></a><strong>2. Xenomai</strong></h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h4><p><strong>Xenomai</strong> 是一个开源的<strong>实时操作系统框架</strong>（Real-Time Operating System Framework），旨在为 Linux 提供<strong>硬实时（Hard Real-Time）</strong>能力。它通过内核扩展和协作调度机制，使普通 Linux 系统能够满足严格实时性要求。</p>
<h4 id="核心特性-1"><a href="#核心特性-1" class="headerlink" title="核心特性"></a><strong>核心特性</strong></h4><ol>
<li><p><strong>双核架构（Cobalt Core）</strong>  </p>
<ul>
<li><strong>实时核（Xenomai）</strong>：处理硬实时任务（如中断响应、定时器）。</li>
<li><strong>非实时核（Linux）</strong>：运行普通任务（如网络通信、文件系统）。</li>
</ul>
</li>
<li><p><strong>Adéos 中间层</strong>  </p>
<ul>
<li>作为硬件抽象层，接管中断并优先分配给 Xenomai 实时核，确保实时任务的确定性。</li>
</ul>
</li>
<li><p><strong>实时 API 支持</strong>  </p>
<ul>
<li>提供多种实时编程接口（如 POSIX、VxWorks 风格的 API），支持跨平台实时应用开发。</li>
<li>与 Linux 原生 API（如 pthreads）兼容。</li>
</ul>
</li>
<li><p><strong>硬实时性能</strong>  </p>
<ul>
<li>中断响应延迟通常低于 10 μs，适用于微秒级精度的控制任务。</li>
</ul>
</li>
</ol>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h4><ul>
<li>Xenomai 通过修改 Linux 内核（或作为内核模块），在硬件中断和 Linux 内核之间插入实时调度层。</li>
<li>实时任务运行在 Xenomai 核，直接访问硬件资源，避免 Linux 内核的调度延迟。</li>
</ul>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ul>
<li>机器人关节控制</li>
<li>CNC 机床</li>
<li>高速数据采集系统</li>
<li>航空航天控制系统</li>
</ul>
<h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a><strong>优势</strong></h4><ul>
<li>低成本（基于开源 Linux）</li>
<li>兼容现有 Linux 生态</li>
<li>硬实时性能接近专用 RTOS（如 VxWorks）</li>
</ul>
<hr>
<h3 id="3-EtherCAT-与-Xenomai-的结合"><a href="#3-EtherCAT-与-Xenomai-的结合" class="headerlink" title="3. EtherCAT 与 Xenomai 的结合"></a><strong>3. EtherCAT 与 Xenomai 的结合</strong></h3><p>在工业控制系统中，两者常结合使用：  </p>
<ul>
<li><strong>Xenomai</strong> 提供实时操作系统环境，确保控制任务的确定性。</li>
<li><strong>EtherCAT</strong> 作为实时通信协议，连接主站（如运行 Xenomai 的工控机）与从站设备（如伺服驱动器）。</li>
</ul>
<h4 id="典型架构示例"><a href="#典型架构示例" class="headerlink" title="典型架构示例"></a><strong>典型架构示例</strong></h4><ol>
<li><strong>硬件</strong>：工业 PC（主站） + EtherCAT 从站设备（伺服驱动器、I&#x2F;O模块）。  </li>
<li><strong>软件</strong>：  <ul>
<li>Xenomai 实时核处理运动控制算法、中断响应。  </li>
<li>EtherCAT 主站协议栈（如 IgH EtherCAT Master）运行在 Xenomai 实时环境中，确保通信周期精确。  </li>
<li>Linux 非实时核处理人机界面（HMI）和网络通信。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>EtherCAT</strong>：实时工业以太网协议，解决高速、高精度设备通信问题。  </li>
<li><strong>Xenomai</strong>：实时操作系统框架，为 Linux 提供硬实时能力。  </li>
<li><strong>协同价值</strong>：在复杂控制系统中，Xenomai 保障实时任务执行，EtherCAT 实现高效设备通信，共同构建高性能工业自动化平台。</li>
</ul>
<h2 id="EtherCAT"><a href="#EtherCAT" class="headerlink" title="EtherCAT"></a>EtherCAT</h2><ul>
<li><p><code>EtherCAT</code>是<code>Ethernet for Control Automation Technolog</code>的简称，是一个实时控制的开放标准。</p>
</li>
<li><p><code>ETG</code>, <code>EtherCAT技术小组</code>，该组织是<code>Beckhoff</code>为支持和推广<code>EtherCAT</code>而成立的。<code>ETG</code>网站是关于<code>EtherCAT</code>的信息来源。</p>
</li>
</ul>
<h3 id="EtherCAT-xenomai-安装"><a href="#EtherCAT-xenomai-安装" class="headerlink" title="EtherCAT xenomai 安装"></a>EtherCAT xenomai 安装</h3><ul>
<li><del><code>notes/PDF/EtherCAT（ubuntu18.04，linux4.9.38，xenomai3.1，igh1.52）配置完整流程.docx</code></del> </li>
<li>pdf文档配置menuconfig时步骤不完整，坑！！！</li>
<li>另一个地址:<code>https://www.icode9.com/content-3-916631.html</code></li>
</ul>
<h3 id="固定RxPDOs"><a href="#固定RxPDOs" class="headerlink" title="固定RxPDOs"></a>固定<code>RxPDOs</code></h3><ul>
<li><p><code>notes/PDF/AP系列驱动器+EtherCAT+手册V1.0.pdf -- P12</code></p>
</li>
<li><p>**对于<code>CSP</code>(循环同步位置)**0x6060的操作方式&#x3D;8：</p>
<ul>
<li>接收PDO 4 ： 0x1700<ul>
<li><code>0x6040</code> – 控制字</li>
<li><code>0x607A</code> – 轨迹目标位置</li>
<li><code>0x60B1</code> – 速度偏移</li>
<li><code>0x60B2</code> – 转矩偏移</li>
</ul>
</li>
</ul>
</li>
<li><p>对于<code>CSV</code>(循环同步速度)0x6060的操作模式&#x3D;9：</p>
<ul>
<li>接收PDO 5：0x1701<ul>
<li><code>0x6040</code> – 控制字</li>
<li><code>0x60FF</code> – 目标速度</li>
<li><code>0x60B2</code> – 转矩偏移量</li>
</ul>
</li>
</ul>
</li>
<li><p>对于<code>CST</code>(循环同步转矩)0x6060的操作方式&#x3D;10：</p>
<ul>
<li>接收PDO 6：0x1702<ul>
<li><code>0x6040</code> – 控制字</li>
<li><code>0x60FF</code> – 目标速度</li>
<li><code>0x60B2</code> – 转矩偏移量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="固定TxPDO"><a href="#固定TxPDO" class="headerlink" title="固定TxPDO"></a>固定<code>TxPDO</code></h3><ul>
<li>发送PDO 5：0x1B00<ul>
<li><code>0x6041</code> – 16 – 状态字</li>
<li><code>0x6064</code> – 32 – 实际电机位置</li>
<li><code>0x60F4</code> – 32 – 位置循环错误（跟随错误）</li>
<li><code>0x606C</code> – 32 – 实际电机速度</li>
<li><code>0x6077</code> – 16 – 转矩实际值</li>
</ul>
</li>
</ul>
<h3 id="请求主站"><a href="#请求主站" class="headerlink" title="请求主站"></a>请求主站</h3><ul>
<li><p>用户程序通过<code>ecrt_request_master</code>请求主站设备，该函数调用<code>ecrt_request_master_err()</code>，取得<code>master</code>设备，并执行<code>ec_master_enter_operation_phase()</code>函数</p>
</li>
<li><p>请求主站设备完成后，开始<strong>创建数据域</strong>，调用<code>ecrt_master_create_domain()</code></p>
</li>
<li><p>创建数据域成功后，分别完成对各从站设备的配置，配置内容包括：<code>PDO</code>映射，<code>SM</code>配置，<code>FFMU</code>配置和<code>DC</code>配置</p>
</li>
<li><p>用户程序调用的入口是<code>ecrt.h</code>和相关的库文件，通过<code>ioctl</code>以驱动的形式实现，与<code>master</code>文件夹中的部分函数稍有区别</p>
</li>
</ul>
<h3 id="从站配置"><a href="#从站配置" class="headerlink" title="从站配置"></a>从站配置</h3><ul>
<li>从站配置是应用层通过<code>ecrt_master_slave_config()</code>函数添加到主站的<code>config</code>链表中</li>
</ul>
<h2 id="PDO"><a href="#PDO" class="headerlink" title="PDO"></a>PDO</h2><ul>
<li><p>过程数据对象(<code>Process Data Object, PDO</code>)，是用来传输实时数据的，提供对设备应用对象的直接访问通道，它用来传输实时短帧数据，具有较高的优先权。</p>
</li>
<li><p><code>PDO</code>传输的数据必须少于或等于8个字节，<code>PDO</code>的<strong>CAN报文数据域</strong>中每个字节都用作数据传输，因此，在应用层上不包含传输控制信息，报文利用率极高。</p>
</li>
<li><p><code>PDO</code>通信是基于生产者&#x2F;消费者的通讯模式，每个<code>PDO</code>有一个唯一的标识符且可以通过一个节点发送，但有多个节点可以接收。<code>PDO</code>的接收不需要消费者确认。</p>
<ul>
<li>由生产者发送的<code>PDO</code>称为发送PDO<code>(TPDO)</code></li>
<li>由消费者接收的<code>PDO</code>称为接收PDO<code>(RPDO)</code></li>
</ul>
</li>
<li><p>每个<code>PDO</code>在对象字典中由两个对象描述： 通信参数和映射参数</p>
<ul>
<li><code>PDO</code>通信参数指明使用哪个<code>COB-ID</code>，传输类型，禁用时间和定时时间</li>
<li><code>PDO</code>映射参数用于设定<code>PDO</code>报文中的数据的映射关系，确定要传输的数据在<code>CAN</code>报文数据域中的定位。该参数允许<code>PDO</code>的生产者和消费者知道正在传输什么信息，而不需要在<code>CAN</code>报文中增加额外的协议控制信息，使传输的效率达到最高。一个<code>PDO</code>最多可以映射64个对象</li>
</ul>
</li>
<li><p><code>PDO</code>通讯具有三种出发模式：内部事件驱动或内部定时器触发，同步触发，远程请求触发</p>
<ul>
<li><strong>内部事件驱动或内部定时触发。</strong>通讯由某一事件触发。例如数字I&#x2F;O口状态改变，超过预先设定的值，定时器中断等都会触发节点发送一个<code>PDO</code>。这种模式可使总线负载达到最小，在相对低的波特率下获得比较高的通讯特性。</li>
<li><strong>同步触发。</strong>同步触发<code>PDO</code>是指<code>CANopen</code>节点收到由管理节点发出的同步报文（同步对象Sync）之后，根据触发报文条件向总线发出<code>PDO</code>报文。同步传输又分为周期性和非周期性。周期性是指<code>CANopen</code>节点收到一定数量的同步报文之后才开始发送；非周期性<code>PDO</code>是指<code>PDO</code>触发条件成立之后，当收到下一个同步对象后马上发送<code>PDO</code></li>
<li><strong>远程请求触发。</strong><code>PDO</code>消费者可以给<code>PDO</code>生产者发送远程<code>PDO</code>请求，相应<code>PDO</code>生产者将对远程帧作出相应，向总线上发送相应的<code>PDO</code>数据。</li>
</ul>
</li>
<li><p><code>PDO</code>通讯时的触发模式由<code>PDO</code>通信参数中的传输类型来确定，传输类型是一个8位无符号整数，这个传输类型值的大小与<code>PDO</code>触发方式的对应关系</p>
</li>
<li><p>主站和从站<code>PDO</code>通信的机制</p>
<ul>
<li><code>PDO</code>的基本概念及其在对象字典中的索引，在主站和从战采用<code>PDO</code>通信方式时，思路是 – 先配置主站的<code>PDO</code>的通信参数(COB-ID,数据传输类型)，再配置从站的通信参数与主站一致，这样就建立了主站与从站的<code>PDO</code>通信的关系。然后再通过字典配置主站<code>PDO</code>映射参数，配置完成后从主站就可以通过<code>PDO</code>通信传输数据。</li>
</ul>
</li>
<li><p><code>PDO</code>传输的“总指挥”就是对象字典。<code>PDO</code>发送什么数据，接收什么数据，什么时候发送和接收，发送和接收的数据都放在哪儿，都是由对象字典配置。</p>
</li>
</ul>
<h2 id="CAN"><a href="#CAN" class="headerlink" title="CAN"></a>CAN</h2><ul>
<li>CAN是控制器局域网络(<code>Controller Area Network, CAN</code>)的简称，是由以研发和生产汽车电子产品著称的德国<code>BOSCH</code>公司开发的，并最终称为国际标准，是国际上应用最广泛的<strong>现场总线</strong>之一</li>
</ul>
<h2 id="EtherCAT-使用与解析–关于ethercat应用层使用"><a href="#EtherCAT-使用与解析–关于ethercat应用层使用" class="headerlink" title="EtherCAT 使用与解析–关于ethercat应用层使用"></a>EtherCAT 使用与解析–关于ethercat应用层使用</h2><ul>
<li><p>url – <code>https://blog.csdn.net/lswdcyy/article/details/105441470</code></p>
</li>
<li><p>下载<code>ethercat</code>源码并且安装好之后，测试<code>ethercat</code>使用可以遵循以下步骤</p>
</li>
<li><p>开启<code>ethercat</code>系统 – <code>sudo /etc/init.d/ethercat start</code></p>
<ul>
<li>执行这一步需要确保一点 – 按照<code>ethercat</code>源码中的<code>README</code>指导将一些需要的文件复制以及创建软连接到<code>/opt/init.d/ethercat</code>以及<code>/opt/sysconfig/ethercat</code>两个文件，前者是系统启动文件，后者是系统配置文件</li>
<li>系统配置文件，是一份变量定义文件，在系统启动脚本中执行，定义两类变量，一个是主站MAC地址(<code>MASTER0_DEVICE</code>)，一个是使用的模块驱动名称(<code>DEVICE_MODULES</code>)</li>
</ul>
</li>
<li><p>开启系统后，要在应用层进行对主站模块的使用，本质上是通过开启<code>/dev/EtherCAT</code>字符设备，而后基于<code>ioctl</code>方式调用内核主站模块各种功能</p>
<ul>
<li>开启系统后，用户主要需要进行从站配置与PDO映射，域操作功能，然后就可以进行PDO交换了</li>
<li><strong>主站程序运行在内核空间，应用层需要一种方式实现对内核调用。通过打开主站创建的字符设备<code>/dev/EtherCAT</code>就是这个作用</strong></li>
<li>主要用到的函数<ul>
<li><code>ec_master_t *ecrt_request_master(unsigned int master_index);</code> – <ul>
<li><strong>负责打开字符设备文件，传入参数为使用主站索引</strong>（使用<code>/etc/init.d/ethercat</code>开启系统的时候可以一次性传入多个MAC地址从而开启多个主站，不同主站创建不同的字符设备，例如<code>/dev/EtherCAT0, /dev/EtherCAT1...</code>），</li>
<li>而这个索引就是用于开启对应的字符设备，从而使用不同的主站，使用<code>open接口</code>打开，然后返回文件描述符，该文件描述符用于<code>ioctl</code>调用对应主站功能。另外在申请到主站后就不再允许进行总线的重新扫描，固化了主站连接的从站链表，而且设置从站状态当前申请状态为<code>PREOP</code></li>
</ul>
</li>
<li><code>ec_domain_t *ecrt_master_create_domain(ec_master_t* master);</code><ul>
<li><strong>负责创建域，</strong><code>domain</code>与<code>PDO</code>映射有密切联系，在激活的位置详谈</li>
<li>这个函数具体内容就是直接在内核空间中创建一块<code>ec_domain</code>空间并且将该空间连接到主站<code>domain</code>链表尾部</li>
</ul>
</li>
<li><code>ec_slave_config_t *ecrt_master_slave_config(ec_master_t* master, uint16_t alias, uint16_t position, uint32_t vendor_id, uint32_t product_code);</code><ul>
<li><strong>从站配置函数</strong>，</li>
<li>主站模块中的从站链表，它们之间的关系为：从站配置是应用层通过<code>ecrt_master_slave_config()</code>函数添加到主站的<code>configs</code>链表中的，而从站链表<code>slaves</code>则是通过<code>ethercat</code>主站状态机通过扫描<code>ethercat</code>总线得到的，两者的共同之处在于<strong>从站配置过程的<code>alias, position, VID, PID</code>，这些在主站扫描到的从站链表中都是有一份参数的，当应用层设置配置和主站扫描到从站信息相匹配的时候，那就将从站与从站配置相联系</strong>（这时候会将主站扫描的<code>SII</code>信息关于<code>sync</code>关联的<code>PDO</code>信息复制到从站配置中，也就是默认<code>PDO</code>配置）；这样，就可以通过从站配置寻找到主站模块中从站配置信息，进而获取到从站信息。</li>
</ul>
</li>
<li><code>int ecrt_slave_config_reg_pdo_entry(ec_slave_config_t *sc, uint16_t index, uint8_t subindex, ec_domain_t *domain, unsigned int *bit position);</code><ul>
<li><strong>从站配置<code>PDO</code>函数</strong></li>
<li>需要注意的一点 – 在主站正式激活之前，所有配置<code>PDO</code>相关的其实并没有相对应的空间申请操作，一切都是进行的计算，计算<code>PDO</code>需要多大空间，计算<code>domains</code>的逻辑位置，计算<code>FMMU</code>的逻辑位置，计算<code>PDO</code>的逻辑位置，直到主站正式激活，主站会根据自身已经申请的域链表<code>domains</code>，获取所有域所需要的空间大小，而后对每个域进行逻辑地址分配，每个域中再对每个<code>FMMU</code>进行逻辑地址分配。</li>
<li>接口参数<ul>
<li><code>uint16_t index</code> – 对象字典索引</li>
<li><code>uint8_t subindex</code> – 对象字典子索引</li>
<li><code>ec_domain_t *domain</code> – 使用的域</li>
<li><code>unsigned int* bit_position</code> – 一个Byte中的偏移量，当PDO映射逻辑地址不是完整的Byte时有用</li>
</ul>
</li>
<li>首先，通过从站应用层配置索引可以获取到主站的从站配置链表中对应的从站配置，而后根据配置目标domain的索引获取到主站的domains链表对应的域，这样就可以实现应用层的从站配置和domain切换到主站对应的从站配置和domain，然后进行pdo映射操作。</li>
<li>每次进行PDO映射的时候，并不是只对设置的一个对象进行处理，而是直接将整个sync关联的PDO都进行批次化处理。所以，本质上来讲，PDO配置映射就是确定PDO的逻辑地址位置</li>
</ul>
</li>
<li><code>int ecrt_master_activate(ec_master_t *master);</code><ul>
<li><strong>函数为正式激活的函数</strong></li>
<li>主站注册的domains链表整体大小计算；经过PDO注册映射之后，对主站中关联的每个domains都是相互独立的，并且每个domains都只是一个计算得到的值，其实并没有需要的空间申请，因此在主站激活的时候会将全部domians需要的空间进行统一申请。具体申请到的PDO映射逻辑空间存放在字符设备打开文件的priv指针处，关于字符设备的file-&gt;priv在字符设备打开eccdev_open的时候进行指定。然后按照主站连接的domains链表顺序对每个domian起始地址进行设置：主要是domain的逻辑起始地址，domain的大小，以及domain中的FMMU的逻辑地址重新设置，最终，domain和FMMU的逻辑起始地址都是在主站全部domains环境下的逻辑起始地址。为了进行PDO映射，在主站激活过程中还对每个domain需要的子报文进行空间申请。在计算子报文需要个数的时候，各个domain计算各自需要的子报文需要，这样就可以满足不同domain的PDO交换周期是可以单独设置的；在domain计算自己需要的子报文个数的时候，计算是以FMMU为一个基本单位进行计算的，每个子报文可承载的数据大小为1486Byte，然后根据一个子报文中FMMU的输入输出情况设置子报文类型，也就是EC_DATAGRAM_LRD类型子报文，EC_DATAGRAM_LRR类型子报文以及EC_DATAGRAM_LRW类型子报文。然后将这些子报文添加到domain的datagram_pairs链表中。当然，整体过程中，domain映射空间和子报文使用的数据空间都是同一段空间。</li>
<li>完成主站的domains域空间处理，之后就停止主站的空闲阶段线程（等待空间阶段线程退出）</li>
<li>开启主站的操作阶段线程，该线程和空闲阶段线程相比不同之处–在于将主站子报文队列组合发送移动到用户手中进行处理</li>
</ul>
</li>
<li><code>uint8_t *ecrt_domain_data(ec_domain_t *domain);</code><ul>
<li><strong>返回domain在逻辑空间的逻辑地址</strong></li>
</ul>
</li>
<li><code>void ecrt_domain_queue(ec_domain_t *domain);</code><ul>
<li><strong>将对应domain空间使用的子报文排列到主站子报文发送链表中</strong></li>
</ul>
</li>
<li><code>void ecrt_master_send(ec_master_t *master);</code><ul>
<li><strong>将主站的子报文发送链表的子报文进行发送</strong>，在发送过程中，默认的会将从站状态机子报文和主站状态机子报文进行排队发送</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ecrt-h头文件接口"><a href="#ecrt-h头文件接口" class="headerlink" title="ecrt.h头文件接口"></a><code>ecrt.h</code>头文件接口</h2><ul>
<li><p><code>ecrt_master_receive()</code></p>
<ul>
<li>功能：从硬件获取接收到的帧并处理数据报。通过调用中断服务例程查询网络设备接收到的帧。提取收到的数据报并将结果发送到队列中的数据报对象。接收到的数据报和超时的数据报将被标记并退出队列</li>
<li>函数原型：<code>void ecrt_master_receive(ec_master_t* master);</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_domain_process()</code></p>
<ul>
<li>功能：确定域数据报的状态。评估接收到的数据报的工作计数器，并在必要时输出统计信息。必须在<code>ecrt_master_receive()</code>接收域数据报之后调用此函数，以便<code>ecrt_domain_state()</code>返回上一次进程数据交换的结果。</li>
<li>函数原型：<code>void ecrt_domain_process(ec_domain_t *domain);</code></li>
<li>参数：<code>domain</code> – 域</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>EC_READ_U16()</code></p>
<ul>
<li>功能：宏函数，计算整数数据，同样还有<code>EC_READ_U32()</code></li>
</ul>
</li>
<li><p><code>EC_WRITE_U16()</code></p>
<ul>
<li>功能：宏函数，将整型数据写入内存。内存大小是<code>ecrt_slave_config_create_sdo_request()</code>的参数。</li>
</ul>
</li>
<li><p><code>ecrt_master_sync_reference_clock()</code></p>
<ul>
<li>功能：将DC参考时钟偏移补偿数据报排队发送，参考时钟将上次取消<code>ecrt_master_application_time()</code>提供的应用程序时间同步</li>
<li>函数原型：<code>void ecrt_master_sync_reference_clock(ec_master_t *master)</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_master_sync_slave_clocks()</code></p>
<ul>
<li>功能：将DC时钟偏移补偿数据报排队发送，所有的子时钟与基准时钟同步</li>
<li>函数原型：<code>void ecrt_master_sync_slave_clocks(ec_master_t* master);</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_domain_queue()</code></p>
<ul>
<li>功能：<strong>将主数据报队列中的所有域数据报排队</strong>。调用此函数可标记域的数据报以便在<code>ecrt_master_send()</code>的下一次调用</li>
<li>函数原型：<code>void ecrt_domain_queue(ec_domain_t* domain);</code></li>
<li>参数：<code>domain</code> – 域</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_master_send()</code></p>
<ul>
<li>功能：<strong>发送队列中的所有数据报</strong>。该方法接收所有排队等待传输的数据报，将他们放入帧中，并将他们传递给以太网设备进行发送</li>
<li>函数原型：<code>void ecrt_master_send(ec_master_t* master);</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_master_application_time()</code></p>
<ul>
<li>功能：设置应用程序时间。在使用分布式时钟操作从机时，主机必须知道应用程序的时间。时间不是由主机本身增加的，因此必须循环调用此方法</li>
<li>函数原型：<code>void ecrt_master_application_time(ec_master_t* master, uint64_t app_time);</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机；<code>app_time</code> – 应用时间</li>
<li>返回值：无</li>
</ul>
</li>
<li><p><code>ecrt_release_master()</code></p>
<ul>
<li>功能：释放请求的<code>ethercat</code>主机</li>
<li>函数原型：<code>void ecrt_release_master(ec_master_t* master);</code></li>
<li>参数：<code>master</code> – <code>ethercat</code>主机</li>
<li>返回值：无</li>
</ul>
</li>
</ul>
<h2 id="关于PDO映射"><a href="#关于PDO映射" class="headerlink" title="关于PDO映射"></a>关于PDO映射</h2><ul>
<li><p><code>https://www.codeleading.com/article/95113301360/#:~:text=%E5%BD%93%E7%84%B6%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E5%B0%B1%E6%98%AF%E4%BD%BF%E7%94%A8ecrt_slave_config_pdos,%28%29%E5%87%BD%E6%95%B0%E5%AF%B9%E4%BB%8E%E7%AB%99%E9%85%8D%E7%BD%AE%E8%BF%9B%E8%A1%8C%E8%AE%BE%E7%BD%AE%EF%BC%8C%E8%AF%A5%E5%87%BD%E6%95%B0%E4%BC%9A%E5%B0%86%E5%8E%9F%E6%9C%ACSII%E5%A4%8D%E5%88%B6%E5%88%B0%E7%9A%84%E4%BB%8E%E7%AB%99%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84sync%E8%BF%9B%E8%A1%8C%E6%B8%85%E9%99%A4%EF%BC%8C%E8%80%8C%E5%90%8E%E4%BE%9D%E6%8D%AE%E6%96%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BF%9B%E8%A1%8C%E8%AE%BE%E7%BD%AE%EF%BC%9A%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E7%BB%93%E6%9E%84%E5%A6%82%E4%B8%8B%EF%BC%9A</code></p>
</li>
<li><p>对于PDO映射，首先它是已经有了一个sync中关联PDO的链表的前提下才进行的PDO映射。</p>
</li>
<li><p>使用<code>ecrt_slave_config_pdos()</code>函数进行PDO的在<code>sync</code>中的配置</p>
<ul>
<li>之所以有这样一个步骤，是因为主站状态部分，主站状态机在扫描SII信息时会提取<code>TxPDO</code>和<code>RxPDO</code>到从站的同步管理器(SII信息中有PDO和sync相关的信息)；然后再使用<code>ecrt_master_slave_config()</code>进行函数配置的时候会将对应从站的sync相关的PDO(<code>master-&gt;slaves-&gt;sync</code>)复制到从站配置部分，这样即使不去人为的配置同步管理器和PDO的映射关系，也没有什么影响</li>
</ul>
</li>
<li><p><code>ecrt_slave_config_pdos()</code></p>
<ul>
<li>函数对从站配置进行设置，会将原本SII复制到从站配置中的sync进行清除，而后依据新的配置进行设置，（目的就是为了对从站同步管理器的自定义设置）</li>
<li>需要使用到的参数分别是<code>sync, pdo, pdo_entry</code>结构体，三者关系是<code>sync</code>索引<code>PDO</code>， <code>PDO</code>索引<code>PDO_entry</code></li>
<li>从站如何获取PDO配置，可以使用<code>sudo ethercat cstruct</code>命令进行该信息的提取</li>
<li>针对每个<code>ec_sync_info_t</code>输入结构数组进行PDO映射处理，分为三个层次<ul>
<li>sync层次 – sync层次主要配置同步管理器的方向和看门狗设置</li>
<li>PDO层次 – 处理PDO的时候需要两个过程，一个是对之前的PDO配置进行清除，另一个是将自定义配置的<code>PDO</code>设置到从站配置的同步管理器链表中，这个过程还会查询之前的默认配置，将之前<code>PDO</code>中的<code>PDO_entry</code>复制到<code>PDO</code>中</li>
</ul>
</li>
</ul>
</li>
<li><p>以上两种PDO配置并不冲突，可以理解为前者是从站的默认配置，后者是用户为了个性化自定义配置（有无均可，只不过自定义的化可能会有冗余信息）</p>
</li>
</ul>
<h2 id="主站和从站"><a href="#主站和从站" class="headerlink" title="主站和从站"></a>主站和从站</h2><ul>
<li>参考：<ul>
<li><code>https://blog.csdn.net/qq923433160/article/details/83781812</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>主站的实现可采用嵌入式和PC机两种方式，均需配备标准以太网MAC控制器，传输介质可使用100BASE-TX规范的5类UTP线缆。</p>
</li>
<li><p>EtherCAT从站设备除了具备通信功能外，还需具备对从站设备的控制功能。常见的从站设备有I&#x2F;O端子、伺服设备、微处理器等。</p>
</li>
<li><p>EtherCAT主站运行需具备以下几个基本功能：</p>
<ul>
<li>读取从站设备描述XML文件并对其进行解析，获取其中配置参数</li>
<li>捕获和发送EtherCAT数据帧，完成EtherCAT子报文解析、打包等</li>
<li>管理从站设备状态，运行状态机，完成主从站状态机设置和维护</li>
<li>可进行非周期性数据通信，完成系统参数配置，处理通讯过程中突发事件</li>
<li>实现周期性过程数据通信，实现数据实时交换，实时监控从站状态，从站反馈 信号实时处理等功能。</li>
</ul>
</li>
</ul>
<h2 id="控制卡"><a href="#控制卡" class="headerlink" title="控制卡"></a>控制卡</h2><ul>
<li>参考：<ul>
<li><code>https://www.cnblogs.com/cariohu/p/15508175.html</code></li>
</ul>
</li>
</ul>
<h3 id="控制卡分类"><a href="#控制卡分类" class="headerlink" title="控制卡分类"></a>控制卡分类</h3><ul>
<li><p>控制器或者控制卡的性能主要取决于控制算法，不同厂家控制卡的性能差别可能非常大。</p>
</li>
<li><p>目前常见工业应用中比较高端的有以色列ACS，美国Aerotech，这是属于第一梯队的，其他国外的流行品牌还有elmo、PMAC、Galil、欧姆龙等。国内的有固高、雷赛、正运动、柏楚等，与国外产品相比仍然有一定差距，但也在不断突破。</p>
</li>
<li><p>根据控制器传递命令给驱动器的方式，可以分为：总线型、模拟量型、PWM型、脉冲型控制卡。</p>
</li>
<li><p>目前，总线型控制卡是最主流的，各大厂家的口号都是一网到底，这个网就是指的总线，就是通过一根总线把所有模块都接上去，确实方便。其他三种类型控制卡也有各自的特色，所以都并行存在于主流市场</p>
</li>
</ul>
<h3 id="总线控制卡"><a href="#总线控制卡" class="headerlink" title="总线控制卡"></a>总线控制卡</h3><ul>
<li><p>常见的总线接口有，<strong>EtherCAT</strong>、CAN、Modbus、Profinet、EPA、SERCOS-Ⅲ等。</p>
</li>
<li><p>总线有这么多种，他们之间是否有联系，又有哪些区别呢？这是我们学习总线之前需要搞清楚的问题，不然总是会心里没底，或者是错误的把总线混搭一起，这些是新手的必经之路。</p>
</li>
<li><p>要想搞清楚不同总线之间的区别与联系，我们就得从总线通讯的组成或者是框架去看</p>
<ul>
<li>通讯的概念出现的很早，早期的电话电报就是一种通讯方式，但工业上的通讯应用都是OSI七层模型。OSI(open system interconnect)即开放系统的互连，这个是二十世纪七十年代的产物，当时就是为了解决各系统之间通讯的问题。</li>
<li>OSI七层模型图，从模型中我们可以看到，通讯最终是转化为比特流发送出去，我们说的通讯速率就是比特流的速率，比如百兆网络100Mbit&#x2F;s。比特流的传输载体是物理层，是我们看的见摸得着的线缆以及接口芯片等。</li>
<li>物理层往上是数据链路层，数据链路层的职责是负责将具体的数据转化成比特流，然后通过物理层的硬件发送。可以简单理解为，硬件的编码与解码，比如要发送数字8，那么数字8的比特流高低电平是怎样的；当收到一串比特流后，应该转换为哪个数字，这个就靠数据链路层完成的，数据链路层也是硬件。 </li>
<li>数据链路层再往上，还有五层。这五层都有一个特点，他们都是软件层，是运行在处理器上的软件代码，这五层完成数据报的解析，编组，归类，最终到显示。</li>
</ul>
</li>
<li><p>当我们用因特网看视频时，这些层就在周而复始发送请求，解析数据，并最终刷新到显示界面。这五层搞起来确实有点复杂，有些时候其实是不需要的，比如我们知道数据的具体含义，我们就不需要再去分组整理数量，直接使用即可，工业通讯应用正是符合这个特点。</p>
</li>
<li><p>尤其是针对运动控制或者过程控制总线，层太多不仅没用，反而会增加成本，并且运动控制或者过程控制这种专用总线上数据的含义都是严格一一对应的，不需各种分组分段解析啥的。所以，将五层压缩为一层，叫应用层。</p>
</li>
<li><p>物理层，数据链路层，应用层都有各自的功能，三层功能没有重叠部分。</p>
</li>
<li><p>发送工作流程是当数据到达后应用层后把数据放到对应的存储区，数据需要发送时到对应区域取出数据，交给数据链路层，比特流经物理层发送出去；</p>
</li>
<li><p>接收工作流程就是反过来，物理层上的比特流被数据链路层解析为正确的数值，放到对应的存储区域，应用层需要数据的时候取走数据即可。</p>
</li>
<li><p>所以，运动控制或者过程控制总线，这种专用总线都是三层模型，三层模型的功能：</p>
<ul>
<li>应用层：搬运数据，完成控制功能</li>
<li>数据链路层：承上启下，生成比特流，以及解析比特流</li>
<li>物理层：比特流传输载体</li>
</ul>
</li>
<li><p>当我们接触或者学习新的总线时，主要是搞清楚总线的框架，即这三层的情况是怎样的。只有搞清楚了这三层，你才不会被各种新鲜名词所吓倒，你才不会去随便混搭总线。搞清楚了总线通讯模型后，我们看下当前最火的两个总线，EtherCAT和CAN总线。</p>
</li>
<li><p>为什么EtherCAT和CAN总线这么火？</p>
</li>
</ul>
<h4 id="CAN总线"><a href="#CAN总线" class="headerlink" title="CAN总线"></a>CAN总线</h4><ul>
<li><p>首先，是CAN总线起步早，博世公司1986年推出，当时主要是面向汽车行业。注意这里我说的是CAN总线，不是CANOPEN总线，CANOPEN只是基于CAN总线的应用层协议，汽车行业基于CAN总线的应用层协议是J1939。经过汽车行业的多年应用，大家发现这个总线的优点很多，速度快，1Mbit在现在看确实不快，但在那个年代还是非常牛的；有COB-ID，有仲裁机制，高优先级的数据可以先传输，低优先级是数据后发送，排队的数据在总线空闲的时候会自动发送，无需人为干预；差分传输，数据传输可靠性高；理论上可以在总线上挂任意多节点；成本低，几块钱的MCU就自带CAN控制器，现在一般同时支持CAN2.0A和2.0B。</p>
</li>
<li><p>既然CAN总线有这么多优点，那就得充分利用上，紧接着有个组织叫CIA(CAN in Automation)起草了基于CANopen的设备及通讯子协议定义DS 301(Draft Standard 301)，也就是我们经常说的301协定。DS301只是CANopen的一个基础规范，具体到细分领域有，I&#x2F;O模组的DS401，运动控制的DS402。讲到这里就出现了我们期盼已久的CANopen协议，之所以火就是因为起步早，又赶上了电机运动控制的蓬勃发展时期，靠谱好用，便宜，易上手。其实基于CAN总线的应用层协议还有北美船舶行业通讯协议，广州周立功公司的iCAN，但这个两个协议都不在运动控制系统中出现。其实协议就是这么简单，你也可以基于CAN总线创立自己的协议，只要有人用，你就很了不起。</p>
</li>
<li><p>这里简单讲下CANopen DS402的相关知识，方便我们后面的理解。DS402里面有一些概念，对象字典，Node-ID，COB-ID，SDO，PDO，NMT，Heartbeat，状态机，Master，Slave，我们都简单介绍下。</p>
<ul>
<li>DS402中规定网络中各设备是主从关系，即Master-Slave模式，原则上只能有一个Master，负责整个网络的管理。其实CAN总线上的都是节点，没有主从的概念，主从的概念是在DS402中规定的，这一点我们要清楚。</li>
<li><strong>对象字典我们可以理解为寄存器表</strong>，只不过DS402已经规定了这个寄存器表的组织结构，包括一部分地址必须给协议使用，如0x6040,0x6041这些都是规定好的。有了对象字典我们就知道每个对象代表的是什么意思，每个厂家都按这个去设计。传输数据的时候我们得知道这个是哪个从站设备的数据，就需要有个Node-ID，简单说就是设备的编号。</li>
<li>假如不同设备同时要传输同样对象字典的数据，那我们该怎样区分呢？这个时候就有COB-ID，COB-ID是对应的编码加上Node-ID，如0x600表示SDO读，对应节点1组合后的COB-ID就是0x600+0x01&#x3D;0x601，节点2则为0x602，以此类推。这样我们就可以通过COB-ID来直接操作数据了，而无需关心是哪个节点的，如果数据同时需要发送，那么总线的仲裁机制就会起作用，COB-ID越小的优先级越高，优先发送，等待的数据在前面的数据发送完之后会自动重发。</li>
</ul>
</li>
<li><p>数据的传输分为两种</p>
<ul>
<li>一种是SDO，就是有问才有答，查询一次回复一次，类似服务生一样。</li>
<li>另一种是PDO，叫过程数据，提前配置好了数据的传输方式后数据就会自动上传，如可以设置数据的最小间隔时间，同步、异步、RTR等。</li>
</ul>
</li>
<li><p>SDO和PDO都是为了传输数据，但PDO传输的是过程数据，更精简，传输数据的效率会更高，<strong>如循环同步模式肯定是PDO传输数据</strong></p>
</li>
<li><p>NMT是网络管理的意思，主站负责管理整个网络，如各节点的状态切换等。</p>
</li>
<li><p>状态机是控制节点切换的，如在非使能状态到使能状态应该怎么响应，这个是状态机管理的。</p>
</li>
<li><p>最后一个是Hearbeat，当然也有NodeGuarding，这两个都是反馈节点的状态。当总线在工作的时候我们得知道节点是否还在线，Hearbeat就类似我们的心跳，间隔多长时间必须收到一次心跳，超出设定时间没收到心跳则表示该节点已死亡。</p>
</li>
<li><p>NodeGuarding是另外一种监测方式，它有主站和从站的互动，这是不同于Hearbeat的，就是主站要发命令给从站，从站也要回应命令，也是要求在规定的时间内，目前Hearbeat用的更多一些。</p>
</li>
</ul>
<h4 id="EtherCAT总线"><a href="#EtherCAT总线" class="headerlink" title="EtherCAT总线"></a>EtherCAT总线</h4><ul>
<li><p>EthterCAT的字面意思就是以太网自动化控制技术。简单点说就是基于以太网，完成自动化控制功能，但肯定与普通以太网还是有区别的。</p>
</li>
<li><p>他们的传输介质是一样的，都是RJ45网口+网线，但EtherCAT网络的数据链路层芯片是专门设计的，其目的是为了提高总线的性能。比如，增加了DC同步单元，数据自动转发，还有FMMU单元，SM单元，详细的情况可以去查询相关资料。</p>
</li>
<li><p>DC同步单元的时钟都是ns为单位，可以满足非常高的同步要求，然后以太网的通讯速度又非常快，现在1000Mbit&#x2F;s都已经不是事了，在每个传输周期可以有非常大量的数据交互。这些都是基于硬件的，做应用的人可以不用关心，我们还是讲讲上层协议。</p>
</li>
<li><p>对硬件感兴趣的可以参考AX58100、ET1100芯片的数据手册，山东大学李正军教授的《EtherCAT工业以太网应用技术》非常不错，里面有详细的介绍，值得一看，这里就不展开讲了。</p>
</li>
<li><p>基于EtherCAT总线的应用层协议有FoE、CoE、SoE、EoE、AoE、VoE，各个协议的具体描述如下表2-2：</p>
<ul>
<li>FoE, File over EtherCAT     –  在EtherCAT总线上传输文件的协议</li>
<li>CoE, CANopen over EtherCAT  –  在EtherCAT总线上执行CANopen协议</li>
<li>SoE, SERCOS over EtherCAT   –  在EtherCAT总线上执行SERCOS协议</li>
<li>EoE, Ethernet over EtherCAT –  在EtherCAT总线上执行Ethernet协议</li>
<li>AoE  –  访问底层现场总线的从站设备的对象字典，如对连接到EtherCAT-CAN网关设备的CAN从站</li>
<li>VoE  –  供应商自定义协议，基于邮箱</li>
</ul>
</li>
<li><p>这些都是运行在EhterCAT总线基础上的应用层协议，各个协议分管与自己相关的工作。</p>
</li>
<li><p>我们现在常用的EtherCAT伺服驱动器，说白了就是把CANopen应用层协议搬到了EtherCAT总线之上。由于EhterCAT总线的高传输速度，所以这个时候可以有更高的控制信号频率，就会有更好的控制效果。</p>
</li>
<li><p>讲到这里，我们可以发现，同样的协议可以在不同的总线上，同样的总线也可以用不同的协议。所以，<strong>当我们讨论总线的时候也要讨论总线的应用层协议</strong>，即我们前文提到的三层模型，只有三层模型都一样的系统才能完美对接。对总线就介绍这么多，原理都是一样的，其他总线可以按照这个方法学习，事半功倍。</p>
</li>
<li><p>有了这样可靠性高，同步性好，控制频率可以很高的总线，现在控制指令的频率到8Khz已经不是问题了。控制卡的指令就可以很快很准的发送给总线上的驱动单元，最终达到好的控制效果。总线型控制系统的所有指令，位置反馈，指示状态，错误代码等等，都是由通讯来完成交互的，这一点和传统的控制方式有很大的区别。</p>
</li>
</ul>
<h2 id="驱动支持的各种模式详解"><a href="#驱动支持的各种模式详解" class="headerlink" title="驱动支持的各种模式详解"></a>驱动支持的各种模式详解</h2><ul>
<li><p>早期非总线的驱动器一般是支持三个工作模式，位置模式，速度模式和电流模式，这个都比较简单，配置好模式，给对应的指令即可工作。</p>
</li>
<li><p>这些模式一般都可以接收模拟量和PWM命令，位置模式还可以接收脉冲命令，这个就不展开讲了，参对应驱动的手册即可知道特定模式支持哪些类型的命令输入。这种驱动最大的缺点就是接线复杂，控制卡离驱动不能太远，还需要考虑控制线缆抗干扰，不利于分布式现场的情况。这种一般是应用于小型独立式设备，设备相对比较小，线缆不会太长，干扰问题比较好解决。</p>
</li>
<li><p>随着总线型驱动器的出现，驱动器的工作模式增加了好几个。没有特殊说明的话，这里的总线指的是CAN总线和EtherCAT总线。</p>
</li>
<li><p>基于这两个总线的驱动器一般都支持如表3-1所示的模式，当然还有PVT模式，IPM模式，但这些现在已经都不太常见了，有需要的可以查阅相关资料。   </p>
<ul>
<li>HM   –  回零模式</li>
<li>PVM  –  带规划的速度模式</li>
<li>PPM  –  带规划的位置模式</li>
<li>CSP  –  循环同步的位置模式</li>
<li>CSV  –  循环同步的速度模式</li>
<li>CST  –  循环同步的转矩模式</li>
</ul>
</li>
<li><p>HM模式是回零模式，驱动器已经内置好了各种回零方式。如先找负限位再找index方式；用限位作为回零原点方式；碰到硬限位回零方式等等。这些回零方式的程序已经在驱动器内部实现好了，我们只需要配置好相关参数，启动回零即可，回零过程都是驱动器内部程序完成。同时，也有状态变量可以监控当前的回零状态，是否完成，是否有报错等。</p>
</li>
<li><p>PVM和PPM是带规划的速度和位置模式，规划的意思就是根据用户设定的加减速度去启动和停止运动。这个两个模式很简单，有点像非总线伺服驱动器的速度模式和位置模式，这里不详细介绍了。</p>
</li>
<li><p>我们重点介绍下循环同步模式，循环同步的意思就是以一个固定的时间间隔，周而复始的发送数据和同步指令。为什么要搞这个玩法呢？PVM PPM不香吗？这是我们学习新知识前需要考虑的问题，搞清楚了背景，理解起来会更有帮助。</p>
<ul>
<li>我们先想下，控制卡+非总线伺服驱动器是怎样实现多轴同步的，是多个驱动的控制命令在同一个DSP中运算，这样时间上就不会有偏差，确保每次都是几乎同一时间把指令发送给驱动器。如果是多个DSP有各自控制的驱动器，这些驱动器之间做同步运动，比如插补，效果都会差于一个DSP内部轴同步的效果，除非你把多个DSP任一时刻都同步起来，同样的时间做同样的运算，这样也许会是一样的效果。</li>
<li>而我们这里说的循环同步就是干这个事情，总线型驱动器与控制卡或者叫master之间的连接只有一条通讯线，无论这条通讯线是CAN总线的半双工，或是EtherCAT总线的全双工，再加100Mbit&#x2F;s的带宽，数据传输总会有先后顺序，这个事实没法改变。假如总线上的所有驱动器都以收到指令数据的那一刻去执行指令，那么驱动器之间就无法很好同步了。</li>
<li>那么应该怎么办呢？人是真的聪明，总会想办法去解决问题，天才的工程师提出了一个解决方案。所有驱动器都先收指令数据，但不要立马执行，等待一个命令再执行，这个就是同步命令，这样就完美的解决了总线上数据传输有先后顺序的问题。大家都是先把数据准备好，然后等待同步命令，这个就好比百米赛跑一样，大家都先准备好，等待发令枪再跑，这样就是公平的。至于最终跑的结果怎样看个人水平，驱动器最终执行的效果怎样也是看驱动器的性能，感觉这个启发真是源于生活，最终又服务于生活。</li>
</ul>
</li>
<li><p>讲完什么是循环同步后，我们看下循环同步的三个模式到底是啥。</p>
</li>
<li><p>首先说CSP，循环同步的位置模式：</p>
<ul>
<li>这个模式接收的是控制卡下发的位置指令，但这个位置不是随便发的，需要根据位置轨迹解算为一个一个点，这个是需要上位机解算的。</li>
<li>上位解算点的这个过程叫粗插，就是粗线条的给出一些点，这些点不是驱动伺服环路能直接使用的，驱动器在接收到这些点后需要再进行精插，最终变成伺服环路能直接执行的位置点。</li>
<li>精插是相对于粗插来说的，精插是以伺服周期为基准时间单位，精细的将轨迹分成很多个位置点，形成一个位置表，每个伺服周期去这个表中取一个值执行即可。</li>
<li>我们以一个T形加减速，有匀速过程的点到点运动为例来剖析CSP模式的细节。如图3-15，是一个点到点运动，位置—时间和速度—时间关系图，加速和减速阶段的轨迹是曲线，匀速阶段是直线。再看下位置图中的插值点，这些点之间的时间是均匀间隔的，每到一个时间点位置轨迹与时间轴围成一个面积，这个面积就是我们在CSP模式发送给驱动器的位置指令，随着时间的增加，这个面积会越来越大。</li>
<li>只要这些插值点是均匀的，指令发送的时间是准确的，满足这两个条件的情况下，电机的转动必然是平滑的。这两个条件中的任何一个不满足，电机的转动都是会顿挫的。</li>
<li>如果插值点不均匀，比如有的时候插值点是间隔10ms，有的时候插值点是20ms。最明显的结果就是电机运动不平滑，那么为什么会不平滑呢？我们知道位置轨迹连续则位置轨迹的导数或者叫曲线的曲率才不会有突变，位置轨迹导数对应着的是速度，速度不突变则电机运转平稳。如果我的插值点时间突然增加或者缩短，则必然会导致曲率突变，这是上位在解算轨迹点需要注意的问题。</li>
<li>尤其是任意轨迹曲线，曲率的突变非常厉害，即使在均匀的插值情况下，电机运转可能都会抖动明显。所以，对任意曲线的插值，还有需要针对锐角以及曲率突变的点做优化，比如用圆弧过度锐角，或者降低运动速度。</li>
<li>到这里我们对CSP的整个细节基本讲完了，在使用过程中，我们还需注意循环同步指令的周期以及指令到达是否准时。指令的周期不应过短，要让驱动器有精插的空间，比如驱动伺服环路400us，那么你就不要给低于400us的同步周期，当然很多驱动也不支持这么短的同步周期，即使支持也不要这样给。同步指令要有硬时性，或者实时性好，我们一般以us为单位，尽可能的准时，指令不准时同样会导致电机运动的时候顿挫严重，甚至驱动器报错。</li>
<li>到这里我们讲完了整个CSP模式的要点，在使用CSP模式的时候如果电机运转不平滑，该怎样去找问题，这才是我们要关注的核心。看到这里应该有一种豁然开朗的感觉，就证明你完全理解了循环同步位置模式的精髓。</li>
</ul>
</li>
<li><p>讲完CSP模式，后面的CSV和CST模式就简单了，我们先看看CSV模式：</p>
<ul>
<li>CSV是循环同步的速度模式，控制卡下发的是速度指令，这个速度指令和位置指令一样，也不是随便给的。需要对速度曲线进行插值，解算每个周期应该给驱动的速度指令，对位置轨迹求导数就是速度，也就有了速度曲线。</li>
<li>同CSP一样，控制卡或者上位也只是粗插，伺服环路还会根据指令和周期的时间进行精插，最终就变成了伺服环路可以执行的指令。</li>
<li>同样，CSV模式对指令的实时性要求同CSP一样，不准时的指令就会导致电机运转的时候顿挫，顿挫就是速度突变造成的，分析方法和CSP模式一样，这里不再赘述</li>
</ul>
</li>
<li><p>看完CSV，我们再看看CST：</p>
<ul>
<li>这个模式和前面两个的共同之处是都为循环同步模式，不同之处是CST模式的指令直接被伺服环路所用，中间没有精插的过程。由于这个不同，CST模式的指令实时性不好的时候我们也很难发现，因为CST模式对应的是电机的电流，电流对应的是电机的输出转矩，电流的突变就是转矩的突变。</li>
<li>转矩的是突变对应三种情况：<ul>
<li>一种是电机输出转矩大于负载转矩，电机加速</li>
<li>另一种是电机输出转矩等于负载转矩，电机还是静止；</li>
<li>甚至是电机输出转矩小于负载转矩，电机被负载拖动，运动控制中这种一般很少</li>
</ul>
</li>
<li>指令实时性不好很难被发现，并不是说CST模式对指令实时性没有要求，既然叫循环同步模式，那就是有这个要求。</li>
</ul>
</li>
<li><p>总结下三个循环同步模式，循环同步模式的出现，使得我们对任意轨迹的指令规划变得非常方便，就是对曲线插值，获得各时刻应该下发的指令。它使我们更加靠近了伺服环路的工作原理，伺服环路其实也是一直在插，不断的解算各个伺服周期的命令，然后算法以读表的方式不断的读取各个周期的指令。</p>
</li>
<li><p>讲到这里，整个驱动器的相关知识就介绍完了。简单总结就是，驱动器有硬件和固件两部分，硬件部分负责控制电机的换向，电流调节，反馈信号采集等；固件部分或者叫软件部分，则是通过硬件的各种反馈信号，周而复的运算，并将运算结果输出到硬件。其实整个伺服系统工作的过程，就是一个不断纠偏的过程，大了就小点，小了就大点，没有真正的静止，一直运动，只是在几个脉冲来回移动，这才是伺服系统的精髓，没有真正的静止。</p>
</li>
</ul>
<h2 id="EtherCAT-配置流程"><a href="#EtherCAT-配置流程" class="headerlink" title="EtherCAT 配置流程"></a>EtherCAT 配置流程</h2><ol>
<li>init master</li>
<li>init slave</li>
<li>init pdo</li>
<li>init pdo_entry</li>
<li>config pdo_entry</li>
<li>config pdo</li>
<li>config slave </li>
<li>config master</li>
<li>config sdo</li>
<li>lock memory</li>
<li>start master</li>
<li>start slave</li>
</ol>
<h2 id="EtherCAT-通讯流程"><a href="#EtherCAT-通讯流程" class="headerlink" title="EtherCAT 通讯流程"></a>EtherCAT 通讯流程</h2><ol>
<li>master receive </li>
<li>slave receive </li>
<li>pdo read update</li>
<li>control strategy</li>
<li>pdo write update</li>
<li>master sync</li>
<li>slave send </li>
<li>master send</li>
</ol>
<h2 id="PDO-1"><a href="#PDO-1" class="headerlink" title="PDO"></a>PDO</h2><ul>
<li>pdo 可以分为三级<ul>
<li>SM(sync manager)，每个SM可以同步多个 pdo</li>
<li>pdo，每个 pdo 包含多个 pdo entry</li>
<li>pdo entry，每个 pdo entry 对应一个 index 和 subindex</li>
</ul>
</li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div>感谢老板支持！敬礼(^^ゞ</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="zhang junyi WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="zhang junyi Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/EtherCat/" rel="tag"># EtherCat</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/22/notebook/Eigen3/2024-05-22-Eigen_2_%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" rel="prev" title="Eigen_2_常用技巧">
      <i class="fa fa-chevron-left"></i> Eigen_2_常用技巧
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/05/22/notebook/Eigen3/2024-05-22-Eigen_1_%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" rel="next" title="Eigen_1_理论基础">
      Eigen_1_理论基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E4%BB%8E%E7%AB%99%E4%BE%9D%E6%AC%A1%E6%9D%BE%E9%97%B8%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.</span> <span class="nav-text">可能出现从站依次松闸现象的原因有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%BB%E7%AB%99%E7%8A%B6%E6%80%81%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">1. 主站状态机控制问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%EF%BC%88Distributed-Clocks-DC%EF%BC%89%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">2. 同步机制（Distributed Clocks, DC）问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-PDO-%E6%98%A0%E5%B0%84%E6%88%96%E8%BF%87%E7%A8%8B%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">3. PDO 映射或过程数据更新问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%AE%BE%E5%A4%87%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E5%B7%AE%E5%BC%82"><span class="nav-number">6.</span> <span class="nav-text">4. 设备响应时间差异</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E5%92%8C%E9%80%9A%E4%BF%A1%E5%BB%B6%E8%BF%9F"><span class="nav-number">7.</span> <span class="nav-text">5. 网络拓扑和通信延迟</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E8%AE%BE%E5%A4%87%E4%B8%8A%E7%94%B5%E9%A1%BA%E5%BA%8F%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="nav-number">8.</span> <span class="nav-text">6. 设备上电顺序不一致</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E8%A7%A6%E5%8F%91%E4%BF%A1%E5%8F%B7%E6%88%96%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4%E4%B8%8D%E5%90%8C%E6%AD%A5"><span class="nav-number">9.</span> <span class="nav-text">7. 触发信号或启动命令不同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">10.</span> <span class="nav-text">结论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EtherCAT-%E4%BB%8E%E7%AB%99%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">11.</span> <span class="nav-text">EtherCAT 从站有几种状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EtherCAT-%E4%BB%8E%E7%AB%99%E7%9A%84-4-%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">12.</span> <span class="nav-text">EtherCAT 从站的 4 种状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88Init%EF%BC%89"><span class="nav-number">12.1.</span> <span class="nav-text">1. 初始化（Init）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%A2%84%E6%93%8D%E4%BD%9C%EF%BC%88Pre-Operational-Pre-Op%EF%BC%89"><span class="nav-number">12.2.</span> <span class="nav-text">2. 预操作（Pre-Operational, Pre-Op）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C%EF%BC%88Safe-Operational-Safe-Op%EF%BC%89"><span class="nav-number">12.3.</span> <span class="nav-text">3. 安全操作（Safe-Operational, Safe-Op）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%93%8D%E4%BD%9C%EF%BC%88Operational-OP%EF%BC%89"><span class="nav-number">12.4.</span> <span class="nav-text">4. 操作（Operational, OP）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B"><span class="nav-number">13.</span> <span class="nav-text">状态转换流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%8A%B6%E6%80%81%E5%A4%84%E7%90%86"><span class="nav-number">14.</span> <span class="nav-text">异常状态处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">15.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ethercat-%E4%B8%BB%E7%AB%99%E4%B8%8E%E4%BB%8E%E7%AB%99%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE"><span class="nav-number">16.</span> <span class="nav-text">ethercat 主站与从站通讯协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-EtherCAT-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E6%9E%B6%E6%9E%84"><span class="nav-number">17.</span> <span class="nav-text">1. EtherCAT 通讯协议架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-EtherCAT-%E9%80%9A%E8%AE%AF%E6%B5%81%E7%A8%8B"><span class="nav-number">18.</span> <span class="nav-text">2. EtherCAT 通讯流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-EtherCAT-%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="nav-number">19.</span> <span class="nav-text">3. EtherCAT 帧结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%B8%BB%E8%A6%81EtherCAT%E9%80%9A%E4%BF%A1%E5%91%BD%E4%BB%A4"><span class="nav-number">20.</span> <span class="nav-text">4. 主要EtherCAT通信命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-EtherCAT-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">21.</span> <span class="nav-text">5. EtherCAT 工作模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%89%E8%87%AA%E7%94%B1%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F%EF%BC%88Free-Run-Mode%EF%BC%89"><span class="nav-number">21.1.</span> <span class="nav-text">1）自由运行模式（Free Run Mode）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%89%E5%90%8C%E6%AD%A5%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88SM-Sync-Mode%EF%BC%89"><span class="nav-number">21.2.</span> <span class="nav-text">2）同步管理模式（SM Sync Mode）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%89%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%B6%E9%92%9F%E6%A8%A1%E5%BC%8F%EF%BC%88DC-Mode%EF%BC%89"><span class="nav-number">21.3.</span> <span class="nav-text">3）分布式时钟模式（DC Mode）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%89%E5%91%A8%E6%9C%9F%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Cyclic-Sync-Mode%EF%BC%89"><span class="nav-number">21.4.</span> <span class="nav-text">4）周期同步模式（Cyclic Sync Mode）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-EtherCAT%E4%B8%8E%E5%85%B6%E4%BB%96%E5%B7%A5%E4%B8%9A%E6%80%BB%E7%BA%BF%E5%AF%B9%E6%AF%94"><span class="nav-number">22.</span> <span class="nav-text">6. EtherCAT与其他工业总线对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-EtherCAT-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">23.</span> <span class="nav-text">7. EtherCAT 应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E7%BB%93%E8%AE%BA"><span class="nav-number">24.</span> <span class="nav-text">8. 结论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ethercat-%E6%98%AF%E4%BB%80%E4%B9%88-%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A"><span class="nav-number">25.</span> <span class="nav-text">ethercat 是什么 详细解释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EtherCAT-%E8%AF%A6%E8%A7%A3"><span class="nav-number">25.1.</span> <span class="nav-text">EtherCAT 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9"><span class="nav-number">25.1.1.</span> <span class="nav-text">核心特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82"><span class="nav-number">25.1.2.</span> <span class="nav-text">技术细节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF"><span class="nav-number">25.1.3.</span> <span class="nav-text">优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">25.1.4.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%8C%96%E4%B8%8E%E7%94%9F%E6%80%81"><span class="nav-number">25.1.5.</span> <span class="nav-text">标准化与生态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">25.1.6.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ethercat-%E5%92%8C-xenomai-%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88-%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A"><span class="nav-number">26.</span> <span class="nav-text">ethercat 和 xenomai 分别是什么 详细解释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-EtherCAT"><span class="nav-number">26.1.</span> <span class="nav-text">1. EtherCAT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">26.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="nav-number">26.1.2.</span> <span class="nav-text">核心特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">26.1.3.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">26.1.4.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF-1"><span class="nav-number">26.1.5.</span> <span class="nav-text">优势</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Xenomai"><span class="nav-number">26.2.</span> <span class="nav-text">2. Xenomai</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-number">26.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7-1"><span class="nav-number">26.2.2.</span> <span class="nav-text">核心特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="nav-number">26.2.3.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">26.2.4.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF-2"><span class="nav-number">26.2.5.</span> <span class="nav-text">优势</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-EtherCAT-%E4%B8%8E-Xenomai-%E7%9A%84%E7%BB%93%E5%90%88"><span class="nav-number">26.3.</span> <span class="nav-text">3. EtherCAT 与 Xenomai 的结合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E6%9E%B6%E6%9E%84%E7%A4%BA%E4%BE%8B"><span class="nav-number">26.3.1.</span> <span class="nav-text">典型架构示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">26.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EtherCAT"><span class="nav-number">27.</span> <span class="nav-text">EtherCAT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EtherCAT-xenomai-%E5%AE%89%E8%A3%85"><span class="nav-number">27.1.</span> <span class="nav-text">EtherCAT xenomai 安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9ARxPDOs"><span class="nav-number">27.2.</span> <span class="nav-text">固定RxPDOs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9ATxPDO"><span class="nav-number">27.3.</span> <span class="nav-text">固定TxPDO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E4%B8%BB%E7%AB%99"><span class="nav-number">27.4.</span> <span class="nav-text">请求主站</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E7%AB%99%E9%85%8D%E7%BD%AE"><span class="nav-number">27.5.</span> <span class="nav-text">从站配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PDO"><span class="nav-number">28.</span> <span class="nav-text">PDO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAN"><span class="nav-number">29.</span> <span class="nav-text">CAN</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EtherCAT-%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%A7%A3%E6%9E%90%E2%80%93%E5%85%B3%E4%BA%8Eethercat%E5%BA%94%E7%94%A8%E5%B1%82%E4%BD%BF%E7%94%A8"><span class="nav-number">30.</span> <span class="nav-text">EtherCAT 使用与解析–关于ethercat应用层使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ecrt-h%E5%A4%B4%E6%96%87%E4%BB%B6%E6%8E%A5%E5%8F%A3"><span class="nav-number">31.</span> <span class="nav-text">ecrt.h头文件接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EPDO%E6%98%A0%E5%B0%84"><span class="nav-number">32.</span> <span class="nav-text">关于PDO映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E7%AB%99%E5%92%8C%E4%BB%8E%E7%AB%99"><span class="nav-number">33.</span> <span class="nav-text">主站和从站</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8D%A1"><span class="nav-number">34.</span> <span class="nav-text">控制卡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8D%A1%E5%88%86%E7%B1%BB"><span class="nav-number">34.1.</span> <span class="nav-text">控制卡分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%8D%A1"><span class="nav-number">34.2.</span> <span class="nav-text">总线控制卡</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAN%E6%80%BB%E7%BA%BF"><span class="nav-number">34.2.1.</span> <span class="nav-text">CAN总线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EtherCAT%E6%80%BB%E7%BA%BF"><span class="nav-number">34.2.2.</span> <span class="nav-text">EtherCAT总线</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E6%94%AF%E6%8C%81%E7%9A%84%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="nav-number">35.</span> <span class="nav-text">驱动支持的各种模式详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EtherCAT-%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="nav-number">36.</span> <span class="nav-text">EtherCAT 配置流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EtherCAT-%E9%80%9A%E8%AE%AF%E6%B5%81%E7%A8%8B"><span class="nav-number">37.</span> <span class="nav-text">EtherCAT 通讯流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PDO-1"><span class="nav-number">38.</span> <span class="nav-text">PDO</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
