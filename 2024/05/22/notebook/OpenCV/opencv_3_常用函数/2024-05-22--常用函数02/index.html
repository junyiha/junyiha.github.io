<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="简介 OpenCV 常用的函数">
<meta property="og:type" content="article">
<meta property="og:title" content="常用函数">
<meta property="og:url" content="https://junyiha.github.io/2024/05/22/notebook/OpenCV/opencv_3_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22--%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B002/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="简介 OpenCV 常用的函数">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-05-22T01:00:00.000Z">
<meta property="article:modified_time" content="2025-06-05T05:31:10.986Z">
<meta property="article:author" content="zhang junyi">
<meta property="article:tag" content="OpenCV">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/2024/05/22/notebook/OpenCV/opencv_3_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22--%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B002/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>常用函数 | junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2024/05/22/notebook/OpenCV/opencv_3_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22--%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B002/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          常用函数
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-05-22 09:00:00" itemprop="dateCreated datePublished" datetime="2024-05-22T09:00:00+08:00">2024-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-05 13:31:10" itemprop="dateModified" datetime="2025-06-05T13:31:10+08:00">2025-06-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenCV/" itemprop="url" rel="index"><span itemprop="name">OpenCV</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>OpenCV 常用的函数</li>
</ul>
<span id="more"></span>

<h2 id="cv-fitLine-函数-详解"><a href="#cv-fitLine-函数-详解" class="headerlink" title="cv::fitLine() 函数 详解"></a>cv::fitLine() 函数 详解</h2><p><code>cv::fitLine()</code> 是 OpenCV 中用于拟合直线的函数，能够根据给定的点集计算最佳拟合直线。该函数返回的是一条最小二乘拟合直线，常用于图像中的直线检测、图像分析等任务。</p>
<h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a><strong>函数原型</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::fitLine</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray points,        <span class="comment">// 输入点集</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray line,         <span class="comment">// 输出拟合直线的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> distType = DIST_L2,   <span class="comment">// 距离类型，默认为 L2</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> param = <span class="number">0.0</span>,       <span class="comment">// 距离度量的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> reps = <span class="number">0.02</span>,       <span class="comment">// 拟合精度（误差阈值）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> aeps = <span class="number">0.01</span>        <span class="comment">// 拟合精度的绝对误差</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a><strong>参数详解</strong></h2><ol>
<li><p>**<code>points</code>**：</p>
<ul>
<li>输入的点集，表示要拟合直线的多个点。类型是 <code>cv::Mat</code> 或 <code>std::vector&lt;cv::Point&gt;</code>，这些点应该是二维坐标。</li>
<li>点集中的每个点都是 <code>cv::Point</code> 类型，要求至少有两个点。常见的点集是通过图像处理得到的边缘点、轮廓点等。</li>
</ul>
</li>
<li><p>**<code>line</code>**：</p>
<ul>
<li>输出参数，拟合得到的直线信息。返回的是一个 <code>cv::Vec4f</code> 类型的向量，包含了拟合直线的参数。格式如下：<ul>
<li><code>line[0]</code>：直线的方向向量 <code>dx</code>，即直线的斜率方向。</li>
<li><code>line[1]</code>：直线的方向向量 <code>dy</code>，即直线的斜率方向。</li>
<li><code>line[2]</code>：直线的一个点的 x 坐标。</li>
<li><code>line[3]</code>：直线的一个点的 y 坐标。</li>
</ul>
</li>
<li>这两个方向向量 <code>(dx, dy)</code> 和一个点 <code>(x, y)</code> 可以完全描述一条直线。通过这些参数，可以进一步求出该直线的方程。</li>
</ul>
</li>
<li><p>**<code>distType</code>**：</p>
<ul>
<li>距离度量类型，决定拟合过程中误差计算的方法。常见的距离度量类型包括：<ul>
<li><code>DIST_L2</code>：标准的欧几里得距离（L2范数，默认值）。</li>
<li><code>DIST_L1</code>：L1 范数。</li>
<li><code>DIST_L12</code>：L1-L2 混合范数。</li>
<li><code>DIST_HUBER</code>：Huber 距离，用于减少离群点的影响。</li>
</ul>
</li>
</ul>
</li>
<li><p>**<code>param</code>**：</p>
<ul>
<li>距离度量的参数，通常不需要调整，默认是 0.0。</li>
</ul>
</li>
<li><p>**<code>reps</code>**：</p>
<ul>
<li>拟合精度（误差阈值），表示拟合过程中的容忍度，默认为 <code>0.02</code>。该值越小，拟合的精度越高。</li>
</ul>
</li>
<li><p>**<code>aeps</code>**：</p>
<ul>
<li>拟合精度的绝对误差，默认为 <code>0.01</code>。通常不需要修改，保持默认值即可。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a><strong>返回值</strong></h2><ul>
<li><code>cv::fitLine()</code> 没有返回值，而是通过 <code>line</code> 输出参数来返回拟合直线的参数。</li>
<li>输出的 <code>line</code> 是一个包含 4 个元素的 <code>cv::Vec4f</code> 类型：<ul>
<li><code>line[0]</code> 和 <code>line[1]</code> 分别是直线的方向向量 <code>(dx, dy)</code>，表示直线的方向。</li>
<li><code>line[2]</code> 和 <code>line[3]</code> 分别是拟合直线上的一个点 <code>(x, y)</code>，可以认为是直线的某个起始点。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="函数工作原理"><a href="#函数工作原理" class="headerlink" title="函数工作原理"></a><strong>函数工作原理</strong></h2><ul>
<li><code>cv::fitLine()</code> 通过最小二乘法拟合一条直线，以最小化所有点到该直线的距离平方和。它使用给定的点集来计算直线的方向向量 <code>(dx, dy)</code> 和直线上的一个点 <code>(x, y)</code>，进而确定拟合直线的参数。</li>
<li>该函数适用于二维平面上的点集，可以处理较为复杂的点集情况，包括带噪声的数据。</li>
</ul>
<hr>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h2><h3 id="1-基本示例"><a href="#1-基本示例" class="headerlink" title="1. 基本示例"></a><strong>1. 基本示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个点集</span></span><br><span class="line">    vector&lt;Point&gt; points;</span><br><span class="line">    points.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    points.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">20</span>, <span class="number">40</span>));</span><br><span class="line">    points.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">30</span>, <span class="number">60</span>));</span><br><span class="line">    points.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">40</span>, <span class="number">80</span>));</span><br><span class="line">    points.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">50</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拟合直线</span></span><br><span class="line">    Vec4f line;</span><br><span class="line">    <span class="built_in">fitLine</span>(points, line, DIST_L2, <span class="number">0</span>, <span class="number">0.01</span>, <span class="number">0.01</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出拟合直线的参数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Line direction vector (dx, dy): (&quot;</span> &lt;&lt; line[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; line[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Point on line (x, y): (&quot;</span> &lt;&lt; line[<span class="number">2</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; line[<span class="number">3</span>] &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Line direction vector (dx, dy): (1, 2)</span><br><span class="line">Point on line (x, y): (10, 20)</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个例子中，使用 <code>cv::fitLine()</code> 拟合了一条直线，返回的 <code>line</code> 参数给出了直线的方向向量 <code>(dx, dy)</code> 和直线上的一个点 <code>(x, y)</code>。这些参数完全描述了拟合的直线。</li>
</ul>
<hr>
<h3 id="2-在图像中绘制拟合直线"><a href="#2-在图像中绘制拟合直线" class="headerlink" title="2. 在图像中绘制拟合直线"></a><strong>2. 在图像中绘制拟合直线</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一张空白图像</span></span><br><span class="line">    Mat img = Mat::<span class="built_in">zeros</span>(<span class="number">400</span>, <span class="number">400</span>, CV_8UC3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个点集（模拟一些散点）</span></span><br><span class="line">    vector&lt;Point&gt; points;</span><br><span class="line">    points.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">50</span>, <span class="number">150</span>));</span><br><span class="line">    points.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">200</span>));</span><br><span class="line">    points.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">150</span>, <span class="number">250</span>));</span><br><span class="line">    points.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">200</span>, <span class="number">300</span>));</span><br><span class="line">    points.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">250</span>, <span class="number">350</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拟合直线</span></span><br><span class="line">    Vec4f line;</span><br><span class="line">    <span class="built_in">fitLine</span>(points, line, DIST_L2, <span class="number">0</span>, <span class="number">0.01</span>, <span class="number">0.01</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取拟合直线的参数</span></span><br><span class="line">    <span class="type">float</span> slope = line[<span class="number">1</span>] / line[<span class="number">0</span>];  <span class="comment">// 直线的斜率</span></span><br><span class="line">    <span class="type">float</span> intercept = line[<span class="number">3</span>] - slope * line[<span class="number">2</span>];  <span class="comment">// 直线的截距</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算直线的端点</span></span><br><span class="line">    <span class="function">Point <span class="title">pt1</span><span class="params">(<span class="number">0</span>, intercept)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">pt2</span><span class="params">(<span class="number">400</span>, slope * <span class="number">400</span> + intercept)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在图像上绘制拟合的直线</span></span><br><span class="line">    <span class="built_in">line</span>(img, pt1, pt2, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制点集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; point : points) &#123;</span><br><span class="line">        <span class="built_in">circle</span>(img, point, <span class="number">3</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图像</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Fitted Line&quot;</span>, img);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个示例中，<code>cv::fitLine()</code> 用于从一些散点中拟合出一条直线。然后，我们计算出这条直线的端点并在图像上绘制了直线和点集。绿色直线表示拟合结果，红色点表示原始点集。</li>
</ul>
<hr>
<h2 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a><strong>常见应用场景</strong></h2><ol>
<li><p><strong>直线检测与分析</strong>：</p>
<ul>
<li>在图像处理中，<code>cv::fitLine()</code> 可用于从边缘检测或轮廓检测得到的点集中拟合直线，识别图像中的直线结构（如建筑物边缘、道路标线等）。</li>
</ul>
</li>
<li><p><strong>轨迹拟合</strong>：</p>
<ul>
<li>在物体跟踪或运动分析中，<code>cv::fitLine()</code> 可用于拟合物体的运动轨迹，识别物体的移动方向和速度。</li>
</ul>
</li>
<li><p><strong>图像校正与配准</strong>：</p>
<ul>
<li>在图像配准过程中，<code>cv::fitLine()</code> 可以用来估计图像中特征点的匹配直线，从而帮助进行几何校正。</li>
</ul>
</li>
<li><p><strong>边缘检测与优化</strong>：</p>
<ul>
<li>在边缘检测任务中，拟合直线可以帮助识别图像中的直线区域，进而优化边缘检测算法。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul>
<li><code>cv::fitLine()</code> 是一个非常实用的函数，能够从点集拟合出一条直线，常用于图像分析、目标检测和图像处理等领域。</li>
<li>该函数利用最小二乘法计算最佳拟合直线，可以处理带有噪声的点集，返回的结果包括直线的方向和位置，适用于多种几何分析任务。</li>
</ul>
<h2 id="cv-mean-函数-详解"><a href="#cv-mean-函数-详解" class="headerlink" title="cv::mean() 函数 详解"></a>cv::mean() 函数 详解</h2><p><code>cv::mean()</code> 是 OpenCV 中用于计算矩阵或图像的均值的函数。它返回一个表示图像或矩阵每个通道的平均值的 <code>Scalar</code> 类型结果。这个函数不仅计算整个图像的均值，还能按通道分别计算均值（对于彩色图像），并且还可以通过掩模计算图像的有效区域均值。</p>
<hr>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a><strong>函数定义</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Scalar <span class="title">cv::mean</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray src,        <span class="comment">// 输入矩阵或图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray mask = noArray()   <span class="comment">// 可选的掩模，默认值为 noArray() 表示不使用掩模</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参数详解-1"><a href="#参数详解-1" class="headerlink" title="参数详解"></a><strong>参数详解</strong></h2><ol>
<li><p>**<code>src</code>**：</p>
<ul>
<li>输入参数，表示要计算均值的矩阵或图像。可以是单通道或多通道矩阵。</li>
<li>如果是多通道图像（如彩色图像），则每个通道的均值会分别计算。</li>
</ul>
</li>
<li><p>**<code>mask</code>**（可选）：</p>
<ul>
<li>一个与 <code>src</code> 同尺寸的掩模（<code>Mat</code>），表示哪些区域参与均值计算。掩模中的非零区域将用于计算均值，零值区域将被忽略。如果不使用掩模，则传入默认值 <code>noArray()</code>，表示计算整个矩阵的均值。</li>
<li>掩模可以用于计算图像感兴趣区域（ROI）的均值。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a><strong>返回值</strong></h2><ul>
<li>返回一个 <code>Scalar</code> 类型的对象，表示输入矩阵或图像中每个通道的均值。<ul>
<li>对于单通道图像，返回的 <code>Scalar</code> 中只有一个元素，表示该通道的均值。</li>
<li>对于多通道图像，<code>Scalar</code> 的每个元素表示每个通道的均值（例如，对于 RGB 图像，返回的 <code>Scalar</code> 会包含三个元素，分别对应蓝色、绿色和红色通道的均值）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h2><ul>
<li><code>cv::mean()</code> 计算给定矩阵或图像中每个通道的均值。如果提供了掩模，只有掩模中非零区域的像素会被用来计算均值。</li>
<li>对于彩色图像，返回的 <code>Scalar</code> 包含每个通道的均值（蓝色、绿色和红色，或其他通道），而对于灰度图像，返回的 <code>Scalar</code> 只包含一个元素，表示单通道图像的均值。</li>
</ul>
<hr>
<h2 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h2><h3 id="计算单通道图像的均值"><a href="#计算单通道图像的均值" class="headerlink" title="计算单通道图像的均值"></a><strong>计算单通道图像的均值</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个简单的 3x3 矩阵（单通道图像）</span></span><br><span class="line">    Mat mat = (<span class="built_in">Mat_</span>&lt;uchar&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">                                     <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">                                     <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算所有元素的均值</span></span><br><span class="line">    Scalar mean_val = <span class="built_in">mean</span>(mat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出均值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Mean value of all elements: &quot;</span> &lt;&lt; mean_val[<span class="number">0</span>] &lt;&lt; endl;  <span class="comment">// 输出矩阵的均值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mean value of all elements: 5</span><br></pre></td></tr></table></figure>

<ul>
<li>这里计算了一个 3x3 矩阵的均值，返回的 <code>Scalar</code> 值为 <code>5</code>，表示所有元素的均值。</li>
</ul>
<hr>
<h3 id="计算多通道图像的均值"><a href="#计算多通道图像的均值" class="headerlink" title="计算多通道图像的均值"></a><strong>计算多通道图像的均值</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 2x2 的彩色图像（3通道，RGB）</span></span><br><span class="line">    Mat img = (<span class="built_in">Mat_</span>&lt;Vec3b&gt;(<span class="number">2</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">Vec3b</span>(<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>), <span class="built_in">Vec3b</span>(<span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>),</span><br><span class="line">                                     <span class="built_in">Vec3b</span>(<span class="number">200</span>, <span class="number">250</span>, <span class="number">50</span>), <span class="built_in">Vec3b</span>(<span class="number">125</span>, <span class="number">175</span>, <span class="number">225</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个通道的均值</span></span><br><span class="line">    Scalar mean_val = <span class="built_in">mean</span>(img);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出每个通道的均值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Mean of Blue channel: &quot;</span> &lt;&lt; mean_val[<span class="number">0</span>] &lt;&lt; endl;   <span class="comment">// 蓝色通道的均值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Mean of Green channel: &quot;</span> &lt;&lt; mean_val[<span class="number">1</span>] &lt;&lt; endl;  <span class="comment">// 绿色通道的均值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Mean of Red channel: &quot;</span> &lt;&lt; mean_val[<span class="number">2</span>] &lt;&lt; endl;    <span class="comment">// 红色通道的均值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mean of Blue channel: 125</span><br><span class="line">Mean of Green channel: 175</span><br><span class="line">Mean of Red channel: 206.25</span><br></pre></td></tr></table></figure>

<ul>
<li>这里计算了一个 2x2 彩色图像的均值。返回的 <code>Scalar</code> 对象包含三个元素，分别表示蓝色、绿色和红色通道的均值。</li>
</ul>
<hr>
<h3 id="计算带掩模的图像均值"><a href="#计算带掩模的图像均值" class="headerlink" title="计算带掩模的图像均值"></a><strong>计算带掩模的图像均值</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 3x3 矩阵</span></span><br><span class="line">    Mat mat = (<span class="built_in">Mat_</span>&lt;uchar&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">                                     <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">                                     <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个掩模（1 表示保留该区域，0 表示忽略）</span></span><br><span class="line">    Mat mask = (<span class="built_in">Mat_</span>&lt;uchar&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">                                     <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">                                     <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用掩模计算均值</span></span><br><span class="line">    Scalar mean_val = <span class="built_in">mean</span>(mat, mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出均值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Mean value using mask: &quot;</span> &lt;&lt; mean_val[<span class="number">0</span>] &lt;&lt; endl;  <span class="comment">// 输出使用掩模的均值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mean value using mask: 5</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个示例中，掩模指定了哪些区域的像素参与均值计算。掩模中的非零区域为 <code>1</code>，这些区域的像素会被用于计算均值。掩模选择了矩阵中的一些元素，计算它们的均值。</li>
</ul>
<hr>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><ol>
<li><p><strong>掩模的大小和类型</strong>：</p>
<ul>
<li>掩模必须与输入图像或矩阵具有相同的尺寸。掩模中的非零值（一般为 <code>1</code>）表示该位置的像素会参与均值计算，零值（<code>0</code>）的位置则会被忽略。</li>
</ul>
</li>
<li><p><strong>返回值的类型</strong>：</p>
<ul>
<li>返回的 <code>Scalar</code> 对象包含每个通道的均值。对于单通道图像，<code>Scalar</code> 只有一个元素；对于多通道图像，<code>Scalar</code> 包含多个元素，分别代表每个通道的均值。</li>
</ul>
</li>
<li><p><strong>性能</strong>：</p>
<ul>
<li><code>cv::mean()</code> 是一个非常高效的函数，适用于计算整个图像或特定区域的均值。</li>
</ul>
</li>
<li><p><strong>图像类型</strong>：</p>
<ul>
<li><code>cv::mean()</code> 可以应用于任何类型的图像，包括灰度图像、彩色图像以及带有透明度通道的图像。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h2><ol>
<li><p><strong>图像亮度分析</strong>：</p>
<ul>
<li><code>cv::mean()</code> 可以用于计算图像的亮度，特别是在图像处理任务中，例如调整图像对比度、亮度增强等。</li>
</ul>
</li>
<li><p><strong>图像预处理</strong>：</p>
<ul>
<li>在图像增强或其他预处理步骤中，计算图像的均值可以用于白平衡调整、曝光校正等。</li>
</ul>
</li>
<li><p><strong>图像背景分析</strong>：</p>
<ul>
<li>计算背景区域的均值，在背景建模和分割算法中非常常见。</li>
</ul>
</li>
<li><p><strong>特定区域的分析</strong>：</p>
<ul>
<li>当图像中某些区域需要特别关注时，可以使用掩模来计算该区域的均值，这在图像分析、医学影像分析等领域中非常有用。</li>
</ul>
</li>
<li><p><strong>颜色分析</strong>：</p>
<ul>
<li>在颜色校正或颜色特征提取时，<code>cv::mean()</code> 可以用于分析不同颜色通道的特性，帮助进行图像分类、检测等任务。</li>
</ul>
</li>
</ol>
<hr>
<p><code>cv::mean()</code> 是一个简单且高效的函数，用于计算图像或矩阵的均值。无论是计算单通道图像的均值，还是彩色图像每个通道的均值，或者是掩模区域的均值，它都非常适用于图像分析、预处理和特征提取等任务。</p>
<h2 id="cv-sum-函数-详解"><a href="#cv-sum-函数-详解" class="headerlink" title="cv::sum() 函数 详解"></a>cv::sum() 函数 详解</h2><p><code>cv::sum()</code> 是 OpenCV 中用于计算矩阵（图像或其他类型的二维数据）所有元素的和的函数。它可以用于快速计算图像或矩阵中所有元素的总和，或者针对每个通道（例如，对于彩色图像的 RGB 通道）分别计算其和。</p>
<hr>
<h2 id="函数定义-1"><a href="#函数定义-1" class="headerlink" title="函数定义"></a><strong>函数定义</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Scalar <span class="title">cv::sum</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray src    <span class="comment">// 输入矩阵或图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参数详解-2"><a href="#参数详解-2" class="headerlink" title="参数详解"></a><strong>参数详解</strong></h2><ol>
<li>**<code>src</code>**：<ul>
<li>输入参数，可以是 <code>cv::Mat</code> 或其他 <code>InputArray</code> 类型，表示要计算和的矩阵或图像。</li>
<li>可以是单通道或多通道矩阵。如果是多通道图像（如彩色图像），则每个通道的和将被分别计算。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a><strong>返回值</strong></h2><ul>
<li>返回一个 <code>cv::Scalar</code> 类型的对象，表示输入矩阵中各个通道的和。<code>Scalar</code> 是一个包含 4 个 <code>double</code> 值的结构体，通常用于表示图像的各个通道的值。<ul>
<li>对于单通道图像，<code>Scalar</code> 的其他元素将为 0。</li>
<li>对于多通道图像（如三通道的 RGB 图像），<code>Scalar</code> 的四个元素分别对应图像的每个通道的和。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h2><ul>
<li><code>cv::sum()</code> 会计算输入矩阵中所有元素的总和。如果是多通道矩阵，它会分别计算每个通道的和。</li>
<li>对于彩色图像，返回的 <code>Scalar</code> 包含四个元素，分别代表 <code>B</code>, <code>G</code>, <code>R</code> 和 <code>A</code> 通道的总和（如果图像有透明度通道）。如果是灰度图像，则返回的 <code>Scalar</code> 中只有一个元素表示所有像素的总和。</li>
</ul>
<hr>
<h2 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h2><h3 id="计算单通道图像的元素和"><a href="#计算单通道图像的元素和" class="headerlink" title="计算单通道图像的元素和"></a><strong>计算单通道图像的元素和</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个简单的 3x3 矩阵</span></span><br><span class="line">    Mat mat = (<span class="built_in">Mat_</span>&lt;uchar&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">                                     <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">                                     <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算所有元素的和</span></span><br><span class="line">    Scalar total_sum = <span class="built_in">sum</span>(mat);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sum of all elements: &quot;</span> &lt;&lt; total_sum[<span class="number">0</span>] &lt;&lt; endl;  <span class="comment">// 输出矩阵所有元素的和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sum of all elements: 45</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个示例中，<code>sum()</code> 函数计算了矩阵 <code>mat</code> 所有元素的总和（即 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 &#x3D; 45），并返回一个 <code>Scalar</code> 对象，<code>total_sum[0]</code> 代表单通道矩阵的总和。</li>
</ul>
<hr>
<h3 id="计算多通道图像的元素和"><a href="#计算多通道图像的元素和" class="headerlink" title="计算多通道图像的元素和"></a><strong>计算多通道图像的元素和</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个简单的 2x2 彩色图像（3通道，RGB）</span></span><br><span class="line">    Mat img = (<span class="built_in">Mat_</span>&lt;Vec3b&gt;(<span class="number">2</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">Vec3b</span>(<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>), <span class="built_in">Vec3b</span>(<span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>),</span><br><span class="line">                                     <span class="built_in">Vec3b</span>(<span class="number">200</span>, <span class="number">250</span>, <span class="number">50</span>), <span class="built_in">Vec3b</span>(<span class="number">125</span>, <span class="number">175</span>, <span class="number">225</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个通道的和</span></span><br><span class="line">    Scalar total_sum = <span class="built_in">sum</span>(img);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出每个通道的和</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sum of Blue channel: &quot;</span> &lt;&lt; total_sum[<span class="number">0</span>] &lt;&lt; endl;   <span class="comment">// 蓝色通道的总和</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sum of Green channel: &quot;</span> &lt;&lt; total_sum[<span class="number">1</span>] &lt;&lt; endl;  <span class="comment">// 绿色通道的总和</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sum of Red channel: &quot;</span> &lt;&lt; total_sum[<span class="number">2</span>] &lt;&lt; endl;    <span class="comment">// 红色通道的总和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sum of Blue channel: 475</span><br><span class="line">Sum of Green channel: 600</span><br><span class="line">Sum of Red channel: 775</span><br></pre></td></tr></table></figure>

<ul>
<li>在这个示例中，<code>sum()</code> 函数分别计算了彩色图像中蓝色、绿色和红色通道的元素和，并返回一个 <code>Scalar</code> 类型的结果。<code>total_sum[0]</code>、<code>total_sum[1]</code> 和 <code>total_sum[2]</code> 分别表示蓝色、绿色和红色通道的总和。</li>
</ul>
<hr>
<h3 id="计算包含透明度通道的图像和"><a href="#计算包含透明度通道的图像和" class="headerlink" title="计算包含透明度通道的图像和"></a><strong>计算包含透明度通道的图像和</strong></h3><p>对于带有透明度通道（例如 BGRA 图像）的图像，<code>cv::sum()</code> 返回一个包含四个元素的 <code>Scalar</code>，分别对应蓝色、绿色、红色和透明度通道的和。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个带透明度通道的 2x2 彩色图像（BGRA）</span></span><br><span class="line">    Mat img = (<span class="built_in">Mat_</span>&lt;Vec4b&gt;(<span class="number">2</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">Vec4b</span>(<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">255</span>), <span class="built_in">Vec4b</span>(<span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>, <span class="number">255</span>),</span><br><span class="line">                                     <span class="built_in">Vec4b</span>(<span class="number">200</span>, <span class="number">250</span>, <span class="number">50</span>, <span class="number">128</span>), <span class="built_in">Vec4b</span>(<span class="number">125</span>, <span class="number">175</span>, <span class="number">225</span>, <span class="number">64</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个通道的和</span></span><br><span class="line">    Scalar total_sum = <span class="built_in">sum</span>(img);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出每个通道的和</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sum of Blue channel: &quot;</span> &lt;&lt; total_sum[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sum of Green channel: &quot;</span> &lt;&lt; total_sum[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sum of Red channel: &quot;</span> &lt;&lt; total_sum[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sum of Alpha channel: &quot;</span> &lt;&lt; total_sum[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sum of Blue channel: 475</span><br><span class="line">Sum of Green channel: 600</span><br><span class="line">Sum of Red channel: 775</span><br><span class="line">Sum of Alpha channel: 447</span><br></pre></td></tr></table></figure>

<ul>
<li><code>total_sum[0]</code> 表示蓝色通道的总和，<code>total_sum[1]</code> 表示绿色通道的总和，<code>total_sum[2]</code> 表示红色通道的总和，<code>total_sum[3]</code> 表示透明度通道（Alpha）的总和。</li>
</ul>
<hr>
<h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><ol>
<li><p><strong>数据类型</strong>：</p>
<ul>
<li><code>cv::sum()</code> 计算的是矩阵中元素的总和，所以返回的 <code>Scalar</code> 类型的每个元素都是 <code>double</code> 类型的数值。即使输入图像是 <code>CV_8UC1</code> 或 <code>CV_8UC3</code> 等，返回的结果也是 <code>double</code> 类型。</li>
</ul>
</li>
<li><p><strong>图像类型</strong>：</p>
<ul>
<li>适用于所有类型的矩阵，单通道或多通道图像（例如灰度图像、彩色图像等）。</li>
</ul>
</li>
<li><p><strong>矩阵的维度</strong>：</p>
<ul>
<li><code>cv::sum()</code> 不关心输入矩阵的维度，适用于任意大小的矩阵。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h2><ol>
<li><p><strong>图像统计分析</strong>：</p>
<ul>
<li>用于计算图像的统计量，如图像中所有像素的总和，或者每个颜色通道的和，这在图像分析中非常常见。</li>
</ul>
</li>
<li><p><strong>图像亮度计算</strong>：</p>
<ul>
<li>可以通过计算图像所有像素的和来评估图像的整体亮度。</li>
</ul>
</li>
<li><p><strong>直方图计算</strong>：</p>
<ul>
<li>在计算图像的直方图时，<code>cv::sum()</code> 可用于计算每个像素值的总和，帮助统计不同强度值的像素分布。</li>
</ul>
</li>
<li><p><strong>图像均值计算</strong>：</p>
<ul>
<li>在图像预处理和归一化时，<code>cv::sum()</code> 可以与其他函数一起使用，计算图像的均值或者其他统计特征。</li>
</ul>
</li>
</ol>
<hr>
<p><code>cv::sum()</code> 是一个非常实用的函数，它帮助快速计算矩阵或图像所有元素的和，并且可以轻松地针对每个通道进行分析。在图像处理、特征提取等任务中具有广泛应用。</p>
<h2 id="cv-boxPoints-函数-详解"><a href="#cv-boxPoints-函数-详解" class="headerlink" title="cv::boxPoints() 函数 详解"></a>cv::boxPoints() 函数 详解</h2><p><code>cv::boxPoints()</code> 是 OpenCV 中用于将 <strong>旋转矩形</strong>（<code>RotatedRect</code>）的角点转换为四个顶点坐标的函数。它常与 <code>cv::minAreaRect()</code> 配合使用，用于从最小外接矩形中提取出矩形的四个顶点。这些顶点是矩形的四个角，用于绘制、分析或其他几何操作。</p>
<hr>
<h2 id="函数定义-2"><a href="#函数定义-2" class="headerlink" title="函数定义"></a><strong>函数定义</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::boxPoints</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> RotatedRect&amp; box,    <span class="comment">// 输入旋转矩形</span></span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;Point2f&gt;&amp; points  <span class="comment">// 输出的四个顶点</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参数详解-3"><a href="#参数详解-3" class="headerlink" title="参数详解"></a><strong>参数详解</strong></h2><ol>
<li><p>**<code>box</code>**：</p>
<ul>
<li>输入参数，类型为 <code>RotatedRect</code>，表示旋转矩形。旋转矩形由三个元素组成：<ul>
<li>**<code>center</code>**：矩形的中心点，类型为 <code>Point2f</code>。</li>
<li>**<code>size</code>**：矩形的尺寸，类型为 <code>Size2f</code>，包括矩形的宽度和高度。</li>
<li>**<code>angle</code>**：矩形的旋转角度，表示矩形相对于坐标轴的旋转角度，以度为单位。</li>
</ul>
</li>
</ul>
</li>
<li><p>**<code>points</code>**：</p>
<ul>
<li>输出参数，类型为 <code>std::vector&lt;Point2f&gt;</code>，表示矩形的四个顶点。<code>boxPoints()</code> 会将旋转矩形的四个角的坐标存储到 <code>points</code> 向量中。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a><strong>返回值</strong></h2><ul>
<li><code>cv::boxPoints()</code> 没有返回值，但它通过输出参数 <code>points</code> 返回旋转矩形的四个顶点的坐标。</li>
</ul>
<hr>
<h2 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h2><ul>
<li><code>cv::boxPoints()</code> 会根据旋转矩形的中心点、尺寸和角度计算出旋转矩形的四个顶点。返回的四个顶点是以顺时针或逆时针方向排列的。</li>
<li>这些顶点是旋转矩形的边界点，可以用于绘制矩形、进一步处理或者分析。</li>
</ul>
<hr>
<h2 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h2><h3 id="从旋转矩形提取四个顶点"><a href="#从旋转矩形提取四个顶点" class="headerlink" title="从旋转矩形提取四个顶点"></a><strong>从旋转矩形提取四个顶点</strong></h3><p>以下是一个示例代码，演示如何从最小外接矩形 (<code>cv::minAreaRect()</code>) 获取旋转矩形的四个顶点，并在图像中绘制它们。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个点集，模拟轮廓</span></span><br><span class="line">    vector&lt;Point&gt; points = &#123;<span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">200</span>), <span class="built_in">Point</span>(<span class="number">200</span>, <span class="number">100</span>), <span class="built_in">Point</span>(<span class="number">300</span>, <span class="number">300</span>), <span class="built_in">Point</span>(<span class="number">150</span>, <span class="number">250</span>)&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算最小外接矩形</span></span><br><span class="line">    RotatedRect minRect = <span class="built_in">minAreaRect</span>(points);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 boxPoints 提取矩形的四个顶点</span></span><br><span class="line">    <span class="function">vector&lt;Point2f&gt; <span class="title">vertices</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">boxPoints</span>(minRect, vertices);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制最小外接矩形</span></span><br><span class="line">    Mat img = Mat::<span class="built_in">zeros</span>(<span class="number">400</span>, <span class="number">400</span>, CV_8UC3);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">line</span>(img, vertices[i], vertices[(i + <span class="number">1</span>) % <span class="number">4</span>], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);  <span class="comment">// 绘制矩形的边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制矩形的中心</span></span><br><span class="line">    <span class="built_in">circle</span>(img, minRect.center, <span class="number">5</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示结果</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Min Area Rect with Box Points&quot;</span>, img);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a><strong>解释</strong></h3><ol>
<li><strong>最小外接矩形计算</strong>：通过 <code>cv::minAreaRect()</code> 计算给定点集的最小外接矩形。</li>
<li><strong><code>boxPoints()</code> 提取四个顶点</strong>：<code>boxPoints()</code> 将旋转矩形转换为四个角的坐标。</li>
<li><strong>绘制矩形</strong>：使用 <code>line()</code> 绘制旋转矩形的四条边，并使用 <code>circle()</code> 绘制矩形的中心。</li>
</ol>
<hr>
<h2 id="返回值示例"><a href="#返回值示例" class="headerlink" title="返回值示例"></a><strong>返回值示例</strong></h2><p>假设输入点集是 <code>&#123;Point(100, 200), Point(200, 100), Point(300, 300), Point(150, 250)&#125;</code>，并且通过 <code>cv::minAreaRect()</code> 得到的旋转矩形 <code>minRect</code> 包含：</p>
<ul>
<li><code>center = (200, 200)</code></li>
<li><code>size = (150, 100)</code></li>
<li><code>angle = -30</code>（即矩形旋转了 -30 度）</li>
</ul>
<p>通过 <code>boxPoints(minRect, vertices)</code> 得到的四个顶点 <code>vertices</code> 可能为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vertices[<span class="number">0</span>] = <span class="built_in">Point2f</span>(<span class="number">100</span>, <span class="number">250</span>)</span><br><span class="line">vertices[<span class="number">1</span>] = <span class="built_in">Point2f</span>(<span class="number">250</span>, <span class="number">100</span>)</span><br><span class="line">vertices[<span class="number">2</span>] = <span class="built_in">Point2f</span>(<span class="number">300</span>, <span class="number">350</span>)</span><br><span class="line">vertices[<span class="number">3</span>] = <span class="built_in">Point2f</span>(<span class="number">150</span>, <span class="number">400</span>)</span><br></pre></td></tr></table></figure>

<p>这些点即为旋转矩形的四个顶点，用于进一步的图像绘制或计算。</p>
<hr>
<h2 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><ol>
<li><p><strong>旋转矩形的角度</strong>：</p>
<ul>
<li><code>cv::minAreaRect()</code> 返回的旋转矩形角度是逆时针方向的角度，因此可以通过 <code>boxPoints()</code> 提取旋转后的四个顶点。</li>
</ul>
</li>
<li><p><strong>矩形的点顺序</strong>：</p>
<ul>
<li>返回的四个顶点按顺时针或逆时针方向排列，可以使用这些点来绘制矩形或进行其他几何操作。</li>
</ul>
</li>
<li><p><strong>不需要额外的转换</strong>：</p>
<ul>
<li>通过 <code>boxPoints()</code>，不需要手动计算矩形的四个顶点，OpenCV 会自动根据旋转矩形的属性来计算和返回它们。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h2><ol>
<li><p><strong>目标检测与定位</strong>：</p>
<ul>
<li>在物体检测任务中，<code>cv::boxPoints()</code> 可以将物体的最小外接矩形转换为可用的顶点，帮助绘制目标边界框。</li>
</ul>
</li>
<li><p><strong>图像分割后的形状分析</strong>：</p>
<ul>
<li>在图像分割或轮廓检测中，计算最小外接矩形并提取顶点，用于进一步分析或操作（如裁剪、目标识别）。</li>
</ul>
</li>
<li><p><strong>旋转矩形的可视化</strong>：</p>
<ul>
<li>在可视化中，<code>boxPoints()</code> 提供了一种方便的方式来获取旋转矩形的四个顶点，以便绘制旋转矩形或显示物体的边界。</li>
</ul>
</li>
<li><p><strong>物体姿势估计</strong>：</p>
<ul>
<li>在物体姿势估计中，<code>cv::boxPoints()</code> 用于获取旋转矩形的边界，这可以用于估计物体在空间中的方向。</li>
</ul>
</li>
</ol>
<hr>
<p><code>cv::boxPoints()</code> 是一个非常有用的函数，能够从旋转矩形中提取出四个顶点，它在计算机视觉和图像处理中具有广泛的应用，特别是在目标检测、物体定位、形状分析等任务中。</p>
<h2 id="cv-minAreaRect-函数-详解"><a href="#cv-minAreaRect-函数-详解" class="headerlink" title="cv::minAreaRect() 函数 详解"></a>cv::minAreaRect() 函数 详解</h2><p><code>cv::minAreaRect()</code> 是 OpenCV 中用于计算最小外接矩形的函数。它返回一个矩形，该矩形包含给定的轮廓或点集，并且具有最小的面积。最小外接矩形的边可能并不是与图像的坐标轴平行的，而是倾斜的，这使得它比普通的矩形更有效地包围给定的点。</p>
<hr>
<h2 id="函数定义-3"><a href="#函数定义-3" class="headerlink" title="函数定义"></a><strong>函数定义</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RotatedRect <span class="title">cv::minAreaRect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray points    <span class="comment">// 输入的点集或轮廓</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参数详解-4"><a href="#参数详解-4" class="headerlink" title="参数详解"></a><strong>参数详解</strong></h2><ol>
<li>**<code>points</code>**：<ul>
<li>输入参数，可以是一个 <code>std::vector&lt;Point&gt;</code> 或 <code>std::vector&lt;std::vector&lt;Point&gt;&gt;</code>（轮廓）的集合，表示一组点。</li>
<li>输入的点集将用于计算最小外接矩形。</li>
<li>这些点应该是二维的坐标，且至少包含 3 个点。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a><strong>返回值</strong></h2><ul>
<li>**<code>RotatedRect</code>**：<ul>
<li>返回一个 <code>RotatedRect</code> 对象，表示最小外接矩形。</li>
<li><code>RotatedRect</code> 包含三个元素：<ul>
<li>**<code>center</code>**：矩形的中心点，类型为 <code>Point2f</code>，表示矩形中心的位置。</li>
<li>**<code>size</code>**：矩形的大小，类型为 <code>Size2f</code>，包括矩形的宽度和高度。</li>
<li>**<code>angle</code>**：矩形的旋转角度，类型为 <code>float</code>，表示矩形的旋转角度，以度为单位，逆时针为正。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h2><p><code>cv::minAreaRect()</code> 使用以下方法计算最小外接矩形：</p>
<ul>
<li>该函数通过计算所有点的旋转矩形来得到最小的矩形。</li>
<li>所得矩形的面积是最小的，且包含所有的输入点。</li>
<li>矩形的边可以是任意角度，不一定与坐标轴平行。</li>
</ul>
<hr>
<h2 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h2><h3 id="最小外接矩形的计算"><a href="#最小外接矩形的计算" class="headerlink" title="最小外接矩形的计算"></a><strong>最小外接矩形的计算</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个点集，模拟轮廓</span></span><br><span class="line">    vector&lt;Point&gt; points = &#123;<span class="built_in">Point</span>(<span class="number">100</span>, <span class="number">200</span>), <span class="built_in">Point</span>(<span class="number">200</span>, <span class="number">100</span>), <span class="built_in">Point</span>(<span class="number">300</span>, <span class="number">300</span>), <span class="built_in">Point</span>(<span class="number">150</span>, <span class="number">250</span>)&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算最小外接矩形</span></span><br><span class="line">    RotatedRect minRect = <span class="built_in">minAreaRect</span>(points);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取矩形的四个顶点</span></span><br><span class="line">    Point2f vertices[<span class="number">4</span>];</span><br><span class="line">    minRect.<span class="built_in">points</span>(vertices);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制最小外接矩形</span></span><br><span class="line">    Mat img = Mat::<span class="built_in">zeros</span>(<span class="number">400</span>, <span class="number">400</span>, CV_8UC3);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">line</span>(img, vertices[i], vertices[(i + <span class="number">1</span>) % <span class="number">4</span>], <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);  <span class="comment">// 绘制矩形边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制矩形的中心</span></span><br><span class="line">    <span class="built_in">circle</span>(img, minRect.center, <span class="number">5</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示结果</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Min Area Rect&quot;</span>, img);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a><strong>解释</strong></h3><ul>
<li><code>minAreaRect()</code> 计算最小外接矩形的中心、宽度、高度和旋转角度。</li>
<li><code>minRect.points(vertices)</code> 用于计算矩形的四个顶点，这些顶点是矩形的四个角。</li>
<li>使用 <code>line()</code> 和 <code>circle()</code> 函数绘制矩形和中心。</li>
</ul>
<hr>
<h2 id="返回值示例-1"><a href="#返回值示例-1" class="headerlink" title="返回值示例"></a><strong>返回值示例</strong></h2><p>假设输入点集是 <code>&#123;Point(100, 200), Point(200, 100), Point(300, 300), Point(150, 250)&#125;</code>，<code>minAreaRect()</code> 的返回值可能如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">center = (<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">size = (<span class="number">150</span>, <span class="number">100</span>)</span><br><span class="line">angle = <span class="number">-30</span></span><br></pre></td></tr></table></figure>

<p>这意味着：</p>
<ul>
<li>最小外接矩形的中心点是 <code>(200, 200)</code>。</li>
<li>矩形的大小是宽度 150，高度 100。</li>
<li>矩形相对于水平方向旋转了 -30 度（逆时针方向）。</li>
</ul>
<hr>
<h2 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><ol>
<li><p><strong>输入点集</strong>：</p>
<ul>
<li><code>cv::minAreaRect()</code> 适用于一组点（例如轮廓或多个离散点），点集必须具有至少 3 个点。</li>
</ul>
</li>
<li><p><strong>返回值的角度</strong>：</p>
<ul>
<li>返回的角度是逆时针方向的角度。</li>
<li><code>angle</code> 值可能为负数，表示矩形相对于水平方向的逆时针旋转。</li>
</ul>
</li>
<li><p><strong>点的顺序</strong>：</p>
<ul>
<li>计算最小外接矩形时，点集的顺序并不重要，因为算法会自动处理。</li>
</ul>
</li>
<li><p><strong>矩形可能不是轴对齐的</strong>：</p>
<ul>
<li>最小外接矩形的边不一定与图像坐标轴平行，它可以旋转，从而实现包围给定点集的最小矩形。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h2><ol>
<li><p><strong>目标检测与定位</strong>：</p>
<ul>
<li>使用最小外接矩形可以为检测到的目标（例如物体、形状等）生成一个最小的框，帮助进一步分析目标的位置信息。</li>
</ul>
</li>
<li><p><strong>形状分析</strong>：</p>
<ul>
<li>用于分析轮廓的大小和形状，可以应用于物体检测、姿势估计等领域。</li>
</ul>
</li>
<li><p><strong>物体跟踪</strong>：</p>
<ul>
<li>在物体跟踪算法中，最小外接矩形可以用来估计目标的边界，并在视频序列中跟踪物体。</li>
</ul>
</li>
<li><p><strong>图像分割后的处理</strong>：</p>
<ul>
<li>在图像分割应用中，通过最小外接矩形可以找出分割区域的边界，进一步进行分析或显示。</li>
</ul>
</li>
</ol>
<hr>
<p><code>cv::minAreaRect()</code> 是一个非常实用的函数，能够为任意点集提供一个最小的外接矩形，并且支持旋转矩形。这使得它在图像处理、目标检测和分析中具有广泛的应用。</p>
<h2 id="cv-contourArea-函数-详解"><a href="#cv-contourArea-函数-详解" class="headerlink" title="cv::contourArea() 函数 详解"></a>cv::contourArea() 函数 详解</h2><p><code>cv::contourArea()</code> 是 OpenCV 中用于计算轮廓面积的函数。它可以用于评估轮廓所围成的区域的大小，通常在物体检测、形状分析等任务中非常有用。</p>
<hr>
<h2 id="函数定义-4"><a href="#函数定义-4" class="headerlink" title="函数定义"></a><strong>函数定义</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">cv::contourArea</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray contour,    <span class="comment">// 输入轮廓</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> oriented = <span class="literal">false</span>  <span class="comment">// 是否计算有向面积（默认 false）</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参数详解-5"><a href="#参数详解-5" class="headerlink" title="参数详解"></a><strong>参数详解</strong></h2><ol>
<li><p>**<code>contour</code>**：</p>
<ul>
<li>输入轮廓，类型为 <code>std::vector&lt;Point&gt;</code>，表示一个封闭的轮廓。轮廓是由轮廓点组成的多边形，通常通过 <code>cv::findContours()</code> 函数提取。</li>
<li>轮廓应为闭合的，且数据应为顺时针或逆时针排列。</li>
</ul>
</li>
<li><p>**<code>oriented</code>**（可选）：</p>
<ul>
<li>布尔值，指定是否计算有向面积。<ul>
<li><code>false</code>（默认值）：计算无向面积，忽略轮廓的方向，返回绝对值。</li>
<li><code>true</code>：计算有向面积，返回正或负值，取决于轮廓的点顺序（顺时针为正，逆时针为负）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a><strong>返回值</strong></h2><ul>
<li>返回计算得到的面积值，类型为 <code>double</code>。<ul>
<li>若 <code>oriented = false</code>，返回绝对面积值。</li>
<li>若 <code>oriented = true</code>，返回带符号的面积值，正值表示顺时针方向的轮廓，负值表示逆时针方向的轮廓。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="工作原理-4"><a href="#工作原理-4" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h2><ul>
<li><p><code>cv::contourArea()</code> 使用 <strong>Shoelace 定理（叉积公式）</strong> 来计算轮廓所围成的区域面积：</p>
<p>[<br>\text{Area} &#x3D; \frac{1}{2} \left| \sum_{i&#x3D;1}^{n-1} (x_i y_{i+1} - x_{i+1} y_i) + (x_n y_1 - x_1 y_n) \right|<br>]</p>
<ul>
<li><code>x_i, y_i</code> 是轮廓点的坐标，<code>n</code> 是轮廓点的数量。</li>
<li>该公式是根据轮廓的点顺序（顺时针或逆时针）来计算。</li>
</ul>
</li>
<li><p>通过轮廓的方向（顺时针或逆时针），可以判断区域的面积是正值还是负值。<code>oriented</code> 参数控制是否返回有向面积。</p>
</li>
</ul>
<hr>
<h2 id="示例代码-5"><a href="#示例代码-5" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h2><h3 id="计算轮廓面积"><a href="#计算轮廓面积" class="headerlink" title="计算轮廓面积"></a><strong>计算轮廓面积</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取图像并转换为灰度</span></span><br><span class="line">    Mat src = <span class="built_in">imread</span>(<span class="string">&quot;image.jpg&quot;</span>, IMREAD_GRAYSCALE);</span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Error loading image!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二值化处理</span></span><br><span class="line">    Mat binary;</span><br><span class="line">    <span class="built_in">threshold</span>(src, binary, <span class="number">128</span>, <span class="number">255</span>, THRESH_BINARY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测轮廓</span></span><br><span class="line">    vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">    vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line">    <span class="built_in">findContours</span>(binary, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算第一个轮廓的面积</span></span><br><span class="line">    <span class="type">double</span> area = <span class="built_in">contourArea</span>(contours[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示结果</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Area of first contour: &quot;</span> &lt;&lt; area &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制轮廓</span></span><br><span class="line">    Mat result = Mat::<span class="built_in">zeros</span>(src.<span class="built_in">size</span>(), CV_8UC3);</span><br><span class="line">    <span class="built_in">drawContours</span>(result, contours, <span class="number">0</span>, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Contours&quot;</span>, result);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算有向面积"><a href="#计算有向面积" class="headerlink" title="计算有向面积"></a><strong>计算有向面积</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> area_with_direction = <span class="built_in">contourArea</span>(contours[<span class="number">0</span>], <span class="literal">true</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Oriented area of first contour: &quot;</span> &lt;&lt; area_with_direction &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>true</code> 将返回有向面积，值为正或负，表示轮廓方向。</li>
</ul>
<hr>
<h2 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><ol>
<li><p><strong>轮廓必须是闭合的</strong>：</p>
<ul>
<li><code>cv::contourArea()</code> 计算的是封闭轮廓的面积。如果轮廓不闭合，面积计算将不准确。</li>
</ul>
</li>
<li><p><strong>顺时针和逆时针方向的区别</strong>：</p>
<ul>
<li>如果轮廓按顺时针方向排列，计算出的面积为正值；如果按逆时针方向排列，计算出的面积为负值。通过 <code>oriented</code> 参数，可以选择是否计算有向面积。</li>
</ul>
</li>
<li><p><strong>对孔洞的处理</strong>：</p>
<ul>
<li>如果轮廓有内嵌孔洞（如轮廓内包含另一个小轮廓），<code>cv::contourArea()</code> 仍然可以正确计算整个轮廓的面积，但需要注意孔洞的影响。多个轮廓可以通过 <code>RETR_CCOMP</code> 或 <code>RETR_TREE</code> 模式在 <code>findContours()</code> 中提取。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h2><ol>
<li><p><strong>形状分析</strong>：</p>
<ul>
<li>在目标检测、物体识别中，计算轮廓的面积用于衡量物体的大小。</li>
</ul>
</li>
<li><p><strong>目标筛选</strong>：</p>
<ul>
<li>在图像分割中，根据面积阈值筛选出目标区域。</li>
</ul>
</li>
<li><p><strong>特征提取</strong>：</p>
<ul>
<li>在机器视觉应用中，面积是形状特征的一部分，可以与其他特征一起用于分类或识别。</li>
</ul>
</li>
<li><p><strong>孔洞检测</strong>：</p>
<ul>
<li>在复杂形状的分析中，计算面积并结合孔洞信息，帮助检测和处理孔洞区域。</li>
</ul>
</li>
</ol>
<hr>
<p><code>cv::contourArea()</code> 是一个简单但重要的函数，用于计算轮廓的面积。在形状分析、图像分割和目标识别中，面积常常是重要的特征。</p>
<h2 id="cv-findContours-函数-详解"><a href="#cv-findContours-函数-详解" class="headerlink" title="cv::findContours() 函数 详解"></a>cv::findContours() 函数 详解</h2><p><code>cv::findContours()</code> 是 OpenCV 中用于从二值图像中检测轮廓的函数。轮廓是用于表示物体边界的闭合曲线，在图像处理领域中广泛应用于目标检测、形状分析和特征提取等任务。</p>
<hr>
<h2 id="函数定义-5"><a href="#函数定义-5" class="headerlink" title="函数定义"></a><strong>函数定义</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::findContours</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray image,                 <span class="comment">// 输入二值图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArrayOfArrays contours,     <span class="comment">// 输出的轮廓</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray hierarchy,            <span class="comment">// 输出的层次结构</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> mode,                         <span class="comment">// 轮廓检索模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> method,                       <span class="comment">// 轮廓逼近方法</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Point offset = Point()            <span class="comment">// 轮廓点的偏移量</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参数详解-6"><a href="#参数详解-6" class="headerlink" title="参数详解"></a><strong>参数详解</strong></h2><ol>
<li><p>**<code>image</code>**：</p>
<ul>
<li>输入图像，必须为二值图像（如由 <code>cv::threshold()</code> 或 <code>cv::Canny()</code> 处理后的图像）。</li>
<li>图像会被修改，因此如果需要保留原图，应传递其副本。</li>
</ul>
</li>
<li><p>**<code>contours</code>**：</p>
<ul>
<li>输出的轮廓，类型为 <code>std::vector&lt;std::vector&lt;Point&gt;&gt;</code>。</li>
<li>每个轮廓是一个点的向量，表示轮廓的边界点。</li>
</ul>
</li>
<li><p>**<code>hierarchy</code>**：</p>
<ul>
<li>输出的层次结构，类型为 <code>std::vector&lt;Vec4i&gt;</code>。</li>
<li>每个轮廓与层次结构中的元素对应，四个值分别表示：<ul>
<li><code>hierarchy[i][0]</code>：下一个轮廓的索引（同层次）。</li>
<li><code>hierarchy[i][1]</code>：上一个轮廓的索引（同层次）。</li>
<li><code>hierarchy[i][2]</code>：第一个子轮廓的索引。</li>
<li><code>hierarchy[i][3]</code>：父轮廓的索引。</li>
</ul>
</li>
<li>如果不需要层次结构，可以传入 <code>noArray()</code>。</li>
</ul>
</li>
<li><p>**<code>mode</code>**（轮廓检索模式）：</p>
<ul>
<li>指定如何检索轮廓：<ul>
<li><code>RETR_EXTERNAL</code>：仅检索最外层轮廓。</li>
<li><code>RETR_LIST</code>：检索所有轮廓，但不建立层次结构。</li>
<li><code>RETR_CCOMP</code>：检索所有轮廓，并将其组织为两级层次结构（外层和内层）。</li>
<li><code>RETR_TREE</code>：检索所有轮廓，并以完整的树状层次结构存储。</li>
</ul>
</li>
</ul>
</li>
<li><p>**<code>method</code>**（轮廓逼近方法）：</p>
<ul>
<li>指定如何存储轮廓的点：<ul>
<li><code>CHAIN_APPROX_NONE</code>：存储所有的轮廓点。</li>
<li><code>CHAIN_APPROX_SIMPLE</code>：压缩水平、垂直和对角方向的冗余点，仅保留拐点。</li>
<li><code>CHAIN_APPROX_TC89_L1</code> 和 <code>CHAIN_APPROX_TC89_KCOS</code>：使用 Teh-Chin 链逼近算法。</li>
</ul>
</li>
</ul>
</li>
<li><p>**<code>offset</code>**（可选）：</p>
<ul>
<li>将所有轮廓点的坐标偏移一个固定值（默认值为 <code>Point(0, 0)</code>）。</li>
<li>常用于图像裁剪后，需要修正轮廓位置的情况。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a><strong>返回值</strong></h2><ul>
<li><code>cv::findContours()</code> 没有返回值，但会通过参数输出轮廓和层次结构。</li>
</ul>
<hr>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a><strong>使用示例</strong></h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取图像并转换为灰度</span></span><br><span class="line">    Mat src = <span class="built_in">imread</span>(<span class="string">&quot;image.jpg&quot;</span>, IMREAD_GRAYSCALE);</span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Error loading image!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二值化处理</span></span><br><span class="line">    Mat binary;</span><br><span class="line">    <span class="built_in">threshold</span>(src, binary, <span class="number">128</span>, <span class="number">255</span>, THRESH_BINARY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测轮廓</span></span><br><span class="line">    vector&lt;vector&lt;Point&gt;&gt; contours;</span><br><span class="line">    vector&lt;Vec4i&gt; hierarchy;</span><br><span class="line">    <span class="built_in">findContours</span>(binary, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制轮廓</span></span><br><span class="line">    Mat result = Mat::<span class="built_in">zeros</span>(src.<span class="built_in">size</span>(), CV_8UC3);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">drawContours</span>(result, contours, (<span class="type">int</span>)i, <span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>, LINE_8, hierarchy, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示结果</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, src);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Contours&quot;</span>, result);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><ol>
<li><p><strong>输入图像必须为二值图像</strong>：</p>
<ul>
<li>可以通过 <code>cv::threshold()</code>、<code>cv::Canny()</code> 等方法生成二值图像。</li>
</ul>
</li>
<li><p><strong>原图像被修改</strong>：</p>
<ul>
<li><code>findContours()</code> 会修改输入图像，通常清除非轮廓部分。</li>
</ul>
</li>
<li><p>**选择适当的 <code>mode</code> 和 <code>method</code>**：</p>
<ul>
<li>根据任务需求选择合适的轮廓检索模式和逼近方法。</li>
</ul>
</li>
<li><p><strong>轮廓点的数量</strong>：</p>
<ul>
<li><code>CHAIN_APPROX_NONE</code> 保存的点数最多，<code>CHAIN_APPROX_SIMPLE</code> 可以显著减少点数。</li>
</ul>
</li>
<li><p><strong>轮廓的存储顺序</strong>：</p>
<ul>
<li>检索到的轮廓存储在 <code>contours</code> 中，顺序与像素扫描顺序一致。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h2><ol>
<li><p><strong>对象检测和分割</strong>：</p>
<ul>
<li>提取物体边界进行目标检测或分割。</li>
</ul>
</li>
<li><p><strong>形状分析</strong>：</p>
<ul>
<li>使用轮廓进行形状匹配和特征分析。</li>
</ul>
</li>
<li><p><strong>边缘检测后处理</strong>：</p>
<ul>
<li>提取 <code>Canny</code> 边缘检测结果中的闭合轮廓。</li>
</ul>
</li>
<li><p><strong>图像测量</strong>：</p>
<ul>
<li>根据轮廓计算面积、周长、质心等几何特征。</li>
</ul>
</li>
</ol>
<hr>
<p><code>cv::findContours()</code> 是一个强大而灵活的工具，可广泛应用于图像分析和计算机视觉任务中。合理选择参数可以优化性能并适应具体需求。</p>
<h2 id="cv-threshold-详解"><a href="#cv-threshold-详解" class="headerlink" title="cv::threshold() 详解"></a>cv::threshold() 详解</h2><p><code>cv::threshold()</code> 是 OpenCV 中用于对图像进行阈值处理的函数，它将图像的像素值根据给定的阈值分成两个区域。通常用于图像分割或简单的二值化处理。</p>
<hr>
<h2 id="函数定义-6"><a href="#函数定义-6" class="headerlink" title="函数定义"></a><strong>函数定义</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">cv::threshold</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray src,        <span class="comment">// 输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray dst,       <span class="comment">// 输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> thresh,         <span class="comment">// 阈值</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> maxval,         <span class="comment">// 最大值</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> type               <span class="comment">// 阈值类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参数详解-7"><a href="#参数详解-7" class="headerlink" title="参数详解"></a><strong>参数详解</strong></h2><ol>
<li><p><strong><code>src</code></strong>:</p>
<ul>
<li>输入图像，必须是单通道图像（如灰度图）。</li>
<li>数据类型可以是 8 位、16 位或 32 位浮点数。</li>
</ul>
</li>
<li><p><strong><code>dst</code></strong>:</p>
<ul>
<li>输出图像，与输入图像具有相同的大小和类型。</li>
<li>经过阈值处理后的结果。</li>
</ul>
</li>
<li><p><strong><code>thresh</code></strong>:</p>
<ul>
<li>指定的阈值，像素值根据此阈值进行分类。</li>
</ul>
</li>
<li><p><strong><code>maxval</code></strong>:</p>
<ul>
<li>当像素值超过（或低于）阈值时设置为的最大值，具体行为取决于 <code>type</code> 参数。</li>
</ul>
</li>
<li><p><strong><code>type</code></strong>:</p>
<ul>
<li>指定阈值操作的类型，支持以下几种：<ul>
<li><code>THRESH_BINARY</code>：二值化处理。<ul>
<li>(\text{dst}(x, y) &#x3D;<br> \begin{cases}<br> \text{maxval} &amp; \text{if src}(x, y) &gt; \text{thresh} \<br> 0 &amp; \text{otherwise}<br> \end{cases})</li>
</ul>
</li>
<li><code>THRESH_BINARY_INV</code>：反转二值化。<ul>
<li>(\text{dst}(x, y) &#x3D;<br> \begin{cases}<br> 0 &amp; \text{if src}(x, y) &gt; \text{thresh} \<br> \text{maxval} &amp; \text{otherwise}<br> \end{cases})</li>
</ul>
</li>
<li><code>THRESH_TRUNC</code>：截断阈值。<ul>
<li>(\text{dst}(x, y) &#x3D;<br> \begin{cases}<br> \text{thresh} &amp; \text{if src}(x, y) &gt; \text{thresh} \<br> \text{src}(x, y) &amp; \text{otherwise}<br> \end{cases})</li>
</ul>
</li>
<li><code>THRESH_TOZERO</code>：零阈值化。<ul>
<li>(\text{dst}(x, y) &#x3D;<br> \begin{cases}<br> \text{src}(x, y) &amp; \text{if src}(x, y) &gt; \text{thresh} \<br> 0 &amp; \text{otherwise}<br> \end{cases})</li>
</ul>
</li>
<li><code>THRESH_TOZERO_INV</code>：反转零阈值化。<ul>
<li>(\text{dst}(x, y) &#x3D;<br> \begin{cases}<br> 0 &amp; \text{if src}(x, y) &gt; \text{thresh} \<br> \text{src}(x, y) &amp; \text{otherwise}<br> \end{cases})</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a><strong>返回值</strong></h2><ul>
<li>函数返回阈值 <code>thresh</code>，在自动计算阈值的模式（如 <code>THRESH_OTSU</code>）下，返回计算后的值。</li>
</ul>
<hr>
<h2 id="示例代码-6"><a href="#示例代码-6" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h2><h3 id="基本二值化"><a href="#基本二值化" class="headerlink" title="基本二值化"></a><strong>基本二值化</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取灰度图像</span></span><br><span class="line">    Mat src = <span class="built_in">imread</span>(<span class="string">&quot;image.jpg&quot;</span>, IMREAD_GRAYSCALE);</span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error loading image!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat dst;</span><br><span class="line">    <span class="comment">// 二值化操作，阈值为 128，最大值为 255</span></span><br><span class="line">    <span class="built_in">threshold</span>(src, dst, <span class="number">128</span>, <span class="number">255</span>, THRESH_BINARY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示结果</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, src);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Thresholded Image&quot;</span>, dst);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="OTSU-阈值法"><a href="#OTSU-阈值法" class="headerlink" title="OTSU 阈值法"></a><strong>OTSU 阈值法</strong></h3><p>OTSU 是一种自动计算最佳阈值的方法，通常用于图像二值化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">threshold</span>(src, dst, <span class="number">0</span>, <span class="number">255</span>, THRESH_BINARY | THRESH_OTSU);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>thresh</code> 参数会被忽略，返回值为自动计算的最佳阈值。</li>
</ul>
<hr>
<h2 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h2><ol>
<li><p><strong>输入图像要求</strong>：</p>
<ul>
<li>只能对单通道图像使用，RGB 图像需要先转换为灰度图。</li>
</ul>
</li>
<li><p><strong>阈值选择</strong>：</p>
<ul>
<li>手动设置阈值时需要通过实验调整合适值。</li>
<li>对于复杂图像，可使用 <code>THRESH_OTSU</code> 自动计算。</li>
</ul>
</li>
<li><p><strong>适合场景</strong>：</p>
<ul>
<li>二值化用于分割前景与背景。</li>
<li>应用范围包括对象检测、OCR（光学字符识别）、医学图像处理等。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="典型应用-1"><a href="#典型应用-1" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h2><ol>
<li><p><strong>分割前景和背景</strong>：</p>
<ul>
<li>根据像素亮度，将目标区域与背景区分开。</li>
</ul>
</li>
<li><p><strong>去除噪声</strong>：</p>
<ul>
<li>对噪声平滑后的图像应用阈值，可以突出重要特征。</li>
</ul>
</li>
<li><p><strong>特征提取</strong>：</p>
<ul>
<li>在二值图像中定位边缘、形状等信息。</li>
</ul>
</li>
<li><p><strong>医学图像分析</strong>：</p>
<ul>
<li>用于 CT 或 MRI 图像的病灶区域分割。</li>
</ul>
</li>
</ol>
<hr>
<p><code>cv::threshold()</code> 是一个简单而高效的工具，适合处理各种图像分割问题，并且通过 OTSU 和其他方法可以自动化调整阈值，提高处理效果。</p>
<h2 id="OpenCV-cv-GaussianBlur-详解"><a href="#OpenCV-cv-GaussianBlur-详解" class="headerlink" title="OpenCV cv::GaussianBlur() 详解"></a>OpenCV cv::GaussianBlur() 详解</h2><p><code>cv::GaussianBlur()</code> 是 OpenCV 中用于对图像进行高斯模糊处理的函数。高斯模糊是一种使用高斯核对图像进行平滑操作的技术，主要用于减少图像中的噪声和细节。</p>
<hr>
<h3 id="函数定义-7"><a href="#函数定义-7" class="headerlink" title="函数定义"></a><strong>函数定义</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::GaussianBlur</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray src,        <span class="comment">// 输入图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray dst,       <span class="comment">// 输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">    Size ksize,            <span class="comment">// 高斯核大小（宽度和高度）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> sigmaX,         <span class="comment">// X 方向的高斯核标准差</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> sigmaY = <span class="number">0</span>,     <span class="comment">// Y 方向的高斯核标准差，默认为 0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> borderType = BORDER_DEFAULT <span class="comment">// 边界模式</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="参数详解-8"><a href="#参数详解-8" class="headerlink" title="参数详解"></a><strong>参数详解</strong></h3><ol>
<li><p>**<code>src</code>**：</p>
<ul>
<li>输入图像，支持单通道或多通道图像。</li>
<li>数据类型可以是 8 位、16 位或 32 位浮点数。</li>
</ul>
</li>
<li><p>**<code>dst</code>**：</p>
<ul>
<li>输出图像，与输入图像具有相同的大小和通道数。</li>
</ul>
</li>
<li><p>**<code>ksize</code>**：</p>
<ul>
<li>高斯核的大小，用 <code>cv::Size</code> 指定。</li>
<li>宽度和高度都必须为正的奇数，例如 <code>cv::Size(3, 3)</code> 或 <code>cv::Size(5, 5)</code>。</li>
<li>核大小越大，模糊效果越强。</li>
</ul>
</li>
<li><p>**<code>sigmaX</code>**：</p>
<ul>
<li>高斯核在 X 方向的标准差，决定模糊的强度。</li>
<li>如果为 0，OpenCV 会根据 <code>ksize</code> 自动计算合适的值。</li>
</ul>
</li>
<li><p>**<code>sigmaY</code>**：</p>
<ul>
<li>高斯核在 Y 方向的标准差。</li>
<li>默认值为 0，表示与 <code>sigmaX</code> 相同。</li>
</ul>
</li>
<li><p>**<code>borderType</code>**：</p>
<ul>
<li>指定边界模式，用于处理图像边缘。常见值包括：<ul>
<li><code>BORDER_CONSTANT</code>：填充常量值。</li>
<li><code>BORDER_REPLICATE</code>：重复最边缘的像素。</li>
<li><code>BORDER_REFLECT</code>：镜像反射模式。</li>
<li><code>BORDER_WRAP</code>：环绕模式。</li>
<li><code>BORDER_DEFAULT</code>（默认）：通常为 <code>BORDER_REFLECT_101</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="工作原理-5"><a href="#工作原理-5" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h3><p>高斯模糊通过卷积操作实现，卷积核的每个权重值由高斯函数决定：<br>[<br>G(x, y) &#x3D; \frac{1}{2\pi \sigma^2} e^{-\frac{x^2 + y^2}{2\sigma^2}}<br>]</p>
<ul>
<li>( G(x, y) ): 高斯核的值。</li>
<li>( \sigma ): 标准差，控制模糊的范围。</li>
<li>( x, y ): 距离核中心的偏移。</li>
</ul>
<p>核大小和标准差共同决定了模糊的效果。标准差越大，权重分布越宽，模糊效果越强。</p>
<hr>
<h3 id="示例代码-7"><a href="#示例代码-7" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h3><h4 id="C-示例"><a href="#C-示例" class="headerlink" title="C++ 示例"></a><strong>C++ 示例</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取输入图像</span></span><br><span class="line">    Mat src = <span class="built_in">imread</span>(<span class="string">&quot;image.jpg&quot;</span>, IMREAD_COLOR);</span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error loading image!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出图像</span></span><br><span class="line">    Mat dst;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用高斯模糊</span></span><br><span class="line">    <span class="built_in">GaussianBlur</span>(src, dst, <span class="built_in">Size</span>(<span class="number">5</span>, <span class="number">5</span>), <span class="number">1.5</span>, <span class="number">1.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示结果</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Original Image&quot;</span>, src);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Gaussian Blurred Image&quot;</span>, dst);</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>核大小和标准差的选择</strong>：</p>
<ul>
<li>核大小应为奇数且适当。过小的核可能导致模糊效果不明显，过大的核会损失细节。</li>
<li>标准差与核大小密切相关，可通过实验确定最佳值。</li>
</ul>
</li>
<li><p><strong>性能影响</strong>：</p>
<ul>
<li>大核会显著增加计算量，可能需要优化（如使用 GPU 加速）。</li>
</ul>
</li>
<li><p><strong>与其他模糊方法的对比</strong>：</p>
<ul>
<li>与均值模糊（<code>cv::blur</code>）相比，高斯模糊更平滑，视觉效果更自然。</li>
<li>与中值模糊（<code>cv::medianBlur</code>）相比，高斯模糊对噪声的抑制能力稍弱，但保留边缘的能力较差。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a><strong>实际应用</strong></h3><ol>
<li><strong>降噪预处理</strong>：<ul>
<li>在边缘检测（如 Canny 边缘检测）前，用于平滑图像，减少虚假边缘。</li>
</ul>
</li>
<li><strong>背景模糊</strong>：<ul>
<li>模糊背景以突出前景目标。</li>
</ul>
</li>
<li><strong>图像缩放前的平滑处理</strong>：<ul>
<li>减少缩放后产生的伪影。</li>
</ul>
</li>
<li><strong>视觉效果增强</strong>：<ul>
<li>在图像处理中实现柔化效果。</li>
</ul>
</li>
</ol>
<p><code>cv::GaussianBlur()</code> 是一种高效、自然的模糊方法，广泛用于各类图像处理任务。</p>
<h2 id="OpenCV-cv-samples-findFile-详解"><a href="#OpenCV-cv-samples-findFile-详解" class="headerlink" title="OpenCV cv::samples::findFile() 详解"></a>OpenCV cv::samples::findFile() 详解</h2><p><code>cv::samples::findFile()</code> 是 OpenCV 中的一个实用函数，用于查找示例文件或数据文件的路径。在进行示例代码编写或加载数据文件时，经常需要使用这个函数来确保程序能够正确地找到所需的文件。</p>
<p>以下是对 <code>cv::samples::findFile()</code> 的解释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">findFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename, <span class="type">bool</span> required = <span class="literal">true</span>, <span class="type">bool</span> silentMode = <span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>filename</code> 参数是要查找的文件名或文件路径。</li>
<li><code>required</code> 参数指示是否将文件视为必需。如果为 true，则函数在找不到文件时会抛出一个异常；如果为 false，则函数会返回空字符串。</li>
<li><code>silentMode</code> 参数指示是否在查找文件时静默模式。如果为 true，则函数在找不到文件时不会输出警告消息；如果为 false，则会输出警告消息。</li>
</ul>
<p>函数返回一个字符串，代表找到的文件的路径。如果文件找不到并且 <code>required</code> 参数为 false，则返回一个空字符串。</p>
<p><code>cv::samples::findFile()</code> 函数通常用于示例代码中，以确保示例文件或数据文件能够在不同的开发环境中正确地加载。例如，在图像处理示例中，可以使用 <code>cv::samples::findFile()</code> 函数来加载示例图像文件。</p>
<p>以下是一个示例用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string filename = cv::samples::<span class="built_in">findFile</span>(<span class="string">&quot;lena.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (filename.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to find the file &#x27;lena.jpg&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(filename);</span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to load the image&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;Image&quot;</span>, image);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码首先使用 <code>cv::samples::findFile()</code> 函数查找名为 “lena.jpg” 的图像文件，然后加载并显示它。</p>
<h2 id="OpenCV-cv-merge-函数-详解"><a href="#OpenCV-cv-merge-函数-详解" class="headerlink" title="OpenCV cv::merge() 函数 详解"></a>OpenCV cv::merge() 函数 详解</h2><p><code>cv::merge()</code> 函数是 OpenCV 库中的一个函数，用于将多个单通道图像合并为一个多通道图像。例如，将三个单通道的图像（比如分别代表 RGB 三个通道的图像）合并成一个三通道的彩色图像。下面是对 <code>cv::merge()</code> 函数的详解：</p>
<h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::merge</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArrayOfArrays mv,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray dst</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul>
<li><code>mv</code>：包含多个单通道图像的数组。每个单通道图像都会被合并到输出的多通道图像中。</li>
<li><code>dst</code>：输出的多通道图像。</li>
</ul>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p><code>cv::merge()</code> 函数用于将多个单通道图像合并成一个多通道图像。例如，如果输入是三个单通道的图像，则函数将会生成一个三通道的彩色图像，其中每个通道分别对应输入数组中的一个单通道图像。</p>
<h3 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>输入数组 <code>mv</code> 中的每个单通道图像的尺寸和数据类型必须相同。</li>
<li>输出的多通道图像 <code>dst</code> 的通道数将与输入数组 <code>mv</code> 的长度相同。</li>
<li>输出的多通道图像 <code>dst</code> 的尺寸与输入数组 <code>mv</code> 中的单通道图像的尺寸相同。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat blueChannel = cv::<span class="built_in">imread</span>(<span class="string">&quot;blue_channel.jpg&quot;</span>, cv::IMREAD_GRAYSCALE);</span><br><span class="line">cv::Mat greenChannel = cv::<span class="built_in">imread</span>(<span class="string">&quot;green_channel.jpg&quot;</span>, cv::IMREAD_GRAYSCALE);</span><br><span class="line">cv::Mat redChannel = cv::<span class="built_in">imread</span>(<span class="string">&quot;red_channel.jpg&quot;</span>, cv::IMREAD_GRAYSCALE);</span><br><span class="line"></span><br><span class="line">std::vector&lt;cv::Mat&gt; channels = &#123;blueChannel, greenChannel, redChannel&#125;;</span><br><span class="line"></span><br><span class="line">cv::Mat mergedImage;</span><br><span class="line">cv::<span class="built_in">merge</span>(channels, mergedImage);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>blueChannel</code>、<code>greenChannel</code> 和 <code>redChannel</code> 是三个单通道的图像，分别代表了蓝色通道、绿色通道和红色通道。通过 <code>cv::merge()</code> 函数将这三个单通道图像合并成一个三通道的彩色图像 <code>mergedImage</code>。</p>
<p><code>cv::merge()</code> 函数是 OpenCV 中用于合并单通道图像的常用函数之一，它为图像处理提供了便利性和灵活性，可以方便地将单通道图像合并成多通道图像。</p>
<h2 id="OpenCV-cv-split-函数-详解"><a href="#OpenCV-cv-split-函数-详解" class="headerlink" title="OpenCV cv::split() 函数 详解"></a>OpenCV cv::split() 函数 详解</h2><p><code>cv::split()</code> 函数是 OpenCV 库中的一个函数，用于将多通道图像分离为各个单通道图像。例如，将一个三通道的彩色图像分离成三个单通道的图像。下面是对 <code>cv::split()</code> 函数的详解：</p>
<h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::split</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray src,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArrayOfArrays mv</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h3><ul>
<li><code>src</code>：输入的多通道图像。</li>
<li><code>mv</code>：包含输出图像的数组。每个单通道图像都会被存储在这个数组中。</li>
</ul>
<h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p><code>cv::split()</code> 函数用于将多通道图像分离成各个单通道图像。例如，如果输入是一个三通道的彩色图像，则函数将会生成三个单通道的图像，每个通道分别存储在输出数组中。</p>
<h3 id="注意事项-9"><a href="#注意事项-9" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>输入图像可以是多通道的，例如 RGB 彩色图像或者 HSV 图像。</li>
<li>输出数组 <code>mv</code> 中的每个单通道图像的尺寸与输入图像的尺寸相同。</li>
<li>输出数组 <code>mv</code> 中的每个单通道图像的数据类型与输入图像的数据类型相同。</li>
<li>输出数组 <code>mv</code> 中的每个单通道图像可以单独访问，进行后续的处理或显示。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat src = cv::<span class="built_in">imread</span>(<span class="string">&quot;input.jpg&quot;</span>, cv::IMREAD_COLOR);</span><br><span class="line">std::vector&lt;cv::Mat&gt; channels;</span><br><span class="line">cv::<span class="built_in">split</span>(src, channels);</span><br><span class="line"></span><br><span class="line">cv::Mat blueChannel = channels[<span class="number">0</span>];  <span class="comment">// 蓝色通道</span></span><br><span class="line">cv::Mat greenChannel = channels[<span class="number">1</span>]; <span class="comment">// 绿色通道</span></span><br><span class="line">cv::Mat redChannel = channels[<span class="number">2</span>];   <span class="comment">// 红色通道</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>src</code> 是一个输入的彩色图像，通过 <code>cv::split()</code> 函数将其分离为三个单通道图像，分别存储在 <code>channels</code> 中。然后，可以通过数组索引来访问各个通道，例如 <code>channels[0]</code> 表示蓝色通道。</p>
<p><code>cv::split()</code> 函数是 OpenCV 中用于分离多通道图像的常用函数之一，它为图像处理提供了灵活性和便利性，可以方便地对各个通道进行单独处理。</p>
<h2 id="OpenCV-cvtColor-函数-详解"><a href="#OpenCV-cvtColor-函数-详解" class="headerlink" title="OpenCV cvtColor() 函数 详解"></a>OpenCV cvtColor() 函数 详解</h2><p><code>cvtColor()</code> 是 OpenCV 库中的一个函数，用于执行图像颜色空间转换。它可以将一种颜色空间的图像转换为另一种颜色空间，例如将 RGB 图像转换为灰度图像或将 BGR 图像转换为 HSV 图像。下面是对 <code>cvtColor()</code> 函数的详解：</p>
<h3 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::cvtColor</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    InputArray src,</span></span></span><br><span class="line"><span class="params"><span class="function">    OutputArray dst,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> code,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> dstCn = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h3><ul>
<li><code>src</code>：输入图像。</li>
<li><code>dst</code>：输出图像，转换后的结果将存储在这里。</li>
<li><code>code</code>：指定要执行的颜色空间转换类型的整数编码。例如，<code>cv::COLOR_BGR2GRAY</code> 表示从 BGR 到灰度图像的转换，<code>cv::COLOR_BGR2HSV</code> 表示从 BGR 到 HSV 的转换，以此类推。完整的转换类型列表可以在 OpenCV 文档中找到。</li>
<li><code>dstCn</code>：可选参数，指定输出图像的通道数，通常为0（默认值），表示与输入图像的通道数相同。</li>
</ul>
<h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><p><code>cvtColor()</code> 函数用于将图像从一个颜色空间转换为另一个颜色空间。它可以执行各种标准的颜色空间转换，例如 RGB 到灰度、RGB 到 HSV、BGR 到 Lab 等等。</p>
<h3 id="注意事项-10"><a href="#注意事项-10" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>在执行颜色空间转换时，像素值可能会超出目标图像类型的范围。因此，输出图像通常需要使用适当的数据类型来存储转换后的像素值。</li>
<li><code>cvtColor()</code> 函数对输入图像和输出图像的尺寸没有限制，但是输入图像和输出图像的通道数需要匹配转换的类型。</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat src = cv::<span class="built_in">imread</span>(<span class="string">&quot;input.jpg&quot;</span>, cv::IMREAD_COLOR);</span><br><span class="line">cv::Mat dst;</span><br><span class="line">cv::<span class="built_in">cvtColor</span>(src, dst, cv::COLOR_BGR2GRAY); <span class="comment">// 将BGR图像转换为灰度图像</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>src</code> 是一个输入的彩色图像，它会被转换为灰度图像，并将结果存储在 <code>dst</code> 中。</p>
<p><code>cvtColor()</code> 函数是 OpenCV 中执行图像颜色空间转换的常用函数之一，它为图像处理提供了强大的功能，包括颜色分析、特征提取和目标识别等方面的应用。</p>
<h2 id="OpenCV-convertTo-函数-详解"><a href="#OpenCV-convertTo-函数-详解" class="headerlink" title="OpenCV convertTo() 函数 详解"></a>OpenCV convertTo() 函数 详解</h2><p><code>convertTo()</code> 是 OpenCV 库中的一个函数，用于执行图像数据类型的转换。它可以将一种图像数据类型转换为另一种，例如从一个单精度浮点数类型转换为无符号8位整型类型。下面是对 <code>convertTo()</code> 函数的详解：</p>
<h3 id="函数原型-4"><a href="#函数原型-4" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> cv::Mat::<span class="built_in">convertTo</span>(</span><br><span class="line">    OutputArray m,</span><br><span class="line">    <span class="type">int</span> rtype,</span><br><span class="line">    <span class="type">double</span> alpha = <span class="number">1</span>,</span><br><span class="line">    <span class="type">double</span> beta = <span class="number">0</span></span><br><span class="line">) <span class="type">const</span></span><br></pre></td></tr></table></figure>

<h3 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="参数说明"></a>参数说明</h3><ul>
<li><code>m</code>：输出图像，转换后的结果将存储在这里。</li>
<li><code>rtype</code>：输出图像的数据类型，例如 <code>CV_8U</code>、<code>CV_32F</code> 等，可以通过 <code>CV_8U</code> 表示8位无符号整数，<code>CV_32F</code> 表示32位单精度浮点数，以此类推。</li>
<li><code>alpha</code>：可选参数，是乘法因子，用于缩放转换后的像素值。</li>
<li><code>beta</code>：可选参数，是加法因子，用于平移转换后的像素值。</li>
</ul>
<h3 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h3><p><code>convertTo()</code> 函数用于将一个 <code>Mat</code> 对象中的像素值类型转换为指定的数据类型。该函数执行的操作可以表达为以下公式：</p>
<p>[ \text{dst}(x,y) &#x3D; \text{saturate_cast} \left( \alpha \cdot \text{src}(x,y) + \beta \right) ]</p>
<p>其中，(\text{dst}(x,y)) 是输出图像中位置 ((x,y)) 处的像素值，(\text{src}(x,y)) 是输入图像中位置 ((x,y)) 处的像素值。(\alpha) 和 (\beta) 是函数的参数，用于缩放和平移像素值。<code>saturate_cast</code> 是一个函数，用于确保结果在特定数据类型的有效范围内。 </p>
<h3 id="注意事项-11"><a href="#注意事项-11" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>转换后的像素值可能会超出目标数据类型的有效范围，因此需要进行适当的饱和处理，<code>convertTo()</code> 函数会自动执行这个操作。</li>
<li>可以通过 <code>alpha</code> 和 <code>beta</code> 参数来控制转换的线性缩放和平移操作，如果不需要，可以将它们设置为默认值。</li>
</ul>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv::Mat src = cv::<span class="built_in">imread</span>(<span class="string">&quot;input.jpg&quot;</span>, cv::IMREAD_COLOR);</span><br><span class="line">cv::Mat dst;</span><br><span class="line">src.<span class="built_in">convertTo</span>(dst, CV_32F); <span class="comment">// 转换为32位浮点型图像</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>src</code> 是一个输入的图像，它会被转换为32位浮点型图像，结果存储在 <code>dst</code> 中。</p>
<p><code>convertTo()</code> 函数是 OpenCV 中用于数据类型转换的重要工具，可以方便地处理不同数据类型之间的图像操作。</p>
<h2 id="OpenCV-cv-putText-函数-详解"><a href="#OpenCV-cv-putText-函数-详解" class="headerlink" title="OpenCV cv::putText()  函数 详解"></a>OpenCV cv::putText()  函数 详解</h2><p><code>cv::putText()</code> 是 OpenCV 中用于在图像上绘制文本的函数。该函数可以在图像上添加指定的字符串，以及指定的字体、颜色、大小和其他样式。下面是该函数的详细说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::putText</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    cv::InputOutputArray img, <span class="comment">// 输入/输出图像</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> String&amp; text, <span class="comment">// 要绘制的文本字符串</span></span></span></span><br><span class="line"><span class="params"><span class="function">    cv::Point org, <span class="comment">// 文本起始位置的坐标（左下角）</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> fontFace, <span class="comment">// 字体类型，例如：cv::FONT_HERSHEY_SIMPLEX、cv::FONT_HERSHEY_PLAIN 等</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">double</span> fontScale, <span class="comment">// 字体大小的缩放系数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    cv::Scalar color, <span class="comment">// 文本颜色，如 cv::Scalar(255, 0, 0) 表示蓝色</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> thickness = <span class="number">1</span>, <span class="comment">// 文本的粗细，默认为 1</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> lineType = LINE_8, <span class="comment">// 文本的线条类型，默认为 8 连通线条</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bottomLeftOrigin = <span class="literal">false</span> <span class="comment">// 如果为 true，则表示坐标 org 是文本左下角的位置，否则是左上角的位置，默认为 false</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>img</code>：输入&#x2F;输出图像，通常是 <code>cv::Mat</code> 类型，表示要在其上绘制文本的图像。</li>
<li><code>text</code>：要绘制的文本字符串。</li>
<li><code>org</code>：文本起始位置的坐标，即文本左下角的位置。如果 <code>bottomLeftOrigin</code> 参数为 false，则表示文本左上角的位置。</li>
<li><code>fontFace</code>：字体类型，可以是预定义的字体类型，如 <code>cv::FONT_HERSHEY_SIMPLEX</code>、<code>cv::FONT_HERSHEY_PLAIN</code> 等。</li>
<li><code>fontScale</code>：字体大小的缩放系数。</li>
<li><code>color</code>：文本颜色，通常使用 <code>cv::Scalar</code> 类型表示，如 <code>cv::Scalar(255, 0, 0)</code> 表示蓝色。</li>
<li><code>thickness</code>：文本的线条粗细，默认为 1。</li>
<li><code>lineType</code>：文本的线条类型，默认为 8 连通线条。</li>
<li><code>bottomLeftOrigin</code>：如果为 true，则表示坐标 <code>org</code> 是文本左下角的位置，否则是左上角的位置，默认为 false。</li>
</ul>
<p>注意：在使用 <code>putText()</code> 函数之前，确保图像类型支持文本绘制操作，即图像的深度必须为 <code>CV_8U</code> 或 <code>CV_32F</code> 类型，而通道数必须为 1 或 3。</p>
<h2 id="OpenCV-cv-imdecode-函数-详解-中文"><a href="#OpenCV-cv-imdecode-函数-详解-中文" class="headerlink" title="OpenCV cv::imdecode() 函数 详解 中文"></a>OpenCV cv::imdecode() 函数 详解 中文</h2><p><code>cv::imdecode()</code> 是 OpenCV 库中的一个函数，用于将图像数据解码为 OpenCV 中的 <code>cv::Mat</code> 对象。该函数通常用于从内存中读取图像数据，而不是从文件中读取。</p>
<p>以下是 <code>cv::imdecode()</code> 函数的一些关键参数及其解释：</p>
<ul>
<li><p><strong>参数1 (<code>buf</code>)：</strong> 这是一个包含图像数据的缓冲区。通常情况下，这是一个 <code>uchar</code> 类型的数组，存储着图像的原始数据。</p>
</li>
<li><p><strong>参数2 (<code>flags</code>)：</strong> 这是一个整数参数，用于指定如何解码图像。常用的标志包括 <code>cv::IMREAD_COLOR</code>（默认值，将图像以BGR颜色格式加载）、<code>cv::IMREAD_GRAYSCALE</code>（将图像以灰度格式加载）和 <code>cv::IMREAD_UNCHANGED</code>（加载图像的所有通道，包括 Alpha 通道）。</p>
</li>
<li><p><strong>返回值：</strong> 函数返回一个 <code>cv::Mat</code> 对象，该对象包含解码后的图像数据。</p>
</li>
</ul>
<p><code>cv::imdecode()</code> 函数的调用示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取图像数据到内存中</span></span><br><span class="line">    std::vector&lt;uchar&gt; data; <span class="comment">// 图像数据的缓冲区</span></span><br><span class="line">    <span class="comment">// 假设 data 被填充了图像数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码图像数据</span></span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imdecode</span>(data, cv::IMREAD_COLOR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查图像是否成功解码</span></span><br><span class="line">    <span class="keyword">if</span> (!image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 成功加载图像，进行进一步的处理</span></span><br><span class="line">        cv::<span class="built_in">imshow</span>(<span class="string">&quot;Decoded Image&quot;</span>, image);</span><br><span class="line">        cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 加载失败</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to decode image.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子演示了如何使用 <code>cv::imdecode()</code> 函数将图像数据解码为 <code>cv::Mat</code> 对象，并在图像成功加载时显示它。</p>
<h2 id="OpenCV-cv-imencode-详解"><a href="#OpenCV-cv-imencode-详解" class="headerlink" title="OpenCV cv::imencode() 详解"></a>OpenCV cv::imencode() 详解</h2><p><code>cv::imencode()</code> 函数是 OpenCV 库中用于将图像编码为特定格式（如JPEG、PNG等）的函数。它可以将 <code>cv::Mat</code> 中存储的图像数据编码为指定格式的图像，并将编码后的图像数据存储到内存缓冲区中。</p>
<p>该函数的原型为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">imencode</span><span class="params">(<span class="type">const</span> String&amp; ext, InputArray img, std::vector&lt;uchar&gt;&amp; buf, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; params = std::vector&lt;<span class="type">int</span>&gt;())</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中参数含义如下：</p>
<ul>
<li><code>ext</code>：字符串参数，用于指定输出图像的格式，例如 <code>&quot;.jpg&quot;</code>、<code>&quot;.png&quot;</code> 等。</li>
<li><code>img</code>：<code>cv::Mat</code> 对象，包含待编码的图像数据。</li>
<li><code>buf</code>：<code>std::vector&lt;uchar&gt;</code> 类型的输出参数，用于存储编码后的图像数据。</li>
<li><code>params</code>（可选）：一个可选的参数向量，用于指定图像编码的参数，如 JPEG 质量、PNG 压缩级别等。具体参数因图像格式而异。</li>
</ul>
<p>下面是一些示例代码，展示了如何使用 <code>cv::imencode()</code> 函数将图像编码为 JPEG 格式并存储到内存中的 <code>std::vector&lt;uchar&gt;</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cv::Mat image = cv::<span class="built_in">imread</span>(<span class="string">&quot;path_to_your_image.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;无法读取图像文件\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;uchar&gt; buffer;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; params;</span><br><span class="line">    params.<span class="built_in">push_back</span>(cv::IMWRITE_JPEG_QUALITY); <span class="comment">// 设置 JPG 质量</span></span><br><span class="line">    params.<span class="built_in">push_back</span>(<span class="number">95</span>); <span class="comment">// 设置 JPG 图像质量，可根据需要调整</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将图像编码为 JPG 格式并保存到内存</span></span><br><span class="line">    <span class="type">bool</span> success = cv::<span class="built_in">imencode</span>(<span class="string">&quot;.jpg&quot;</span>, image, buffer, params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="comment">// buffer 中现在存储了编码后的 JPG 数据，可以进行保存或其他处理</span></span><br><span class="line">        <span class="comment">// 例如，将内存中的 JPG 数据保存到文件</span></span><br><span class="line">        FILE *file = <span class="built_in">fopen</span>(<span class="string">&quot;saved_image.jpg&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fwrite</span>(buffer.<span class="built_in">data</span>(), <span class="built_in">sizeof</span>(uchar), buffer.<span class="built_in">size</span>(), file);</span><br><span class="line">            <span class="built_in">fclose</span>(file);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;图像保存成功\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;无法保存图像\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;图像编码失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在示例中，<code>cv::imencode()</code> 将 <code>cv::Mat</code> 中的图像数据编码为 JPG 格式，并将编码后的数据存储在 <code>buffer</code> 中。之后，将 <code>buffer</code> 中的数据写入文件 <code>&quot;saved_image.jpg&quot;</code>。</p>
<p>要注意，在使用 <code>cv::imencode()</code> 函数之前，需要确保已经正确读取了图像数据并存储在 <code>cv::Mat</code> 对象中。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>感谢老板支持！敬礼(^^ゞ</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="zhang junyi WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="zhang junyi Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/OpenCV/" rel="tag"># OpenCV</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/22/notebook/OpenCV/opencv_3_%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/2024-05-22--%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B001/" rel="prev" title="常用函数">
      <i class="fa fa-chevron-left"></i> 常用函数
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/05/22/notebook/OpenCV/opencv_0_%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86/2024-05-22-opencv_5_%E5%9B%BE%E5%83%8F%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" rel="next" title="OpenCV 图像理论基础">
      OpenCV 图像理论基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cv-fitLine-%E5%87%BD%E6%95%B0-%E8%AF%A6%E8%A7%A3"><span class="nav-number">2.</span> <span class="nav-text">cv::fitLine() 函数 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">函数原型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="nav-number">4.</span> <span class="nav-text">参数详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">5.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">6.</span> <span class="nav-text">函数工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">7.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B"><span class="nav-number">7.1.</span> <span class="nav-text">1. 基本示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9C%A8%E5%9B%BE%E5%83%8F%E4%B8%AD%E7%BB%98%E5%88%B6%E6%8B%9F%E5%90%88%E7%9B%B4%E7%BA%BF"><span class="nav-number">7.2.</span> <span class="nav-text">2. 在图像中绘制拟合直线</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">8.</span> <span class="nav-text">常见应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">9.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cv-mean-%E5%87%BD%E6%95%B0-%E8%AF%A6%E8%A7%A3"><span class="nav-number">10.</span> <span class="nav-text">cv::mean() 函数 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="nav-number">11.</span> <span class="nav-text">函数定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3-1"><span class="nav-number">12.</span> <span class="nav-text">参数详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-1"><span class="nav-number">13.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">14.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="nav-number">15.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%8D%95%E9%80%9A%E9%81%93%E5%9B%BE%E5%83%8F%E7%9A%84%E5%9D%87%E5%80%BC"><span class="nav-number">15.1.</span> <span class="nav-text">计算单通道图像的均值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%A4%9A%E9%80%9A%E9%81%93%E5%9B%BE%E5%83%8F%E7%9A%84%E5%9D%87%E5%80%BC"><span class="nav-number">15.2.</span> <span class="nav-text">计算多通道图像的均值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%B8%A6%E6%8E%A9%E6%A8%A1%E7%9A%84%E5%9B%BE%E5%83%8F%E5%9D%87%E5%80%BC"><span class="nav-number">15.3.</span> <span class="nav-text">计算带掩模的图像均值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">16.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">17.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cv-sum-%E5%87%BD%E6%95%B0-%E8%AF%A6%E8%A7%A3"><span class="nav-number">18.</span> <span class="nav-text">cv::sum() 函数 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89-1"><span class="nav-number">19.</span> <span class="nav-text">函数定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3-2"><span class="nav-number">20.</span> <span class="nav-text">参数详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-2"><span class="nav-number">21.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="nav-number">22.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="nav-number">23.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%8D%95%E9%80%9A%E9%81%93%E5%9B%BE%E5%83%8F%E7%9A%84%E5%85%83%E7%B4%A0%E5%92%8C"><span class="nav-number">23.1.</span> <span class="nav-text">计算单通道图像的元素和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%A4%9A%E9%80%9A%E9%81%93%E5%9B%BE%E5%83%8F%E7%9A%84%E5%85%83%E7%B4%A0%E5%92%8C"><span class="nav-number">23.2.</span> <span class="nav-text">计算多通道图像的元素和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%8C%85%E5%90%AB%E9%80%8F%E6%98%8E%E5%BA%A6%E9%80%9A%E9%81%93%E7%9A%84%E5%9B%BE%E5%83%8F%E5%92%8C"><span class="nav-number">23.3.</span> <span class="nav-text">计算包含透明度通道的图像和</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="nav-number">24.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">25.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cv-boxPoints-%E5%87%BD%E6%95%B0-%E8%AF%A6%E8%A7%A3"><span class="nav-number">26.</span> <span class="nav-text">cv::boxPoints() 函数 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89-2"><span class="nav-number">27.</span> <span class="nav-text">函数定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3-3"><span class="nav-number">28.</span> <span class="nav-text">参数详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-3"><span class="nav-number">29.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-2"><span class="nav-number">30.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-3"><span class="nav-number">31.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%97%8B%E8%BD%AC%E7%9F%A9%E5%BD%A2%E6%8F%90%E5%8F%96%E5%9B%9B%E4%B8%AA%E9%A1%B6%E7%82%B9"><span class="nav-number">31.1.</span> <span class="nav-text">从旋转矩形提取四个顶点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A"><span class="nav-number">31.2.</span> <span class="nav-text">解释</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E7%A4%BA%E4%BE%8B"><span class="nav-number">32.</span> <span class="nav-text">返回值示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="nav-number">33.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">34.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cv-minAreaRect-%E5%87%BD%E6%95%B0-%E8%AF%A6%E8%A7%A3"><span class="nav-number">35.</span> <span class="nav-text">cv::minAreaRect() 函数 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89-3"><span class="nav-number">36.</span> <span class="nav-text">函数定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3-4"><span class="nav-number">37.</span> <span class="nav-text">参数详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-4"><span class="nav-number">38.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-3"><span class="nav-number">39.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-4"><span class="nav-number">40.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E5%A4%96%E6%8E%A5%E7%9F%A9%E5%BD%A2%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">40.1.</span> <span class="nav-text">最小外接矩形的计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A-1"><span class="nav-number">40.2.</span> <span class="nav-text">解释</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">41.</span> <span class="nav-text">返回值示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3"><span class="nav-number">42.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="nav-number">43.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cv-contourArea-%E5%87%BD%E6%95%B0-%E8%AF%A6%E8%A7%A3"><span class="nav-number">44.</span> <span class="nav-text">cv::contourArea() 函数 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89-4"><span class="nav-number">45.</span> <span class="nav-text">函数定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3-5"><span class="nav-number">46.</span> <span class="nav-text">参数详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-5"><span class="nav-number">47.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-4"><span class="nav-number">48.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-5"><span class="nav-number">49.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E8%BD%AE%E5%BB%93%E9%9D%A2%E7%A7%AF"><span class="nav-number">49.1.</span> <span class="nav-text">计算轮廓面积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%89%E5%90%91%E9%9D%A2%E7%A7%AF"><span class="nav-number">49.2.</span> <span class="nav-text">计算有向面积</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-4"><span class="nav-number">50.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="nav-number">51.</span> <span class="nav-text">典型应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cv-findContours-%E5%87%BD%E6%95%B0-%E8%AF%A6%E8%A7%A3"><span class="nav-number">52.</span> <span class="nav-text">cv::findContours() 函数 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89-5"><span class="nav-number">53.</span> <span class="nav-text">函数定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3-6"><span class="nav-number">54.</span> <span class="nav-text">参数详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-6"><span class="nav-number">55.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">56.</span> <span class="nav-text">使用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">56.1.</span> <span class="nav-text">基本用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-5"><span class="nav-number">57.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="nav-number">58.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cv-threshold-%E8%AF%A6%E8%A7%A3"><span class="nav-number">59.</span> <span class="nav-text">cv::threshold() 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89-6"><span class="nav-number">60.</span> <span class="nav-text">函数定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3-7"><span class="nav-number">61.</span> <span class="nav-text">参数详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-7"><span class="nav-number">62.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-6"><span class="nav-number">63.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BA%8C%E5%80%BC%E5%8C%96"><span class="nav-number">63.1.</span> <span class="nav-text">基本二值化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OTSU-%E9%98%88%E5%80%BC%E6%B3%95"><span class="nav-number">63.2.</span> <span class="nav-text">OTSU 阈值法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-6"><span class="nav-number">64.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8-1"><span class="nav-number">65.</span> <span class="nav-text">典型应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenCV-cv-GaussianBlur-%E8%AF%A6%E8%A7%A3"><span class="nav-number">66.</span> <span class="nav-text">OpenCV cv::GaussianBlur() 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89-7"><span class="nav-number">66.1.</span> <span class="nav-text">函数定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3-8"><span class="nav-number">66.2.</span> <span class="nav-text">参数详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-5"><span class="nav-number">66.3.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-7"><span class="nav-number">66.4.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E7%A4%BA%E4%BE%8B"><span class="nav-number">66.4.1.</span> <span class="nav-text">C++ 示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-7"><span class="nav-number">66.5.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="nav-number">66.6.</span> <span class="nav-text">实际应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenCV-cv-samples-findFile-%E8%AF%A6%E8%A7%A3"><span class="nav-number">67.</span> <span class="nav-text">OpenCV cv::samples::findFile() 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenCV-cv-merge-%E5%87%BD%E6%95%B0-%E8%AF%A6%E8%A7%A3"><span class="nav-number">68.</span> <span class="nav-text">OpenCV cv::merge() 函数 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-1"><span class="nav-number">68.1.</span> <span class="nav-text">函数原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="nav-number">68.2.</span> <span class="nav-text">参数说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD"><span class="nav-number">68.3.</span> <span class="nav-text">功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-8"><span class="nav-number">68.4.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">68.5.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenCV-cv-split-%E5%87%BD%E6%95%B0-%E8%AF%A6%E8%A7%A3"><span class="nav-number">69.</span> <span class="nav-text">OpenCV cv::split() 函数 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-2"><span class="nav-number">69.1.</span> <span class="nav-text">函数原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-1"><span class="nav-number">69.2.</span> <span class="nav-text">参数说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD-1"><span class="nav-number">69.3.</span> <span class="nav-text">功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-9"><span class="nav-number">69.4.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">69.5.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenCV-cvtColor-%E5%87%BD%E6%95%B0-%E8%AF%A6%E8%A7%A3"><span class="nav-number">70.</span> <span class="nav-text">OpenCV cvtColor() 函数 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-3"><span class="nav-number">70.1.</span> <span class="nav-text">函数原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-2"><span class="nav-number">70.2.</span> <span class="nav-text">参数说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD-2"><span class="nav-number">70.3.</span> <span class="nav-text">功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-10"><span class="nav-number">70.4.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">70.5.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenCV-convertTo-%E5%87%BD%E6%95%B0-%E8%AF%A6%E8%A7%A3"><span class="nav-number">71.</span> <span class="nav-text">OpenCV convertTo() 函数 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-4"><span class="nav-number">71.1.</span> <span class="nav-text">函数原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-3"><span class="nav-number">71.2.</span> <span class="nav-text">参数说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD-3"><span class="nav-number">71.3.</span> <span class="nav-text">功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-11"><span class="nav-number">71.4.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="nav-number">71.5.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenCV-cv-putText-%E5%87%BD%E6%95%B0-%E8%AF%A6%E8%A7%A3"><span class="nav-number">72.</span> <span class="nav-text">OpenCV cv::putText()  函数 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenCV-cv-imdecode-%E5%87%BD%E6%95%B0-%E8%AF%A6%E8%A7%A3-%E4%B8%AD%E6%96%87"><span class="nav-number">73.</span> <span class="nav-text">OpenCV cv::imdecode() 函数 详解 中文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenCV-cv-imencode-%E8%AF%A6%E8%A7%A3"><span class="nav-number">74.</span> <span class="nav-text">OpenCV cv::imencode() 详解</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
