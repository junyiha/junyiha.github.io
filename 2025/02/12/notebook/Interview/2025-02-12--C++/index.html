<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="摘要 搜集的关于C++编程语言的面试题及答案">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面试题">
<meta property="og:url" content="https://junyiha.github.io/2025/02/12/notebook/Interview/2025-02-12--C++/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="摘要 搜集的关于C++编程语言的面试题及答案">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-02-12T01:00:00.000Z">
<meta property="article:modified_time" content="2025-04-28T08:08:39.314Z">
<meta property="article:author" content="zhang junyi">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/2025/02/12/notebook/Interview/2025-02-12--C++/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>C++面试题 | junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2025/02/12/notebook/Interview/2025-02-12--C++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-12 09:00:00" itemprop="dateCreated datePublished" datetime="2025-02-12T09:00:00+08:00">2025-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Interview/" itemprop="url" rel="index"><span itemprop="name">Interview</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>搜集的关于C++编程语言的面试题及答案</li>
</ul>
<span id="more"></span>

<h2 id="为什么-当一个类打算被用作其他类的基类时，它的析构函数必须是虚的"><a href="#为什么-当一个类打算被用作其他类的基类时，它的析构函数必须是虚的" class="headerlink" title="为什么 当一个类打算被用作其他类的基类时，它的析构函数必须是虚的"></a>为什么 当一个类打算被用作其他类的基类时，它的析构函数必须是虚的</h2><p>当一个类被设计为基类时，其析构函数应该是<strong>虚函数</strong>，这样可以确保在<strong>删除派生类对象时，能够正确调用派生类和基类的析构函数</strong>，避免内存泄漏或未释放资源的问题。</p>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a><strong>原因分析</strong></h2><p>在 C++ 中，如果基类的析构函数不是虚的，那么当通过基类指针删除派生类对象时，<strong>只会调用基类的析构函数，而不会调用派生类的析构函数</strong>，这可能导致资源未正确释放，造成内存泄漏或其他问题。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h2><h3 id="非虚析构的错误示范"><a href="#非虚析构的错误示范" class="headerlink" title="非虚析构的错误示范"></a><strong>非虚析构的错误示范</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base Destructor&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 非虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Derived Destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> obj; <span class="comment">// 只会调用 Base 的析构函数，不会调用 Derived 的析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base Destructor</span><br></pre></td></tr></table></figure>
<p><strong>问题：</strong></p>
<ul>
<li>由于 <code>Base</code> 的析构函数不是虚的，<code>delete obj</code> 只会调用 <code>Base</code> 的析构函数，而不会调用 <code>Derived</code> 的析构函数。</li>
<li><code>Derived</code> 可能分配了一些资源（如动态分配的内存、文件句柄等），但它的析构函数没有执行，导致资源泄漏。</li>
</ul>
<hr>
<h3 id="正确做法：使用虚析构"><a href="#正确做法：使用虚析构" class="headerlink" title="正确做法：使用虚析构"></a><strong>正确做法：使用虚析构</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base Destructor&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 设为虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Derived Destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> obj; <span class="comment">// 先调用 Derived 的析构函数，再调用 Base 的析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>输出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived Destructor</span><br><span class="line">Base Destructor</span><br></pre></td></tr></table></figure>
<p><strong>正确性：</strong></p>
<ul>
<li><code>delete obj</code> 时，先调用 <code>Derived</code> 的析构函数，再调用 <code>Base</code> 的析构函数，确保资源正确释放。</li>
<li>这样可以正确执行派生类的清理逻辑，避免内存泄漏。</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><h3 id="为什么基类的析构函数必须是虚的？"><a href="#为什么基类的析构函数必须是虚的？" class="headerlink" title="为什么基类的析构函数必须是虚的？"></a><strong>为什么基类的析构函数必须是虚的？</strong></h3><ol>
<li><p><strong>确保正确释放资源</strong>  </p>
<ul>
<li>让 <code>delete</code> 通过基类指针调用时，能够正确执行派生类的析构函数，防止内存泄漏或资源泄露。</li>
</ul>
</li>
<li><p><strong>遵循多态行为</strong>  </p>
<ul>
<li>C++ 采用<strong>动态绑定</strong>的方式来处理虚函数，确保在运行时可以正确调用派生类的析构函数。</li>
</ul>
</li>
<li><p><strong>防止未定义行为</strong>  </p>
<ul>
<li>如果基类的析构函数不是虚的，删除派生类对象时会导致<strong>未定义行为</strong>，尤其当派生类包含动态分配的资源时。</li>
</ul>
</li>
</ol>
<h3 id="什么时候不需要虚析构？"><a href="#什么时候不需要虚析构？" class="headerlink" title="什么时候不需要虚析构？"></a><strong>什么时候不需要虚析构？</strong></h3><p>如果一个类<strong>不会被继承</strong>，或者<strong>不会通过基类指针或引用删除派生类对象</strong>，那么它的析构函数可以不设为虚的，以减少开销。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonVirtualDestructor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">NonVirtualDestructor</span>() &#123; cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>但是，如果类是基类，就应该让析构函数是虚的！</strong></p>
<h2 id="左值引用与右值引用有什么区别，左值引用和右值引用的目的是什么"><a href="#左值引用与右值引用有什么区别，左值引用和右值引用的目的是什么" class="headerlink" title="左值引用与右值引用有什么区别，左值引用和右值引用的目的是什么"></a>左值引用与右值引用有什么区别，左值引用和右值引用的目的是什么</h2><ul>
<li><p>要弄明白右值引用到底是怎么一回事，必须要对左值和右值做一个明确的理解。</p>
<ul>
<li>左值 (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说， 左值是表达式（不一定是赋值表达式）后依然存在的持久对象。</li>
<li>右值 (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。</li>
</ul>
</li>
<li><p>而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。</p>
<ul>
<li>纯右值 (prvalue, pure rvalue)，纯粹的右值，要么是纯粹的字面量，例如 10, true； 要么是求值结果相当于字面量或匿名临时对象，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值</li>
</ul>
</li>
<li><p>需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。</p>
</li>
</ul>
<h2 id="C-右值引用-详解"><a href="#C-右值引用-详解" class="headerlink" title="C++ 右值引用 详解"></a>C++ 右值引用 详解</h2><p>C++11引入了右值引用（Rvalue References）的概念，它是C++中一种新的引用类型，用于支持移动语义（Move Semantics）和完美转发（Perfect Forwarding）。右值引用与传统的左值引用（Lvalue References）有所不同，主要用于优化移动语义和避免临时对象的不必要拷贝。下面是关于右值引用的详细解释：</p>
<h3 id="1-右值引用的语法："><a href="#1-右值引用的语法：" class="headerlink" title="1. 右值引用的语法："></a>1. 右值引用的语法：</h3><p>右值引用的语法是在类型名后添加 &amp;&amp;，表示对右值的引用。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rvref = <span class="number">42</span>;  <span class="comment">// rvref 是对右值 42 的引用</span></span><br></pre></td></tr></table></figure>

<h3 id="2-移动语义（Move-Semantics）："><a href="#2-移动语义（Move-Semantics）：" class="headerlink" title="2. 移动语义（Move Semantics）："></a>2. 移动语义（Move Semantics）：</h3><p>移动语义是指将资源从一个对象转移到另一个对象，而不是进行深拷贝。右值引用使得我们可以区分左值和右值，并且能够在移动语义下实现高效的资源转移。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2 = std::<span class="built_in">move</span>(v1);  <span class="comment">// 移动 v1 到 v2，v1 变为空</span></span><br></pre></td></tr></table></figure>

<h3 id="3-完美转发（Perfect-Forwarding）："><a href="#3-完美转发（Perfect-Forwarding）：" class="headerlink" title="3. 完美转发（Perfect Forwarding）："></a>3. 完美转发（Perfect Forwarding）：</h3><p>完美转发是指在函数模板中保留函数调用时的精确类型信息。右值引用在完美转发中发挥着重要作用，允许在不丢失值类别（value category）信息的情况下将参数传递给其他函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forwarder</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">target</span>(std::forward&lt;T&gt;(arg));  <span class="comment">// 保留 arg 的值类别信息进行转发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-std-move-函数："><a href="#4-std-move-函数：" class="headerlink" title="4. std::move() 函数："></a>4. std::move() 函数：</h3><p>std::move() 是一个用于将左值转换为右值引用的函数，它并不移动对象，而只是改变对象的类型，使其可以绑定到移动构造函数或移动赋值运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2 = std::<span class="built_in">move</span>(v);  <span class="comment">// 将 v 转为右值引用，调用移动构造函数</span></span><br></pre></td></tr></table></figure>

<h3 id="5-注意事项："><a href="#5-注意事项：" class="headerlink" title="5. 注意事项："></a>5. 注意事项：</h3><ul>
<li>在使用右值引用时要谨慎，确保不会访问到已经被移动的对象。</li>
<li>尽量使用 std::move() 来明确表达对象的移动语义，以提高代码的可读性和性能。</li>
</ul>
<p>右值引用的引入使得C++具备了更加灵活和高效的资源管理能力，可以在不牺牲性能的情况下实现资源的有效转移和管理，是C++11引入的一个重要特性。</p>
<h2 id="C-协程-详解"><a href="#C-协程-详解" class="headerlink" title="C++ 协程 详解"></a>C++ 协程 详解</h2><p>C++20引入了协程（Coroutines）的概念，它是一种轻量级的并发编程模型，可以简化异步编程和状态机的实现。协程允许在函数内部通过暂停和恢复的方式来控制执行流程，从而实现异步操作、生成器和状态机等功能。下面是关于C++协程的详细解释：</p>
<h3 id="1-协程的基本概念："><a href="#1-协程的基本概念：" class="headerlink" title="1. 协程的基本概念："></a>1. 协程的基本概念：</h3><ul>
<li><strong>生成器（Generator）</strong>：协程可以用于实现生成器，即能够生成一系列值的函数，每次调用都可以产生一个新值，并在下次调用时继续执行。</li>
<li><strong>异步操作（Asynchronous Operations）</strong>：协程可以用于实现异步操作，即函数可以在执行过程中暂停等待异步操作的结果，并在异步操作完成后恢复执行。</li>
<li><strong>状态机（State Machines）</strong>：协程可以用于实现状态机，即函数可以在不同的状态之间切换，并在每个状态下执行不同的逻辑。</li>
</ul>
<h3 id="2-C-20-中的协程支持："><a href="#2-C-20-中的协程支持：" class="headerlink" title="2. C++20 中的协程支持："></a>2. C++20 中的协程支持：</h3><p>C++20 引入了 <code>co_await</code>、<code>co_yield</code>、<code>co_return</code> 等关键字，用于定义和控制协程。协程的定义通过 <code>co_return</code> 关键字返回一个协程类型（如 <code>std::coroutine_handle</code>），并使用 <code>co_await</code> 和 <code>co_yield</code> 控制执行流程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyCoroutine</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_never&#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">final_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> std::suspend_always&#123;&#125;; &#125;</span><br><span class="line">        <span class="function">MyCoroutine <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">return_value</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; value = v; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">await_ready</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">await_suspend</span><span class="params">(std::coroutine_handle&lt;&gt; h)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">await_resume</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyCoroutine <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">co_return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyCoroutine c = <span class="built_in">foo</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; c.<span class="built_in">await_resume</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-使用协程的注意事项："><a href="#3-使用协程的注意事项：" class="headerlink" title="3. 使用协程的注意事项："></a>3. 使用协程的注意事项：</h3><ul>
<li>协程是一种特殊的函数类型，定义和使用方式与普通函数略有不同，需要熟悉相关语法和约定。</li>
<li>协程的执行流程是可以暂停和恢复的，需要谨慎处理协程中的状态和资源管理问题，避免出现悬空指针和资源泄漏等问题。</li>
<li>协程可以有效地简化异步编程和状态机的实现，但也需要考虑其对性能和可维护性的影响。</li>
</ul>
<p>总的来说，C++协程是一种强大的并发编程工具，可以简化异步编程和状态机的实现，提高代码的可读性和可维护性。通过合理地使用协程，可以实现更加简洁和高效的异步代码，提高程序的性能和响应性。</p>
<h2 id="进程-线程-协程-之间的区别-详解"><a href="#进程-线程-协程-之间的区别-详解" class="headerlink" title="进程 线程 协程 之间的区别 详解"></a>进程 线程 协程 之间的区别 详解</h2><p>进程（Process）、线程（Thread）和协程（Coroutine）是计算机中用于实现并发的三种重要机制，它们在管理和利用计算机资源方面有着不同的特点和应用场景。下面是对进程、线程和协程之间的区别进行详细解释：</p>
<h3 id="1-进程（Process）："><a href="#1-进程（Process）：" class="headerlink" title="1. 进程（Process）："></a>1. 进程（Process）：</h3><ul>
<li><strong>定义</strong>：进程是计算机中执行中的程序的实例，它拥有独立的内存空间、代码和数据，并且由操作系统进行管理。</li>
<li><strong>特点</strong>：<ul>
<li>独立性：每个进程拥有独立的内存空间，不同进程之间无法直接共享内存数据。</li>
<li>安全性：进程之间的内存空间是隔离的，可以保证数据的安全性和稳定性。</li>
<li>并发性：多个进程可以并发执行，由操作系统进行调度和管理，互相之间不会影响。</li>
</ul>
</li>
<li><strong>应用场景</strong>：进程常用于实现多任务、多用户和多进程通信等需求，例如操作系统中的进程管理和应用程序的并发执行。</li>
</ul>
<h3 id="2-线程（Thread）："><a href="#2-线程（Thread）：" class="headerlink" title="2. 线程（Thread）："></a>2. 线程（Thread）：</h3><ul>
<li><strong>定义</strong>：线程是操作系统中最小的执行单元，它是进程的一个执行流程，拥有独立的执行栈和程序计数器，但共享相同的进程地址空间和资源。</li>
<li><strong>特点</strong>：<ul>
<li>共享性：线程之间共享相同的内存空间和资源，可以方便地进行数据共享和通信。</li>
<li>轻量级：相比于进程，线程的创建和切换成本较低，可以更高效地实现并发操作。</li>
<li>并发性：多个线程可以并发执行，共享进程的资源，但需要注意线程安全性问题。</li>
</ul>
</li>
<li><strong>应用场景</strong>：线程常用于实现多线程编程、并行计算和异步任务处理等需求，例如多线程服务器、图形界面程序和网络通信等。</li>
</ul>
<h3 id="3-协程（Coroutine）："><a href="#3-协程（Coroutine）：" class="headerlink" title="3. 协程（Coroutine）："></a>3. 协程（Coroutine）：</h3><ul>
<li><strong>定义</strong>：协程是一种用户态的轻量级线程，它可以在函数内部实现暂停和恢复执行流程，不需要操作系统的调度和管理。</li>
<li><strong>特点</strong>：<ul>
<li>用户态实现：协程是在用户态下实现的，不依赖于操作系统的线程和进程调度，具有较低的开销和更高的灵活性。</li>
<li>非抢占式：协程不会被强制中断，而是由程序员显式地控制协程的暂停和恢复，可以更灵活地管理执行流程。</li>
<li>轻量级：相比于线程和进程，协程的创建和切换成本更低，适用于大量的并发任务和高频的状态切换。</li>
</ul>
</li>
<li><strong>应用场景</strong>：协程常用于实现异步编程、状态机和生成器等需求，例如事件驱动编程、协作式任务调度和高效的生成器实现。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>进程、线程和协程是实现并发编程的三种主要机制，各自具有不同的特点和应用场景。</li>
<li>进程提供了独立的执行环境和安全的数据隔离，适用于多任务和多用户的场景。</li>
<li>线程提供了共享的执行环境和资源，可以更高效地实现并发操作和数据共享。</li>
<li>协程提供了用户态的轻量级并发机制，可以实现高效的异步编程和状态机，适用于需要大量的并发任务和高频的状态切换的场景。</li>
</ul>
<h2 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h2><ul>
<li>术语–<strong>多态</strong>，指的是有多种形式，因此函数多态允许函数可以有多种形式。</li>
<li>在了解多态之前，需要了解虚函数<ul>
<li>虚函数的虚字的意义，就是在所谓的“动态联编”或者是“推迟联编”上，一个类的函数并不是在编译时被确定的，而是在运行时被确定的，<strong>由于编写代码的时候并不确定被调用的是基类的函数还是哪一个派生类的函数，所以被称为“虚”函数</strong></li>
<li>虚函数是指<strong>一个类中希望重载的成员函数</strong>，当用一个基类指针或引用指向一个继承类对象的时候，调用一个虚函数，实际调用的是继承类的版本。</li>
<li>而函数重载，是允许参数不同，但函数名相同。函数重载的关键是函数的参数列表–也称为<strong>函数特征标</strong>(<code>function signature</code>)。</li>
<li>如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。</li>
<li><strong>C++允许定义名称相同的函数，条件是它们的特征标不同</strong>。如果参数数目和&#x2F;或参数类型不同，则特征标也不同。</li>
</ul>
</li>
<li>同一代码可以产生不同效果的特点，称为“多态”</li>
</ul>
<h2 id="虚函数和纯虚函数"><a href="#虚函数和纯虚函数" class="headerlink" title="虚函数和纯虚函数"></a>虚函数和纯虚函数</h2><ul>
<li><p>虚函数的虚字的意义，就是在所谓的“动态联编”或者是“推迟联编”上，一个类的函数并不是在编译时被确定的，而是在运行时被确定的，<strong>由于编写代码的时候并不确定被调用的是基类的函数还是哪一个派生类的函数，所以被称为“虚”函数</strong></p>
</li>
<li><p>虚函数是C++中用于实现多态(<code>polymorphism</code>)的机制，核心理念就是通过基类访问派生类定义的函数。</p>
</li>
<li><p>注意：在普通的虚函数后面加上<code>=0</code>，这样就声明了一个纯虚函数(<code>pure virtual function</code>)</p>
</li>
<li><p>纯虚函数用来规范派生类的行为，实际上就是所谓的接口，他告诉使用者，我们<strong>派生类都会有这个函数</strong></p>
</li>
<li><p>在什么情况下使用纯虚函数？</p>
<ul>
<li>当想在基类中<strong>抽象出一个方法，且该基类只能被继承，而不能被实例化时</strong></li>
<li>这个方法<strong>必须在派生类中被实现</strong></li>
</ul>
</li>
<li><p>如果满足以上两点，可以考虑将该方法被声明为纯虚函数</p>
</li>
<li><p>当一个类打算被用作其他类的基类时，<strong>它的析构函数必须是虚的</strong></p>
</li>
</ul>
<h2 id="虚函数和纯虚函数的区别-详解"><a href="#虚函数和纯虚函数的区别-详解" class="headerlink" title="虚函数和纯虚函数的区别 详解"></a>虚函数和纯虚函数的区别 详解</h2><p>虚函数（Virtual Function）和纯虚函数（Pure Virtual Function）都是用于实现多态性的重要机制，但它们有一些关键的区别。</p>
<h3 id="虚函数（Virtual-Function）："><a href="#虚函数（Virtual-Function）：" class="headerlink" title="虚函数（Virtual Function）："></a>虚函数（Virtual Function）：</h3><ol>
<li><p><strong>定义</strong>：虚函数是在基类中使用 <code>virtual</code> 关键字声明的成员函数，它可以被派生类重写（覆盖）。</p>
</li>
<li><p><strong>实现</strong>：虚函数可以在基类中提供默认的实现，但派生类可以选择是否覆盖它。如果派生类覆盖了虚函数，则在运行时根据对象的实际类型来调用对应的函数。</p>
</li>
<li><p><strong>语法</strong>：虚函数可以有实现，也可以没有实现。如果在基类中定义了虚函数的实现，派生类可以选择是否覆盖该函数；如果在基类中定义了纯虚函数，派生类必须实现该函数。</p>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Display from Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Display from Derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="纯虚函数（Pure-Virtual-Function）："><a href="#纯虚函数（Pure-Virtual-Function）：" class="headerlink" title="纯虚函数（Pure Virtual Function）："></a>纯虚函数（Pure Virtual Function）：</h3><ol>
<li><p><strong>定义</strong>：纯虚函数是在基类中声明但没有提供实现的虚函数，它在基类中不具有实际的功能，而是为了让派生类必须提供实现。</p>
</li>
<li><p><strong>实现</strong>：派生类必须实现基类中定义的纯虚函数，否则派生类也会成为抽象类。</p>
</li>
<li><p><strong>语法</strong>：纯虚函数用 <code>virtual</code> 关键字声明，并在后面添加 <code>= 0</code> 来表示该函数是纯虚函数。</p>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Display from Derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="区别总结："><a href="#区别总结：" class="headerlink" title="区别总结："></a>区别总结：</h3><ol>
<li>虚函数可以有实现，派生类可以选择是否覆盖；纯虚函数没有实现，派生类必须提供实现。</li>
<li>虚函数用 <code>virtual</code> 关键字声明；纯虚函数用 <code>virtual</code> 关键字声明并在后面添加 <code>= 0</code>。</li>
<li>基类中含有纯虚函数的类被称为抽象类，不能创建实例对象；而含有虚函数的类可以创建实例对象。</li>
<li>使用虚函数的目的是实现运行时多态，而使用纯虚函数的目的是定义接口，强制派生类实现特定的行为。</li>
</ol>
<h2 id="C-虚函数和纯虚函数的实际应用"><a href="#C-虚函数和纯虚函数的实际应用" class="headerlink" title="C++ 虚函数和纯虚函数的实际应用"></a>C++ 虚函数和纯虚函数的实际应用</h2><p>虚函数和纯虚函数在 C++ 中有着广泛的实际应用，它们主要用于实现多态性和定义接口，以下是它们的一些常见实际应用：</p>
<h3 id="虚函数的实际应用："><a href="#虚函数的实际应用：" class="headerlink" title="虚函数的实际应用："></a>虚函数的实际应用：</h3><ol>
<li><p><strong>实现运行时多态性</strong>：虚函数允许在基类中定义函数的行为，而派生类可以根据自己的需要覆盖（重写）这些函数，从而实现基于对象的实际类型的动态调用。</p>
</li>
<li><p><strong>实现基类的默认行为</strong>：基类中的虚函数可以提供默认的行为，派生类可以选择是否覆盖它们。这样可以在基类中提供一些通用的实现，而在派生类中根据需要进行特化。</p>
</li>
<li><p><strong>方便的扩展</strong>：通过在基类中添加虚函数，可以方便地在派生类中添加新的行为，而不需要修改基类的定义。</p>
</li>
<li><p><strong>实现抽象类</strong>：虚函数可以使基类成为抽象类，即含有至少一个纯虚函数的类，抽象类不能创建对象，只能用作接口的定义。</p>
</li>
</ol>
<h3 id="纯虚函数的实际应用："><a href="#纯虚函数的实际应用：" class="headerlink" title="纯虚函数的实际应用："></a>纯虚函数的实际应用：</h3><ol>
<li><p><strong>定义接口</strong>：纯虚函数用于定义接口，强制派生类实现特定的行为。基类中的纯虚函数提供了一种规范，告诉派生类必须提供的函数接口。</p>
</li>
<li><p><strong>实现多继承的接口</strong>：纯虚函数可以用于实现多继承的接口，一个类可以继承多个含有纯虚函数的抽象类，并提供它们的具体实现。</p>
</li>
<li><p><strong>防止实例化抽象类</strong>：含有纯虚函数的类被称为抽象类，抽象类不能创建实例对象，但可以被用作基类，派生类必须实现所有纯虚函数才能被实例化。</p>
</li>
<li><p><strong>提供默认行为</strong>：纯虚函数可以提供基类中的默认行为，派生类可以选择是否覆盖它们，从而实现基类的通用行为和派生类的特定行为。</p>
</li>
</ol>
<p>综上所述，虚函数和纯虚函数在 C++ 中有着重要的应用，它们为面向对象编程提供了灵活性和可扩展性，能够更好地组织和设计代码结构，提高代码的可维护性和可重用性。</p>
<h2 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h2><ul>
<li><p>引用变量</p>
<ul>
<li>引用是已定义的变量的别名（另一个名称）</li>
<li>引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的</li>
<li><code>int rats; int &amp; rodents = rats;  // make rodents an alias for rate</code></li>
<li>其中，<code>&amp;</code>不是地址运算符，而是类型标识符的一部分。就像声明中的<code>char*</code>指的是指向<code>char</code>的指针一样，<code>int&amp;</code>指的是指向int的引用。</li>
</ul>
<ul>
<li>引用经常被用作函数参数，使得函数中的变量名称为调用程序中的变量的别名，这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量</li>
</ul>
</li>
<li><p>指针</p>
<ul>
<li>指针，是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元</li>
</ul>
</li>
<li><p>区别：</p>
<ul>
<li>指针是存储变量地址的变量；引用是变量的别名。</li>
<li>指针变量定义时不必初始化；引用定义时必须初始化，不然会报错</li>
<li>指针变量定义时可以初始化为NULL；引用不能初始化为NULL，不然报错。</li>
<li>const修饰指针变量，const放在之前，指针变量所指向变量的值不可改变，指针值可以改变；const放在之后，指针变量所指向变量的值可以改变，指针值不可以改变；const修饰引用，const放在&amp;之前，不能修改引用所表示的变量的值；const放在&amp;之后，const的作用被忽略，可以修改引用所表示的变量的值。</li>
<li>非常指针在指针赋值后可以改变指针值；引用在初始化后不能再作为别的变量的别名</li>
<li>sizeof运算符作用于指针变量得到指针变量自身大小；作用于引用，得到引用所指向的变量的大小。</li>
<li>指针可以有多级，引用只有一级。</li>
<li>指针的自增、自减表示指向下一个同类型变量的地址，一般用于指向数组的指针；引用的自增、自减表示指向变量值的增、减。</li>
</ul>
</li>
</ul>
<h2 id="C-类型转化"><a href="#C-类型转化" class="headerlink" title="C++类型转化"></a>C++类型转化</h2><ul>
<li><p>在C++中，类型转换可以通过以下方式进行：</p>
<ul>
<li>隐式类型转换(Implicit Conversion)：在不需要显示指定的情况下，编译器会自动进行类型转换。例如，将一个整数复制给浮点类型变量时，编译器会自动从整型到浮点型的隐式转换</li>
<li>显式类型转换(Explicit Conversion)：有时需要手动将一个数据类型转换为另一个数据类型。C++提供了几种显示类型转换操作符：<ul>
<li>static_cast： 用于执行静态类型检查的转换，在合理范围内允许不同但相关的数据类型之间的转换</li>
<li>dynamic_cast: 用于执行安全向下造型(downcasting)，主要用于基类和派生类之间的转换</li>
<li>const_cast: 用于去除常量属性或者添加常量属性</li>
<li>reinterpret_cast: 一种底层强制类型转换，通常用于将指针或引用重新解释为其他指针或引用。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意，在使用显式类型转换时，请确保转换是安全且符合语义逻辑。错误的使用可能导致运行时错误或未定义行为</p>
</li>
</ul>
<h2 id="C-中的堆和栈的区别"><a href="#C-中的堆和栈的区别" class="headerlink" title="C++中的堆和栈的区别"></a>C++中的堆和栈的区别</h2><ul>
<li>在C++中，堆(heap)和栈(stack)是两种不同的内存分配方式，它们有以下区别<ul>
<li>分配方式：栈上的变量是通过系统自动进行分配和释放的，而堆上的内存则需要手动进行分配和释放。</li>
<li>内存管理：栈内存由编译器自动管理，它在会变量超出作用域时自动释放。而堆内存需要手动分配和释放，在不再使用时必须显式的调用delete或者delete[]进行回收</li>
<li>大小限制：栈通常比较小，并且大小固定，而堆没有固定大小限制，可以动态地分配所需要大小的内存空间</li>
<li>访问速度：由于栈上的变量是连续分配的，因此访问速度相对较快。而堆上的内存分散在各个地址上，访问速度相对较慢</li>
<li>生命周期：栈上的变量生命周期受到作用域控制，当离开作用域时会自动销毁。而堆上的对象在手动释放之前一直存在。</li>
</ul>
</li>
</ul>
<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ul>
<li>指针和引用是C++中的两个重要概念，它们可以用于间接访问对象或变量。下面是他们的区别：<ul>
<li>定义和使用方式：指针使用 * 来声明和解引用，而引用使用 &amp; 来声明，不需要解引用</li>
<li>空值：指针可以为空(nullptr)，表示没有指向任何对象或变量，而引用必须始终引用有效的对象</li>
<li>可变性：指针本身可以重新赋值为另一个地址，即改变所指向的对象或变量；而引用一旦初始化后就不能再改变所引用的对象</li>
<li>对象关系：指针可以指向多个不同类型的对象，并且可以通过运算符修改所指向对象的指；而引用始终与特定类型的对象相关联，并且无法更改为引用其他类型的对象</li>
<li>空间占用：通常情况下，指针需要占据内存空间来存储地址信息；而引用本质上只是原对象的一个别名，并不需要额外的空间。</li>
</ul>
</li>
</ul>
<h2 id="关键字static的使用"><a href="#关键字static的使用" class="headerlink" title="关键字static的使用"></a>关键字static的使用</h2><ul>
<li>关键字 static 在C++中有多种用法，以下是其中几种常见的用法</li>
</ul>
<ol>
<li><p>静态变量(Static Variables) : 在函数内部声明的静态变量具有静态生存期，即他们在整个程序执行期间都存在，并且只会初始化一次</p>
</li>
<li><p>静态成员变量(Static Member Variables) : 静态成员变量属于类本身而不是类的实例，并且在所有类对象之间共享，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sharedVariable; <span class="comment">// 静态成员变量声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::sharedVariable = <span class="number">10</span>; <span class="comment">// 静态成员变量定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; MyClass::sharedVariable &lt;&lt; endl; <span class="comment">// 访问静态成员变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态成员函数(Static Member Functions) : 静态成员函数属于类本身而不是类的实例，可以直接通过类名来调用，而不需要创建对象实例。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">myStaticFunction</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is a static member function.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass::<span class="built_in">myStaticFunction</span>(); <span class="comment">// 调用静态成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>除了以上几种用法，’static’ 还可以用于限制变量或函数的作用于为当前文件(称为内部链接)以及在类模板中声明静态数据成员等。具体使用取决于上下文和需求</li>
</ul>
<h2 id="C-中map，如果key不存在，使用-形式遍历能成功吗"><a href="#C-中map，如果key不存在，使用-形式遍历能成功吗" class="headerlink" title="C++中map，如果key不存在，使用[]形式遍历能成功吗"></a>C++中map，如果key不存在，使用[]形式遍历能成功吗</h2><ul>
<li>在C++中，使用[]操作符形式访问一个map时，如果key不存在，会自动创建该key，并将其与一个默认值关联起来。</li>
<li>因此，遍历一个map并使用[]形式访问时，如果key不存在，会在该位置插入新的键值对。请注意，在使用[]操作符访问时要确保map是可写的（非const）。</li>
</ul>
<h2 id="动态多态的实现原理"><a href="#动态多态的实现原理" class="headerlink" title="动态多态的实现原理"></a>动态多态的实现原理</h2><ul>
<li><p>动态多态是面向对象编程中的一个重要概念，它通过基类指针或引用调用派生类对象的虚函数实现。其实现原理主要涉及虚函数表(vtable)和虚函数指针(vptr)</p>
</li>
<li><p>在C++中，当一个类声明了虚函数时，编译器会为该类生成一个隐藏的指向虚函数表的指针–虚函数指针(vptr)。该指针位于每个对象的内存布局开头或者继承体系的最顶层基类对象中。而对应每个带有虚函数的类编译器还会创建一个虚函数表，其中存储着该类所有虚函数的地址。</p>
</li>
<li><p>当使用基类指针或引用调用某个派生类对象的虚函数时，首先通过基类指针&#x2F;引用找到对应对象中存储的vptr，然后根据vptr找到对应的虚函数表，在虚函数表中查找需要调用的虚函数，并执行相应代码</p>
</li>
<li><p>这种机制使得在运行时能够动态地选择适当的派生类版本进行调用。通过动态多态可以实现面向对象编程中的封装，继承和多态等特性，提高代码灵活性和可扩展性。</p>
</li>
</ul>
<h2 id="虚函数表是属于类的还是类对象的"><a href="#虚函数表是属于类的还是类对象的" class="headerlink" title="虚函数表是属于类的还是类对象的"></a>虚函数表是属于类的还是类对象的</h2><ul>
<li><p>虚函数表(vtable)是属于类的，而不是类对象的。每个带有虚函数的类都会在编译过程中生成一个对应的虚函数表。这个表存储了该类所有虚函数的地址，并且在编译时确定。</p>
</li>
<li><p>每个类对象都包含一个指向其所属类的虚函数表的指针–虚函数指针(vptr)，他是隐藏在对象内存布局开头或继承体系最顶层基类对象中的成员。通过这个指针，可以在运行时动态地找到并调用正确的虚函数。</p>
</li>
<li><p>因此，所有同一类类型的对象共享同一个虚函数表，而不是每个对象都拥有自己独立的虚函数表。这种设计节省了内存空间，并且保证了同一类型对象调用相同虚函数时能够得到正确结果。</p>
</li>
</ul>
<h2 id="虚函数表里面有什么"><a href="#虚函数表里面有什么" class="headerlink" title="虚函数表里面有什么"></a>虚函数表里面有什么</h2><p>虚函数表（Virtual Function Table，简称 vtable）是 C++ 中实现多态性的关键机制之一。每个含有虚函数的类都会在其对象中维护一个指向虚函数表的指针（通常称为虚函数指针），这个表存储了该类的虚函数的地址。</p>
<p>虚函数表中主要包含以下内容：</p>
<ol>
<li><p><strong>虚函数的地址</strong>：虚函数表中存储了类的每个虚函数的地址，这些地址指向了对应的虚函数的实际实现。在派生类中覆盖（重写）基类的虚函数时，虚函数表中存储的地址会被更新为派生类的虚函数地址。</p>
</li>
<li><p><strong>偏移量（可选）</strong>：在包含多重继承或虚拟继承的情况下，虚函数表可能还包含了用于解析虚函数调用的偏移量。这些偏移量用于确定虚函数在继承层次结构中的具体位置。</p>
</li>
<li><p><strong>其他元数据（可选）</strong>：虚函数表可能还包含一些其他元数据，例如用于运行时类型信息（RTTI）的指针等。</p>
</li>
</ol>
<p>总的来说，虚函数表存储了类的虚函数的地址和相关的元数据，它允许在运行时根据对象的实际类型来动态调用对应的虚函数，实现了运行时多态性。</p>
<h2 id="虚函数表是怎么使用的"><a href="#虚函数表是怎么使用的" class="headerlink" title="虚函数表是怎么使用的"></a>虚函数表是怎么使用的</h2><p>虚函数表（Virtual Function Table，简称 vtable）是 C++ 中实现多态性的关键机制之一。它是用于在运行时确定对象的动态类型并调用正确的虚函数的。下面是虚函数表的基本使用方法：</p>
<ol>
<li><strong>定义虚函数：</strong> 在基类中声明虚函数，即在函数声明前加上关键字 <code>virtual</code>。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基类虚函数的默认实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>派生类重写虚函数：</strong> 派生类可以重写基类的虚函数，以实现特定的行为。在派生类中重写虚函数时，函数的签名（返回类型、函数名和参数列表）必须与基类中的虚函数完全一致。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 派生类中对虚函数的重写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>编译器创建虚函数表：</strong> 当类中包含虚函数时，编译器会在编译阶段为该类创建虚函数表。虚函数表是一个指针数组，存储了虚函数的地址。</p>
</li>
<li><p><strong>对象存储指向虚函数表的指针：</strong> 对象中包含一个指向虚函数表的指针（通常是在对象的开头或结尾）。这个指针被称为虚函数指针（vptr）。编译器会在对象的内存布局中插入这个指针，并在构造函数中进行初始化。</p>
</li>
<li><p><strong>运行时动态绑定：</strong> 当通过基类指针或引用调用虚函数时，实际调用的是指向对象的虚函数表中相应函数的指针。这个过程被称为动态绑定或运行时多态。编译器在运行时根据对象的动态类型找到正确的虚函数表，并调用正确的函数。</p>
</li>
</ol>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">foo</span>(); <span class="comment">// 调用 Derived 类中的 foo() 函数</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，即使 <code>ptr</code> 的静态类型是 <code>Base*</code>，但由于它指向的是 <code>Derived</code> 类的对象，因此在运行时调用的是 <code>Derived</code> 类中的 <code>foo()</code> 函数。</p>
<p>这就是虚函数表的基本使用方法和工作原理。通过虚函数表，C++ 实现了运行时多态性，让程序能够根据对象的动态类型调用正确的虚函数。</p>
<h2 id="虚函数表是在编译的哪个阶段生成的"><a href="#虚函数表是在编译的哪个阶段生成的" class="headerlink" title="虚函数表是在编译的哪个阶段生成的"></a>虚函数表是在编译的哪个阶段生成的</h2><p>虚函数表（Virtual Function Table，简称 vtable）是在编译阶段生成的。编译器在编译类的源代码时，会扫描类中的虚函数，并为每个包含虚函数的类生成一个对应的虚函数表。</p>
<p>具体来说，虚函数表是在编译器为每个类生成的元数据中创建的。这些元数据包含了类的布局信息、虚函数的偏移量以及指向虚函数表的指针。编译器会在编译阶段根据这些信息为每个类生成虚函数表，并将其存储在程序的可执行文件中。</p>
<p>在运行时，每个对象的内存布局中都包含一个指向相应类的虚函数表的指针。这个指针（通常称为虚函数指针或 vptr）在对象构造时被初始化，指向类的虚函数表。这样，在运行时通过这个指针就能够动态地调用正确的虚函数。</p>
<p>总之，虚函数表是在编译阶段由编译器根据类的元数据生成的，它包含了类的虚函数的地址，用于在运行时实现多态性。</p>
<h2 id="虚函数表在文件中的位置"><a href="#虚函数表在文件中的位置" class="headerlink" title="虚函数表在文件中的位置"></a>虚函数表在文件中的位置</h2><p>虚函数表（Virtual Function Table，简称 vtable）通常是存储在程序的可执行文件中的数据段（例如 <code>.data</code> 段）中的。具体来说，每个包含虚函数的类都会在编译时生成一个对应的虚函数表，然后将这些虚函数表存储在可执行文件的数据段中。</p>
<p>在程序加载到内存时，操作系统会将数据段中的虚函数表加载到内存中的相应位置。每个对象的内存布局中都包含一个指向相应类的虚函数表的指针（通常称为虚函数指针或 vptr），该指针指向加载到内存中的虚函数表。</p>
<p>虚函数表的确切位置取决于编译器、操作系统和目标平台等因素。通常情况下，虚函数表会作为静态数据存储在程序的数据段中，并且在程序加载时被映射到内存中的合适位置。</p>
<h2 id="虚基类-详解"><a href="#虚基类-详解" class="headerlink" title="虚基类 详解"></a>虚基类 详解</h2><p>虚基类（Virtual Base Class）是C++中用于处理菱形继承（Diamond Inheritance）问题的一种技术。在菱形继承中，派生类同时继承自多个共同的基类，而这些基类又有一个共同的基类。这样会导致派生类中含有多个共同基类的子对象，而造成资源浪费和混乱。虚基类的引入就是为了解决这个问题。</p>
<p>下面是虚基类的一些详解：</p>
<ol>
<li><p><strong>菱形继承问题：</strong> 考虑如下的继承关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line"> / \</span><br><span class="line">B   C</span><br><span class="line"> \ /</span><br><span class="line">  D</span><br></pre></td></tr></table></figure>
<p>在这个继承结构中，如果 B 和 C 类都继承自 A 类，而 D 类同时继承自 B 和 C 类，则在 D 类中会包含两份 A 类的成员，导致资源的浪费和访问的混乱。</p>
</li>
<li><p><strong>解决方案：</strong> 使用虚基类可以解决菱形继承问题。当一个基类被声明为虚基类时，它的派生类中不会包含对这个虚基类的多个实例，而是共享同一个实例。</p>
</li>
<li><p><strong>语法：</strong> 将基类声明为虚基类的语法是在派生类的基类列表中，在基类名称前加上 <code>virtual</code> 关键字。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;; <span class="comment">// B 继承自 A 的虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;; <span class="comment">// C 继承自 A 的虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;; <span class="comment">// D 继承自 B 和 C，A 被声明为虚基类</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>派生类中的虚基类构造：</strong> 虚基类的构造由最底层的派生类负责完成。在构造虚基类对象时，虚基类的构造函数只会被调用一次。</p>
</li>
<li><p><strong>虚基类的存储：</strong> 虚基类的指针通常存储在对象的最开始位置，以确保派生类中共享同一个虚基类实例的指针是一致的。</p>
</li>
</ol>
<p>虚基类的引入使得多继承中的派生类能够更好地组织和管理共享的基类，避免了菱形继承问题带来的资源浪费和混乱。</p>
<h2 id="如何去管理内存，防止内存泄漏"><a href="#如何去管理内存，防止内存泄漏" class="headerlink" title="如何去管理内存，防止内存泄漏"></a>如何去管理内存，防止内存泄漏</h2><p>管理内存以防止内存泄漏是编程中非常重要的一部分，特别是在使用动态内存分配（如 <code>new</code> 和 <code>malloc</code>）的情况下。以下是一些防止内存泄漏的常见方法：</p>
<ol>
<li><p><strong>使用智能指针：</strong> C++11引入了智能指针，如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>，它们可以自动管理动态分配的内存。<code>std::unique_ptr</code> 确保只有一个指针可以指向所管理的对象，而 <code>std::shared_ptr</code> 则允许多个指针共享相同的对象。当不再需要指针时，它们会自动释放所管理的内存。</p>
</li>
<li><p><strong>RAII（资源获取即初始化）：</strong> RAII 是一种 C++ 编程范式，它通过在对象构造函数中获取资源并在析构函数中释放资源来管理资源。这种方法可以确保资源的正确释放，即使在发生异常或函数提前返回的情况下也能保证资源被释放。</p>
</li>
<li><p><strong>正确使用动态内存分配函数：</strong> 当使用 <code>new</code> 和 <code>delete</code> 或 <code>malloc</code> 和 <code>free</code> 时，务必确保每次分配的内存都有相应的释放操作。避免出现分配了内存但未释放的情况，否则会导致内存泄漏。</p>
</li>
<li><p><strong>检查内存分配的返回值：</strong> 在使用动态内存分配函数时，应该检查返回值是否为 <code>nullptr</code> 或 <code>NULL</code>，以确保内存分配成功。如果分配失败，应该进行适当的错误处理而不是继续使用未初始化的内存。</p>
</li>
<li><p><strong>避免循环引用：</strong> 在使用智能指针时，特别是 <code>std::shared_ptr</code>，应该避免形成循环引用。循环引用会导致对象无法被正确释放，从而造成内存泄漏。可以使用 <code>std::weak_ptr</code> 来打破循环引用。</p>
</li>
<li><p><strong>使用工具进行内存泄漏检测：</strong> 可以使用诸如 Valgrind、AddressSanitizer 等工具来检测程序中的内存泄漏问题。这些工具可以帮助识别出程序中未释放的内存，并提供有用的调试信息来帮助解决问题。</p>
</li>
</ol>
<p>综上所述，合理使用智能指针、RAII、正确的内存分配函数、避免循环引用以及使用工具进行检测是防止内存泄漏的关键。</p>
<h2 id="静态成员函数可以是虚函数吗"><a href="#静态成员函数可以是虚函数吗" class="headerlink" title="静态成员函数可以是虚函数吗"></a>静态成员函数可以是虚函数吗</h2><ul>
<li><p>静态成员函数不能声明为虚函数。虚函数是通过动态绑定来实现的，他需要在运行时根据对象的类型来确定调用的函数，但静态成员函数属于类本身而不是对象，没有动态绑定的需求</p>
</li>
<li><p>虚函数依赖于对象的内存布局和虚函数表来进行动态分配，而静态成员函数并不依赖于任何具体对象的状态或特征，所以不适合使用虚函数机制。静态成员函数是属于整个类而非某个具体对象的，并且他们可以直接通过类名访问，无需创建对象实例。</p>
</li>
<li><p>因此，在C++中，将静态成员函数声明为虚函数是无效且错误的。</p>
</li>
</ul>
<h2 id="为什么析构函数默认不是虚函数"><a href="#为什么析构函数默认不是虚函数" class="headerlink" title="为什么析构函数默认不是虚函数"></a>为什么析构函数默认不是虚函数</h2><ul>
<li><p>C++中析构函数默认不是虚函数的原因是为了避免额外的开销和复杂性</p>
</li>
<li><p>在设计类继承关系时，当基类指针指向派生类对象并通过该指针进行delete操作时，如果基类的析构函数时虚函数，那么会触发动态绑定，从而调用到正确的派生类析构函数。这样可以确保在删除基类指针时，正确地释放派生类对象的资源。</p>
</li>
<li><p>然而，将所有的析构函数都声明为虚函数会导致额外的开销。每个对象都需要额外存储一个虚函数表指针(vptr)，增加了对象的内存消耗，对于大规模或频繁创建和销毁对象的场景来说，这种额外开销可能是不可接受的。</p>
</li>
<li><p>因此，在C++中，默认情况下将析构函数声明为非虚函数。如果在父类中定义了虚析构函数，并且希望在继承体系中正确地释放资源，那么需要手动将派生类的析构函数声明为虚函数。</p>
</li>
</ul>
<h2 id="内存对齐的作用"><a href="#内存对齐的作用" class="headerlink" title="内存对齐的作用"></a>内存对齐的作用</h2><ul>
<li><p>内存对齐是指在分配和使用内存时，数据对象的起始地址需按照一定规则对齐的原则。具体而言，就是要求某些特定类型的数据在内存中的地址必须是某个值(通常是他自身大小)的整数倍</p>
</li>
<li><p>内存对齐的作用主要有以下几点：</p>
<ul>
<li>提高访问效率： 许多计算机体系结构要求特定类型的数据从特定地址开始读取或写入。如果为满足对齐要求，会导致额外的CPU周期来处理这种非对齐访问，从而降低程序性能</li>
<li>减少内存碎片： 当不同大小的数据对象按照自然字节对齐方式进行排列时，可能会出现内存碎片问题。通过按照特定规则进行对齐，可以减少内存碎片，提高空间利用率</li>
<li>支持硬件操作： 一些硬件设备(如网络卡，图形加速器等)要求数据在内存中按照固定格式排列以支持高效地传输和处理。通过正确进行内存对齐，可以确保数据符合硬件设备所需的格式要求</li>
</ul>
</li>
</ul>
<p>内存对齐是计算机中的一个重要概念，它确保数据在内存中的存储位置符合硬件要求，提高了访问内存的效率。以下是内存对齐的详细解释：</p>
<h3 id="1-为什么需要内存对齐？"><a href="#1-为什么需要内存对齐？" class="headerlink" title="1. 为什么需要内存对齐？"></a>1. 为什么需要内存对齐？</h3><p>内存对齐的目的主要有两个方面：</p>
<ul>
<li><strong>硬件要求</strong>：某些硬件架构要求特定类型的数据位于特定地址上。例如，某些 CPU 可能只能从特定地址开始访问特定大小的数据，如果数据没有正确对齐，可能会导致性能下降甚至错误。</li>
<li><strong>数据结构的自然对齐</strong>：某些数据类型在内存中的布局方式与其自身的大小相关。例如，一个4字节大小的整数通常会在4字节对齐的地址上开始，这样访问它的效率更高。</li>
</ul>
<h3 id="2-内存对齐规则"><a href="#2-内存对齐规则" class="headerlink" title="2. 内存对齐规则"></a>2. 内存对齐规则</h3><p>内存对齐规则通常由硬件或编译器定义，但是一般遵循以下原则：</p>
<ul>
<li><strong>基本对齐原则</strong>：数据的存储地址必须是其大小的整数倍。例如，一个4字节大小的整数通常要求其地址是4的倍数。</li>
<li><strong>数据结构对齐</strong>：复合数据类型（如结构体或类）的对齐要求取决于其成员中最大的对齐要求。</li>
</ul>
<h3 id="3-内存对齐的影响"><a href="#3-内存对齐的影响" class="headerlink" title="3. 内存对齐的影响"></a>3. 内存对齐的影响</h3><p>内存对齐可能会影响程序的内存使用和性能：</p>
<ul>
<li><strong>内存浪费</strong>：由于对齐要求，可能会导致一些内存空间被浪费掉。例如，在一个结构体中，如果某些成员的大小小于对齐要求，可能会在其后插入填充字节以满足对齐要求。</li>
<li><strong>性能影响</strong>：正确的内存对齐可以提高程序的性能，因为它允许 CPU 以更高效的方式访问数据。</li>
</ul>
<h3 id="4-如何控制内存对齐"><a href="#4-如何控制内存对齐" class="headerlink" title="4. 如何控制内存对齐"></a>4. 如何控制内存对齐</h3><p>在 C&#x2F;C++ 中，可以使用一些手段来控制内存对齐：</p>
<ul>
<li><strong>结构体对齐控制</strong>：可以使用 <code>#pragma pack</code> 指令（或者类似的编译器特性）来修改结构体的对齐方式，以减少内存浪费或者与外部库&#x2F;硬件的要求匹配。</li>
<li><strong>对齐属性</strong>：某些编译器提供了特殊的属性或指示符，可以用来指定变量或数据结构的对齐方式。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>内存对齐是一项重要的概念，对于理解计算机内存布局、编写高效的代码都非常重要。合理地处理内存对齐可以提高程序的性能和效率。</p>
<h2 id="vector-和-map-用迭代器一遍遍历容器一边删除元素，迭代器会失效吗"><a href="#vector-和-map-用迭代器一遍遍历容器一边删除元素，迭代器会失效吗" class="headerlink" title="vector 和 map 用迭代器一遍遍历容器一边删除元素，迭代器会失效吗"></a>vector 和 map 用迭代器一遍遍历容器一边删除元素，迭代器会失效吗</h2><ul>
<li><p>是的，当使用迭代器遍历容器并删除元素时，迭代器可能会失效。</p>
</li>
<li><p>对于vector来说，如果使用普通迭代器(例如 std::vector<int>::iterator)进行遍历和删除操作，当你删除一个元素后，后面的元素会向前填补空缺，导致当前迭代器指向的位置已经不再有效。此时继续使用该迭代器将产生为定义行为</p>
</li>
<li><p>对于map来说，使用普通迭代器或者逆向迭代器进行遍历并删除操作同样存在迭代器失效的问题。因为在删除某个键值对后，其他键值对的位置可能发生变化，导致当前迭代器无法正确指向下一个要访问的元素。</p>
</li>
<li><p>解决这个问题的一种常见的方式是使用 erase-remove 惯用法。即通过调用容器提供的成员函数 erase() 来移除需要删除的元素，并保持正确的迭代器位置。例如，在 std::vector 中可以使用 erase-remove idiom</p>
<ul>
<li>vec.erase(std::remove(vec.begin(), vec.end(), value), vec.end());</li>
</ul>
</li>
<li><p>而在map中可以配合使用返回下一个有效迭代器的 erase() 成员函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition)</span><br><span class="line">        it = map.<span class="built_in">erase</span>(it);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：</p>
<ul>
<li>C++11 引入了范围循环 for-each，但不适用于在迭代过程中删除元素的情况，因为他使用的是临时迭代器并不允许修改容器。</li>
</ul>
</li>
</ul>
<h2 id="map是有序的还是无序的，底层实现是什么"><a href="#map是有序的还是无序的，底层实现是什么" class="headerlink" title="map是有序的还是无序的，底层实现是什么"></a>map是有序的还是无序的，底层实现是什么</h2><ul>
<li><p>std::map 是有序的关联容器，底层实现通常是红黑树(Red-Black Tree)</p>
</li>
<li><p>红黑树是一种自平衡二叉查找树，它能够保持键值对按照键的大小顺序进行排序。这意味着当你遍历 std::map 时，会按照键的升序顺序返回元素。</p>
</li>
<li><p>红黑树具有以下性质：</p>
<ul>
<li>每个节点要么是红色，要么是黑色</li>
<li>根节点和叶子节点(空节点)都被认为是黑色的。</li>
<li>如果一个节点是红色的，则其子节点必须是黑色的。</li>
<li>对于任意一个节点而言，从该节点到其所有后代叶子节点的简单路径上，包含相同数量的黑色节点。</li>
</ul>
</li>
<li><p>这些性质保证了红黑树的平衡性，并且在最坏情况下仍然能够保持较高的插入，删除和查找操作效率。因此，在std::map中插入，删除和查找元素的平均时间复杂度为O(logN)，其中N是元素数量。</p>
</li>
<li><p>需要注意的是，在C++11引入之前，C++标准库中还提供了一个无序关联容器 std::unordered_map，它使用哈希表作为底层实现，并且不保持元素按照特定的顺序。在 std::unordered_map 中，插入，删除和查找元素的平均时间复杂度为O(1)，但是哈希表可能会占用更多的内存，并且无法保证元素顺序。</p>
</li>
</ul>
<h2 id="map为什么底层实现是红黑树而不是AVL"><a href="#map为什么底层实现是红黑树而不是AVL" class="headerlink" title="map为什么底层实现是红黑树而不是AVL"></a>map为什么底层实现是红黑树而不是AVL</h2><ul>
<li><p>在C++标准库中，std::map底层实现选择红黑树而不是AVL树是因为红黑树相对于AVL树有一些优势：</p>
<ul>
<li>插入和删除操作更高效： 红黑树的插入和删除操作比AVL树要快。这是因为红黑树通过旋转和颜色调整来保持平衡，不需要进行严格的平衡修复。AVL树则需要在每次插入或删除后执行可能多次的旋转以保持平衡，这导致了更多的开销。</li>
<li>更好的空间利用率： 红黑树通常比AVL树占用更少的内存。AVL树每个节点都需要存储额外的平衡因子信息，而红黑树只需要一个额外位表示节点颜色即可</li>
<li>查找操作性能相似： 在查找元素方面，红黑树和AVL树具有类似的性能。他们都具有O(logN)的时间复杂度，并且提供了快速的查找能力。</li>
</ul>
</li>
<li><p>综合考虑这些因素，C++标准库选择了选择使用红黑树作为 std::map 的底层实现，然后，在某些特定场景下，如果对插入和删除操作频繁，对空间要求较高且查找操作相对较少，可以考虑使用AVL树或者其他数据结构来满足特定需求</p>
</li>
</ul>
<h2 id="C-多线程编程用过哪些锁来实现同步或互斥"><a href="#C-多线程编程用过哪些锁来实现同步或互斥" class="headerlink" title="C++多线程编程用过哪些锁来实现同步或互斥"></a>C++多线程编程用过哪些锁来实现同步或互斥</h2><ul>
<li><p>互斥锁(Mutex) : 最常见的锁机制之一，通过lock()和unlock()函数来保护临界区，确保只有一个线程可以进入临界区执行操作</p>
</li>
<li><p>递归锁(Recursive Mutex) : 类似于互斥锁，但允许同一线程多次枷锁。这种情况通常在嵌套函数调用时需要使用</p>
</li>
<li><p>条件变量(Condition Variable) : 用于线程间的等待与唤醒机制。一个线程可以等待某个条件满足后再继续执行，另一个线程则可以发送信号来唤醒等待中的线程。</p>
</li>
<li><p>读写锁(Read-Write Lock) : 也称为共享-独占锁，允许多个线程同时读取共享资源，但只允许一个线程独占写入</p>
</li>
<li><p>自旋锁(Spinlock) : 在获取锁时不会主动阻塞线程，而是通过不断尝试获取直到成功。适用于对临界其的竞争非常短暂的情况</p>
</li>
<li><p>屏障(Barrier) : 用于控制多个线程并行执行，在所有线程都达到屏障点后再继续执行后续操作</p>
</li>
<li><p>这些锁都可以在C++标准库中找到对应的实现，例如 std::mutex, std::recursive_mutex, std::condition_variable, std::shared_mutex等。选择合适场景的锁机制是多线程编程中重要的技巧之一，需要根据具体需求和性能考虑作出选择。</p>
</li>
</ul>
<h2 id="C和C-的区别"><a href="#C和C-的区别" class="headerlink" title="C和C++的区别"></a>C和C++的区别</h2><ul>
<li><p>设计思想上</p>
<ul>
<li>C++是面向对象的语言，C是面向过程的语言</li>
</ul>
</li>
<li><p>语法上：</p>
<ul>
<li>C++ 具有封装，继承，多态三种特性</li>
<li>C++ 相比C，增加了类型安全的功能，比如强制类型转换</li>
<li>C++ 支持范式编程，比如模板类，函数模板等。</li>
</ul>
</li>
</ul>
<h2 id="const-限定符"><a href="#const-限定符" class="headerlink" title="const 限定符"></a>const 限定符</h2><ul>
<li><p>作用</p>
<ul>
<li>修饰变量：表明该变量的值不可以被改变</li>
<li>修饰指针：区分指向常量的指针和常量指针</li>
<li>修饰引用：用于形参，既避免了拷贝，又避免了函数对值的修改</li>
<li>修饰成员函数：表示函数不能修改成员变量(实际上是修饰this指针)</li>
</ul>
</li>
<li><p>补充：</p>
<ul>
<li>对于局部对象，常量存放在栈区</li>
<li>对于全局对象，常量存放在全局&#x2F;静态存储区</li>
<li>对于字面值常量，常量存放在常量存储区(代码段)</li>
</ul>
</li>
</ul>
<h2 id="指向常量的指针-VS-常量指针"><a href="#指向常量的指针-VS-常量指针" class="headerlink" title="指向常量的指针 VS 常量指针"></a>指向常量的指针 VS 常量指针</h2><ul>
<li><p>指向常量的指针(pointer to const):</p>
<ul>
<li>具有只能够读取内存中数据，却不能够修改内存中数据的属性的指针(底层const)</li>
<li>const int * p 或者 int const * p</li>
</ul>
</li>
<li><p>常量指针(const pointer):</p>
<ul>
<li>常量指针是指 指针所指向的位置不能改变，即指针本身是一个常量(顶层const)，但是指针所指向的内容可以改变</li>
<li>常量指针必须在声明的同时对其初始化，不允许先声明一个指针常量随后在对其赋值，这和声明一般的常量是一样的。</li>
<li><code>int * const p = &amp;a;</code></li>
</ul>
</li>
</ul>
<h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><ul>
<li>常量表达式(const expression)是指值不会改变并且在编译过程就能得到计算结果的表达式</li>
<li>一般来说，如果认定变量是一个常量表达式，那就把它声明成 constexpr 类型</li>
<li>一个 constexpr 指针的初始值必须是 nullptr 或者 0， 或者是存储于某个固定地址中的对象</li>
<li>constexpr 函数是指能用于常量表达式的函数</li>
<li>函数的返回类型及所有的形参的类型都得是字面值类型</li>
<li>函数体中必须有且仅有一条return语句。</li>
</ul>
<h2 id="define-VS-const"><a href="#define-VS-const" class="headerlink" title="#define VS const"></a>#define VS const</h2><ul>
<li><p>#define</p>
<ul>
<li>宏定义，相当于字符替换</li>
<li>预处理器处理</li>
<li>无类型安全检查</li>
<li>不分配内存</li>
<li>存储在代码段(.text)</li>
<li>可用 #undef 取消</li>
</ul>
</li>
<li><p>const</p>
<ul>
<li>常量声明</li>
<li>编译器处理</li>
<li>有类型安全检查</li>
<li>要分配内存</li>
<li>存储在数据段(.data, .bbs)</li>
<li>不可取消</li>
</ul>
</li>
</ul>
<h2 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h2><ul>
<li><p>sizeof 运算符的结果部分地依赖于其作用的类型</p>
<ul>
<li>对char或者类型为char的表达式执行sizeof运算，结果的1</li>
<li>对引用类型执行sizeof运算符得到被引用对象所占空间的大小</li>
<li>对指针执行sizeof运算得到指针本身所占空间的大小</li>
<li>对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小</li>
<li>对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有元素个执行一次sizeof运算并将所得结果求和</li>
<li>对string对象或者vector对象执行sizeof运算只返回该类型固定部分的大小。</li>
</ul>
</li>
<li><p>定义一个空类型，里面没有成员变量和成员函数，求sizeof结果为1.空类型的实例中不包括任何信息，本来求sizeof得到0，但是当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例，至于占用多少内存，由编译器决定，一般有一个char类新的内存</p>
</li>
<li><p>如果该类型中添加一个构造函数和析构函数，再对该类型求sizeof结果仍为1。调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的类型只与类型相关，而与类型的实例无关，编译器也不会因为这两个函数在实例内添加任何额外的信息</p>
</li>
<li><p>如果把析构函数标记为虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针，在32位的机器上，一个指针占4个字节的空间，因此求sizeof得到4；在64位机器上，一个指针占8个字节的空间，因此求sizeof得到8</p>
</li>
</ul>
<h2 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h2><ul>
<li>static_cast ：任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast</li>
<li>dynamic_cast ： 用于(动态)多态类型转换，只能用于含有虚函数的类，用于类层次间的向上向下转化</li>
<li>const_cast ： 去除”指向常量的指针“的const性质</li>
<li>reinterpret_cast ：为运算对象的位模式提供较低层次的重新解释，常用于函数指针的转换</li>
</ul>
<h2 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h2><ul>
<li>实参是形参的初始值</li>
</ul>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul>
<li><p>修饰局部变量 ： 使得被修饰的变量变为静态变量，存储在静态区。存储在静态区的数据生命周期与程序相同，在main函数之前初始化，在程序推出时销毁，默认初始化为0</p>
</li>
<li><p>修饰全局变量 ： 限制了链接属性，是的全局变量只能在声明它的源文件中访问</p>
</li>
<li><p>修饰普通函数 ： 使得函数只能在声明它的源文件中访问</p>
</li>
<li><p>修饰类的成员变量和成员函数 ：使其只属于类而不是属于某个对象，对多个对象来说，静态数据成员只存储一处，供所有对象共用</p>
</li>
<li><p>静态成员调用格式 ： &lt;类名&gt;::&lt;静态成员&gt;</p>
</li>
<li><p>静态成员函数调用格式 ： &lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;)</p>
</li>
</ul>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ul>
<li><p>指针参数传递本质上是值传递，所传递的是一个地址值</p>
</li>
<li><p>一般情况下，输入用传值或者传const reference, 输出传引用(或指针)</p>
</li>
</ul>
<h2 id="内联函数的使用"><a href="#内联函数的使用" class="headerlink" title="内联函数的使用"></a>内联函数的使用</h2><ul>
<li>将函数指定为内联函数(inline)，通常就是将它在每个调用点上内联地展开</li>
<li>一般来说，内联机制用于优化规模小(Google C++ Style 建议10行以下)，流程直接，频繁调用的函数</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数</li>
</ul>
<h2 id="编译器对inline函数的处理步骤"><a href="#编译器对inline函数的处理步骤" class="headerlink" title="编译器对inline函数的处理步骤"></a>编译器对inline函数的处理步骤</h2><ul>
<li>将inline函数体复制到inline函数调用点处</li>
<li>为所用inline函数中的局部变量分配内存空间</li>
<li>将inline函数的输入参数和返回值映射到调用方法的局部变量空间中</li>
<li>如果inline函数有多个返回点，将其转变为inline函数代码块末尾的分支(使用goto)</li>
</ul>
<h2 id="内联函数的优缺点"><a href="#内联函数的优缺点" class="headerlink" title="内联函数的优缺点"></a>内联函数的优缺点</h2><ul>
<li><p>优点：</p>
<ul>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈，栈帧开辟与回收，结果返回等，从而提高了程序运行速度</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换(同普通函数)，而宏定义则不会</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能</li>
<li>内联函数在运行时可以调试，而宏定义不可以</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>代码膨胀，内敛是以代码膨胀(复制)为代价，消除函数调用带来的开销，如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间</li>
<li>inline函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像non-inline可以直接链接</li>
<li>是否内敛，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ul>
</li>
</ul>
<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><ul>
<li>调用一个返回引用的函数得到左值，其他返回类型得到右值</li>
</ul>
<h2 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h2><ul>
<li>assert是一种预处理器宏。使用一个表达式作为它的条件 ： assert(expr)</li>
<li>首先对expr求值，如果 表达式为false，assert输出信息并终止程序的执行。如果表达式为true，assert什么也不做</li>
</ul>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul>
<li>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参共同决定，与函数名无关</li>
<li>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址</li>
<li>有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样</li>
<li>用途：调用函数和做函数的参数，比如回调函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">fun</span><span class="params">(<span class="type">char</span> *p)</span></span>&#123;...&#125;  <span class="comment">// 函数fun</span></span><br><span class="line"><span class="type">char</span> *(*pf)(<span class="type">char</span> *p);    <span class="comment">// 函数指针pf</span></span><br><span class="line">pf = fun;                <span class="comment">// 函数指针pf指向函数fun</span></span><br><span class="line"><span class="built_in">pf</span>(p);                   <span class="comment">// 通过函数指针pf调用函数fun</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><ul>
<li>this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象</li>
<li>this的目的总是指向”这个“对象，所以this是一个常量指针，被隐含地声明为 ClassName *const this，这意味着不能给this指针赋值</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给this指针，然后调用成员函数，每次成员函数存取数据时，都隐式使用this指针</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针</li>
<li>this并不是一个常规变量，而是个右值，所以不能取得this的地址(不能&amp;this)</li>
<li>在以下场景中，经常需要显式引用this指针<ul>
<li>为实现对象的链式引用</li>
<li>为避免对同一对象进行赋值操作</li>
<li>在实现一些数据结构时，例如list</li>
</ul>
</li>
</ul>
<h2 id="拷贝函数"><a href="#拷贝函数" class="headerlink" title="拷贝函数"></a>拷贝函数</h2><ul>
<li>C++深拷贝与浅拷贝<ul>
<li>在未定义显式拷贝构造函数的情况下，系统会调用默认的拷贝函数：即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但是当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以此时必须采用深拷贝</li>
<li>深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来存储数据，从而就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝</li>
</ul>
</li>
</ul>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ul>
<li>整理析构函数的特性<ul>
<li>析构函数与构造函数的构造顺序相反</li>
<li>当对象结束声明周期时，系统会自动执行析构函数</li>
<li>析构函数声明时在函数名前加取反符号，不带任何参数，也没有返回值</li>
<li>如果用户没有声明析构函数，系统会自动生成一个缺省的析构函数。</li>
<li>如果类中有指针，且在使用的过程总动态申请了内存，那么需要显示构造析构函数，在销毁类指针，释放掉申请的内存空间，避免内存泄漏</li>
</ul>
</li>
</ul>
<h2 id="访问控制与封装-public-private-protected"><a href="#访问控制与封装-public-private-protected" class="headerlink" title="访问控制与封装  public&#x2F;private&#x2F;protected"></a>访问控制与封装  public&#x2F;private&#x2F;protected</h2><ul>
<li>定义在public说明符之后的成员在整个程序内可被访问，public成员定义接口</li>
<li>定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了(即隐藏了)类的实现细节</li>
<li>基类希望它的派生类有权访问该成员，同时禁止其他用户访问，我们用受保护的(protected)访问运算符说明这样的成员</li>
</ul>
<h2 id="struct与class的区别"><a href="#struct与class的区别" class="headerlink" title="struct与class的区别"></a>struct与class的区别</h2><ul>
<li>struct与class定义的唯一区别就是默认的访问权限(struct默认是public,class默认是private)</li>
<li>使用习惯上，只有少量成员变量的，使用struct定义</li>
</ul>
<p>在C++中，struct和class都是用来定义自定义数据类型（类）的关键字，它们之间的区别主要体现在默认的访问控制权限和成员变量&#x2F;函数的默认访问权限上。下面是详细解释：</p>
<ol>
<li><p><strong>默认的访问控制权限</strong>：</p>
<ul>
<li>struct：在struct中，默认的访问控制权限是公有的（public），这意味着结构体的成员变量和成员函数默认是公有的，可以在外部访问。</li>
<li>class：在class中，默认的访问控制权限是私有的（private），这意味着类的成员变量和成员函数默认是私有的，只能在类的内部访问。</li>
</ul>
</li>
<li><p><strong>成员变量和成员函数的默认访问权限</strong>：</p>
<ul>
<li>struct：结构体中的成员变量和成员函数默认是公有的，可以被外部访问。</li>
<li>class：类中的成员变量和成员函数默认是私有的，只能在类的内部访问。</li>
</ul>
</li>
<li><p><strong>语义上的区别</strong>：</p>
<ul>
<li>在C++中，struct通常用于表示一组相关的数据，而class通常用于表示一组相关的数据和操作。</li>
<li>从语义上来说，struct更偏向于C语言中的结构体，主要用于存储数据；而class更偏向于面向对象的概念，可以包含数据和对数据的操作。</li>
</ul>
</li>
<li><p><strong>继承权限默认设置</strong>：</p>
<ul>
<li>在class中，如果不显式指定继承的访问权限，则默认是私有继承（private inheritance）。</li>
<li>在struct中，如果不显式指定继承的访问权限，则默认是公有继承（public inheritance）。</li>
</ul>
</li>
</ol>
<p>除了上述区别外，struct和class在其他方面基本相同，它们都可以包含成员变量和成员函数，都可以进行继承和多态等操作。在实际编程中，选择使用struct还是class取决于具体的需求和编程习惯，但通常情况下，struct更适合简单的数据封装，而class更适合面向对象的设计。</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><ul>
<li>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元(friend)</li>
</ul>
<h2 id="构造函数的初始化顺序"><a href="#构造函数的初始化顺序" class="headerlink" title="构造函数的初始化顺序"></a>构造函数的初始化顺序</h2><ul>
<li>成员变量的初始化顺序与他们在类定义中的出现顺序一致： 构造函数初始值列表中初始值的前后位置关系不会影响</li>
</ul>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><ul>
<li>用于类的构造函数，阻止其执行隐式类型转换，但是仍可以被用来进行显式类型转换</li>
</ul>
<h2 id="C-explicit关键字的作用？"><a href="#C-explicit关键字的作用？" class="headerlink" title="C++ explicit关键字的作用？"></a>C++ explicit关键字的作用？</h2><p>在C++中，<code>explicit</code>关键字用于修饰类的构造函数，它有两种主要用途：</p>
<ol>
<li><p><strong>禁止隐式类型转换：</strong> 当一个构造函数被声明为<code>explicit</code>时，它将禁止编译器执行隐式类型转换。这意味着，该构造函数只能在显式调用的情况下进行类型转换，而不能在隐式类型转换的上下文中使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span> : value(x) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exampleFunction</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在没有 explicit 关键字的情况下，可能发生隐式类型转换</span></span><br><span class="line">    <span class="comment">// MyClass newObj = 42;  // 错误，因为构造函数使用 explicit，禁止隐式类型转换</span></span><br><span class="line">    <span class="function">MyClass <span class="title">newObj</span><span class="params">(<span class="number">42</span>)</span></span>;  <span class="comment">// 正确，需要显式调用构造函数</span></span><br><span class="line">    <span class="type">int</span> val = newObj.<span class="built_in">getValue</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，如果构造函数没有使用<code>explicit</code>关键字，那么在<code>exampleFunction(42)</code>这一行可能发生隐式类型转换，导致错误。通过使用<code>explicit</code>关键字，可以防止这种隐式类型转换。</p>
</li>
<li><p><strong>防止二义性问题：</strong> 在涉及到函数重载的情况下，<code>explicit</code>关键字还可以防止二义性问题。如果一个构造函数可以被隐式调用，而另一个构造函数不能，那么在某些上下文中可能会导致编译器无法确定应该调用哪个构造函数的问题。使用<code>explicit</code>可以帮助解决这种二义性。</p>
</li>
</ol>
<p>总的来说，<code>explicit</code>关键字用于提高代码的安全性和可读性，确保在类型转换的情况下只能进行显式调用。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li>迭代器(iterator)模式，又称游标(Cursor)模式，用于提供一种方法顺序访问一个聚合对象中各种元素，而又不需要暴露该对象的内部表示</li>
<li>迭代器本质上是类模板，只是表现的像指针</li>
</ul>
<h2 id="顺序容器操作-emplace"><a href="#顺序容器操作-emplace" class="headerlink" title="顺序容器操作 emplace"></a>顺序容器操作 emplace</h2><ul>
<li>当调用push或者insert成员函数时，我们将元素类型的对象传递给他们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素</li>
</ul>
<h2 id="resize-reserve"><a href="#resize-reserve" class="headerlink" title="resize &#x2F; reserve"></a>resize &#x2F; reserve</h2><ul>
<li>resize : 改变容器内含有元素的数量</li>
<li>reserve : 改变容器的最大容量</li>
</ul>
<h2 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h2><ul>
<li><p>在向容器中添加元素后：</p>
<ul>
<li>如果容器是vector或者string，且存储空间被重新分配，则指向容器的迭代器，指针和引用都会失效</li>
<li>对于deque，插入到除首尾之外的任何位置都会导致迭代器，指针和引用失效</li>
<li>对于list，指向容器的迭代器，指针和引用仍然有效。</li>
</ul>
</li>
<li><p>从容器删除元素后：</p>
<ul>
<li>对于list，指向容器的迭代器指针和引用仍然有效</li>
<li>对于deque，在首尾之外的任何位置删除元素，其他元素的迭代器也会失效。</li>
<li>对于关联式容器(例如 std::set &#x2F; std::map)，插入元素不会使任何迭代器失效</li>
<li>对于无序关联式容器(例如 std::unordered_set &#x2F; std::unordered_map)，插入元素之后如果发生了rehash(新元素的个数大于max_load_factor() * bucket_count())，则所有迭代器失效</li>
</ul>
</li>
</ul>
<h2 id="vector对象是如何增长的"><a href="#vector对象是如何增长的" class="headerlink" title="vector对象是如何增长的"></a>vector对象是如何增长的</h2><ul>
<li><p>当不得不获取新的内存空间时，vector和string的实现通常会分配一个比新的空间需求更大的内存空间。容器预留这些空间作为备用，可以用来保存更多的新元素。这样，就需要每次添加新元素都重新分配容器和内存空间了</p>
</li>
<li><p>capacity 操作告诉我们容器在不扩张内存空间的情况下可以容纳多少个元素，reserve操作允许我们通知容器它应该准备保存多少个元素</p>
</li>
<li><p>初始时刻 vector的capacity为0，塞入第一个元素后capacity增加为1</p>
</li>
<li><p>不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容</p>
</li>
<li><p>从空间上分析，扩容因子越大，意味着预留空间越大，浪费的空间也越多，所以从空间考虑，扩容因子越小越好</p>
</li>
<li><p>从时间上分析，如果预留空间不足的话，就需要重新开辟一段空间，把原有的数据复制到新空间，如果扩容因子无限大的话，那显然就不在需要额外开辟空间了，所以从时间角度看，扩容因子越大越好</p>
</li>
</ul>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><ul>
<li>除了顺序容器外，标准库还定义了三个顺序容器适配器：stack, queue和priority_queue</li>
<li>本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样</li>
<li>默认情况下，stack和queue时基于deque实现的，priority_queue是在vector之上实现的</li>
</ul>
<h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><ul>
<li><p>一个lambda表达式表示一个可调用的代码单元，我们可以将其理解为一个未命名的内联函数。一个lambda表达式具有如下形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list)-&gt;<span class="keyword">return</span> <span class="built_in">type</span> (function body)</span><br></pre></td></tr></table></figure></li>
<li><p>其中capture list(捕获列表)是一个lambda所在函数中定义的局部变量的列表(通常为空)</p>
</li>
<li><p>return type, parameter list和function body与任何普通函数一样，分别表示返回类型，参数列表和函数体。但是与普通函数不同，lambda必须使用尾置返回来指定返回类型</p>
</li>
<li><p>我们可以忽略参数列表和返回类型，但必须包含捕获列表和函数体:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] (<span class="keyword">return</span> <span class="number">42</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><ul>
<li>map ： 关键字-值对；</li>
<li>set ： 关键字即值</li>
<li>map ： 按关键字有序保存元素(底层为红黑树)；unordered_map：无序集合(底层为哈希表)</li>
<li>map : 关键字不可重复出现；multimap : 关键字可重复出现</li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><ul>
<li><p>智能指针的行为类似常规指针，重要的区别在于它负责自动释放所指向的对象</p>
</li>
<li><p>shared_ptr</p>
<ul>
<li>允许多个指针指向同一个对象</li>
<li>我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数。一旦一个shared_ptr的计数器变为0，他就会自动释放自己所管理的对象</li>
</ul>
</li>
<li><p>unique_ptr</p>
<ul>
<li>独占所指向的对象</li>
</ul>
</li>
<li><p>weak_ptr</p>
<ul>
<li>weak_ptr是一种弱引用，指向shared_ptr所管理的对象</li>
<li>可打破环状引用(cycles of reference，两个其实已经没有被使用的对象彼此互相指向，使之看似还在被使用的状态)的问题</li>
</ul>
</li>
<li><p>make_shared</p>
<ul>
<li>make_shared 在动态内存中分配一个对象并初始化它，返回执行此对象的shared_ptr</li>
</ul>
</li>
</ul>
<h2 id="C-智能指针-详解"><a href="#C-智能指针-详解" class="headerlink" title="C++ 智能指针 详解"></a>C++ 智能指针 详解</h2><p>C++智能指针是一种用于管理动态内存的机制，它能够在不再需要对象时自动释放所分配的内存，从而避免了内存泄漏等问题。C++标准库提供了两种主要的智能指针：<code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>。下面是对这两种智能指针的详细解释：</p>
<h3 id="std-unique-ptr："><a href="#std-unique-ptr：" class="headerlink" title="std::unique_ptr："></a>std::unique_ptr：</h3><ol>
<li><p><strong>特点</strong>：</p>
<ul>
<li><code>std::unique_ptr</code> 表示独占所有权的指针，即同一时间只能有一个 <code>std::unique_ptr</code> 指向某个对象。</li>
<li>当 <code>std::unique_ptr</code> 被销毁时，它所管理的对象也会被销毁，从而自动释放所占用的内存。</li>
</ul>
</li>
<li><p><strong>使用方法</strong>：</p>
<ul>
<li>创建 <code>std::unique_ptr</code> 对象时，可以通过 <code>std::make_unique</code> 函数或直接使用构造函数来初始化。</li>
<li><code>std::unique_ptr</code> 对象可以通过 <code>get</code> 方法获取原始指针，通过 <code>reset</code> 方法重新指定对象或释放指针。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;  <span class="comment">// 输出 42</span></span><br><span class="line">    <span class="comment">// ptr 销毁时自动释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="std-shared-ptr："><a href="#std-shared-ptr：" class="headerlink" title="std::shared_ptr："></a>std::shared_ptr：</h3><ol>
<li><p><strong>特点</strong>：</p>
<ul>
<li><code>std::shared_ptr</code> 表示共享所有权的指针，多个 <code>std::shared_ptr</code> 可以同时指向同一个对象。</li>
<li>当最后一个指向对象的 <code>std::shared_ptr</code> 被销毁时，对象才会被销毁，从而自动释放所占用的内存。</li>
</ul>
</li>
<li><p><strong>使用方法</strong>：</p>
<ul>
<li>创建 <code>std::shared_ptr</code> 对象时，可以通过 <code>std::make_shared</code> 函数或直接使用构造函数来初始化。</li>
<li><code>std::shared_ptr</code> 对象可以通过 <code>get</code> 方法获取原始指针，通过 <code>reset</code> 方法重新指定对象或释放指针。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// ptr2 和 ptr1 共享所有权</span></span><br><span class="line">    std::cout &lt;&lt; *ptr1 &lt;&lt; std::endl;  <span class="comment">// 输出 42</span></span><br><span class="line">    std::cout &lt;&lt; *ptr2 &lt;&lt; std::endl;  <span class="comment">// 输出 42</span></span><br><span class="line">    <span class="comment">// ptr1 和 ptr2 销毁时自动释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="其他智能指针："><a href="#其他智能指针：" class="headerlink" title="其他智能指针："></a>其他智能指针：</h3><p>除了 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>，C++标准库还提供了 <code>std::weak_ptr</code> 和 <code>std::auto_ptr</code>（已被弃用）等智能指针，它们各自具有特定的功能和用途。<code>std::weak_ptr</code> 用于解决 <code>std::shared_ptr</code> 的循环引用问题，<code>std::auto_ptr</code> 已经被 <code>std::unique_ptr</code> 替代，不推荐使用。</p>
<p>智能指针的引入极大地简化了动态内存管理，减少了内存泄漏和悬空指针等问题的发生，提高了程序的安全性和可靠性。</p>
<h2 id="C-std-shared-ptr循环引用会引发什么？"><a href="#C-std-shared-ptr循环引用会引发什么？" class="headerlink" title="C++ std::shared_ptr循环引用会引发什么？"></a>C++ std::shared_ptr循环引用会引发什么？</h2><p>在 C++ 中，<code>std::shared_ptr</code> 的循环引用会导致内存泄漏，因为它会阻止对象的析构函数被调用，从而无法正确释放内存。</p>
<p>循环引用指的是两个或多个对象相互持有 <code>std::shared_ptr</code>，形成了一个环形的引用关系。在这种情况下，每个对象都至少有一个 <code>std::shared_ptr</code> 指向它，因此它们的引用计数都不会变为 0，即使没有任何外部引用，它们也不会被销毁。</p>
<p>当循环引用发生时，<code>std::shared_ptr</code> 无法及时释放内存，从而导致内存泄漏。这是因为 <code>std::shared_ptr</code> 使用引用计数来管理内存，每个对象都会维护一个引用计数，当引用计数为 0 时才会释放内存。但是在循环引用中，每个对象都互相持有对方的 <code>std::shared_ptr</code>，导致它们的引用计数永远不会降为 0。</p>
<p>为了避免循环引用导致的内存泄漏，可以考虑以下几种解决方案：</p>
<ol>
<li>使用 <code>std::weak_ptr</code> 打破循环引用：<code>std::weak_ptr</code> 是一种弱引用指针，它不会增加对象的引用计数，因此可以用于解决循环引用问题。其中一个对象持有 <code>std::shared_ptr</code>，而另一个对象持有 <code>std::weak_ptr</code>，这样即使存在循环引用，也不会导致内存泄漏。</li>
<li>尽量避免循环引用：在设计程序时，尽量避免出现循环引用的情况，可以通过合理设计对象之间的关系来减少循环引用的发生。</li>
<li>使用其他智能指针：如 <code>std::unique_ptr</code>，它是独占所有权的智能指针，不会发生循环引用问题，但需要注意不能用于对象之间的共享所有权的情况。</li>
</ol>
<h2 id="怎么解决std-shared-ptr循环引用的问题"><a href="#怎么解决std-shared-ptr循环引用的问题" class="headerlink" title="怎么解决std::shared_ptr循环引用的问题"></a>怎么解决std::shared_ptr循环引用的问题</h2><p>解决 <code>std::shared_ptr</code> 循环引用问题的一种常见方法是使用 <code>std::weak_ptr</code> 来打破循环引用。<code>std::weak_ptr</code> 是一种弱引用指针，它不会增加对象的引用计数，因此可以用于解决循环引用问题。以下是解决循环引用问题的步骤：</p>
<ol>
<li><p><strong>设计对象关系：</strong> 在设计程序时，尽量避免出现循环引用的情况。如果存在对象之间的循环引用，应该仔细分析对象之间的关系，并尝试重新设计以减少循环引用的发生。</p>
</li>
<li><p><strong>使用std::weak_ptr：</strong> 将循环引用中的其中一个指针替换为 <code>std::weak_ptr</code>。由于 <code>std::weak_ptr</code> 不会增加对象的引用计数，因此它不会导致循环引用。通过使用 <code>std::weak_ptr</code>，可以避免循环引用导致的内存泄漏。</p>
</li>
<li><p><strong>在需要访问对象时使用lock()：</strong> 如果需要在 <code>std::weak_ptr</code> 所指向的对象上执行操作，可以使用 <code>lock()</code> 方法将 <code>std::weak_ptr</code> 转换为 <code>std::shared_ptr</code>。<code>lock()</code> 方法会检查被引用的对象是否仍然存在，如果存在则返回一个有效的 <code>std::shared_ptr</code>，否则返回一个空指针。通过使用 <code>lock()</code> 方法，可以确保操作的安全性，并避免在对象已经被销毁时访问无效内存。</p>
</li>
</ol>
<p>下面是一个示例，演示了如何使用 <code>std::weak_ptr</code> 来解决循环引用的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::weak_ptr&lt;A&gt; a_weak_ptr; <span class="comment">// 使用 weak_ptr 打破循环引用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; a_ptr = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b_ptr = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    a_ptr-&gt;b_ptr = b_ptr;</span><br><span class="line">    b_ptr-&gt;a_weak_ptr = a_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>B</code> 类中使用 <code>std::weak_ptr</code> 来持有 <code>A</code> 类的指针，从而打破了 <code>A</code> 类和 <code>B</code> 类之间的循环引用。这样可以确保对象在不再需要时能够正确地被销毁，避免内存泄漏的发生。</p>
<h2 id="拷贝控制-对象移动"><a href="#拷贝控制-对象移动" class="headerlink" title="拷贝控制 对象移动"></a>拷贝控制 对象移动</h2><ul>
<li>右值引用：所谓右值引用就是必须绑定到右值的引用。我们通过&amp;&amp;而不是&amp;来获的右值引用。右值引用有一个重要的性质：只能绑定到一个将要销毁的对象</li>
<li>左值持久，右值短暂：左值有持久的状态，而右值要么是字面常量，要么是在表达式求职过程中创建的临时对象</li>
<li>通过调用std::move来获得绑定到左值上的右值引用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr1 = <span class="number">42</span>;   <span class="comment">// 正确：字面常量是右值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = rr1;  <span class="comment">// 错误：表达式rr1是左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1);  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="OOP-概述"><a href="#OOP-概述" class="headerlink" title="OOP:概述"></a>OOP:概述</h2><ul>
<li>面向对象程序设计(object-oriented programming)的核心思路是数据抽象(封装)，继承和动态绑定(多态)<ul>
<li>通过数据抽象，我们可以将接口与实现分离</li>
<li>使用继承，可以定义相似的类型并对其相似关系建模</li>
<li>使用动态绑定，可以在一定程度上忽略相似类型的区别，而以同意的方式使用他们的对象</li>
</ul>
</li>
</ul>
<h2 id="定义派生类和基类-–-初始化顺序"><a href="#定义派生类和基类-–-初始化顺序" class="headerlink" title="定义派生类和基类 – 初始化顺序"></a>定义派生类和基类 – 初始化顺序</h2><ul>
<li>每个类控制它自己的成员初始化过程、</li>
<li>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员</li>
</ul>
<h2 id="静态多态-动态多态"><a href="#静态多态-动态多态" class="headerlink" title="静态多态 &#x2F; 动态多态"></a>静态多态 &#x2F; 动态多态</h2><ul>
<li><p>静态多态是通过重载和模板技术实现，在编译的时候确定</p>
</li>
<li><p>动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定</p>
</li>
<li><p>重载： 两个函数名字相同，但是参数的个数或者类型不同</p>
</li>
<li><p>重写： 子类继承父类，父类函数中被声明为虚函数，子类中重新定义了这个虚函数</p>
</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul>
<li>虚函数： 基类希望派生类覆盖的函数，可以将其定义为虚函数，这样每一个派生类可以个自定义适合自身的版本</li>
<li>当基类定义virtual函数的时候，它希望派生类可以自己定义这个函数</li>
<li>如果使用virtual，程序依据引用或者指针所指向对象的类型来选择方法</li>
<li>如果不使用virtual，程序依据引用类型或者指针类型选择一个方法</li>
<li>虚函数表指针：在有虚函数的类的对象最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表</li>
<li>虚函数表中放了虚函数的地址，实际的虚函数在代码段(.text)中</li>
<li>当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址</li>
<li>使用了虚函数，会增加访问内存开销，降低效率</li>
</ul>
<p>C++中的虚函数是一种用于实现多态性（Polymorphism）的重要机制，它允许子类重写（override）父类的成员函数，并在运行时动态地选择调用哪个版本的函数。以下是关于C++虚函数的详细解释：</p>
<ol>
<li><p><strong>声明虚函数</strong>：</p>
<ul>
<li>在C++中，通过在基类（父类）中声明虚函数，可以将其标记为虚函数。使用关键字<code>virtual</code>在函数声明前面声明函数为虚函数。</li>
<li>虚函数的声明格式如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> return_type <span class="title">function_name</span><span class="params">(parameters)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li>在基类中使用<code>= 0</code>来声明纯虚函数，纯虚函数没有实现，必须在派生类中实现。</li>
</ul>
</li>
<li><p><strong>实现虚函数</strong>：</p>
<ul>
<li>派生类（子类）可以选择性地重写基类的虚函数，通过在派生类中提供相同的函数签名和关键字<code>override</code>来实现。</li>
<li>派生类可以选择性地使用<code>override</code>关键字，以明确地表明该函数是对基类虚函数的重写。</li>
</ul>
</li>
<li><p><strong>多态性</strong>：</p>
<ul>
<li>多态性是指通过基类指针或引用调用虚函数时，会根据实际对象的类型来动态地选择调用哪个版本的函数。</li>
<li>运行时多态性（Run-time Polymorphism）是在运行时根据对象的类型来选择调用的函数版本，而不是在编译时确定。</li>
</ul>
</li>
<li><p><strong>虚函数表（vtable）</strong>：</p>
<ul>
<li>虚函数通过使用虚函数表来实现多态性。每个包含虚函数的类都有一个虚函数表，其中存储了指向各个虚函数的指针。</li>
<li>每个对象都包含一个指向其类的虚函数表的指针。当调用虚函数时，程序会根据对象的虚函数表指针来确定调用哪个函数。</li>
</ul>
</li>
<li><p><strong>动态绑定</strong>：</p>
<ul>
<li>虚函数的调用是动态绑定的（Dynamic Binding），意味着在运行时确定要调用的函数版本。</li>
<li>这与静态绑定（Static Binding）不同，静态绑定在编译时确定要调用的函数版本。</li>
</ul>
</li>
<li><p><strong>虚析构函数</strong>：</p>
<ul>
<li>在C++中，通常将基类的析构函数声明为虚析构函数。这样可以确保在删除派生类对象时，会调用派生类的析构函数。</li>
</ul>
</li>
</ol>
<p>虚函数是C++中实现多态性的重要机制，它允许子类覆盖父类的函数，并在运行时动态地选择调用的函数版本。虚函数通过虚函数表实现多态性，动态绑定确保在运行时确定调用的函数版本。</p>
<h2 id="析构函数为什么是虚函数？"><a href="#析构函数为什么是虚函数？" class="headerlink" title="析构函数为什么是虚函数？"></a>析构函数为什么是虚函数？</h2><ul>
<li>将可能会被继承的基类的析构函数设置为虚函数，可以保证当我们new一个派生类，然后使用基类指针指向该派生类对象，释放掉基类指针时可以释放掉派生类的空间，防止内存泄漏</li>
</ul>
<h2 id="C-构造函数可以是虚函数吗"><a href="#C-构造函数可以是虚函数吗" class="headerlink" title="C++ 构造函数可以是虚函数吗"></a>C++ 构造函数可以是虚函数吗</h2><p>在 C++ 中，构造函数不能声明为虚函数。这是因为在对象创建时，虚函数表尚未形成，因此构造函数不能被动态绑定。在构造函数期间，对象的动态类型还不可用，因此虚函数的行为是未定义的。如果您尝试在构造函数中声明虚函数，编译器可能会发出警告或错误。</p>
<h2 id="为什么C-默认析构函数不是虚函数？"><a href="#为什么C-默认析构函数不是虚函数？" class="headerlink" title="为什么C++默认析构函数不是虚函数？"></a>为什么C++默认析构函数不是虚函数？</h2><ul>
<li>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存；所以只有当一个类会被用作基类时才将其设置为虚函数。</li>
</ul>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><ul>
<li>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做，书写&#x3D;0就可以将一个虚函数说明为纯虚函数</li>
<li>含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类(abstract base class)</li>
</ul>
<h2 id="虚函数-VS-纯虚函数"><a href="#虚函数-VS-纯虚函数" class="headerlink" title="虚函数 VS 纯虚函数"></a>虚函数 VS 纯虚函数</h2><ul>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能够让这个函数在它的子类里面可以被覆盖(override)，这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，他要留到子类里面去实现</li>
<li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类</li>
<li>虚函数的类用于 实作继承，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li>
<li>带纯虚函数的类叫做抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类</li>
</ul>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><ul>
<li>公有继承：保持原始状态(没有特殊要求一般用公有继承)</li>
<li>私有继承：基类的所有成员都变为派生类的私有成员</li>
<li>保护继承：基类的public作为派生类的保护成员，其他不变</li>
</ul>
<h2 id="多重继承与虚继承"><a href="#多重继承与虚继承" class="headerlink" title="多重继承与虚继承"></a>多重继承与虚继承</h2><ul>
<li>虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝，即浪费存储空间，又存在二义性的问题</li>
<li>底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针(占用一个指针的存储空间，4字节)和虚基类表(不占用类对象的存储空间。)(需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了)；当虚继承的子类被当作父类继承时，虚基类指针也会被继承。</li>
<li>实际上，vbptr指的是虚基类表指针(virtual base table pointer)，该指针指向了一个虚基类表(virtual table), 虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚基类也不用像普通多继承那样维持着公共基类(虚基类)的两份同样的拷贝，节省了存储空间</li>
</ul>
<h2 id="new-delete"><a href="#new-delete" class="headerlink" title="new &amp; delete"></a>new &amp; delete</h2><ul>
<li><p>当我们使用一条new表达式时，实际执行了三步操作</p>
<ul>
<li>new表达式调用了一个名为operator new(或者 operator new[])的标准库函数，该函数(从自由存储区上)分配一块足够大的，原始的，未命名的内存空间(无需指定内存块的大小)以便存储特定类型的对象(或者对象的数组)</li>
<li>编译器运行响应的构造函数以构造这些对象，并为其传入初值</li>
<li>对象被分配了空间并构造完成，返回一个指向该对象的指针</li>
</ul>
</li>
<li><p>当我们使用了一条delete表达式删除一个动态分配的对象时，实际执行了两步操作：</p>
<ul>
<li>对sp所指的对象或者arr所指的数组中的元素执行对应的析构函数</li>
<li>编译器调用名为operator delete(或者operate delete[])的标准库函数释放内存空间</li>
</ul>
</li>
</ul>
<h2 id="new和malloc有什么区别"><a href="#new和malloc有什么区别" class="headerlink" title="new和malloc有什么区别"></a>new和malloc有什么区别</h2><p><code>new</code> 和 <code>malloc</code> 是 C++ 中用于动态内存分配的两种不同的方式，它们有以下主要区别：</p>
<ol>
<li><p><strong>类型安全性：</strong></p>
<ul>
<li><code>new</code> 是 C++ 的运算符，能够为指定的类型分配内存，并返回相应类型的指针。由于是针对特定类型的操作，因此 <code>new</code> 在分配内存时会自动计算所需的字节数，并将内存初始化为该类型的默认值。</li>
<li><code>malloc</code> 是 C 语言中的库函数，它分配的内存是以字节为单位的，返回的是 <code>void*</code> 类型的指针。因此，使用 <code>malloc</code> 分配内存后需要进行显式的类型转换。</li>
</ul>
</li>
<li><p><strong>构造函数和析构函数的调用：</strong></p>
<ul>
<li>当使用 <code>new</code> 分配内存时，会自动调用对象的构造函数进行初始化，并在对象被销毁时调用析构函数。</li>
<li><code>malloc</code> 只是分配内存，不会调用任何构造函数或析构函数。如果需要在分配内存时执行一些初始化操作，需要手动调用构造函数。</li>
</ul>
</li>
<li><p><strong>内存大小：</strong></p>
<ul>
<li><code>new</code> 操作符会根据指定的类型自动计算所需的内存大小，并返回一个指向该类型的指针。</li>
<li><code>malloc</code> 分配的内存大小需要显式指定，以字节为单位。</li>
</ul>
</li>
<li><p><strong>异常处理：</strong></p>
<ul>
<li>如果 <code>new</code> 分配内存失败，会抛出 <code>std::bad_alloc</code> 异常。</li>
<li>如果 <code>malloc</code> 分配内存失败，会返回 <code>NULL</code>，需要手动检查分配是否成功。</li>
</ul>
</li>
<li><p><strong>对于数组的支持：</strong></p>
<ul>
<li><code>new</code> 可以用于动态分配数组，并自动计算所需的内存大小。</li>
<li><code>malloc</code> 分配数组时需要手动计算所需的内存大小，并进行类型转换。</li>
</ul>
</li>
</ol>
<p>综上所述，<code>new</code> 提供了更加方便、类型安全、自动化的内存分配方式，并支持对象构造和析构函数的调用，而 <code>malloc</code> 则是 C 语言的库函数，更为底层，需要手动管理内存分配和释放，并且不支持类型安全和自动化的构造和析构过程。在 C++ 中推荐优先使用 <code>new</code> 和 <code>delete</code> 来进行动态内存分配和释放。</p>
<h2 id="new的对象可以使用free释放吗？"><a href="#new的对象可以使用free释放吗？" class="headerlink" title="new的对象可以使用free释放吗？"></a>new的对象可以使用free释放吗？</h2><p>不，<code>new</code> 分配的对象不能使用 <code>free</code> 函数进行释放。在 C++ 中，应该使用 <code>delete</code> 运算符来释放由 <code>new</code> 分配的内存。</p>
<p><code>new</code> 和 <code>delete</code> 是 C++ 中用于动态内存分配和释放的运算符，它们是对应的，分别用于分配和释放内存。</p>
<p>使用 <code>delete</code> 来释放 <code>new</code> 分配的对象有以下几点原因：</p>
<ol>
<li><code>new</code> 和 <code>delete</code> 是 C++ 的运算符，对应关系更为明确，使用它们能够让代码更加清晰和易读。</li>
<li><code>delete</code> 会调用对象的析构函数来释放资源，确保对象被正确地销毁，而 <code>free</code> 不会调用对象的析构函数。</li>
<li><code>new</code> 和 <code>delete</code> 以及 <code>malloc</code> 和 <code>free</code> 并非完全兼容，混合使用会导致未定义行为。</li>
</ol>
<p>因此，在 C++ 中，应该始终使用 <code>delete</code> 来释放由 <code>new</code> 分配的内存，而不是 <code>free</code>。</p>
<h2 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc &amp; free"></a>malloc &amp; free</h2><ul>
<li><p>malloc需要显式的指出内存大小：函数接收一个表示待分配字节数的size_t</p>
</li>
<li><p>返回指向分配空间的指针(void*)或者返回0以表示分配失败(从堆上动态分配内存)</p>
</li>
<li><p>free函数接收一个void*，踏实malloc返回的指针的副本，free将相关内存返回给系统，调用free(0)没有任何意义</p>
</li>
<li><p>operate new的一种简单实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *operater <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="type">void</span> *men = <span class="built_in">malloc</span>(size))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> mem;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="malloc实现原理-详解"><a href="#malloc实现原理-详解" class="headerlink" title="malloc实现原理 详解"></a>malloc实现原理 详解</h2><p><code>malloc()</code> 是C语言标准库中用于动态内存分配的函数，它用于在程序运行时动态地分配一块指定大小的内存空间。下面是 <code>malloc()</code> 实现原理的简要解释：</p>
<ol>
<li><p><strong>空闲内存管理</strong>：</p>
<ul>
<li><code>malloc()</code> 通过管理一块内存池来实现内存的分配和释放。该内存池中包含了未分配的空闲内存块。</li>
<li>初始时，整个内存池是一片连续的未分配内存。</li>
</ul>
</li>
<li><p><strong>内存分配</strong>：</p>
<ul>
<li>当程序调用 <code>malloc(size)</code> 时，<code>malloc()</code> 首先搜索内存池中的空闲内存块，找到一块足够大的空闲内存块。</li>
<li>如果找到了足够大的空闲内存块，<code>malloc()</code> 将这块内存分配给程序，并返回指向这块内存的指针。</li>
<li>如果没有足够大的空闲内存块，<code>malloc()</code> 可以选择增加内存池的大小，从操作系统中请求更多的内存，然后将其中一部分内存分配给程序。</li>
</ul>
</li>
<li><p><strong>内存释放</strong>：</p>
<ul>
<li>当程序调用 <code>free(ptr)</code> 时，其中 <code>ptr</code> 是之前由 <code>malloc()</code> 返回的指针，<code>free()</code> 将释放 <code>ptr</code> 指向的内存块，并将该内存块标记为空闲状态。</li>
<li><code>free()</code> 并不将内存块立即返回给操作系统，而是将其标记为空闲状态，以便后续的 <code>malloc()</code> 调用可以重用这块内存。</li>
</ul>
</li>
<li><p><strong>内存分片</strong>：</p>
<ul>
<li>内存池中的内存分为不同大小的内存块，这些内存块大小通常以 2 的幂次方递增。</li>
<li>当程序请求分配的内存大小不是内存块大小的整数倍时，<code>malloc()</code> 可能会选择比请求稍大一点的内存块，将多余的内存保留在这个内存块中，以便后续的小内存请求可以重用这个内存块的剩余空间。</li>
</ul>
</li>
<li><p><strong>内存对齐</strong>：</p>
<ul>
<li><code>malloc()</code> 返回的内存地址通常是按照特定的字节对齐方式对齐的，以提高内存访问效率。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>malloc()</code> 的实现主要包括管理内存池、搜索空闲内存块、分配内存、释放内存等步骤。通过这些步骤，<code>malloc()</code> 实现了在程序运行时动态地分配和释放内存的功能。</p>
<h2 id="tcmalloc-详解"><a href="#tcmalloc-详解" class="headerlink" title="tcmalloc 详解"></a>tcmalloc 详解</h2><p>TCMalloc（Thread-Caching malloc）是由Google开发的用于多线程环境下的高效内存分配器。它是对标准的malloc函数的替代，专门针对多线程环境和大规模内存分配进行了优化。下面是TCMalloc的详细解释：</p>
<h3 id="特点和优势："><a href="#特点和优势：" class="headerlink" title="特点和优势："></a>特点和优势：</h3><ol>
<li><p><strong>线程缓存（Thread-Caching）</strong>：</p>
<ul>
<li>TCMalloc通过为每个线程分配一个本地线程缓存（Thread Cache），避免了多线程环境下频繁的锁竞争。</li>
<li>每个线程都有一个独立的内存缓存，减少了线程之间的竞争和同步开销，提高了内存分配的并发性能。</li>
</ul>
</li>
<li><p><strong>粒度适应（Size Class）</strong>：</p>
<ul>
<li>TCMalloc将内存分配划分为不同的大小类别（Size Class），针对不同大小的内存请求采用不同的分配策略，以最小化内存碎片和提高内存使用效率。</li>
<li>TCMalloc会根据内存请求的大小选择合适的Size Class进行分配，从而避免了传统内存分配器可能存在的内存浪费问题。</li>
</ul>
</li>
<li><p><strong>高效的内存回收（Memory Reclamation）</strong>：</p>
<ul>
<li>TCMalloc使用高效的内存回收机制，包括延迟释放（Delayed Freeing）和定期回收（Central Cache）等，以减少内存碎片和提高内存回收的效率。</li>
<li>TCMalloc会将未使用的内存块缓存在本地线程缓存中，定期将这些内存块回收到全局内存池中。</li>
</ul>
</li>
<li><p><strong>空间效率和性能</strong>：</p>
<ul>
<li>TCMalloc具有较高的内存使用效率和分配性能，在大规模多线程环境下表现良好。</li>
<li>与标准的malloc函数相比，TCMalloc在大规模并发情况下可以显著减少锁竞争和内存碎片，并提高内存分配的性能和效率。</li>
</ul>
</li>
<li><p><strong>可配置性</strong>：</p>
<ul>
<li>TCMalloc提供了丰富的配置选项，可以根据应用程序的需求进行调整和优化，包括线程缓存大小、内存回收策略等。</li>
</ul>
</li>
</ol>
<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ul>
<li>大规模多线程应用程序：TCMalloc特别适用于需要高效处理大量并发内存分配请求的多线程应用程序，如服务器端应用、分布式系统等。</li>
</ul>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>TCMalloc并不是适用于所有场景的通用内存分配器，某些特定的应用场景可能需要根据实际情况选择合适的内存分配器。</li>
<li>在使用TCMalloc时，需要注意合理配置相关参数，以达到最佳的性能和效率。</li>
</ul>
<p>总的来说，TCMalloc通过线程缓存、粒度适应和高效的内存回收等优化手段，提供了高效的内存分配和回收机制，特别适用于大规模多线程环境下的高性能应用程序。</p>
<h2 id="固有的不可移植性"><a href="#固有的不可移植性" class="headerlink" title="固有的不可移植性"></a>固有的不可移植性</h2><ul>
<li><p>volatile</p>
<ul>
<li>当对象的值可能在程序控制或者检测之外(操作系统，硬件，其他线程等)被改变时，应该将该对象声明为 volatile，关键字 volatile 告诉编译器不应该对这样的对象进行优化</li>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值(没有被volatile修饰的变量，可能由于编译器的优化，从CPU寄存器中取值)</li>
</ul>
</li>
<li><p>extern</p>
<ul>
<li>在多个文件之间共享对象</li>
<li>extern “C” 的作用是让C++编译器将 extern “C”声明的代码当作C语言代码处理，可以避免C++因为符号修饰导致代码不能和C语言库中的符号进行链接的问题</li>
</ul>
</li>
</ul>
<h2 id="h-和-cpp-文件的区别"><a href="#h-和-cpp-文件的区别" class="headerlink" title=".h 和 .cpp 文件的区别"></a>.h 和 .cpp 文件的区别</h2><ul>
<li>.h文件里面放声明，.cpp文件里面放定义</li>
<li>.cpp文件会被编译成实际的二进制代码，而.h文件实在被include中之后复制粘贴到.cpp文件中</li>
</ul>
<h2 id="C-可变长模板-详解"><a href="#C-可变长模板-详解" class="headerlink" title="C++ 可变长模板 详解"></a>C++ 可变长模板 详解</h2><p>可变长模板（Variadic Templates）是C++11引入的一项特性，它允许模板接受可变数量的参数。这使得在泛型编程中更加灵活，能够处理不同数量和类型的参数。下面详细解释可变长模板的主要概念和用法：</p>
<h3 id="1-模板参数包（Template-Parameter-Pack）"><a href="#1-模板参数包（Template-Parameter-Pack）" class="headerlink" title="1. 模板参数包（Template Parameter Pack）"></a>1. 模板参数包（Template Parameter Pack）</h3><p>可变长模板中的关键元素之一是<strong>模板参数包</strong>，它使用省略号（<code>...</code>）表示。模板参数包允许模板接受可变数量的参数。在函数模板中，模板参数包可以用于表示函数的参数列表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，<code>Args</code>是一个模板参数包，可以接受任意数量的模板参数。</p>
<h3 id="2-模板展开（Template-Expansion）"><a href="#2-模板展开（Template-Expansion）" class="headerlink" title="2. 模板展开（Template Expansion）"></a>2. 模板展开（Template Expansion）</h3><p><strong>模板展开</strong>是指将模板参数包中的参数展开，以便在模板中使用这些参数。通常使用递归或折叠表达式来实现模板展开。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">(T first, Args... rest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理 first</span></span><br><span class="line">    <span class="comment">// 递归调用处理剩余的参数</span></span><br><span class="line">    <span class="built_in">myFunction</span>(rest...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，<code>myFunction</code>通过递归调用实现了对参数的展开处理。</p>
<h3 id="3-基本情况与递归模板"><a href="#3-基本情况与递归模板" class="headerlink" title="3. 基本情况与递归模板"></a>3. 基本情况与递归模板</h3><p>在使用可变长模板时，通常需要定义基本情况和递归模板，以处理模板参数包中的参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本情况</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理单个参数的情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T first, Args... rest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理 first</span></span><br><span class="line">    <span class="comment">// 递归调用处理剩余的参数</span></span><br><span class="line">    <span class="built_in">process</span>(rest...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-使用递归展开模板参数包"><a href="#4-使用递归展开模板参数包" class="headerlink" title="4. 使用递归展开模板参数包"></a>4. 使用递归展开模板参数包</h3><p>在递归展开模板参数包时，可以使用递归函数、递归类模板或者C++17引入的折叠表达式（fold expression）。</p>
<h4 id="4-1-递归函数"><a href="#4-1-递归函数" class="headerlink" title="4.1 递归函数"></a>4.1 递归函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理单个参数的情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(T first, Args... rest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理 first</span></span><br><span class="line">    <span class="built_in">process</span>(rest...);  <span class="comment">// 递归调用处理剩余的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-递归类模板"><a href="#4-2-递归类模板" class="headerlink" title="4.2 递归类模板"></a>4.2 递归类模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">process</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理单个参数的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Processor</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">process</span><span class="params">(T first, Args... rest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理 first</span></span><br><span class="line">        Processor&lt;Args...&gt;::<span class="built_in">process</span>(rest...);  <span class="comment">// 递归调用处理剩余的参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-折叠表达式（C-17）"><a href="#4-3-折叠表达式（C-17）" class="headerlink" title="4.3 折叠表达式（C++17）"></a>4.3 折叠表达式（C++17）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (<span class="built_in">processSingle</span>(args), ...);  <span class="comment">// 使用折叠表达式展开参数包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processSingle</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理单个参数的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例：打印任意数量参数的函数"><a href="#示例：打印任意数量参数的函数" class="headerlink" title="示例：打印任意数量参数的函数"></a>示例：打印任意数量参数的函数</h3><p>下面是一个示例，演示了如何使用可变长模板实现一个函数，用于打印任意数量的参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本情况：当没有参数时，终止递归</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归情况：打印第一个参数，并递归调用处理剩余的参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T first, Args... rest)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">print</span>(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">3.14</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>print</code>函数接受任意数量的参数，并使用递归展开参数包，打印每一个参数。这样，你可以传递不同数量和类型的参数给<code>print</code>函数。</p>
<h2 id="C-如何解决多继承造成的类成员重复的问题？"><a href="#C-如何解决多继承造成的类成员重复的问题？" class="headerlink" title="C++ 如何解决多继承造成的类成员重复的问题？"></a>C++ 如何解决多继承造成的类成员重复的问题？</h2><p>在C++中，多继承可能导致一个类从多个基类中继承相同的成员（变量或函数），这可能会引起命名冲突和二义性。为了解决这个问题，C++提供了一些机制：</p>
<ol>
<li><p><strong>虚继承（Virtual Inheritance）：</strong> 使用虚继承可以解决菱形继承（diamond inheritance）问题，其中一个派生类从两个不相关的基类派生而来，而另一个派生类继承这两个基类。虚继承可以防止在派生类中出现多个对同一基类的实例。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultipleDerived</span> : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MultipleDerived obj;</span><br><span class="line">    obj.data = <span class="number">42</span>; <span class="comment">// 可以正常访问基类的成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用命名空间（Namespace）：</strong> 将基类的成员放置在不同的命名空间中，从而避免命名冲突。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FirstNamespace &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SecondNamespace &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> FirstNamespace::Base, <span class="keyword">public</span> SecondNamespace::Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FirstNamespace::Base::data = <span class="number">42</span>;  <span class="comment">// 使用命名空间解决命名冲突</span></span><br><span class="line">        SecondNamespace::Base::data = <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重命名成员：</strong> 在派生类中可以重命名具有冲突名称的成员，以避免二义性。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultipleDerived</span> : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> derived1Data; <span class="comment">// 重命名避免冲突</span></span><br><span class="line">    <span class="type">int</span> derived2Data; <span class="comment">// 重命名避免冲突</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些方法的选择取决于具体的情况。虚继承通常在菱形继承中使用，而使用命名空间或重命名成员则可以帮助避免普通的多继承带来的命名冲突。在设计时，尽量避免过于复杂的多继承结构，以减少潜在的问题。</p>
<h2 id="C-为什么要有class？"><a href="#C-为什么要有class？" class="headerlink" title="C++ 为什么要有class？"></a>C++ 为什么要有class？</h2><ul>
<li><p>考察目的：</p>
<ul>
<li>考对oop基础的理解，而不是考死语法。可引申出动态多态，RAII，类型系统，隐式成员等一票问题。大牛还是菜鸡，用这一个问题就暴露了</li>
</ul>
</li>
<li><p>参考答案</p>
<ul>
<li>类是C++用来实现OOP封装、继承和多态的核心机制</li>
</ul>
</li>
</ul>
<h2 id="指针是什么？你能不用指针写C-程序吗？指针好还是不好？"><a href="#指针是什么？你能不用指针写C-程序吗？指针好还是不好？" class="headerlink" title="指针是什么？你能不用指针写C++程序吗？指针好还是不好？"></a>指针是什么？你能不用指针写C++程序吗？指针好还是不好？</h2><ul>
<li><p>考察目的</p>
<ul>
<li>这个问题不仅考C基础和计算机原理基础，还可引申出引用，拷贝和移动语义，const correctness，value semantic等一票基础问题。</li>
</ul>
</li>
<li><p>参考答案</p>
<ul>
<li>C++用虚函数实现多态，用RAII（和析构，异常机制）实现自动资源管理，用拷贝和移动定义资源的复制和转移，进而用隐式成员（Rule of 5，析构，拷贝构造，拷贝赋值，移动构造，移动赋值）来帮助用户省去手写冗余代码，最终达到不多写一个字的资源管理。如果说面向对象的概念已经有些过时了，资源管理却是永不过时的，也是C++从机制上不同于C的最主要一点。有些人写的糟糕C++代码其实是把写面向过程套了一层class的皮、滥用多态让代码纠缠不清、最终既不仅没有简化逻辑，也没有简化资源管理。</li>
</ul>
</li>
</ul>
<h2 id="经典问题：vector和list有什么区别？"><a href="#经典问题：vector和list有什么区别？" class="headerlink" title="经典问题：vector和list有什么区别？"></a>经典问题：vector和list有什么区别？</h2><ul>
<li>考察目的<ul>
<li>一个不了解C++如何控制资源颗粒度的程序员恐怕不是一个好的C++程序员。可引申出一大票算法和数据结构问题。</li>
</ul>
</li>
</ul>
<p><code>std::vector</code>和<code>std::list</code>是C++标准库中的两种不同类型的容器，它们有一些重要的区别，主要涉及底层实现、内存分配和访问速度等方面。</p>
<ol>
<li><p><strong>底层实现：</strong></p>
<ul>
<li><code>std::vector</code> 是基于动态数组实现的，它在内存中是连续存储的，支持快速的随机访问。</li>
<li><code>std::list</code> 是基于双向链表实现的，每个元素在内存中是分散存储的，支持高效的插入和删除操作。</li>
</ul>
</li>
<li><p><strong>内存分配：</strong></p>
<ul>
<li><code>std::vector</code> 的内存是连续分配的，这样可以充分利用缓存，对于顺序访问元素非常高效。</li>
<li><code>std::list</code> 的内存是分散分配的，插入和删除操作不需要移动其他元素，因此在这些操作上更为高效。</li>
</ul>
</li>
<li><p><strong>插入和删除操作：</strong></p>
<ul>
<li><code>std::vector</code> 在末尾进行插入和删除操作是高效的，但在中间或头部进行插入和删除可能需要移动其他元素，效率较低。</li>
<li><code>std::list</code> 在任意位置进行插入和删除操作是高效的，因为它只需要调整相邻元素的指针。</li>
</ul>
</li>
<li><p><strong>随机访问：</strong></p>
<ul>
<li><code>std::vector</code> 支持常量时间的随机访问，因为它在内存中是连续存储的。</li>
<li><code>std::list</code> 不支持常量时间的随机访问，需要通过遍历链表来访问元素。</li>
</ul>
</li>
<li><p><strong>迭代器的稳定性：</strong></p>
<ul>
<li><code>std::vector</code> 在插入或删除元素后，可能会导致迭代器失效。</li>
<li><code>std::list</code> 在插入或删除元素后，仍然能够保持迭代器的有效性。</li>
</ul>
</li>
</ol>
<p>根据具体的需求，选择使用<code>std::vector</code>还是<code>std::list</code>。如果需要频繁的随机访问和在末尾进行插入和删除操作，<code>std::vector</code>可能更合适。如果需要在任意位置高效地进行插入和删除操作，或者迭代器稳定性对算法有重要影响，那么<code>std::list</code>可能更合适。</p>
<h2 id="C-为什么要有类型？"><a href="#C-为什么要有类型？" class="headerlink" title="C++为什么要有类型？"></a>C++为什么要有类型？</h2><ul>
<li>考察目的<ul>
<li>考对静态类型语言的理解和权衡，可引申出类型安全，泛型，模板元编程，编译时计算，静态多态等一众问题。</li>
</ul>
</li>
</ul>
<p>C++是一种静态类型的编程语言，这意味着在编译时就需要明确指定变量的类型。类型在C++中是一个非常重要的概念，它提供了以下几个关键的优势：</p>
<ol>
<li><p><strong>类型安全：</strong> 类型系统可以帮助在编译时捕捉一些错误，防止在运行时发生类型不匹配的问题。这有助于减少由于类型错误引起的潜在程序漏洞和错误。</p>
</li>
<li><p><strong>性能优化：</strong> 静态类型信息使得编译器可以进行更好的优化，生成更高效的机器代码。编译器能够在编译时知道变量的类型，从而进行更好的类型检查和优化。</p>
</li>
<li><p><strong>代码可读性：</strong> 类型信息提供了对代码含义的额外描述，使得代码更加清晰易懂。通过类型信息，读者可以更容易地理解代码的意图，从而提高代码的可维护性。</p>
</li>
<li><p><strong>代码组织和模块化：</strong> 类型有助于将代码组织成各种数据结构和抽象类型，从而支持更好的模块化和封装。这使得代码更易于维护和重用。</p>
</li>
<li><p><strong>静态分析和工具支持：</strong> 静态类型语言可以受益于许多静态分析工具，如编译器和IDE。这些工具可以在编码的早期阶段检测潜在的错误，提供更好的开发体验。</p>
</li>
<li><p><strong>安全性：</strong> 类型系统有助于防止一些类型相关的安全漏洞，如空指针引用、越界访问等。通过类型检查，可以避免一些常见的编程错误。</p>
</li>
<li><p><strong>代码可维护性：</strong> 类型系统有助于更好地组织和管理代码，提高代码的可维护性。类型信息可以作为文档，帮助开发人员理解和维护代码。</p>
</li>
</ol>
<p>尽管动态类型语言（如Python和JavaScript）在某些情况下更灵活，但静态类型语言的类型系统提供了一些关键的优势，特别是对于大型、复杂的项目。这种优势使得C++等静态类型语言在需要高性能、可维护和安全性的场景中得到广泛应用。</p>
<h2 id="进程间常用的通讯方式"><a href="#进程间常用的通讯方式" class="headerlink" title="进程间常用的通讯方式"></a>进程间常用的通讯方式</h2><p>进程间通信（Inter-Process Communication，IPC）是指在操作系统中，不同进程之间进行数据交换和通信的机制。常见的进程间通信方式包括：</p>
<ol>
<li><p><strong>管道（Pipe）</strong>：</p>
<ul>
<li>匿名管道：在父进程中创建，用于与子进程进行通信。只能实现单向通信。</li>
<li>命名管道：在文件系统中创建一个特殊类型的文件，多个进程可以通过打开该文件来进行通信。可以实现双向通信。</li>
</ul>
</li>
<li><p><strong>消息队列（Message Queues）</strong>：</p>
<ul>
<li>允许进程通过消息传递的方式进行通信，消息在队列中排队，接收方可以按照先后顺序处理消息。</li>
<li>提供了比管道更灵活的通信方式，可以实现双向通信。</li>
</ul>
</li>
<li><p><strong>信号量（Semaphores）</strong>：</p>
<ul>
<li>用于进程间的同步和互斥控制。可以用于多个进程之间的协调，以及资源的共享和保护。</li>
</ul>
</li>
<li><p><strong>共享内存（Shared Memory）</strong>：</p>
<ul>
<li>允许多个进程共享同一块内存区域，这样可以实现高效的数据交换。</li>
<li>由于共享内存操作的直接性和高效性，但也需要进行适当的同步和互斥控制，以避免数据一致性问题。</li>
</ul>
</li>
<li><p><strong>套接字（Sockets）</strong>：</p>
<ul>
<li>提供了网络编程中进程间通信的一种方式，不仅限于本地进程间通信，也可以在不同主机上的进程间进行通信。</li>
<li>套接字通信提供了高度灵活性和可扩展性，常用于网络应用程序的开发。</li>
</ul>
</li>
<li><p><strong>信号（Signals）</strong>：</p>
<ul>
<li>用于向进程发送异步通知，例如某个事件的发生或者异常的发生。</li>
<li>信号提供了一种轻量级的通信机制，用于处理特定的事件或者错误情况。</li>
</ul>
</li>
<li><p><strong>文件锁（File Locks）</strong>：</p>
<ul>
<li>通过对文件进行加锁来实现进程间的同步和互斥控制。</li>
<li>常用于控制对共享文件的访问，以避免多个进程同时修改文件造成的数据损坏。</li>
</ul>
</li>
</ol>
<p>选择适当的进程间通信方式取决于应用程序的需求和性能要求，通常需要权衡通信的复杂度、效率、可靠性和安全性等因素。</p>
<h2 id="C-std-vector扩容机制和实现原理"><a href="#C-std-vector扩容机制和实现原理" class="headerlink" title="C++ std::vector扩容机制和实现原理"></a>C++ std::vector扩容机制和实现原理</h2><p>C++标准库中的<code>std::vector</code>是一个动态数组，它可以根据需要自动扩容以容纳更多的元素。下面是<code>std::vector</code>的扩容机制和实现原理：</p>
<h3 id="扩容机制："><a href="#扩容机制：" class="headerlink" title="扩容机制："></a>扩容机制：</h3><ol>
<li><p><strong>初始容量（Initial Capacity）</strong>：</p>
<ul>
<li><code>std::vector</code>在创建时通常会分配一定的初始容量，以减少频繁的扩容操作。初始容量可以通过构造函数或<code>reserve()</code>函数指定。</li>
</ul>
</li>
<li><p><strong>动态扩容（Dynamic Resizing）</strong>：</p>
<ul>
<li>当向<code>std::vector</code>中添加元素时，如果当前容量不足以容纳新元素，则<code>std::vector</code>会动态地分配更大的内存空间，并将原有元素复制到新的内存区域中。</li>
<li>扩容操作通常会使得<code>std::vector</code>的容量成倍增加（例如，翻倍或乘以某个增长因子），以保证添加元素的时间复杂度为均摊常数时间。</li>
</ul>
</li>
</ol>
<h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h3><ol>
<li><p><strong>连续内存存储</strong>：</p>
<ul>
<li><code>std::vector</code>中的元素通常是连续存储的，即在内存中以连续的地址存储。这使得<code>std::vector</code>支持快速的随机访问和迭代。</li>
</ul>
</li>
<li><p><strong>分配器（Allocator）</strong>：</p>
<ul>
<li><code>std::vector</code>通过分配器（allocator）来管理内存的分配和释放。分配器是一个模板参数，默认使用<code>std::allocator</code>。</li>
<li>分配器负责分配和释放内存，并在需要时调用元素的构造函数和析构函数。</li>
</ul>
</li>
<li><p><strong>扩容策略</strong>：</p>
<ul>
<li>当<code>std::vector</code>需要扩容时，通常会分配比当前容量更大的内存空间，然后将原有元素复制到新的内存区域中，并释放原有内存空间。</li>
<li>扩容时通常会根据增长因子（例如2倍增长）计算新的容量，以减少扩容的次数和复制的次数，从而提高性能。</li>
</ul>
</li>
<li><p><strong>异常安全性</strong>：</p>
<ul>
<li><code>std::vector</code>保证在扩容过程中的异常安全性。如果在元素复制过程中发生异常，<code>std::vector</code>会保持不变，不会造成资源泄漏。</li>
</ul>
</li>
<li><p><strong>移动语义（Move Semantics）</strong>：</p>
<ul>
<li>C++11引入了移动语义，可以在元素复制过程中使用移动构造函数或移动赋值运算符，提高性能。当元素支持移动语义时，<code>std::vector</code>会优先使用移动操作而不是复制操作。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>std::vector</code>通过动态扩容机制和连续内存存储实现了高效的元素添加和访问操作。在添加元素时，如果当前容量不足，<code>std::vector</code>会动态地分配更大的内存空间，并将原有元素复制到新的内存区域中，以保证添加元素的时间复杂度为均摊常数时间。</p>
<h2 id="std-vector扩容-怎么查看扩容了多少"><a href="#std-vector扩容-怎么查看扩容了多少" class="headerlink" title="std::vector扩容 怎么查看扩容了多少"></a>std::vector扩容 怎么查看扩容了多少</h2><p>在C++标准库中，<code>std::vector</code>没有提供直接查看扩容量的方法。由于<code>std::vector</code>的实现细节被封装在库中，并且它的扩容行为是自动进行的，因此用户无法直接获取扩容量的信息。</p>
<p>但是，你可以通过以下方式间接了解<code>std::vector</code>的扩容行为：</p>
<ol>
<li><p><strong>预留空间（Reserve）</strong>：<code>std::vector</code>提供了<code>reserve()</code>函数，可以预留一定数量的元素空间，而不会实际添加元素。如果你在添加大量元素之前先调用<code>reserve()</code>函数，可以减少扩容的次数，间接降低了扩容的影响。</p>
</li>
<li><p><strong>容量查询（Capacity）</strong>：<code>std::vector</code>提供了<code>capacity()</code>函数，用于查询当前<code>std::vector</code>的容量（即已分配的内存空间大小）。虽然这并不直接告诉你扩容了多少，但可以通过跟踪容量的变化，大致了解扩容的频率和幅度。</p>
</li>
<li><p><strong>测试与分析</strong>：通过编写测试代码，并观察<code>std::vector</code>在添加元素时容量的变化，可以推断出扩容的情况。你可以在不同的情况下测试<code>std::vector</code>的扩容行为，例如在添加元素前后分别查询容量，比较它们的差异。</p>
</li>
</ol>
<p>虽然无法直接查看<code>std::vector</code>的扩容量，但通过上述方法，你可以了解到<code>std::vector</code>的扩容行为，并根据实际需求进行优化。</p>
<h2 id="C-std-vector是线程安全的吗"><a href="#C-std-vector是线程安全的吗" class="headerlink" title="C++ std::vector是线程安全的吗"></a>C++ std::vector是线程安全的吗</h2><p>在 C++ 标准库中，<code>std::vector</code> 并不是线程安全的。也就是说，如果多个线程同时访问和修改同一个 <code>std::vector</code> 实例，而其中至少有一个线程对其进行了修改操作（比如添加、删除元素等），就会导致未定义行为（Undefined Behavior）。</p>
<p>以下是一些可能导致问题的情况：</p>
<ol>
<li><p><strong>并发访问和修改</strong>：多个线程同时对同一个 <code>std::vector</code> 进行读写操作，没有采取适当的同步措施。</p>
</li>
<li><p><strong>数据竞争</strong>：当一个线程在添加或删除元素时，另一个线程可能同时进行其他操作，导致数据竞争和未定义行为。</p>
</li>
</ol>
<p>为了确保线程安全性，需要采取适当的同步措施，比如使用互斥锁（<code>std::mutex</code>）、读写锁（<code>std::shared_mutex</code>）、信号量等机制来保护 <code>std::vector</code> 的并发访问。另外，C++17 中引入了并行算法（parallel algorithms），其中的一些算法可以安全地并发地处理容器，包括 <code>std::vector</code>。</p>
<p>在多线程环境中使用 <code>std::vector</code> 时，需要特别注意以下几点：</p>
<ul>
<li><p><strong>避免共享</strong>：尽量避免多个线程共享同一个 <code>std::vector</code> 实例，如果需要共享，确保采取了适当的同步措施。</p>
</li>
<li><p><strong>使用线程安全容器</strong>：考虑使用线程安全的容器，比如 <code>std::shared_mutex</code> 或第三方线程安全容器库。</p>
</li>
<li><p><strong>注意迭代器失效</strong>：在多线程环境中进行添加、删除操作时，要注意迭代器的失效问题，避免产生悬空指针。</p>
</li>
</ul>
<p>总之，在多线程环境中使用 <code>std::vector</code> 时，一定要确保采取了适当的线程同步措施，以避免数据竞争和未定义行为。</p>
<h2 id="std-vector多线程访问会崩溃吗？"><a href="#std-vector多线程访问会崩溃吗？" class="headerlink" title="std::vector多线程访问会崩溃吗？"></a>std::vector多线程访问会崩溃吗？</h2><p>在多线程环境中访问 <code>std::vector</code> 可能会导致程序崩溃，但不是一定会发生。具体是否会崩溃取决于多个因素，包括线程访问顺序、访问的方式、操作系统和编译器的实现等。</p>
<p>以下是一些可能导致程序崩溃的情况：</p>
<ol>
<li><p><strong>数据竞争</strong>：如果多个线程同时对同一个 <code>std::vector</code> 进行读写操作，并且没有采取适当的同步措施（比如互斥锁），就会导致数据竞争，进而导致未定义行为，包括程序崩溃。</p>
</li>
<li><p><strong>迭代器失效</strong>：在多线程环境中，如果一个线程在对 <code>std::vector</code> 进行添加或删除操作时，另一个线程同时进行迭代器操作（比如遍历、删除元素等），就有可能导致迭代器失效，进而导致程序崩溃。</p>
</li>
<li><p><strong>内存分配问题</strong>：如果多个线程同时对 <code>std::vector</code> 进行扩容操作，并且没有采取适当的同步措施，可能会导致内存分配问题，进而导致程序崩溃。</p>
</li>
<li><p><strong>操作系统和编译器实现</strong>：不同的操作系统和编译器实现对多线程访问 <code>std::vector</code> 的行为可能有所不同，一些实现可能会检测到并发访问，并在必要时引发异常或终止程序。</p>
</li>
</ol>
<p>综上所述，虽然在多线程环境中访问 <code>std::vector</code> 可能会导致程序崩溃，但并不是一定会发生。为了确保程序的稳定性和可靠性，必须采取适当的线程同步措施，以避免数据竞争和未定义行为。</p>
<h2 id="std-vector扩容的时候多线程访问会崩溃吗"><a href="#std-vector扩容的时候多线程访问会崩溃吗" class="headerlink" title="std::vector扩容的时候多线程访问会崩溃吗"></a>std::vector扩容的时候多线程访问会崩溃吗</h2><p>在多线程环境中，如果多个线程同时访问一个 <code>std::vector</code> 实例，并且其中至少有一个线程在进行扩容操作（比如调用 <code>push_back()</code> 添加元素导致容量不足），那么确实存在一定的风险，可能会导致程序崩溃或产生未定义行为。</p>
<p>以下是可能导致问题的情况：</p>
<ol>
<li><p><strong>数据竞争</strong>：如果一个线程正在扩容 <code>std::vector</code>，而另一个线程同时在对 <code>std::vector</code> 进行其他操作（比如访问元素、修改元素、删除元素等），并且没有采取适当的同步措施（比如使用互斥锁），就会导致数据竞争，从而产生未定义行为。</p>
</li>
<li><p><strong>内存分配问题</strong>：<code>std::vector</code> 在扩容时需要重新分配内存空间，并且将原来的元素拷贝到新的内存空间中。如果多个线程同时进行扩容操作，可能会导致内存分配冲突或拷贝过程中的数据不一致，进而导致程序崩溃。</p>
</li>
</ol>
<p>为了避免这种情况，可以采取以下几种方式：</p>
<ul>
<li><p><strong>线程同步</strong>：在多线程环境中使用 <code>std::vector</code> 时，确保对其进行操作的线程之间采取适当的同步措施，比如使用互斥锁来保护对 <code>std::vector</code> 的访问。</p>
</li>
<li><p><strong>单线程访问</strong>：如果可能的话，尽量避免多个线程同时访问同一个 <code>std::vector</code> 实例，可以通过线程间的消息传递或者将 <code>std::vector</code> 复制到每个线程中来避免并发访问。</p>
</li>
</ul>
<p>总之，在多线程环境中使用 <code>std::vector</code> 时，一定要格外小心，并确保采取了适当的线程同步措施，以避免数据竞争和未定义行为。</p>
<h2 id="std-vector扩容的方法"><a href="#std-vector扩容的方法" class="headerlink" title="std::vector扩容的方法"></a>std::vector扩容的方法</h2><p>在 C++ 标准库中，<code>std::vector</code> 的扩容是由容器自动管理的，而不是由用户手动控制的。当 <code>std::vector</code> 中的元素数量达到当前容量时，如果继续添加新元素，则会触发扩容操作，以确保足够的内存空间来容纳新元素。</p>
<p>下面是 <code>std::vector</code> 扩容的一般过程：</p>
<ol>
<li><p><strong>检查容量</strong>：在添加新元素之前，<code>std::vector</code> 会先检查当前容器的大小和容量。如果当前元素数量已经达到了容器的容量上限，则需要进行扩容。</p>
</li>
<li><p><strong>分配新空间</strong>：一旦需要扩容，<code>std::vector</code> 会分配一块新的内存空间，通常是原来容量的两倍大小（具体实现可能有所不同）。</p>
</li>
<li><p><strong>移动元素</strong>：然后，<code>std::vector</code> 会将原来的元素从旧的内存空间移动到新的内存空间中。这个过程可能会涉及到大量的内存拷贝或移动操作。</p>
</li>
<li><p><strong>释放旧空间</strong>：最后，<code>std::vector</code> 会释放原来的内存空间，以避免内存泄漏。</p>
</li>
</ol>
<p>在这个过程中，用户不需要手动介入或控制扩容操作，一切都由 <code>std::vector</code> 自动完成。这种自动扩容的机制可以简化代码，减少了用户的工作量，并且保证了 <code>std::vector</code> 的动态增长能力。</p>
<p>虽然用户无法手动控制 <code>std::vector</code> 的扩容过程，但可以通过 <code>reserve()</code> 函数来预留一定大小的内存空间，以减少扩容操作的频率，从而提高性能。<code>reserve()</code> 函数可以在添加大量元素之前预留足够的内存空间，避免多次扩容操作。</p>
<h2 id="std-vector缩容的方法"><a href="#std-vector缩容的方法" class="headerlink" title="std::vector缩容的方法"></a>std::vector缩容的方法</h2><p>在 C++ 标准库中，<code>std::vector</code> 并没有提供直接的缩容方法。相比之下，<code>std::vector</code> 的扩容是由容器自动管理的，而不需要用户手动介入。当元素数量减少时，<code>std::vector</code> 并不会立即释放多余的内存，而是保留这些空闲内存以备将来使用，以减少频繁的内存分配和释放操作，从而提高性能。</p>
<p>但是，如果用户确实希望手动释放 <code>std::vector</code> 中多余的内存，可以考虑使用以下方法之一：</p>
<ol>
<li><strong>使用 <code>shrink_to_fit()</code> 函数</strong>：</li>
</ol>
<p><code>shrink_to_fit()</code> 函数可以请求将 <code>std::vector</code> 的容量减小到与其当前大小相匹配的值。但是，这只是一个请求，具体是否会真正地释放多余的内存，取决于具体的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="comment">// 添加元素到 vector 中</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩小容量</span></span><br><span class="line">vec.<span class="built_in">shrink_to_fit</span>();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>**重新分配一个新的 <code>std::vector</code>**：</li>
</ol>
<p>如果希望完全释放 <code>std::vector</code> 中的多余内存，可以创建一个新的 <code>std::vector</code>，并使用移动语义将元素从原来的 <code>std::vector</code> 移动到新的 <code>std::vector</code> 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; oldVec;</span><br><span class="line"><span class="comment">// 添加元素到原 vector 中</span></span><br><span class="line">oldVec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">oldVec.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">oldVec.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的 vector，并使用移动语义将元素从原 vector 移动到新 vector 中</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(std::move(oldVec))</span></span>;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，缩容操作可能会导致内存重新分配和元素的拷贝或移动，因此应该谨慎使用。通常情况下，由于 <code>std::vector</code> 的动态增长能力和性能表现，用户无需过多关注内存的释放和缩容操作。</p>
<h2 id="C-std-map底层原理-详解"><a href="#C-std-map底层原理-详解" class="headerlink" title="C++ std::map底层原理 详解"></a>C++ std::map底层原理 详解</h2><p><code>std::map</code> 是 C++ 标准库提供的关联容器，它提供了基于键值对的存储和快速的查找功能。<code>std::map</code> 的底层通常使用红黑树（Red-Black Tree）实现。下面是关于 <code>std::map</code> 的底层原理的详细解释：</p>
<h3 id="红黑树（Red-Black-Tree）："><a href="#红黑树（Red-Black-Tree）：" class="headerlink" title="红黑树（Red-Black Tree）："></a>红黑树（Red-Black Tree）：</h3><ol>
<li><p><strong>定义</strong>：</p>
<ul>
<li>红黑树是一种自平衡的二叉搜索树，它在每个节点上都增加了一个额外的存储位来表示节点的颜色（红色或黑色）。</li>
<li>红黑树满足以下性质：<ol>
<li>每个节点要么是红色，要么是黑色。</li>
<li>根节点是黑色的。</li>
<li>每个叶子节点（NIL节点，空节点）是黑色的。</li>
<li>如果一个节点是红色的，则其子节点必须是黑色的。</li>
<li>从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>操作</strong>：</p>
<ul>
<li>插入、删除和查找操作在红黑树上执行，以保持红黑树的平衡性质。</li>
</ul>
</li>
</ol>
<h3 id="std-map-的底层实现："><a href="#std-map-的底层实现：" class="headerlink" title="std::map 的底层实现："></a>std::map 的底层实现：</h3><ol>
<li><p><strong>数据结构</strong>：</p>
<ul>
<li><code>std::map</code> 的底层通常使用红黑树实现。每个节点包含一个键值对（key-value pair），键值对根据键的大小顺序排列。</li>
<li>由于红黑树是一种自平衡二叉搜索树，因此 <code>std::map</code> 中的元素是有序存储的。</li>
</ul>
</li>
<li><p><strong>查找操作</strong>：</p>
<ul>
<li><code>std::map</code> 的查找操作具有较好的时间复杂度，通常为 O(log n)，其中 n 为 <code>std::map</code> 中元素的数量。</li>
<li>查找操作通过红黑树的特性进行，在每次比较后，根据比较结果向左或向右移动，直到找到目标元素或到达叶子节点。</li>
</ul>
</li>
<li><p><strong>插入和删除操作</strong>：</p>
<ul>
<li><code>std::map</code> 的插入和删除操作会触发红黑树的平衡调整，以保持红黑树的平衡性质。</li>
<li>插入操作会根据插入元素的键值，找到合适的位置并插入，然后进行必要的平衡调整。</li>
<li>删除操作会删除目标元素，并进行必要的平衡调整。</li>
</ul>
</li>
<li><p><strong>迭代器</strong>：</p>
<ul>
<li><code>std::map</code> 的迭代器提供了有序访问元素的功能，可以按照键值的顺序进行遍历。</li>
</ul>
</li>
</ol>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p><code>std::map</code> 底层通常使用红黑树实现，通过红黑树的自平衡特性，实现了快速的插入、删除和查找操作，并且提供了有序存储和遍历的功能。红黑树的平衡性保证了 <code>std::map</code> 的性能稳定性，在大多数情况下具有较好的性能表现。</p>
<h2 id="std-map是线程安全的吗？"><a href="#std-map是线程安全的吗？" class="headerlink" title="std::map是线程安全的吗？"></a>std::map是线程安全的吗？</h2><p>不，<code>std::map</code> 是 C++ STL 中的关联容器，它并不是线程安全的。</p>
<p>在 C++11 之前的标准中，C++ STL 的容器类（包括 <code>std::map</code>）都不提供多线程安全的保证。如果在多个线程中同时对同一个 <code>std::map</code> 进行读写操作，会导致数据竞争和未定义行为，可能导致程序崩溃或产生不确定的结果。</p>
<p>为了在多线程环境中安全地使用 <code>std::map</code>，可以采用以下几种方法之一：</p>
<ol>
<li><strong>互斥量（Mutex）：</strong> 使用互斥量来保护 <code>std::map</code>，在对其进行读写操作时加锁，保证同一时刻只有一个线程可以对其进行操作。</li>
<li><strong>使用线程安全的容器：</strong> 一些 C++ 标准库的实现提供了线程安全版本的容器，如 <code>std::map</code> 的线程安全版本 <code>std::mutex</code>。使用这些容器可以简化多线程编程，并且避免手动管理互斥量带来的复杂性。</li>
<li><strong>使用锁粒度更细的并发数据结构：</strong> 一些并发数据结构（如 <code>std::shared_mutex</code>、<code>std::atomic</code>、<code>std::atomic_shared_ptr</code> 等）可以在细粒度上实现线程安全，从而提高并发性。</li>
</ol>
<p>需要注意的是，对于某些特定的应用场景，可能需要根据实际情况选择合适的线程安全策略。</p>
<h2 id="能够使std-map变为线程安全的吗？"><a href="#能够使std-map变为线程安全的吗？" class="headerlink" title="能够使std::map变为线程安全的吗？"></a>能够使std::map变为线程安全的吗？</h2><p>是的，可以通过使用互斥量（mutex）或使用并发容器等方式使 <code>std::map</code> 变为线程安全的。以下是两种常见的方法：</p>
<ol>
<li><strong>使用互斥量（Mutex）：</strong> 在对 <code>std::map</code> 进行读写操作时，使用互斥量进行加锁，以确保同一时刻只有一个线程对 <code>std::map</code> 进行操作。可以使用 <code>std::mutex</code> 或 <code>std::shared_mutex</code> 来实现互斥量的锁定和解锁。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; myMap;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertToMap</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 加锁</span></span><br><span class="line">    myMap[key] = value;</span><br><span class="line">&#125; <span class="comment">// 自动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getFromMap</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">return</span> myMap[key];</span><br><span class="line">&#125; <span class="comment">// 自动解锁</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用线程安全的容器：</strong> 一些 C++ 标准库的实现提供了线程安全版本的容器，如 <code>std::map</code> 的线程安全版本 <code>std::mutex</code>。使用这些容器可以简化多线程编程，并且避免手动管理互斥量带来的复杂性。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; myMap;</span><br><span class="line">std::shared_mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertToMap</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 加锁</span></span><br><span class="line">    myMap[key] = value;</span><br><span class="line">&#125; <span class="comment">// 自动解锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getFromMap</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">return</span> myMap[key];</span><br><span class="line">&#125; <span class="comment">// 自动解锁</span></span><br></pre></td></tr></table></figure>

<p>在以上两种方法中，通过互斥量或线程安全容器的方式，可以确保在多线程环境中对 <code>std::map</code> 的安全访问，避免了数据竞争和未定义行为的发生。</p>
<h2 id="如何实现无锁std-map"><a href="#如何实现无锁std-map" class="headerlink" title="如何实现无锁std::map"></a>如何实现无锁std::map</h2><p>实现无锁的 <code>std::map</code> 是一个相当复杂的任务，需要考虑到并发访问和数据一致性等方面的问题。通常情况下，为了实现无锁的容器，需要使用一些基于并发编程原理的数据结构，比如并发哈希表、跳跃表等。以下是一种可能的无锁 <code>std::map</code> 的简单实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockFreeMap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        std::atomic&lt;Node*&gt; next;</span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">const</span> Key&amp; k, <span class="type">const</span> Value&amp; v) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::atomic&lt;Node*&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LockFreeMap</span>() : <span class="built_in">head</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LockFreeMap</span>() &#123;</span><br><span class="line">        Node* current = head.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">while</span> (current) &#123;</span><br><span class="line">            Node* next = current-&gt;next.<span class="built_in">load</span>();</span><br><span class="line">            <span class="keyword">delete</span> current;</span><br><span class="line">            current = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> Key&amp; key, <span class="type">const</span> Value&amp; value)</span> </span>&#123;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">        Node* current = head.<span class="built_in">load</span>();</span><br><span class="line">        Node* previous = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current &amp;&amp; current-&gt;key &lt; key) &#123;</span><br><span class="line">                previous = current;</span><br><span class="line">                current = current-&gt;next.<span class="built_in">load</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (previous &amp;&amp; previous-&gt;next.<span class="built_in">load</span>() != current) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            newNode-&gt;next.<span class="built_in">store</span>(current);</span><br><span class="line">            <span class="keyword">if</span> (!previous-&gt;next.<span class="built_in">compare_exchange_weak</span>(current, newNode)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">const</span> Key&amp; key, Value&amp; value)</span> </span>&#123;</span><br><span class="line">        Node* current = head.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">while</span> (current &amp;&amp; current-&gt;key &lt; key) &#123;</span><br><span class="line">            current = current-&gt;next.<span class="built_in">load</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current &amp;&amp; current-&gt;key == key) &#123;</span><br><span class="line">            value = current-&gt;value;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选的删除函数</span></span><br><span class="line">    <span class="comment">// void remove(const Key&amp; key) &#123;&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是一个基于链表的简单无锁 <code>std::map</code> 实现，它使用了原子操作来保证并发访问的正确性。在实际应用中，要实现一个高效的无锁 <code>std::map</code> 需要考虑更多的细节，如内存管理、并发冲突解决策略、性能优化等。因此，对于实际的生产环境，建议使用已经经过充分测试和优化的现有并发容器库，而不是自己编写无锁数据结构。</p>
<h2 id="hashmap-详解"><a href="#hashmap-详解" class="headerlink" title="hashmap 详解"></a>hashmap 详解</h2><p>哈希表（Hash Map）是一种常见的数据结构，它基于哈希函数实现了键值对的存储和快速的查找操作。下面是哈希表的详细解释：</p>
<h3 id="哈希表的结构和原理："><a href="#哈希表的结构和原理：" class="headerlink" title="哈希表的结构和原理："></a>哈希表的结构和原理：</h3><ol>
<li><p><strong>数据结构</strong>：</p>
<ul>
<li>哈希表由一个数组（或称为桶、槽）和一个哈希函数组成。数组的每个元素称为一个桶，每个桶可以存储一个或多个键值对。</li>
<li>哈希函数将键映射到数组索引，将键值对存储在相应的桶中。</li>
</ul>
</li>
<li><p><strong>哈希函数</strong>：</p>
<ul>
<li>哈希函数接受一个键作为输入，并生成一个固定大小的哈希码（哈希值）。哈希码可以将键映射到数组索引。</li>
<li>好的哈希函数应该具有以下特性：<ul>
<li>一致性：对于相同的键，哈希函数应始终生成相同的哈希码。</li>
<li>均匀性：哈希函数应将键均匀地映射到数组索引，以减少冲突（多个键映射到同一个索引）的发生。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>解决冲突</strong>：</p>
<ul>
<li>由于哈希函数的输出空间通常小于键的集合，可能会发生冲突。冲突是指多个键映射到同一个数组索引的情况。</li>
<li>哈希表通常使用开放地址法或链地址法来解决冲突：<ul>
<li>开放地址法：发生冲突时，通过探测序列在哈希表中查找下一个可用的位置。</li>
<li>链地址法：在数组每个位置上存储一个链表（或其他数据结构），将冲突的键值对存储在同一个位置的链表中。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="哈希表的优点和缺点："><a href="#哈希表的优点和缺点：" class="headerlink" title="哈希表的优点和缺点："></a>哈希表的优点和缺点：</h3><ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li>快速的查找操作：通过哈希函数直接定位到存储位置，平均时间复杂度为 O(1)。</li>
<li>灵活的存储空间：根据需求动态分配数组大小，节省内存空间。</li>
<li>适用于大规模数据：在数据量大的情况下，哈希表通常比线性数据结构更高效。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>冲突处理：冲突可能会影响性能，需要选择合适的解决冲突方法。</li>
<li>内存消耗：需要额外的内存空间来存储哈希表数组，且存在一定的内存浪费。</li>
<li>哈希函数设计：选择合适的哈希函数对性能影响较大，不同的数据集可能需要不同的哈希函数。</li>
</ul>
</li>
</ul>
<h3 id="C-中的哈希表："><a href="#C-中的哈希表：" class="headerlink" title="C++ 中的哈希表："></a>C++ 中的哈希表：</h3><p>在 C++ 标准库中，<code>std::unordered_map</code> 提供了哈希表的实现，它基于哈希函数和链地址法解决冲突。使用 <code>std::unordered_map</code> 可以实现键值对的快速存储和查找，具有和哈希表相似的特性。</p>
<h2 id="读写锁与互斥锁的区别"><a href="#读写锁与互斥锁的区别" class="headerlink" title="读写锁与互斥锁的区别"></a>读写锁与互斥锁的区别</h2><p>读写锁（RW锁）和互斥锁（Mutex锁）都是用于多线程编程中实现线程同步的机制，但它们在实现方式和应用场景上有所不同。</p>
<h3 id="1-读写锁（RW锁）："><a href="#1-读写锁（RW锁）：" class="headerlink" title="1. 读写锁（RW锁）："></a>1. 读写锁（RW锁）：</h3><ul>
<li><strong>适用场景</strong>：适用于读操作频繁、写操作较少的场景，例如读多写少的共享资源。</li>
<li><strong>并发性</strong>：允许多个线程同时获取读锁，但只允许一个线程获取写锁。</li>
<li><strong>特点</strong>：读锁之间不互斥，可以并发读取共享资源；写锁与读锁和写锁都互斥，保证在写操作时不会有其他读写操作。</li>
<li><strong>性能</strong>：在读操作远远多于写操作时，性能优于互斥锁，因为允许并发读取。</li>
</ul>
<h3 id="2-互斥锁（Mutex锁）："><a href="#2-互斥锁（Mutex锁）：" class="headerlink" title="2. 互斥锁（Mutex锁）："></a>2. 互斥锁（Mutex锁）：</h3><ul>
<li><strong>适用场景</strong>：适用于对共享资源进行临界区保护，即任何时刻只能有一个线程访问共享资源的场景。</li>
<li><strong>并发性</strong>：一次只允许一个线程持有锁，其他线程需要等待锁的释放才能继续执行。</li>
<li><strong>特点</strong>：线程之间互斥，保证临界区的互斥访问，防止竞争条件和数据不一致性问题。</li>
<li><strong>性能</strong>：在并发度较低、临界区保护较小的情况下性能较好，但在读操作较多时可能会成为性能瓶颈。</li>
</ul>
<h3 id="区别总结：-1"><a href="#区别总结：-1" class="headerlink" title="区别总结："></a>区别总结：</h3><ul>
<li><strong>并发性</strong>：读写锁允许多个线程同时获取读锁，但只允许一个线程获取写锁；互斥锁一次只允许一个线程持有锁。</li>
<li><strong>适用场景</strong>：读写锁适用于读操作频繁、写操作较少的场景；互斥锁适用于任何时刻只能有一个线程访问临界区的场景。</li>
<li><strong>性能</strong>：在读操作频繁、写操作较少的情况下，读写锁的性能优于互斥锁；在并发度低、临界区保护较小的情况下，互斥锁性能较好。</li>
</ul>
<p>总的来说，读写锁适用于读多写少的场景，提高了并发读取共享资源的能力；而互斥锁适用于临界区保护，保证了临界区的互斥访问，防止了竞争条件和数据不一致性问题。在选择锁的时候需要根据具体的应用场景和性能需求来进行选择。</p>
<h2 id="C-std-vector-和-std-queue的区别"><a href="#C-std-vector-和-std-queue的区别" class="headerlink" title="C++ std::vector 和 std::queue的区别"></a>C++ std::vector 和 std::queue的区别</h2><p><code>std::vector</code> 和 <code>std::queue</code> 都是 C++ 标准库中提供的容器，但它们在功能和用途上有一些不同之处。</p>
<h3 id="std-vector："><a href="#std-vector：" class="headerlink" title="std::vector："></a>std::vector：</h3><ul>
<li><strong>容器类型</strong>：<code>std::vector</code> 是一个动态数组容器，可以动态增长和缩小，支持随机访问和元素的插入、删除操作。</li>
<li><strong>特点</strong>：<code>std::vector</code> 的元素在内存中是连续存储的，支持随机访问和常数时间的尾部插入和删除操作，但在中间插入和删除操作的时间复杂度较高。</li>
<li><strong>用途</strong>：适用于需要随机访问和动态增长的情况，如数组、动态数组、缓冲区等。</li>
</ul>
<h3 id="std-queue："><a href="#std-queue：" class="headerlink" title="std::queue："></a>std::queue：</h3><ul>
<li><strong>容器类型</strong>：<code>std::queue</code> 是一个队列容器，实现了先进先出（FIFO）的数据结构，只能在队尾插入元素，在队头删除元素。</li>
<li><strong>特点</strong>：<code>std::queue</code> 提供了入队（push）、出队（pop）、查看队头元素（front）、查看队尾元素（back）等操作，但不支持随机访问和中间插入删除操作。</li>
<li><strong>用途</strong>：适用于需要按照先进先出顺序处理元素的情况，如任务队列、消息队列等。</li>
</ul>
<h3 id="区别总结：-2"><a href="#区别总结：-2" class="headerlink" title="区别总结："></a>区别总结：</h3><ul>
<li><strong>功能</strong>：<code>std::vector</code> 提供了动态数组的功能，支持随机访问和动态增长；<code>std::queue</code> 实现了队列的功能，支持先进先出的操作。</li>
<li><strong>操作</strong>：<code>std::vector</code> 支持随机访问、插入、删除等操作；<code>std::queue</code> 只支持入队、出队等队列操作。</li>
<li><strong>性能</strong>：<code>std::vector</code> 的随机访问和尾部插入删除操作的性能较好；<code>std::queue</code> 的入队和出队操作的性能较好。</li>
</ul>
<p>综上所述，<code>std::vector</code> 和 <code>std::queue</code> 在功能和用途上有所不同，开发者需要根据具体的需求来选择合适的容器类型。如果需要随机访问和动态增长，可以选择 <code>std::vector</code>；如果需要先进先出的队列操作，可以选择 <code>std::queue</code>。</p>
<h2 id="C-std-vector-push-back-是怎么操作的-详解"><a href="#C-std-vector-push-back-是怎么操作的-详解" class="headerlink" title="C++ std::vector::push_back()是怎么操作的 详解"></a>C++ std::vector::push_back()是怎么操作的 详解</h2><p><code>std::vector::push_back()</code> 是 C++ 标准库中 <code>std::vector</code> 容器提供的一个成员函数，用于在 vector 的末尾添加一个元素。这个操作的实现方式涉及到 vector 的内部机制，下面是对 <code>std::vector::push_back()</code> 操作的详细解释：</p>
<h3 id="1-实现原理："><a href="#1-实现原理：" class="headerlink" title="1. 实现原理："></a>1. 实现原理：</h3><ul>
<li><strong>空间分配</strong>：当调用 <code>push_back()</code> 添加元素时，如果 vector 的内部存储空间不足以容纳新的元素，会自动进行空间的重新分配。</li>
<li><strong>内存分配</strong>：通常情况下，vector 会分配比当前容量大一定倍数的内存空间（如两倍），然后将原来的元素拷贝到新的内存空间中。</li>
<li><strong>添加元素</strong>：在空间重新分配之后，新的元素会被添加到 vector 的末尾，更新 vector 的大小和容量信息。</li>
<li><strong>复杂度</strong>：通常情况下，<code>push_back()</code> 操作的时间复杂度为 O(1)，但当 vector 需要重新分配空间时，时间复杂度会变为 O(N)，其中 N 是 vector 中元素的数量。</li>
</ul>
<h3 id="2-代码示例："><a href="#2-代码示例：" class="headerlink" title="2. 代码示例："></a>2. 代码示例：</h3><p>下面是一个简单的代码示例，演示了如何使用 <code>push_back()</code> 添加元素到 vector 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加元素到 vector 中</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 vector 中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-注意事项："><a href="#3-注意事项：" class="headerlink" title="3. 注意事项："></a>3. 注意事项：</h3><ul>
<li><strong>空间重新分配</strong>：频繁调用 <code>push_back()</code> 可能会触发多次空间重新分配，影响性能。为了避免这种情况，可以通过 <code>reserve()</code> 函数预留一定大小的空间，减少空间重新分配的次数。</li>
<li><strong>异常安全性</strong>：<code>push_back()</code> 操作在添加元素时可能会抛出异常（如内存分配失败），因此在使用时需要注意异常安全性。</li>
</ul>
<p>总的来说，<code>std::vector::push_back()</code> 是向 <code>std::vector</code> 容器中添加元素的常用操作，它通过动态分配内存空间来实现元素的添加，并且具有较好的性能特性。</p>
<h2 id="C-std-vector-push-back-和std-vector-emplace-back-的区别"><a href="#C-std-vector-push-back-和std-vector-emplace-back-的区别" class="headerlink" title="C++ std::vector::push_back()和std::vector::emplace_back()的区别"></a>C++ std::vector::push_back()和std::vector::emplace_back()的区别</h2><p><code>std::vector::push_back()</code> 和 <code>std::vector::emplace_back()</code> 都是 <code>std::vector</code> 容器提供的成员函数，用于在 vector 的末尾添加一个元素。它们的主要区别在于元素的构造方式和参数传递方式。</p>
<h3 id="std-vector-push-back-："><a href="#std-vector-push-back-：" class="headerlink" title="std::vector::push_back()："></a>std::vector::push_back()：</h3><ul>
<li><strong>作用</strong>：<code>push_back()</code> 用于将一个已存在的元素添加到 vector 的末尾。</li>
<li><strong>参数</strong>：接受一个元素类型的参数，通常是元素的拷贝或移动。</li>
<li><strong>构造方式</strong>：会调用元素类型的拷贝构造函数或移动构造函数来创建新的元素。</li>
<li><strong>适用情况</strong>：适用于已存在的元素，或需要从已有的对象创建新的元素。</li>
</ul>
<h3 id="std-vector-emplace-back-："><a href="#std-vector-emplace-back-：" class="headerlink" title="std::vector::emplace_back()："></a>std::vector::emplace_back()：</h3><ul>
<li><strong>作用</strong>：<code>emplace_back()</code> 用于在 vector 的末尾直接构造一个新的元素。</li>
<li><strong>参数</strong>：接受与元素类型的构造函数相匹配的参数，直接传递给元素类型的构造函数。</li>
<li><strong>构造方式</strong>：直接调用元素类型的构造函数来创建新的元素，避免了拷贝或移动的开销。</li>
<li><strong>适用情况</strong>：适用于直接构造新的元素，或需要通过构造函数参数来初始化元素。</li>
</ul>
<h3 id="区别总结：-3"><a href="#区别总结：-3" class="headerlink" title="区别总结："></a>区别总结：</h3><ul>
<li><strong>构造方式</strong>：<code>push_back()</code> 使用拷贝构造函数或移动构造函数来创建新的元素；<code>emplace_back()</code> 直接调用构造函数来构造新的元素。</li>
<li><strong>参数传递</strong>：<code>push_back()</code> 接受元素类型的参数，通常是拷贝或移动的形式；<code>emplace_back()</code> 接受构造函数的参数，直接传递给元素类型的构造函数。</li>
<li><strong>性能</strong>：由于避免了拷贝或移动的开销，<code>emplace_back()</code> 的性能可能会比 <code>push_back()</code> 更好。</li>
</ul>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;Foo&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 push_back() 添加元素</span></span><br><span class="line">    <span class="function">Foo <span class="title">foo1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(foo1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 emplace_back() 添加元素</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 vector 中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Foo&amp; foo : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; foo.value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>push_back()</code> 使用已存在的对象 <code>foo1</code> 添加元素，而 <code>emplace_back()</code> 直接通过构造函数参数来构造新的元素。</p>
<h2 id="面向对象编程-多态详解"><a href="#面向对象编程-多态详解" class="headerlink" title="面向对象编程 多态详解"></a>面向对象编程 多态详解</h2><p>面向对象编程（Object-Oriented Programming，OOP）中的多态（Polymorphism）是指同一个类的不同对象对同一个消息会做出不同的响应。具体来说，多态有两种形式：编译时多态（静态多态）和运行时多态（动态多态）。</p>
<h3 id="1-编译时多态（静态多态）："><a href="#1-编译时多态（静态多态）：" class="headerlink" title="1. 编译时多态（静态多态）："></a>1. 编译时多态（静态多态）：</h3><p>编译时多态是通过函数的重载和模板实现的，也称为静态多态。在编译时多态中，编译器根据函数参数的类型、个数和顺序来选择调用合适的函数或模板实例。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Integer: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5</span>);        <span class="comment">// 调用 print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);     <span class="comment">// 调用 print(double)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-运行时多态（动态多态）："><a href="#2-运行时多态（动态多态）：" class="headerlink" title="2. 运行时多态（动态多态）："></a>2. 运行时多态（动态多态）：</h3><p>运行时多态是通过继承和虚函数实现的，也称为动态多态。在运行时多态中，当基类指针或引用指向派生类对象时，通过虚函数表（vtable）实现动态绑定，即根据对象的实际类型来调用对应的函数。</p>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal makes a sound&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog barks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cat meows&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal* animalPtr;</span><br><span class="line"></span><br><span class="line">    Dog dog;</span><br><span class="line">    Cat cat;</span><br><span class="line"></span><br><span class="line">    animalPtr = &amp;dog;</span><br><span class="line">    animalPtr-&gt;<span class="built_in">makeSound</span>();   <span class="comment">// 输出: Dog barks</span></span><br><span class="line"></span><br><span class="line">    animalPtr = &amp;cat;</span><br><span class="line">    animalPtr-&gt;<span class="built_in">makeSound</span>();   <span class="comment">// 输出: Cat meows</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-多态的优点："><a href="#3-多态的优点：" class="headerlink" title="3. 多态的优点："></a>3. 多态的优点：</h3><ul>
<li><p><strong>可扩展性</strong>：通过继承和虚函数实现的多态使得程序更容易扩展和维护，可以在不修改现有代码的情况下添加新的派生类和功能。</p>
</li>
<li><p><strong>灵活性</strong>：多态允许基类指针或引用指向派生类对象，使得同一段代码能够处理不同类型的对象，从而提高了代码的灵活性和复用性。</p>
</li>
<li><p><strong>简化代码</strong>：多态可以使代码更简洁和清晰，通过统一的接口和行为来处理不同类型的对象，减少了条件语句的使用。</p>
</li>
</ul>
<p>总的来说，多态是面向对象编程中的一个重要概念，通过将不同类型的对象统一对待，实现了代码的灵活性、可扩展性和简洁性。</p>
<h2 id="C-静态多态的细节和过程-详解"><a href="#C-静态多态的细节和过程-详解" class="headerlink" title="C++ 静态多态的细节和过程 详解"></a>C++ 静态多态的细节和过程 详解</h2><p>C++ 中的静态多态是通过函数重载和模板实现的。在编译时多态中，编译器根据函数参数的类型、个数和顺序来选择调用合适的函数或模板实例。</p>
<h3 id="1-函数重载："><a href="#1-函数重载：" class="headerlink" title="1. 函数重载："></a>1. 函数重载：</h3><p>函数重载是指在同一个作用域中定义多个函数，这些函数具有相同的名称但是参数列表不同。在调用函数时，编译器会根据实参的类型、个数和顺序来选择调用合适的函数。</p>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Integer: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5</span>);        <span class="comment">// 调用 print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);     <span class="comment">// 调用 print(double)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，根据参数的类型选择调用合适的 <code>print</code> 函数，实现了编译时多态。</p>
<h3 id="2-函数模板："><a href="#2-函数模板：" class="headerlink" title="2. 函数模板："></a>2. 函数模板：</h3><p>函数模板是一种通用的函数定义方式，允许在编写代码时不指定具体的类型，而是在调用时根据参数的类型自动推导出对应的函数实例。</p>
<h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5</span>);        <span class="comment">// 调用 print&lt;int&gt;(int)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);     <span class="comment">// 调用 print&lt;double&gt;(double)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，通过函数模板定义了一个通用的 <code>print</code> 函数，根据实参的类型自动推导出对应的函数实例，实现了编译时多态。</p>
<h3 id="静态多态的过程："><a href="#静态多态的过程：" class="headerlink" title="静态多态的过程："></a>静态多态的过程：</h3><ol>
<li><p>在编写代码时，定义了多个具有相同名称但参数列表不同的函数或模板。</p>
</li>
<li><p>在调用函数时，编译器根据实参的类型、个数和顺序匹配到合适的函数或模板实例。</p>
</li>
<li><p>编译器根据匹配到的函数或模板实例生成对应的调用代码。</p>
</li>
<li><p>在程序运行时，调用生成的调用代码执行相应的操作。</p>
</li>
</ol>
<p>总的来说，静态多态是通过函数重载和模板实现的，编译器在编译时根据参数的类型、个数和顺序选择调用合适的函数或模板实例，从而实现了编译时多态。</p>
<h2 id="C-动态多态的细节和过程-详解"><a href="#C-动态多态的细节和过程-详解" class="headerlink" title="C++ 动态多态的细节和过程 详解"></a>C++ 动态多态的细节和过程 详解</h2><p>C++ 中的动态多态是通过继承和虚函数实现的。在运行时多态中，当基类指针或引用指向派生类对象时，通过虚函数表（vtable）实现动态绑定，即根据对象的实际类型来调用对应的函数。</p>
<h3 id="1-虚函数："><a href="#1-虚函数：" class="headerlink" title="1. 虚函数："></a>1. 虚函数：</h3><p>虚函数是在基类中声明为 <code>virtual</code> 的成员函数。当基类的指针或引用指向派生类对象时，可以通过虚函数实现对派生类中重写的函数的动态调用。</p>
<h4 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal makes a sound&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog barks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cat meows&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal* animalPtr;</span><br><span class="line"></span><br><span class="line">    Dog dog;</span><br><span class="line">    Cat cat;</span><br><span class="line"></span><br><span class="line">    animalPtr = &amp;dog;</span><br><span class="line">    animalPtr-&gt;<span class="built_in">makeSound</span>();   <span class="comment">// 输出: Dog barks</span></span><br><span class="line"></span><br><span class="line">    animalPtr = &amp;cat;</span><br><span class="line">    animalPtr-&gt;<span class="built_in">makeSound</span>();   <span class="comment">// 输出: Cat meows</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Animal</code> 类中的 <code>makeSound()</code> 函数被声明为虚函数，因此可以通过基类指针 <code>animalPtr</code> 调用派生类中重写的 <code>makeSound()</code> 函数，实现了动态多态。</p>
<h3 id="2-虚函数表（vtable）："><a href="#2-虚函数表（vtable）：" class="headerlink" title="2. 虚函数表（vtable）："></a>2. 虚函数表（vtable）：</h3><p>每个含有虚函数的类都有一个虚函数表，其中存储了指向虚函数的指针。当对象被创建时，会为其分配一个虚函数表，并在表中存储该对象的虚函数地址。</p>
<p>当调用虚函数时，编译器会根据对象的实际类型查找虚函数表，并根据表中存储的虚函数地址来调用对应的函数。</p>
<h3 id="动态多态的过程："><a href="#动态多态的过程：" class="headerlink" title="动态多态的过程："></a>动态多态的过程：</h3><ol>
<li><p>在定义类时，通过在基类中声明虚函数来实现多态性。</p>
</li>
<li><p>在创建对象时，为对象分配虚函数表，并在表中存储虚函数地址。</p>
</li>
<li><p>当基类指针或引用指向派生类对象时，根据对象的实际类型查找虚函数表，并根据表中存储的虚函数地址来调用对应的函数。</p>
</li>
<li><p>在程序运行时，根据对象的实际类型动态调用相应的函数，实现了运行时多态。</p>
</li>
</ol>
<p>总的来说，动态多态是通过继承和虚函数实现的，在运行时根据对象的实际类型来调用相应的函数，从而实现了动态绑定和多态性。</p>
<h2 id="返回值类型不同，函数名和函数参数相同，能够做到静态多态吗？"><a href="#返回值类型不同，函数名和函数参数相同，能够做到静态多态吗？" class="headerlink" title="返回值类型不同，函数名和函数参数相同，能够做到静态多态吗？"></a>返回值类型不同，函数名和函数参数相同，能够做到静态多态吗？</h2><p>在 C++ 中，函数的重载（Function Overloading）允许在同一个作用域中定义多个函数，这些函数具有相同的名称但是参数列表不同。在函数重载中，编译器根据函数的参数类型、个数和顺序来选择调用合适的函数，实现了静态多态。</p>
<p>但是，函数的重载仅仅是通过参数的不同来实现的，而不涉及函数的返回值类型。如果仅仅是返回值类型不同而函数名和函数参数相同，是无法实现静态多态的。因为编译器无法根据函数的返回值类型来选择调用合适的函数。</p>
<p>下面是一个例子说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载，参数列表不同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Integer: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值类型不同，但函数名和参数列表相同</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">5</span>);   <span class="comment">// 编译错误：对 &#x27;foo&#x27; 的调用不明确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，定义了两组函数重载，第一组是参数列表不同的 <code>foo</code> 函数，可以实现静态多态。而第二组是返回值类型不同但函数名和参数列表相同的 <code>foo</code> 函数，在调用时会导致编译错误，因为编译器无法确定调用哪个函数。</p>
<p>因此，静态多态是通过参数列表的不同来实现的，而函数的返回值类型不同并不影响函数的重载。</p>
<h2 id="返回值类型不同，函数名和函数参数相同，通过模板能够做到静态多态吗？"><a href="#返回值类型不同，函数名和函数参数相同，通过模板能够做到静态多态吗？" class="headerlink" title="返回值类型不同，函数名和函数参数相同，通过模板能够做到静态多态吗？"></a>返回值类型不同，函数名和函数参数相同，通过模板能够做到静态多态吗？</h2><p>是的，通过模板（Template）可以实现函数模板的重载，从而实现静态多态。函数模板允许定义一种通用的函数，可以处理不同类型的参数，但是在调用时根据实参的类型推导出对应的函数实例。</p>
<p>下面是一个示例说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板重载，返回值类型不同，但参数列表相同</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">double</span> <span class="built_in">foo</span>&lt;<span class="type">double</span>&gt;(<span class="type">double</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result1 = <span class="built_in">foo</span>(<span class="number">5</span>);       <span class="comment">// 调用模板函数 foo&lt;int&gt;(int)，返回类型为 int</span></span><br><span class="line">    <span class="type">double</span> result2 = <span class="built_in">foo</span>(<span class="number">3.14</span>); <span class="comment">// 调用特化的模板函数 foo&lt;double&gt;(double)，返回类型为 double</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result 1: &quot;</span> &lt;&lt; result1 &lt;&lt; std::endl;  <span class="comment">// 输出：10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result 2: &quot;</span> &lt;&lt; result2 &lt;&lt; std::endl;  <span class="comment">// 输出：6.28</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，定义了一个函数模板 <code>foo</code>，该模板可以处理任意类型的参数。同时，通过对 <code>double</code> 类型的特化，定义了另一个版本的 <code>foo</code> 函数，处理 <code>double</code> 类型的参数。在调用函数 <code>foo</code> 时，编译器会根据实参的类型推导出对应的函数实例，从而实现了静态多态。</p>
<p>因此，通过函数模板的重载和特化，可以实现返回值类型不同但函数名和参数列表相同的静态多态。</p>
<h2 id="多态是在运行时做的还是编译时做的"><a href="#多态是在运行时做的还是编译时做的" class="headerlink" title="多态是在运行时做的还是编译时做的"></a>多态是在运行时做的还是编译时做的</h2><p>多态（Polymorphism）在 C++ 中既可以在编译时实现（静态多态），也可以在运行时实现（动态多态）。</p>
<ol>
<li><p><strong>编译时多态（静态多态）</strong>：编译时多态是通过函数重载和模板实现的，编译器在编译阶段根据函数的参数类型、个数和顺序来选择调用合适的函数或模板实例。编译时多态的特点是，在编译阶段就确定了函数调用的具体实现，因此效率更高。</p>
</li>
<li><p><strong>运行时多态（动态多态）</strong>：运行时多态是通过继承和虚函数实现的，当基类指针或引用指向派生类对象时，通过虚函数表实现动态绑定，即根据对象的实际类型来调用对应的函数。运行时多态的特点是，在运行时根据对象的实际类型确定函数调用的具体实现，因此更灵活。</p>
</li>
</ol>
<p>在实际开发中，根据具体需求和性能要求选择合适的多态实现方式。静态多态适用于在编译时就能确定函数调用的场景，而动态多态适用于需要在运行时根据对象的实际类型确定函数调用的场景。</p>
<h2 id="静态多态和动态多态的区别"><a href="#静态多态和动态多态的区别" class="headerlink" title="静态多态和动态多态的区别"></a>静态多态和动态多态的区别</h2><p>静态多态和动态多态是两种不同的多态实现方式，它们在实现原理、使用时机和效率等方面有着明显的区别。</p>
<h3 id="1-实现原理：-1"><a href="#1-实现原理：-1" class="headerlink" title="1. 实现原理："></a>1. 实现原理：</h3><ul>
<li><p><strong>静态多态</strong>：通过函数重载和模板实现。在编译阶段根据函数的参数类型、个数和顺序来选择调用合适的函数或模板实例。</p>
</li>
<li><p><strong>动态多态</strong>：通过继承和虚函数实现。当基类指针或引用指向派生类对象时，通过虚函数表实现动态绑定，即根据对象的实际类型来调用对应的函数。</p>
</li>
</ul>
<h3 id="2-使用时机："><a href="#2-使用时机：" class="headerlink" title="2. 使用时机："></a>2. 使用时机：</h3><ul>
<li><p><strong>静态多态</strong>：适用于在编译时就能确定函数调用的场景，例如根据参数类型的不同选择不同的函数实现。</p>
</li>
<li><p><strong>动态多态</strong>：适用于需要在运行时根据对象的实际类型确定函数调用的场景，例如基类指针或引用指向派生类对象时的函数调用。</p>
</li>
</ul>
<h3 id="3-效率："><a href="#3-效率：" class="headerlink" title="3. 效率："></a>3. 效率：</h3><ul>
<li><p><strong>静态多态</strong>：在编译时确定函数调用的具体实现，因此效率更高，但不够灵活。</p>
</li>
<li><p><strong>动态多态</strong>：在运行时确定函数调用的具体实现，灵活性更高，但会稍微降低一些性能，因为需要在运行时查找虚函数表。</p>
</li>
</ul>
<h3 id="4-编程模型："><a href="#4-编程模型：" class="headerlink" title="4. 编程模型："></a>4. 编程模型：</h3><ul>
<li><p><strong>静态多态</strong>：通常使用函数重载和模板来实现，是一种编译期间的机制。</p>
</li>
<li><p><strong>动态多态</strong>：通常使用继承和虚函数来实现，是一种运行时的机制。</p>
</li>
</ul>
<p>总的来说，静态多态和动态多态各有优缺点，在不同的场景下选择合适的多态实现方式能够提高代码的可维护性和灵活性。</p>
<h2 id="原子操作是怎么做的"><a href="#原子操作是怎么做的" class="headerlink" title="原子操作是怎么做的"></a>原子操作是怎么做的</h2><p>原子操作是计算机科学中一种重要的操作方式，用于确保多个线程或进程同时访问共享资源时的正确性。原子操作是不可中断的操作，它要么完全执行成功，要么完全不执行，不会出现部分执行的情况。</p>
<p>在现代计算机体系结构中，原子操作通常是通过硬件支持来实现的，其中包括处理器提供的原子指令和内存模型的支持。下面是一些常见的原子操作机制：</p>
<ol>
<li><p><strong>原子指令：</strong> 许多处理器提供了原子指令集，如原子加载（atomic load）、原子存储（atomic store）、原子交换（atomic exchange）、原子加法（atomic add）等。这些指令能够保证在多线程或多进程环境下对内存的操作是原子的，不会被中断或干扰。</p>
</li>
<li><p><strong>自旋锁：</strong> 自旋锁是一种基于原子操作的锁机制，它通过循环等待的方式来获取锁，直到成功获取锁为止。自旋锁通常使用原子的测试和设置（test-and-set）指令来实现，它能够在多核处理器上有效地防止竞争条件的发生。</p>
</li>
<li><p><strong>原子操作库：</strong> 许多编程语言和操作系统提供了原子操作的库函数或API，如C++11引入了 <code>&lt;atomic&gt;</code> 头文件，提供了一系列原子操作的模板类和函数，可以在多线程环境中安全地进行操作。</p>
</li>
<li><p><strong>事务内存（Transactional Memory）：</strong> 事务内存是一种新兴的并发控制机制，它提供了一种以原子方式执行一组指令序列的方法。事务内存通过硬件或软件来实现，能够在保持原子性的同时提高并发性。</p>
</li>
<li><p><strong>硬件支持的原子操作：</strong> 一些现代处理器提供了硬件支持的原子操作，如 Compare-and-Swap（CAS）指令，它是一种原子操作，可以在一个内存地址上进行比较和交换操作，通常用于实现同步原语和锁。</p>
</li>
</ol>
<p>总的来说，原子操作是通过硬件和软件的支持来保证在多线程或多进程环境下对共享资源的操作是原子的，不会出现竞争条件或数据不一致的情况。</p>
<h2 id="C-STL常见的容器有哪些"><a href="#C-STL常见的容器有哪些" class="headerlink" title="C++ STL常见的容器有哪些"></a>C++ STL常见的容器有哪些</h2><p>C++ STL（Standard Template Library，标准模板库）提供了丰富的容器类模板，用于存储和管理数据。以下是一些常见的 C++ STL 容器：</p>
<ol>
<li><p><strong>序列容器（Sequence Containers）：</strong></p>
<ul>
<li><code>std::vector</code>：动态数组，支持快速随机访问和尾部插入删除。</li>
<li><code>std::deque</code>：双端队列，支持快速随机访问和两端插入删除。</li>
<li><code>std::list</code>：双向链表，支持快速插入删除和双向迭代器。</li>
<li><code>std::forward_list</code>：单向链表，支持快速插入删除和单向迭代器。</li>
</ul>
</li>
<li><p><strong>关联容器（Associative Containers）：</strong></p>
<ul>
<li><code>std::set</code>：有序集合，元素唯一且自动排序。</li>
<li><code>std::map</code>：有序键值对容器，键唯一且自动排序。</li>
<li><code>std::multiset</code>：有序多重集合，元素可重复且自动排序。</li>
<li><code>std::multimap</code>：有序多重键值对容器，键可重复且自动排序。</li>
<li><code>std::unordered_set</code>：无序集合，元素唯一且哈希存储。</li>
<li><code>std::unordered_map</code>：无序键值对容器，键唯一且哈希存储。</li>
<li><code>std::unordered_multiset</code>：无序多重集合，元素可重复且哈希存储。</li>
<li><code>std::unordered_multimap</code>：无序多重键值对容器，键可重复且哈希存储。</li>
</ul>
</li>
<li><p><strong>容器适配器（Container Adapters）：</strong></p>
<ul>
<li><code>std::stack</code>：栈，基于序列容器实现的后进先出（LIFO）数据结构。</li>
<li><code>std::queue</code>：队列，基于序列容器实现的先进先出（FIFO）数据结构。</li>
<li><code>std::priority_queue</code>：优先队列，基于序列容器实现的优先级队列。</li>
</ul>
</li>
<li><p><strong>关联容器适配器（Associative Container Adapters）：</strong></p>
<ul>
<li><code>std::priority_queue</code>：优先队列，基于关联容器实现的优先级队列。</li>
</ul>
</li>
</ol>
<p>这些容器提供了不同的数据存储和访问方式，开发者可以根据需求选择合适的容器。容器之间提供了一致的接口，使得在代码中可以方便地进行切换和替换，而不需要修改大部分代码。</p>
<h2 id="std-unorder-map和std-map插入搜索复杂度"><a href="#std-unorder-map和std-map插入搜索复杂度" class="headerlink" title="std::unorder_map和std::map插入搜索复杂度"></a>std::unorder_map和std::map插入搜索复杂度</h2><p><code>std::unordered_map</code> 和 <code>std::map</code> 是 C++ STL 提供的两种常用的关联容器，它们之间在插入和搜索操作的复杂度上有所不同：</p>
<ol>
<li><p><strong>std::unordered_map</strong>：</p>
<ul>
<li><strong>插入复杂度（Average Insertion Complexity）：</strong> O(1)（常数时间）。</li>
<li><strong>搜索复杂度（Average Search Complexity）：</strong> O(1)（常数时间），但是考虑到哈希冲突的情况，可能会退化为 O(n)，其中 n 是 <code>std::unordered_map</code> 中元素的数量。</li>
</ul>
<p><code>std::unordered_map</code> 是基于哈希表实现的，它通过哈希函数将键映射到存储桶（bucket），并在存储桶中使用链表或其他数据结构来处理哈希冲突。在平均情况下，插入和搜索操作都是常数时间复杂度的，但在最坏情况下，可能会因为哈希冲突导致链表变得很长，搜索的复杂度可能会退化为线性时间复杂度。</p>
</li>
<li><p><strong>std::map</strong>：</p>
<ul>
<li><strong>插入复杂度（Average Insertion Complexity）：</strong> O(log n)（对数时间）。</li>
<li><strong>搜索复杂度（Average Search Complexity）：</strong> O(log n)（对数时间）。</li>
</ul>
<p><code>std::map</code> 是基于红黑树实现的，它是一种自平衡的二叉搜索树。在插入和搜索操作时，红黑树会保持平衡，因此插入和搜索的时间复杂度都是对数时间的。</p>
</li>
</ol>
<p>因此，当需要在 C++ 中使用关联容器时，可以根据实际需求选择 <code>std::unordered_map</code> 还是 <code>std::map</code>。如果对搜索性能有较高的要求，并且可以接受在某些情况下插入性能较差的情况，可以选择 <code>std::map</code>；如果对插入和搜索性能都有较高要求，并且可以接受在某些情况下搜索性能略低于 <code>std::map</code>，但总体上更为均衡，可以选择 <code>std::unordered_map</code>。</p>
<h2 id="跳板插入删除复杂度"><a href="#跳板插入删除复杂度" class="headerlink" title="跳板插入删除复杂度"></a>跳板插入删除复杂度</h2><p>跳表（Skip List）是一种随机化数据结构，它可以支持快速的插入、删除和搜索操作，其插入和删除的平均时间复杂度为 O(log n)，搜索的时间复杂度也是 O(log n)，其中 n 是跳表中元素的数量。以下是跳表插入和删除操作的详细说明：</p>
<ol>
<li><p><strong>插入操作：</strong></p>
<ul>
<li>首先，从顶层开始，沿着每一层的链表，找到要插入的位置前面的节点。</li>
<li>然后，为新节点生成随机高度，这个高度决定了新节点的层数。</li>
<li>在每一层中，将新节点插入到前面找到的节点之后，并更新指针。</li>
<li>插入完成后，如果新节点的层数比当前跳表的最大层数要高，则需要更新跳表的最大层数。</li>
</ul>
</li>
<li><p><strong>删除操作：</strong></p>
<ul>
<li>首先，从顶层开始，沿着每一层的链表，找到要删除的节点前面的节点。</li>
<li>然后，从每一层中删除要删除的节点，并更新指针。</li>
<li>删除完成后，如果删除节点后某一层的链表为空，可以将该层的链表删除，并更新跳表的最大层数。</li>
</ul>
</li>
</ol>
<p>跳表的插入和删除操作需要通过更新指针来调整跳表的结构，因此时间复杂度是 O(log n)，其中 n 是跳表中元素的数量。需要注意的是，由于跳表是一种随机化数据结构，因此插入和删除操作的最坏时间复杂度是 O(n)，但是平均情况下的时间复杂度是 O(log n)。</p>
<p>跳表的搜索操作也是 O(log n) 的时间复杂度，因为每次搜索都是从顶层开始，沿着每一层的链表向右移动，直到找到目标节点或者到达最底层。由于跳表中每一层的节点数量都是有序的，因此可以利用二分查找的思想来加速搜索过程。</p>
<h2 id="跳板为什么不用B-树"><a href="#跳板为什么不用B-树" class="headerlink" title="跳板为什么不用B+树"></a>跳板为什么不用B+树</h2><p>跳表和 B+ 树是两种不同的数据结构，它们各自适用于不同的场景和需求，因此在某些情况下选择跳表而不是 B+ 树可能是出于以下一些考虑：</p>
<ol>
<li><p><strong>实现简单：</strong> 跳表的实现相对较为简单，而 B+ 树的实现则更加复杂。跳表的基本操作（插入、删除、搜索）相对容易理解和实现，不需要复杂的平衡调整过程，而 B+ 树需要考虑到节点分裂、合并、调整等操作。</p>
</li>
<li><p><strong>高效的随机访问：</strong> 跳表支持快速的随机访问，其搜索操作的时间复杂度为 O(log n)，与 B+ 树相比在某些场景下可能更加高效，尤其是在内存中数据存储、高并发的读写操作等方面。</p>
</li>
<li><p><strong>适合有序集合操作：</strong> 跳表的有序特性使得它在有序集合的操作上更加灵活，如范围查找、范围删除等操作更容易实现。</p>
</li>
<li><p><strong>无需频繁的平衡调整：</strong> 跳表在插入和删除操作时不需要频繁地进行平衡调整，而 B+ 树需要保持平衡，可能需要进行频繁的节点分裂、合并等操作，这可能会增加操作的开销。</p>
</li>
<li><p><strong>易于并发处理：</strong> 跳表的节点分布相对简单，节点之间的关系不像 B+ 树那样严格，这使得跳表更容易进行并发处理。</p>
</li>
</ol>
<p>总的来说，虽然 B+ 树在某些方面（如磁盘存储、范围查询等）具有优势，但在一些内存中的场景下，跳表可能更加适合，因为它的实现相对简单、高效的随机访问和更容易的并发处理等特性使得它成为了一种有竞争力的选择。</p>
<h2 id="如何通过redis实现一个限流组件，要求限制每秒5个链接"><a href="#如何通过redis实现一个限流组件，要求限制每秒5个链接" class="headerlink" title="如何通过redis实现一个限流组件，要求限制每秒5个链接"></a>如何通过redis实现一个限流组件，要求限制每秒5个链接</h2><p>通过 Redis 实现一个限流组件是一个常见的场景，可以使用 Redis 的计数器和过期时间等功能来实现。以下是一种可能的实现方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RateLimiter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_host=<span class="string">&#x27;localhost&#x27;</span>, redis_port=<span class="number">6379</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.redis_conn = redis.StrictRedis(host=redis_host, port=redis_port)</span><br><span class="line">        <span class="variable language_">self</span>.key = <span class="string">&#x27;rate_limiter&#x27;</span></span><br><span class="line">        <span class="variable language_">self</span>.limit = <span class="number">5</span></span><br><span class="line">        <span class="variable language_">self</span>.expiry = <span class="number">1</span>  <span class="comment"># 每秒钟清空计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_allowed</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 获取当前时间戳</span></span><br><span class="line">        current_time = time.time()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 尝试获取计数器的值</span></span><br><span class="line">        count = <span class="variable language_">self</span>.redis_conn.get(<span class="variable language_">self</span>.key)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> count:</span><br><span class="line">            <span class="comment"># 如果计数器不存在，则初始化为 1，并设置过期时间</span></span><br><span class="line">            <span class="variable language_">self</span>.redis_conn.setex(<span class="variable language_">self</span>.key, <span class="variable language_">self</span>.expiry, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        count = <span class="built_in">int</span>(count)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> count &lt; <span class="variable language_">self</span>.limit:</span><br><span class="line">            <span class="comment"># 如果计数器未达到限制，则递增计数器的值，并设置过期时间</span></span><br><span class="line">            <span class="variable language_">self</span>.redis_conn.incr(<span class="variable language_">self</span>.key)</span><br><span class="line">            <span class="variable language_">self</span>.redis_conn.expire(<span class="variable language_">self</span>.key, <span class="variable language_">self</span>.expiry)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果计数器达到了限制，则不允许新的连接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">limiter = RateLimiter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> limiter.is_allowed():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;连接 <span class="subst">&#123;i+<span class="number">1</span>&#125;</span> 允许访问&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;连接 <span class="subst">&#123;i+<span class="number">1</span>&#125;</span> 超过限制，不允许访问&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>RateLimiter</code> 类通过 Redis 实现了一个基于令牌桶算法的限流组件。每次访问时，会尝试获取计数器的值，如果计数器不存在，则初始化为 1，并设置过期时间；如果计数器存在且未达到限制，则递增计数器的值，并设置过期时间；如果计数器达到了限制，则不允许新的连接。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>感谢老板支持！敬礼(^^ゞ</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="zhang junyi WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="zhang junyi Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/cpp/" rel="tag"># cpp</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/02/12/notebook/Network/2025-02-12-tcp_ip/" rel="prev" title="TCP/IP">
      <i class="fa fa-chevron-left"></i> TCP/IP
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/02/12/notebook/Interview/2025-02-18--Qt%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="next" title="项目构建">
      项目构建 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%91%98%E8%A6%81"><span class="nav-number">1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-%E5%BD%93%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%89%93%E7%AE%97%E8%A2%AB%E7%94%A8%E4%BD%9C%E5%85%B6%E4%BB%96%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%B1%BB%E6%97%B6%EF%BC%8C%E5%AE%83%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E6%98%AF%E8%99%9A%E7%9A%84"><span class="nav-number">2.</span> <span class="nav-text">为什么 当一个类打算被用作其他类的基类时，它的析构函数必须是虚的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">原因分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">4.</span> <span class="nav-text">示例代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E8%99%9A%E6%9E%90%E6%9E%84%E7%9A%84%E9%94%99%E8%AF%AF%E7%A4%BA%E8%8C%83"><span class="nav-number">4.1.</span> <span class="nav-text">非虚析构的错误示范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%99%9A%E6%9E%90%E6%9E%84"><span class="nav-number">4.2.</span> <span class="nav-text">正确做法：使用虚析构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E6%98%AF%E8%99%9A%E7%9A%84%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">为什么基类的析构函数必须是虚的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E9%9C%80%E8%A6%81%E8%99%9A%E6%9E%90%E6%9E%84%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">什么时候不需要虚析构？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">6.</span> <span class="nav-text">左值引用与右值引用有什么区别，左值引用和右值引用的目的是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-%E8%AF%A6%E8%A7%A3"><span class="nav-number">7.</span> <span class="nav-text">C++ 右值引用 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="nav-number">7.1.</span> <span class="nav-text">1. 右值引用的语法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%EF%BC%88Move-Semantics%EF%BC%89%EF%BC%9A"><span class="nav-number">7.2.</span> <span class="nav-text">2. 移动语义（Move Semantics）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%EF%BC%88Perfect-Forwarding%EF%BC%89%EF%BC%9A"><span class="nav-number">7.3.</span> <span class="nav-text">3. 完美转发（Perfect Forwarding）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-std-move-%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">7.4.</span> <span class="nav-text">4. std::move() 函数：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="nav-number">7.5.</span> <span class="nav-text">5. 注意事项：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%8D%8F%E7%A8%8B-%E8%AF%A6%E8%A7%A3"><span class="nav-number">8.</span> <span class="nav-text">C++ 协程 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="nav-number">8.1.</span> <span class="nav-text">1. 协程的基本概念：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-C-20-%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%94%AF%E6%8C%81%EF%BC%9A"><span class="nav-number">8.2.</span> <span class="nav-text">2. C++20 中的协程支持：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="nav-number">8.3.</span> <span class="nav-text">3. 使用协程的注意事项：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB-%E8%AF%A6%E8%A7%A3"><span class="nav-number">9.</span> <span class="nav-text">进程 线程 协程 之间的区别 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%BF%9B%E7%A8%8B%EF%BC%88Process%EF%BC%89%EF%BC%9A"><span class="nav-number">9.1.</span> <span class="nav-text">1. 进程（Process）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89%EF%BC%9A"><span class="nav-number">9.2.</span> <span class="nav-text">2. 线程（Thread）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8D%8F%E7%A8%8B%EF%BC%88Coroutine%EF%BC%89%EF%BC%9A"><span class="nav-number">9.3.</span> <span class="nav-text">3. 协程（Coroutine）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">9.4.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81"><span class="nav-number">10.</span> <span class="nav-text">什么是多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">11.</span> <span class="nav-text">虚函数和纯虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB-%E8%AF%A6%E8%A7%A3"><span class="nav-number">12.</span> <span class="nav-text">虚函数和纯虚函数的区别 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%88Virtual-Function%EF%BC%89%EF%BC%9A"><span class="nav-number">12.1.</span> <span class="nav-text">虚函数（Virtual Function）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%88Pure-Virtual-Function%EF%BC%89%EF%BC%9A"><span class="nav-number">12.2.</span> <span class="nav-text">纯虚函数（Pure Virtual Function）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">12.3.</span> <span class="nav-text">区别总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="nav-number">13.</span> <span class="nav-text">C++ 虚函数和纯虚函数的实际应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%EF%BC%9A"><span class="nav-number">13.1.</span> <span class="nav-text">虚函数的实际应用：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%EF%BC%9A"><span class="nav-number">13.2.</span> <span class="nav-text">纯虚函数的实际应用：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">引用和指针的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="nav-number">15.</span> <span class="nav-text">C++类型转化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">16.</span> <span class="nav-text">C++中的堆和栈的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">17.</span> <span class="nav-text">指针和引用的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97static%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">18.</span> <span class="nav-text">关键字static的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%ADmap%EF%BC%8C%E5%A6%82%E6%9E%9Ckey%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E4%BD%BF%E7%94%A8-%E5%BD%A2%E5%BC%8F%E9%81%8D%E5%8E%86%E8%83%BD%E6%88%90%E5%8A%9F%E5%90%97"><span class="nav-number">19.</span> <span class="nav-text">C++中map，如果key不存在，使用[]形式遍历能成功吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">20.</span> <span class="nav-text">动态多态的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%98%AF%E5%B1%9E%E4%BA%8E%E7%B1%BB%E7%9A%84%E8%BF%98%E6%98%AF%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84"><span class="nav-number">21.</span> <span class="nav-text">虚函数表是属于类的还是类对象的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E9%87%8C%E9%9D%A2%E6%9C%89%E4%BB%80%E4%B9%88"><span class="nav-number">22.</span> <span class="nav-text">虚函数表里面有什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E7%9A%84"><span class="nav-number">23.</span> <span class="nav-text">虚函数表是怎么使用的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%98%AF%E5%9C%A8%E7%BC%96%E8%AF%91%E7%9A%84%E5%93%AA%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%94%9F%E6%88%90%E7%9A%84"><span class="nav-number">24.</span> <span class="nav-text">虚函数表是在编译的哪个阶段生成的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">25.</span> <span class="nav-text">虚函数表在文件中的位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB-%E8%AF%A6%E8%A7%A3"><span class="nav-number">26.</span> <span class="nav-text">虚基类 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%8E%BB%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">27.</span> <span class="nav-text">如何去管理内存，防止内存泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97"><span class="nav-number">28.</span> <span class="nav-text">静态成员函数可以是虚函数吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E4%B8%8D%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">29.</span> <span class="nav-text">为什么析构函数默认不是虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">30.</span> <span class="nav-text">内存对齐的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%EF%BC%9F"><span class="nav-number">30.1.</span> <span class="nav-text">1. 为什么需要内存对齐？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99"><span class="nav-number">30.2.</span> <span class="nav-text">2. 内存对齐规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">30.3.</span> <span class="nav-text">3. 内存对齐的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="nav-number">30.4.</span> <span class="nav-text">4. 如何控制内存对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">30.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector-%E5%92%8C-map-%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%80%E9%81%8D%E9%81%8D%E5%8E%86%E5%AE%B9%E5%99%A8%E4%B8%80%E8%BE%B9%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BC%9A%E5%A4%B1%E6%95%88%E5%90%97"><span class="nav-number">31.</span> <span class="nav-text">vector 和 map 用迭代器一遍遍历容器一边删除元素，迭代器会失效吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E8%BF%98%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84%EF%BC%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">32.</span> <span class="nav-text">map是有序的还是无序的，底层实现是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AFAVL"><span class="nav-number">33.</span> <span class="nav-text">map为什么底层实现是红黑树而不是AVL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E9%94%81%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E6%88%96%E4%BA%92%E6%96%A5"><span class="nav-number">34.</span> <span class="nav-text">C++多线程编程用过哪些锁来实现同步或互斥</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">35.</span> <span class="nav-text">C和C++的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const-%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="nav-number">36.</span> <span class="nav-text">const 限定符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88-VS-%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="nav-number">37.</span> <span class="nav-text">指向常量的指针 VS 常量指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constexpr"><span class="nav-number">38.</span> <span class="nav-text">constexpr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#define-VS-const"><span class="nav-number">39.</span> <span class="nav-text">#define VS const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sizeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">40.</span> <span class="nav-text">sizeof 运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-number">41.</span> <span class="nav-text">显式转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="nav-number">42.</span> <span class="nav-text">形参和实参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-number">43.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">44.</span> <span class="nav-text">参数传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">45.</span> <span class="nav-text">内联函数的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9inline%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4"><span class="nav-number">46.</span> <span class="nav-text">编译器对inline函数的处理步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">47.</span> <span class="nav-text">内联函数的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%92%8Creturn%E8%AF%AD%E5%8F%A5"><span class="nav-number">48.</span> <span class="nav-text">返回类型和return语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E5%B8%AE%E5%8A%A9"><span class="nav-number">49.</span> <span class="nav-text">调试帮助</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">50.</span> <span class="nav-text">函数指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this-%E6%8C%87%E9%92%88"><span class="nav-number">51.</span> <span class="nav-text">this 指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0"><span class="nav-number">52.</span> <span class="nav-text">拷贝函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">53.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85-public-private-protected"><span class="nav-number">54.</span> <span class="nav-text">访问控制与封装  public&#x2F;private&#x2F;protected</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#struct%E4%B8%8Eclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">55.</span> <span class="nav-text">struct与class的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-number">56.</span> <span class="nav-text">友元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">57.</span> <span class="nav-text">构造函数的初始化顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#explicit"><span class="nav-number">58.</span> <span class="nav-text">explicit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-explicit%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">59.</span> <span class="nav-text">C++ explicit关键字的作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">60.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C-emplace"><span class="nav-number">61.</span> <span class="nav-text">顺序容器操作 emplace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#resize-reserve"><span class="nav-number">62.</span> <span class="nav-text">resize &#x2F; reserve</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%83%BD%E4%BD%BF%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="nav-number">63.</span> <span class="nav-text">容器操作可能使迭代器失效</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%A2%9E%E9%95%BF%E7%9A%84"><span class="nav-number">64.</span> <span class="nav-text">vector对象是如何增长的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">65.</span> <span class="nav-text">容器适配器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">66.</span> <span class="nav-text">lambda 表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="nav-number">67.</span> <span class="nav-text">关联容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">68.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E8%AF%A6%E8%A7%A3"><span class="nav-number">69.</span> <span class="nav-text">C++ 智能指针 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#std-unique-ptr%EF%BC%9A"><span class="nav-number">69.1.</span> <span class="nav-text">std::unique_ptr：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-shared-ptr%EF%BC%9A"><span class="nav-number">69.2.</span> <span class="nav-text">std::shared_ptr：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9A"><span class="nav-number">69.3.</span> <span class="nav-text">其他智能指针：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-std-shared-ptr%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%BC%9A%E5%BC%95%E5%8F%91%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">70.</span> <span class="nav-text">C++ std::shared_ptr循环引用会引发什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3std-shared-ptr%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">71.</span> <span class="nav-text">怎么解决std::shared_ptr循环引用的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6-%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8"><span class="nav-number">72.</span> <span class="nav-text">拷贝控制 对象移动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OOP-%E6%A6%82%E8%BF%B0"><span class="nav-number">73.</span> <span class="nav-text">OOP:概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%B1%BB-%E2%80%93-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">74.</span> <span class="nav-text">定义派生类和基类 – 初始化顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81"><span class="nav-number">75.</span> <span class="nav-text">静态多态 &#x2F; 动态多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">76.</span> <span class="nav-text">虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">77.</span> <span class="nav-text">析构函数为什么是虚函数？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97"><span class="nav-number">78.</span> <span class="nav-text">C++ 构造函数可以是虚函数吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88C-%E9%BB%98%E8%AE%A4%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8D%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">79.</span> <span class="nav-text">为什么C++默认析构函数不是虚函数？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="nav-number">80.</span> <span class="nav-text">抽象基类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0-VS-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">81.</span> <span class="nav-text">虚函数 VS 纯虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">82.</span> <span class="nav-text">访问控制与继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">83.</span> <span class="nav-text">多重继承与虚继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-delete"><span class="nav-number">84.</span> <span class="nav-text">new &amp; delete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new%E5%92%8Cmalloc%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">85.</span> <span class="nav-text">new和malloc有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8free%E9%87%8A%E6%94%BE%E5%90%97%EF%BC%9F"><span class="nav-number">86.</span> <span class="nav-text">new的对象可以使用free释放吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc-free"><span class="nav-number">87.</span> <span class="nav-text">malloc &amp; free</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E8%AF%A6%E8%A7%A3"><span class="nav-number">88.</span> <span class="nav-text">malloc实现原理 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcmalloc-%E8%AF%A6%E8%A7%A3"><span class="nav-number">89.</span> <span class="nav-text">tcmalloc 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E7%82%B9%E5%92%8C%E4%BC%98%E5%8A%BF%EF%BC%9A"><span class="nav-number">89.1.</span> <span class="nav-text">特点和优势：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="nav-number">89.2.</span> <span class="nav-text">使用场景：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="nav-number">89.3.</span> <span class="nav-text">注意事项：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BA%E6%9C%89%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7"><span class="nav-number">90.</span> <span class="nav-text">固有的不可移植性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#h-%E5%92%8C-cpp-%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">91.</span> <span class="nav-text">.h 和 .cpp 文件的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%8F%AF%E5%8F%98%E9%95%BF%E6%A8%A1%E6%9D%BF-%E8%AF%A6%E8%A7%A3"><span class="nav-number">92.</span> <span class="nav-text">C++ 可变长模板 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E5%8C%85%EF%BC%88Template-Parameter-Pack%EF%BC%89"><span class="nav-number">92.1.</span> <span class="nav-text">1. 模板参数包（Template Parameter Pack）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A8%A1%E6%9D%BF%E5%B1%95%E5%BC%80%EF%BC%88Template-Expansion%EF%BC%89"><span class="nav-number">92.2.</span> <span class="nav-text">2. 模板展开（Template Expansion）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5%E4%B8%8E%E9%80%92%E5%BD%92%E6%A8%A1%E6%9D%BF"><span class="nav-number">92.3.</span> <span class="nav-text">3. 基本情况与递归模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E5%B1%95%E5%BC%80%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E5%8C%85"><span class="nav-number">92.4.</span> <span class="nav-text">4. 使用递归展开模板参数包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="nav-number">92.4.1.</span> <span class="nav-text">4.1 递归函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E9%80%92%E5%BD%92%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">92.4.2.</span> <span class="nav-text">4.2 递归类模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88C-17%EF%BC%89"><span class="nav-number">92.4.3.</span> <span class="nav-text">4.3 折叠表达式（C++17）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%89%93%E5%8D%B0%E4%BB%BB%E6%84%8F%E6%95%B0%E9%87%8F%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">92.5.</span> <span class="nav-text">示例：打印任意数量参数的函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%BB%A7%E6%89%BF%E9%80%A0%E6%88%90%E7%9A%84%E7%B1%BB%E6%88%90%E5%91%98%E9%87%8D%E5%A4%8D%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">93.</span> <span class="nav-text">C++ 如何解决多继承造成的类成员重复的问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89class%EF%BC%9F"><span class="nav-number">94.</span> <span class="nav-text">C++ 为什么要有class？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%A0%E8%83%BD%E4%B8%8D%E7%94%A8%E6%8C%87%E9%92%88%E5%86%99C-%E7%A8%8B%E5%BA%8F%E5%90%97%EF%BC%9F%E6%8C%87%E9%92%88%E5%A5%BD%E8%BF%98%E6%98%AF%E4%B8%8D%E5%A5%BD%EF%BC%9F"><span class="nav-number">95.</span> <span class="nav-text">指针是什么？你能不用指针写C++程序吗？指针好还是不好？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%EF%BC%9Avector%E5%92%8Clist%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">96.</span> <span class="nav-text">经典问题：vector和list有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-number">97.</span> <span class="nav-text">C++为什么要有类型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%B8%B8%E7%94%A8%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F"><span class="nav-number">98.</span> <span class="nav-text">进程间常用的通讯方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-std-vector%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">99.</span> <span class="nav-text">C++ std::vector扩容机制和实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="nav-number">99.1.</span> <span class="nav-text">扩容机制：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="nav-number">99.2.</span> <span class="nav-text">实现原理：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-vector%E6%89%A9%E5%AE%B9-%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E6%89%A9%E5%AE%B9%E4%BA%86%E5%A4%9A%E5%B0%91"><span class="nav-number">100.</span> <span class="nav-text">std::vector扩容 怎么查看扩容了多少</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-std-vector%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="nav-number">101.</span> <span class="nav-text">C++ std::vector是线程安全的吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-vector%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E4%BC%9A%E5%B4%A9%E6%BA%83%E5%90%97%EF%BC%9F"><span class="nav-number">102.</span> <span class="nav-text">std::vector多线程访问会崩溃吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-vector%E6%89%A9%E5%AE%B9%E7%9A%84%E6%97%B6%E5%80%99%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E4%BC%9A%E5%B4%A9%E6%BA%83%E5%90%97"><span class="nav-number">103.</span> <span class="nav-text">std::vector扩容的时候多线程访问会崩溃吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-vector%E6%89%A9%E5%AE%B9%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">104.</span> <span class="nav-text">std::vector扩容的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-vector%E7%BC%A9%E5%AE%B9%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">105.</span> <span class="nav-text">std::vector缩容的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-std-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E8%AF%A6%E8%A7%A3"><span class="nav-number">106.</span> <span class="nav-text">C++ std::map底层原理 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88Red-Black-Tree%EF%BC%89%EF%BC%9A"><span class="nav-number">106.1.</span> <span class="nav-text">红黑树（Red-Black Tree）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-map-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">106.2.</span> <span class="nav-text">std::map 的底层实现：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="nav-number">106.3.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-map%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">107.</span> <span class="nav-text">std::map是线程安全的吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%BD%E5%A4%9F%E4%BD%BFstd-map%E5%8F%98%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">108.</span> <span class="nav-text">能够使std::map变为线程安全的吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%94%81std-map"><span class="nav-number">109.</span> <span class="nav-text">如何实现无锁std::map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashmap-%E8%AF%A6%E8%A7%A3"><span class="nav-number">110.</span> <span class="nav-text">hashmap 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="nav-number">110.1.</span> <span class="nav-text">哈希表的结构和原理：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">110.2.</span> <span class="nav-text">哈希表的优点和缺点：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%9A"><span class="nav-number">110.3.</span> <span class="nav-text">C++ 中的哈希表：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">111.</span> <span class="nav-text">读写锁与互斥锁的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%88RW%E9%94%81%EF%BC%89%EF%BC%9A"><span class="nav-number">111.1.</span> <span class="nav-text">1. 读写锁（RW锁）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88Mutex%E9%94%81%EF%BC%89%EF%BC%9A"><span class="nav-number">111.2.</span> <span class="nav-text">2. 互斥锁（Mutex锁）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="nav-number">111.3.</span> <span class="nav-text">区别总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-std-vector-%E5%92%8C-std-queue%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">112.</span> <span class="nav-text">C++ std::vector 和 std::queue的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#std-vector%EF%BC%9A"><span class="nav-number">112.1.</span> <span class="nav-text">std::vector：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-queue%EF%BC%9A"><span class="nav-number">112.2.</span> <span class="nav-text">std::queue：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93%EF%BC%9A-2"><span class="nav-number">112.3.</span> <span class="nav-text">区别总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-std-vector-push-back-%E6%98%AF%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9C%E7%9A%84-%E8%AF%A6%E8%A7%A3"><span class="nav-number">113.</span> <span class="nav-text">C++ std::vector::push_back()是怎么操作的 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="nav-number">113.1.</span> <span class="nav-text">1. 实现原理：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="nav-number">113.2.</span> <span class="nav-text">2. 代码示例：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="nav-number">113.3.</span> <span class="nav-text">3. 注意事项：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-std-vector-push-back-%E5%92%8Cstd-vector-emplace-back-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">114.</span> <span class="nav-text">C++ std::vector::push_back()和std::vector::emplace_back()的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#std-vector-push-back-%EF%BC%9A"><span class="nav-number">114.1.</span> <span class="nav-text">std::vector::push_back()：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-vector-emplace-back-%EF%BC%9A"><span class="nav-number">114.2.</span> <span class="nav-text">std::vector::emplace_back()：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93%EF%BC%9A-3"><span class="nav-number">114.3.</span> <span class="nav-text">区别总结：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">114.4.</span> <span class="nav-text">示例代码：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E5%A4%9A%E6%80%81%E8%AF%A6%E8%A7%A3"><span class="nav-number">115.</span> <span class="nav-text">面向对象编程 多态详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BC%96%E8%AF%91%E6%97%B6%E5%A4%9A%E6%80%81%EF%BC%88%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%EF%BC%89%EF%BC%9A"><span class="nav-number">115.1.</span> <span class="nav-text">1. 编译时多态（静态多态）：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="nav-number">115.1.1.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81%EF%BC%88%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%EF%BC%89%EF%BC%9A"><span class="nav-number">115.2.</span> <span class="nav-text">2. 运行时多态（动态多态）：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="nav-number">115.2.1.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-number">115.3.</span> <span class="nav-text">3. 多态的优点：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E7%BB%86%E8%8A%82%E5%92%8C%E8%BF%87%E7%A8%8B-%E8%AF%A6%E8%A7%A3"><span class="nav-number">116.</span> <span class="nav-text">C++ 静态多态的细节和过程 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%9A"><span class="nav-number">116.1.</span> <span class="nav-text">1. 函数重载：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-2"><span class="nav-number">116.1.1.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%EF%BC%9A"><span class="nav-number">116.2.</span> <span class="nav-text">2. 函数模板：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-3"><span class="nav-number">116.2.1.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">116.3.</span> <span class="nav-text">静态多态的过程：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E7%BB%86%E8%8A%82%E5%92%8C%E8%BF%87%E7%A8%8B-%E8%AF%A6%E8%A7%A3"><span class="nav-number">117.</span> <span class="nav-text">C++ 动态多态的细节和过程 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">117.1.</span> <span class="nav-text">1. 虚函数：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-4"><span class="nav-number">117.1.1.</span> <span class="nav-text">示例：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%88vtable%EF%BC%89%EF%BC%9A"><span class="nav-number">117.2.</span> <span class="nav-text">2. 虚函数表（vtable）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="nav-number">117.3.</span> <span class="nav-text">动态多态的过程：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9B%B8%E5%90%8C%EF%BC%8C%E8%83%BD%E5%A4%9F%E5%81%9A%E5%88%B0%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%E5%90%97%EF%BC%9F"><span class="nav-number">118.</span> <span class="nav-text">返回值类型不同，函数名和函数参数相同，能够做到静态多态吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9B%B8%E5%90%8C%EF%BC%8C%E9%80%9A%E8%BF%87%E6%A8%A1%E6%9D%BF%E8%83%BD%E5%A4%9F%E5%81%9A%E5%88%B0%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%E5%90%97%EF%BC%9F"><span class="nav-number">119.</span> <span class="nav-text">返回值类型不同，函数名和函数参数相同，通过模板能够做到静态多态吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%98%AF%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%81%9A%E7%9A%84%E8%BF%98%E6%98%AF%E7%BC%96%E8%AF%91%E6%97%B6%E5%81%9A%E7%9A%84"><span class="nav-number">120.</span> <span class="nav-text">多态是在运行时做的还是编译时做的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">121.</span> <span class="nav-text">静态多态和动态多态的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A-1"><span class="nav-number">121.1.</span> <span class="nav-text">1. 实现原理：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA%EF%BC%9A"><span class="nav-number">121.2.</span> <span class="nav-text">2. 使用时机：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%95%88%E7%8E%87%EF%BC%9A"><span class="nav-number">121.3.</span> <span class="nav-text">3. 效率：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="nav-number">121.4.</span> <span class="nav-text">4. 编程模型：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84"><span class="nav-number">122.</span> <span class="nav-text">原子操作是怎么做的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-STL%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%B9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">123.</span> <span class="nav-text">C++ STL常见的容器有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-unorder-map%E5%92%8Cstd-map%E6%8F%92%E5%85%A5%E6%90%9C%E7%B4%A2%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">124.</span> <span class="nav-text">std::unorder_map和std::map插入搜索复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E6%9D%BF%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">125.</span> <span class="nav-text">跳板插入删除复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E6%9D%BF%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8B-%E6%A0%91"><span class="nav-number">126.</span> <span class="nav-text">跳板为什么不用B+树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87redis%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%99%90%E6%B5%81%E7%BB%84%E4%BB%B6%EF%BC%8C%E8%A6%81%E6%B1%82%E9%99%90%E5%88%B6%E6%AF%8F%E7%A7%925%E4%B8%AA%E9%93%BE%E6%8E%A5"><span class="nav-number">127.</span> <span class="nav-text">如何通过redis实现一个限流组件，要求限制每秒5个链接</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">672</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
