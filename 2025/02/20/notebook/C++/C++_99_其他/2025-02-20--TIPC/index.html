<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"junyiha.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="摘要 在机场行李搬运项目中用到了TIPC协议，完成进程间的通讯。现在学习相关知识，形成笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux TIPC">
<meta property="og:url" content="https://junyiha.github.io/2025/02/20/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2025-02-20--TIPC/index.html">
<meta property="og:site_name" content="junyi&#39;s blog">
<meta property="og:description" content="摘要 在机场行李搬运项目中用到了TIPC协议，完成进程间的通讯。现在学习相关知识，形成笔记。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-02-20T02:00:00.000Z">
<meta property="article:modified_time" content="2025-04-28T08:08:39.231Z">
<meta property="article:author" content="zhang junyi">
<meta property="article:tag" content="CppOthers">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://junyiha.github.io/2025/02/20/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2025-02-20--TIPC/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Linux TIPC | junyi's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">junyi's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">hahahahaha</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://junyiha.github.io/2025/02/20/notebook/C++/C++_99_%E5%85%B6%E4%BB%96/2025-02-20--TIPC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhang junyi">
      <meta itemprop="description" content="工作学习笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junyi's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux TIPC
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-20 10:00:00" itemprop="dateCreated datePublished" datetime="2025-02-20T10:00:00+08:00">2025-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-28 16:08:39" itemprop="dateModified" datetime="2025-04-28T16:08:39+08:00">2025-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>在机场行李搬运项目中用到了TIPC协议，完成进程间的通讯。现在学习相关知识，形成笔记。</li>
</ul>
<span id="more"></span>

<h2 id="TIPC与ROS的区别与联系"><a href="#TIPC与ROS的区别与联系" class="headerlink" title="TIPC与ROS的区别与联系"></a>TIPC与ROS的区别与联系</h2><h3 id="TIPC与ROS的区别与联系-1"><a href="#TIPC与ROS的区别与联系-1" class="headerlink" title="TIPC与ROS的区别与联系"></a><strong>TIPC与ROS的区别与联系</strong></h3><p><strong>TIPC（Transparent Inter-Process Communication）</strong>和<strong>ROS（Robot Operating System）</strong>是两种不同的技术，分别用于解决不同类型的问题。TIPC 是一种通信协议，主要用于分布式系统中的进程间通信，而 ROS 是一个针对机器人开发的操作系统框架，提供了大量的工具和库来支持机器人应用的开发。在某些应用场景下，它们可能会互补，协同工作。</p>
<hr>
<h2 id="TIPC与ROS的区别"><a href="#TIPC与ROS的区别" class="headerlink" title="TIPC与ROS的区别"></a><strong>TIPC与ROS的区别</strong></h2><h3 id="1-定义和用途"><a href="#1-定义和用途" class="headerlink" title="1. 定义和用途"></a><strong>1. 定义和用途</strong></h3><ul>
<li><p><strong>TIPC</strong>：</p>
<ul>
<li>TIPC 是一个<strong>通信协议</strong>，专为高效的进程间通信（IPC）设计，主要用于分布式系统和集群环境中的节点间通信。</li>
<li>它特别适用于要求低延迟、高吞吐量的系统，且主要应用于<strong>Linux 环境</strong>中的集群、通信和分布式应用。</li>
</ul>
</li>
<li><p><strong>ROS</strong>：</p>
<ul>
<li>ROS 是一个完整的<strong>操作系统框架</strong>，专门为机器人应用开发而设计。它为机器人开发提供了硬件抽象层、设备驱动、库、工具和消息传递系统等。</li>
<li>ROS 使用了<strong>发布-订阅机制（Pub&#x2F;Sub）</strong>来实现节点之间的通信，支持多种通信方式（如 TCP&#x2F;IP、UDP 等）。</li>
</ul>
</li>
</ul>
<h3 id="2-设计目标"><a href="#2-设计目标" class="headerlink" title="2. 设计目标"></a><strong>2. 设计目标</strong></h3><ul>
<li><p><strong>TIPC</strong>：</p>
<ul>
<li>提供低延迟和高吞吐量的通信机制，适用于<strong>集群通信</strong>和<strong>分布式系统</strong>，特别是在需要高可靠性、自动路由和容错的系统中。</li>
<li>TIPC 主要目标是<strong>优化进程间通信</strong>，并提供强大的网络层次结构，适应大规模集群。</li>
</ul>
</li>
<li><p><strong>ROS</strong>：</p>
<ul>
<li>提供了一整套开发工具和库，旨在<strong>简化机器人应用程序的开发和集成</strong>。</li>
<li>ROS 的核心包括<strong>消息传递机制</strong>、硬件接口、算法库等，并为开发者提供支持机器人感知、运动规划、控制等模块的功能。</li>
</ul>
</li>
</ul>
<h3 id="3-通信模型"><a href="#3-通信模型" class="headerlink" title="3. 通信模型"></a><strong>3. 通信模型</strong></h3><ul>
<li><p><strong>TIPC</strong>：</p>
<ul>
<li>TIPC 是一种面向<strong>高效集群通信</strong>的协议，支持<strong>服务寻址</strong>（通过服务类型和实例号），允许分布式节点之间的直接通信。</li>
<li>TIPC 设计主要考虑到<strong>低延迟</strong>和<strong>高吞吐量</strong>，在集群内的节点间可以提供<strong>高性能的数据传输</strong>。</li>
</ul>
</li>
<li><p><strong>ROS</strong>：</p>
<ul>
<li>ROS 提供了多种通信机制，主要是基于<strong>发布-订阅（Pub&#x2F;Sub）</strong>模型。节点通过发布消息（Publish）和订阅消息（Subscribe）进行通信。</li>
<li>ROS 还支持<strong>服务-客户端模型</strong>，用于同步请求&#x2F;响应的通信。</li>
<li>ROS 的通信实现基于 TCP&#x2F;IP 协议栈，也支持通过 UDP 和其他协议进行数据传输。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="TIPC与ROS的联系"><a href="#TIPC与ROS的联系" class="headerlink" title="TIPC与ROS的联系"></a><strong>TIPC与ROS的联系</strong></h2><p>尽管 TIPC 和 ROS 是两个不同的系统，但它们有潜在的互补性，在某些应用场景中可以一起使用。ROS 自身也依赖于进程间通信，而 TIPC 可以提供一种高效、可靠的通信方式，尤其在<strong>分布式机器人系统</strong>中使用时，TIPC 可能会作为底层通信协议为 ROS 提供支持。</p>
<h3 id="1-ROS中的通信需求"><a href="#1-ROS中的通信需求" class="headerlink" title="1. ROS中的通信需求"></a><strong>1. ROS中的通信需求</strong></h3><ul>
<li>ROS 中的节点通常需要在多个机器人或多个进程之间交换大量数据。<strong>TCP&#x2F;IP</strong> 或 <strong>UDP</strong> 协议通常用于节点间的消息传递。</li>
<li>在分布式或集群化的机器人系统中，网络中节点的数量可能会增多，这时需要一个高效、可靠的通信协议来确保各节点之间的快速消息传递，特别是在集群环境中。TIPC 可以在这样的场景下作为一个理想的选择。</li>
</ul>
<h3 id="2-TIPC作为ROS的底层通信协议"><a href="#2-TIPC作为ROS的底层通信协议" class="headerlink" title="2. TIPC作为ROS的底层通信协议"></a><strong>2. TIPC作为ROS的底层通信协议</strong></h3><ul>
<li>在基于<strong>Linux</strong>的机器人系统中，TIPC 可以作为 ROS <strong>节点间通信</strong>的底层协议之一。由于 TIPC 提供了<strong>高性能的分布式通信</strong>和<strong>自动路由机制</strong>，它能够满足 ROS 在高吞吐量、低延迟环境下对通信的需求。</li>
<li>在 ROS 中，现有的通信机制（如 ROS Master 和 ROS Topic）可以使用 TCP&#x2F;IP、UDP 或其他协议。如果 ROS 系统需要跨多个集群节点运行，TIPC 可以作为<strong>透明的通信协议</strong>来实现节点间高效的数据传输，尤其适用于需要<strong>自动路由</strong>和<strong>容错</strong>的环境。</li>
</ul>
<hr>
<h2 id="3-结合使用案例"><a href="#3-结合使用案例" class="headerlink" title="3. 结合使用案例"></a><strong>3. 结合使用案例</strong></h2><ul>
<li><strong>大规模机器人系统</strong>：在大规模机器人系统中，可能需要多个机器人节点在多个物理服务器上运行。TIPC 可以提供集群间的通信，ROS 则提供机器人控制和感知等上层功能。</li>
<li><strong>分布式机器人控制</strong>：在多个机器人进行协作时，ROS 可以控制各个机器人的动作和决策，而 TIPC 可以确保多个机器人的消息交换在集群内的高效传输。</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><h3 id="TIPC与ROS的区别："><a href="#TIPC与ROS的区别：" class="headerlink" title="TIPC与ROS的区别："></a><strong>TIPC与ROS的区别</strong>：</h3><ul>
<li><strong>TIPC</strong> 是一种专注于高效、低延迟、可靠的分布式通信协议，适用于集群环境。</li>
<li><strong>ROS</strong> 是一个集成了多种工具和库的操作系统框架，专门针对机器人开发，提供了节点间通信机制（包括发布-订阅和服务-客户端模型）。</li>
</ul>
<h3 id="TIPC与ROS的联系："><a href="#TIPC与ROS的联系：" class="headerlink" title="TIPC与ROS的联系："></a><strong>TIPC与ROS的联系</strong>：</h3><ul>
<li>在基于 Linux 的分布式机器人系统中，TIPC 可以作为 ROS 底层通信协议之一，为其提供高效的集群通信。</li>
<li>ROS 的通信模型（如发布-订阅）可以依赖 TIPC 提供的高效数据传输，尤其适用于高吞吐量和低延迟的要求。</li>
</ul>
<p>如果你正在开发一个需要高效集群通信的分布式机器人系统，考虑将 ROS 和 TIPC 结合使用可能是一个不错的选择。</p>
<h2 id="详细解释Linux中的TIPC"><a href="#详细解释Linux中的TIPC" class="headerlink" title="详细解释Linux中的TIPC"></a>详细解释Linux中的TIPC</h2><h2 id="Linux中的TIPC（Transparent-Inter-Process-Communication）详解"><a href="#Linux中的TIPC（Transparent-Inter-Process-Communication）详解" class="headerlink" title="Linux中的TIPC（Transparent Inter-Process Communication）详解"></a><strong>Linux中的TIPC（Transparent Inter-Process Communication）详解</strong></h2><h3 id="1-什么是TIPC？"><a href="#1-什么是TIPC？" class="headerlink" title="1. 什么是TIPC？"></a><strong>1. 什么是TIPC？</strong></h3><p>TIPC（Transparent Inter-Process Communication，透明进程间通信）是一种<strong>面向集群</strong>的高效、低延迟的通信协议，主要用于<strong>分布式系统</strong>中的进程间通信（IPC）。它由<strong>瑞典爱立信公司（Ericsson）</strong>开发，最初用于<strong>电信系统</strong>，后来被集成到 Linux 内核（从 2.6.16 版本开始支持）。  </p>
<h3 id="2-TIPC的特点"><a href="#2-TIPC的特点" class="headerlink" title="2. TIPC的特点"></a><strong>2. TIPC的特点</strong></h3><p>✅ <strong>高性能</strong>：相比传统 IPC 机制（如 UNIX 域套接字、消息队列等），TIPC 更适合在<strong>高吞吐量、低延迟</strong>环境下使用。<br>✅ <strong>分布式支持</strong>：TIPC 可以<strong>跨多个节点</strong>（cluster）进行通信，适用于<strong>分布式系统</strong>。<br>✅ <strong>动态寻址</strong>：TIPC 使用<strong>服务寻址（service addressing）</strong>，无需依赖 IP 地址，使应用程序更具可扩展性。<br>✅ <strong>自动路由</strong>：TIPC 内部<strong>自动管理节点间的连接</strong>，简化了开发者的网络管理工作。<br>✅ <strong>可靠性</strong>：支持<strong>链路状态监控</strong>，确保通信的高可用性。  </p>
<hr>
<h2 id="3-TIPC的通信架构"><a href="#3-TIPC的通信架构" class="headerlink" title="3. TIPC的通信架构"></a><strong>3. TIPC的通信架构</strong></h2><p>TIPC 的通信架构主要由 <strong>“节点（node）”、”网络（network）” 和 “集群（cluster）”</strong> 组成。</p>
<h3 id="3-1-TIPC-结构"><a href="#3-1-TIPC-结构" class="headerlink" title="3.1 TIPC 结构"></a><strong>3.1 TIPC 结构</strong></h3><ul>
<li><strong>集群（Cluster）</strong>：多个 TIPC 节点组成一个集群，相互之间可以直接通信。  </li>
<li><strong>节点（Node）</strong>：一个运行 TIPC 的机器（可以是物理机或虚拟机），属于某个集群。  </li>
<li><strong>端口（Port）</strong>：进程间通信的端点，类似于 socket 的端口。  </li>
<li><strong>服务（Service）</strong>：在 TIPC 中，应用程序通过<strong>服务类型（Type）+ 实例 ID（Instance）</strong> 来寻址，而不是直接使用 IP 地址。</li>
</ul>
<hr>
<h2 id="4-TIPC的寻址方式"><a href="#4-TIPC的寻址方式" class="headerlink" title="4. TIPC的寻址方式"></a><strong>4. TIPC的寻址方式</strong></h2><p>TIPC 提供了<strong>三种寻址方式</strong>：</p>
<h3 id="4-1-传统套接字寻址"><a href="#4-1-传统套接字寻址" class="headerlink" title="4.1 传统套接字寻址"></a><strong>4.1 传统套接字寻址</strong></h3><p>类似于 TCP&#x2F;UDP，通过 <code>port ID</code> 进行通信：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_tipc</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.family = AF_TIPC;</span><br><span class="line">addr.addrtype = TIPC_ADDR_ID;</span><br><span class="line">addr.addr.id.ref = &lt;port_id&gt;; <span class="comment">// 端口ID</span></span><br><span class="line">addr.addr.id.node = &lt;node_id&gt;; <span class="comment">// 节点ID</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-服务寻址"><a href="#4-2-服务寻址" class="headerlink" title="4.2 服务寻址"></a><strong>4.2 服务寻址</strong></h3><p>使用<strong>服务类型（Type）+ 实例 ID（Instance）</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_tipc</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.family = AF_TIPC;</span><br><span class="line">addr.addrtype = TIPC_ADDR_NAME;</span><br><span class="line">addr.addr.name.name.type = &lt;service_type&gt;; <span class="comment">// 服务类型</span></span><br><span class="line">addr.addr.name.name.instance = &lt;instance_id&gt;; <span class="comment">// 实例ID</span></span><br></pre></td></tr></table></figure>
<p>这种方式比直接使用 <code>port ID</code> 更灵活，允许多个进程提供相同的服务，并实现负载均衡。</p>
<h3 id="4-3-服务范围寻址"><a href="#4-3-服务范围寻址" class="headerlink" title="4.3 服务范围寻址"></a><strong>4.3 服务范围寻址</strong></h3><p>在 <code>service range</code> 内进行广播或组播：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_tipc</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.family = AF_TIPC;</span><br><span class="line">addr.addrtype = TIPC_ADDR_NAMESEQ;</span><br><span class="line">addr.addr.nameseq.type = &lt;service_type&gt;; <span class="comment">// 服务类型</span></span><br><span class="line">addr.addr.nameseq.lower = &lt;min_instance_id&gt;; <span class="comment">// 最小实例</span></span><br><span class="line">addr.addr.nameseq.upper = &lt;max_instance_id&gt;; <span class="comment">// 最大实例</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-TIPC-的工作模式"><a href="#5-TIPC-的工作模式" class="headerlink" title="5. TIPC 的工作模式"></a><strong>5. TIPC 的工作模式</strong></h2><p>TIPC 支持多种通信模式，包括：</p>
<ol>
<li><strong>单播（Unicast）</strong>：点对点通信。</li>
<li><strong>组播（Multicast）</strong>：面向一组进程发送消息。</li>
<li><strong>广播（Broadcast）</strong>：在整个 TIPC 网络中广播消息。</li>
</ol>
<hr>
<h2 id="6-如何在Linux中使用TIPC？"><a href="#6-如何在Linux中使用TIPC？" class="headerlink" title="6. 如何在Linux中使用TIPC？"></a><strong>6. 如何在Linux中使用TIPC？</strong></h2><p>TIPC 主要通过<strong>套接字（socket）</strong>进行通信，下面介绍如何在 Linux 中使用 TIPC。</p>
<h3 id="6-1-安装TIPC"><a href="#6-1-安装TIPC" class="headerlink" title="6.1 安装TIPC"></a><strong>6.1 安装TIPC</strong></h3><p>在大多数现代 Linux 发行版（如 Ubuntu、CentOS）中，TIPC 内核模块默认已包含，但可能需要手动加载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> modprobe tipc</span><br></pre></td></tr></table></figure>
<p>检查 TIPC 是否已启用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep tipc</span><br></pre></td></tr></table></figure>

<h3 id="6-2-配置-TIPC"><a href="#6-2-配置-TIPC" class="headerlink" title="6.2 配置 TIPC"></a><strong>6.2 配置 TIPC</strong></h3><p>如果要在不同主机之间使用 TIPC，需要手动配置网络：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> tipc node <span class="built_in">set</span> netid 1234</span><br><span class="line"><span class="built_in">sudo</span> tipc bearer <span class="built_in">enable</span> media eth dev eth0</span><br><span class="line"><span class="built_in">sudo</span> tipc <span class="built_in">link</span> <span class="built_in">set</span> eth:1 up</span><br></pre></td></tr></table></figure>
<p><strong>参数解析</strong>：</p>
<ul>
<li><code>netid 1234</code>：设置 TIPC 网络 ID，所有 TIPC 进程必须使用相同的 netid 才能通信。</li>
<li><code>bearer enable media eth dev eth0</code>：启用基于 <code>eth0</code> 的 TIPC 传输。</li>
<li><code>link set eth:1 up</code>：启用节点间通信。</li>
</ul>
<hr>
<h2 id="7-TIPC-套接字编程"><a href="#7-TIPC-套接字编程" class="headerlink" title="7. TIPC 套接字编程"></a><strong>7. TIPC 套接字编程</strong></h2><p>TIPC 提供了 <strong>面向流（SOCK_STREAM）</strong> 和 <strong>面向数据报（SOCK_RDM）</strong> 两种套接字。</p>
<h3 id="7-1-服务器端"><a href="#7-1-服务器端" class="headerlink" title="7.1 服务器端"></a><strong>7.1 服务器端</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_tipc</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TIPC套接字</span></span><br><span class="line">    sock = socket(AF_TIPC, SOCK_RDM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定服务</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.family = AF_TIPC;</span><br><span class="line">    server_addr.addrtype = TIPC_ADDR_NAME;</span><br><span class="line">    server_addr.addr.name.name.type = <span class="number">1000</span>; <span class="comment">// 服务类型</span></span><br><span class="line">    server_addr.addr.name.name.instance = <span class="number">1</span>; <span class="comment">// 实例ID</span></span><br><span class="line">    server_addr.addr.name.domain = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(sock, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TIPC Server ready...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len = recv(sock, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-2-客户端"><a href="#7-2-客户端" class="headerlink" title="7.2 客户端"></a><strong>7.2 客户端</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_tipc</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="type">char</span> message[] = <span class="string">&quot;Hello, TIPC!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TIPC套接字</span></span><br><span class="line">    sock = socket(AF_TIPC, SOCK_RDM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器地址</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.family = AF_TIPC;</span><br><span class="line">    server_addr.addrtype = TIPC_ADDR_NAME;</span><br><span class="line">    server_addr.addr.name.name.type = <span class="number">1000</span>; <span class="comment">// 服务类型</span></span><br><span class="line">    server_addr.addr.name.name.instance = <span class="number">1</span>; <span class="comment">// 实例ID</span></span><br><span class="line">    server_addr.addr.name.domain = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">if</span> (sendto(sock, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Send failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message sent!\n&quot;</span>);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a><strong>8. 总结</strong></h2><ul>
<li>TIPC 是<strong>Linux 内核级</strong>的高效 IPC 机制，特别适用于<strong>分布式系统</strong>。</li>
<li>采用<strong>服务寻址</strong>（Type + Instance）代替传统的 IP 地址，提高了灵活性。</li>
<li>提供 <strong>单播、组播、广播</strong> 机制，适用于<strong>高性能</strong>的实时通信场景。</li>
<li>通过 <code>socket(AF_TIPC, ...)</code> 进行编程，使用方式类似 TCP&#x2F;UDP，但<strong>不依赖 IP 协议</strong>。</li>
</ul>
<p>如果你对具体应用场景有问题，欢迎继续交流！ 🚀</p>
<h2 id="tipc的优点和缺点"><a href="#tipc的优点和缺点" class="headerlink" title="tipc的优点和缺点"></a>tipc的优点和缺点</h2><h3 id="TIPC（Transparent-Inter-Process-Communication）的优缺点"><a href="#TIPC（Transparent-Inter-Process-Communication）的优缺点" class="headerlink" title="TIPC（Transparent Inter-Process Communication）的优缺点"></a><strong>TIPC（Transparent Inter-Process Communication）的优缺点</strong></h3><p>TIPC 是一种为分布式系统和集群设计的进程间通信协议，具有很多独特的优势，但也有一定的局限性。以下是它的<strong>优点</strong>和<strong>缺点</strong>：</p>
<hr>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h2><h3 id="1-高性能"><a href="#1-高性能" class="headerlink" title="1. 高性能"></a>1. <strong>高性能</strong></h3><p>TIPC 采用的是基于<strong>高效的数据传输协议</strong>，能够提供<strong>低延迟</strong>和<strong>高吞吐量</strong>的通信。它非常适合高性能计算（HPC）、实时应用、以及其他对延迟要求严格的场景。  </p>
<ul>
<li>它通过<strong>内核空间直接通信</strong>（而不是通过用户空间），减少了上下文切换和传输开销。</li>
<li>支持<strong>高速的数据包转发</strong>，且网络拥塞时能够保持稳定的性能。</li>
</ul>
<h3 id="2-分布式支持"><a href="#2-分布式支持" class="headerlink" title="2. 分布式支持"></a>2. <strong>分布式支持</strong></h3><p>TIPC 设计之初便是为了支持<strong>分布式系统和集群环境</strong>，它允许在<strong>多个节点之间</strong>进行透明的通信，而不依赖于传统的 IP 地址。  </p>
<ul>
<li>它提供<strong>服务寻址机制</strong>，使得不同节点可以通过服务类型和实例号来访问应用，而不需要知道其他节点的具体 IP 地址或端口。</li>
<li>在大规模集群中，TIPC 可以<strong>自动发现服务</strong>并动态建立连接，简化了集群管理。</li>
</ul>
<h3 id="3-自动路由"><a href="#3-自动路由" class="headerlink" title="3. 自动路由"></a>3. <strong>自动路由</strong></h3><p>TIPC 提供了内建的<strong>自动路由功能</strong>，这意味着它可以在不同节点之间进行自动通信路由。  </p>
<ul>
<li>即使节点发生变动或链路出现故障，TIPC 可以自动找到新的路径，确保通信的<strong>可靠性</strong>和<strong>稳定性</strong>。</li>
</ul>
<h3 id="4-高可用性"><a href="#4-高可用性" class="headerlink" title="4. 高可用性"></a>4. <strong>高可用性</strong></h3><p>TIPC 具有<strong>链路监控功能</strong>，能够检测链路的状态并采取相应的恢复措施，提供<strong>容错</strong>和<strong>高可用性</strong>。</p>
<ul>
<li>例如，在某个节点或链路发生故障时，TIPC 可以自动选择其他可用路径来传输数据，保证服务的可用性。</li>
</ul>
<h3 id="5-灵活的寻址方式"><a href="#5-灵活的寻址方式" class="headerlink" title="5. 灵活的寻址方式"></a>5. <strong>灵活的寻址方式</strong></h3><p>TIPC 支持<strong>服务寻址</strong>，通过<strong>服务类型</strong>和<strong>实例ID</strong>来标识通信目标，而不是固定的 IP 地址或端口。  </p>
<ul>
<li>这种寻址方式使得应用程序更加灵活，支持动态部署、负载均衡等特性。</li>
<li>服务寻址简化了集群中节点的管理，避免了传统的静态 IP 地址配置。</li>
</ul>
<hr>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h2><h3 id="1-只适用于局域网（LAN）"><a href="#1-只适用于局域网（LAN）" class="headerlink" title="1. 只适用于局域网（LAN）"></a>1. <strong>只适用于局域网（LAN）</strong></h3><p>TIPC 设计主要针对<strong>局域网环境</strong>，其传输协议并不适合广域网（WAN）中的跨地域通信。  </p>
<ul>
<li>在跨地区或跨互联网的分布式系统中，TIPC 的使用可能受到网络延迟和带宽限制的影响，无法提供理想的性能。</li>
</ul>
<h3 id="2-不兼容传统的-TCP-IP-网络"><a href="#2-不兼容传统的-TCP-IP-网络" class="headerlink" title="2. 不兼容传统的 TCP&#x2F;IP 网络"></a>2. <strong>不兼容传统的 TCP&#x2F;IP 网络</strong></h3><p>TIPC 是一种专门为集群设计的协议，与<strong>传统的 TCP&#x2F;IP 协议栈</strong>不完全兼容。  </p>
<ul>
<li>因此，TIPC 网络通信无法直接与传统的互联网通信（如 HTTP、HTTPS、FTP）进行互通，可能需要特定的网关或协议转换层。</li>
</ul>
<h3 id="3-较为复杂的配置"><a href="#3-较为复杂的配置" class="headerlink" title="3. 较为复杂的配置"></a>3. <strong>较为复杂的配置</strong></h3><p>TIPC 的配置和管理较为复杂，需要<strong>手动设置网络ID</strong>、<strong>节点标识符</strong>以及<strong>通信链路</strong>。  </p>
<ul>
<li>对于中小型应用或环境，可能需要额外的学习成本来掌握如何正确配置 TIPC。</li>
</ul>
<h3 id="4-缺少跨平台支持"><a href="#4-缺少跨平台支持" class="headerlink" title="4. 缺少跨平台支持"></a>4. <strong>缺少跨平台支持</strong></h3><p>虽然 TIPC 在 Linux 环境中广泛应用，但它并没有广泛支持其他操作系统（如 Windows 或 macOS），因此限制了其在多平台系统中的应用。  </p>
<ul>
<li>对于需要跨多个操作系统平台的分布式系统，可能需要考虑其他通信协议（如 gRPC、MQTT 等）。</li>
</ul>
<h3 id="5-开发社区和文档支持较少"><a href="#5-开发社区和文档支持较少" class="headerlink" title="5. 开发社区和文档支持较少"></a>5. <strong>开发社区和文档支持较少</strong></h3><p>TIPC 是由 Ericsson 开发并由 Linux 内核支持的，虽然它是一个非常强大的协议，但相比于其他通信协议（如 TCP&#x2F;IP、HTTP 等），其<strong>开发社区较小</strong>，<strong>文档和教程相对较少</strong>。  </p>
<ul>
<li>对开发者来说，可能需要投入更多时间来理解协议的内部机制和使用方法，且缺乏像其他成熟协议一样丰富的社区支持。</li>
</ul>
<hr>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h2><h3 id="TIPC的优势："><a href="#TIPC的优势：" class="headerlink" title="TIPC的优势："></a><strong>TIPC的优势：</strong></h3><ul>
<li>高效低延迟的通信，适合高性能和实时系统。</li>
<li>优秀的分布式支持，自动路由，服务发现等特性。</li>
<li>高可用性，容错能力强，适合集群和大规模分布式系统。</li>
</ul>
<h3 id="TIPC的不足："><a href="#TIPC的不足：" class="headerlink" title="TIPC的不足："></a><strong>TIPC的不足：</strong></h3><ul>
<li>限于局域网内使用，跨区域通信存在限制。</li>
<li>配置和管理相对复杂，缺少跨平台支持。</li>
<li>与传统 TCP&#x2F;IP 网络不兼容，不支持互联网通信。</li>
</ul>
<p>TIPC 适用于大规模分布式系统和集群环境，但对于跨地区或跨平台应用，其使用会受到一定限制。在选择是否使用 TIPC 时，需根据具体的系统架构和网络环境来决定。</p>
<h2 id="linux-tipc协议-详解"><a href="#linux-tipc协议-详解" class="headerlink" title="linux tipc协议 详解"></a>linux tipc协议 详解</h2><p>TIPC（Transparent Inter-Process Communication）是一种在 Linux 中用于进程间通信的协议。它允许在集群中的不同节点之间进行通信，提供了可靠的消息传递和服务发现机制。下面是 TIPC 协议的一些详细解释：</p>
<ol>
<li><p><strong>通信模式</strong>：</p>
<ul>
<li><strong>消息模式（Message Mode）</strong>：在这种模式下，发送方发送消息给接收方，并等待确认。这种模式适用于需要确保消息到达并被处理的情况。</li>
<li><strong>流模式（Stream Mode）</strong>：与消息模式不同，流模式下发送方可以连续地向接收方发送数据，而不需要等待确认。这种模式适用于实时数据传输等场景。</li>
</ul>
</li>
<li><p><strong>消息类型</strong>：</p>
<ul>
<li><strong>点对点消息</strong>：消息从一个节点直接发送到另一个节点。</li>
<li><strong>组播消息</strong>：消息被发送到一个特定的组，并被组中的所有节点接收。</li>
</ul>
</li>
<li><p><strong>服务发现</strong>：TIPC 提供了服务发现机制，允许节点在集群中发现和订阅特定的服务。这种机制可以使得节点能够动态地发现和连接到可用的服务。</p>
</li>
<li><p><strong>路由机制</strong>：TIPC 使用一种分层的路由机制，以确保消息可以通过集群中的节点进行传递。这种机制使得 TIPC 能够在大规模集群中进行高效的通信。</p>
</li>
<li><p><strong>配置和管理</strong>：TIPC 的配置和管理通常是通过一组命令行工具完成的，这些工具允许管理员配置节点的网络参数、查看节点状态等。</p>
</li>
<li><p><strong>应用领域</strong>：TIPC 通常用于构建需要高可靠性和实时性的分布式系统，如电信网络、工业自动化等领域。</p>
</li>
</ol>
<p>总的来说，TIPC 提供了一种可靠的、高性能的进程间通信机制，适用于构建各种分布式系统。</p>
<h2 id="linux-tipc头文件-详解"><a href="#linux-tipc头文件-详解" class="headerlink" title="linux tipc头文件 详解"></a>linux tipc头文件 详解</h2><p>在 Linux 中，TIPC 的头文件通常位于 <code>/usr/include/linux/tipc.h</code>。这个头文件包含了 TIPC 协议的相关定义、数据结构和函数声明，为开发者提供了使用 TIPC 的接口和工具。</p>
<p>以下是 <code>/usr/include/linux/tipc.h</code> 中可能包含的一些重要内容：</p>
<ol>
<li><p><strong>数据结构定义</strong>：TIPC 头文件包含了许多数据结构的定义，这些数据结构用于表示 TIPC 协议中的消息、节点信息、连接状态等。</p>
</li>
<li><p><strong>常量定义</strong>：头文件中包含了一些常量的定义，用于表示 TIPC 协议中的各种参数和限制，如最大消息长度、最大节点数等。</p>
</li>
<li><p><strong>函数声明</strong>：TIPC 头文件中还包含了一些函数的声明，这些函数提供了对 TIPC 协议的操作接口，包括消息的发送和接收、节点的注册和发现、连接的建立和管理等。</p>
</li>
<li><p><strong>错误码定义</strong>：TIPC 头文件中可能还包含了一些错误码的定义，用于表示 TIPC 操作过程中可能发生的错误情况，方便开发者进行错误处理和调试。</p>
</li>
<li><p><strong>其他相关定义</strong>：除了上述内容之外，TIPC 头文件还可能包含一些其他相关的定义，如事件类型、选项参数等。</p>
</li>
</ol>
<p>开发者可以通过包含 <code>/usr/include/linux/tipc.h</code> 头文件来访问 TIPC 协议的相关接口和功能，从而在应用程序中实现进程间通信、服务发现等功能。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>感谢老板支持！敬礼(^^ゞ</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="zhang junyi WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="zhang junyi Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CppOthers/" rel="tag"># CppOthers</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/02/20/notebook/Robotics/2025-02-20--%E6%89%8B%E7%9C%BC%E6%A0%87%E5%AE%9A/" rel="prev" title="机械臂手眼标定">
      <i class="fa fa-chevron-left"></i> 机械臂手眼标定
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/02/20/notebook/Interview/2025-02-20--%E7%BB%BC%E5%90%88%E7%B4%A0%E8%B4%A8/" rel="next" title="个人综合素质">
      个人综合素质 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%91%98%E8%A6%81"><span class="nav-number">1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TIPC%E4%B8%8EROS%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="nav-number">2.</span> <span class="nav-text">TIPC与ROS的区别与联系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TIPC%E4%B8%8EROS%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB-1"><span class="nav-number">2.1.</span> <span class="nav-text">TIPC与ROS的区别与联系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TIPC%E4%B8%8EROS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">TIPC与ROS的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89%E5%92%8C%E7%94%A8%E9%80%94"><span class="nav-number">3.1.</span> <span class="nav-text">1. 定义和用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="nav-number">3.2.</span> <span class="nav-text">2. 设计目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.3.</span> <span class="nav-text">3. 通信模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TIPC%E4%B8%8EROS%E7%9A%84%E8%81%94%E7%B3%BB"><span class="nav-number">4.</span> <span class="nav-text">TIPC与ROS的联系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ROS%E4%B8%AD%E7%9A%84%E9%80%9A%E4%BF%A1%E9%9C%80%E6%B1%82"><span class="nav-number">4.1.</span> <span class="nav-text">1. ROS中的通信需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-TIPC%E4%BD%9C%E4%B8%BAROS%E7%9A%84%E5%BA%95%E5%B1%82%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.2.</span> <span class="nav-text">2. TIPC作为ROS的底层通信协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="nav-number">5.</span> <span class="nav-text">3. 结合使用案例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TIPC%E4%B8%8EROS%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">6.1.</span> <span class="nav-text">TIPC与ROS的区别：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TIPC%E4%B8%8EROS%E7%9A%84%E8%81%94%E7%B3%BB%EF%BC%9A"><span class="nav-number">6.2.</span> <span class="nav-text">TIPC与ROS的联系：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8ALinux%E4%B8%AD%E7%9A%84TIPC"><span class="nav-number">7.</span> <span class="nav-text">详细解释Linux中的TIPC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E4%B8%AD%E7%9A%84TIPC%EF%BC%88Transparent-Inter-Process-Communication%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="nav-number">8.</span> <span class="nav-text">Linux中的TIPC（Transparent Inter-Process Communication）详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFTIPC%EF%BC%9F"><span class="nav-number">8.1.</span> <span class="nav-text">1. 什么是TIPC？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-TIPC%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">8.2.</span> <span class="nav-text">2. TIPC的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-TIPC%E7%9A%84%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84"><span class="nav-number">9.</span> <span class="nav-text">3. TIPC的通信架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-TIPC-%E7%BB%93%E6%9E%84"><span class="nav-number">9.1.</span> <span class="nav-text">3.1 TIPC 结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-TIPC%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-number">10.</span> <span class="nav-text">4. TIPC的寻址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E4%BC%A0%E7%BB%9F%E5%A5%97%E6%8E%A5%E5%AD%97%E5%AF%BB%E5%9D%80"><span class="nav-number">10.1.</span> <span class="nav-text">4.1 传统套接字寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%9C%8D%E5%8A%A1%E5%AF%BB%E5%9D%80"><span class="nav-number">10.2.</span> <span class="nav-text">4.2 服务寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%9C%8D%E5%8A%A1%E8%8C%83%E5%9B%B4%E5%AF%BB%E5%9D%80"><span class="nav-number">10.3.</span> <span class="nav-text">4.3 服务范围寻址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-TIPC-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">11.</span> <span class="nav-text">5. TIPC 的工作模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E4%B8%AD%E4%BD%BF%E7%94%A8TIPC%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">6. 如何在Linux中使用TIPC？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E5%AE%89%E8%A3%85TIPC"><span class="nav-number">12.1.</span> <span class="nav-text">6.1 安装TIPC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E9%85%8D%E7%BD%AE-TIPC"><span class="nav-number">12.2.</span> <span class="nav-text">6.2 配置 TIPC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-TIPC-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B"><span class="nav-number">13.</span> <span class="nav-text">7. TIPC 套接字编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="nav-number">13.1.</span> <span class="nav-text">7.1 服务器端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">13.2.</span> <span class="nav-text">7.2 客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E6%80%BB%E7%BB%93"><span class="nav-number">14.</span> <span class="nav-text">8. 总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tipc%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-number">15.</span> <span class="nav-text">tipc的优点和缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TIPC%EF%BC%88Transparent-Inter-Process-Communication%EF%BC%89%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">15.1.</span> <span class="nav-text">TIPC（Transparent Inter-Process Communication）的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">16.</span> <span class="nav-text">优点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%AB%98%E6%80%A7%E8%83%BD"><span class="nav-number">16.1.</span> <span class="nav-text">1. 高性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%86%E5%B8%83%E5%BC%8F%E6%94%AF%E6%8C%81"><span class="nav-number">16.2.</span> <span class="nav-text">2. 分布式支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%87%AA%E5%8A%A8%E8%B7%AF%E7%94%B1"><span class="nav-number">16.3.</span> <span class="nav-text">3. 自动路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="nav-number">16.4.</span> <span class="nav-text">4. 高可用性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="nav-number">16.5.</span> <span class="nav-text">5. 灵活的寻址方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">17.</span> <span class="nav-text">缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8F%AA%E9%80%82%E7%94%A8%E4%BA%8E%E5%B1%80%E5%9F%9F%E7%BD%91%EF%BC%88LAN%EF%BC%89"><span class="nav-number">17.1.</span> <span class="nav-text">1. 只适用于局域网（LAN）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%8D%E5%85%BC%E5%AE%B9%E4%BC%A0%E7%BB%9F%E7%9A%84-TCP-IP-%E7%BD%91%E7%BB%9C"><span class="nav-number">17.2.</span> <span class="nav-text">2. 不兼容传统的 TCP&#x2F;IP 网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%BE%83%E4%B8%BA%E5%A4%8D%E6%9D%82%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">17.3.</span> <span class="nav-text">3. 较为复杂的配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BC%BA%E5%B0%91%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81"><span class="nav-number">17.4.</span> <span class="nav-text">4. 缺少跨平台支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%BC%80%E5%8F%91%E7%A4%BE%E5%8C%BA%E5%92%8C%E6%96%87%E6%A1%A3%E6%94%AF%E6%8C%81%E8%BE%83%E5%B0%91"><span class="nav-number">17.5.</span> <span class="nav-text">5. 开发社区和文档支持较少</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">18.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TIPC%E7%9A%84%E4%BC%98%E5%8A%BF%EF%BC%9A"><span class="nav-number">18.1.</span> <span class="nav-text">TIPC的优势：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TIPC%E7%9A%84%E4%B8%8D%E8%B6%B3%EF%BC%9A"><span class="nav-number">18.2.</span> <span class="nav-text">TIPC的不足：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux-tipc%E5%8D%8F%E8%AE%AE-%E8%AF%A6%E8%A7%A3"><span class="nav-number">19.</span> <span class="nav-text">linux tipc协议 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linux-tipc%E5%A4%B4%E6%96%87%E4%BB%B6-%E8%AF%A6%E8%A7%A3"><span class="nav-number">20.</span> <span class="nav-text">linux tipc头文件 详解</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhang junyi</p>
  <div class="site-description" itemprop="description">工作学习笔记</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">686</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/junyiha" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;junyiha" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://x.com/zhangjunyiha" title="Twitter → https:&#x2F;&#x2F;x.com&#x2F;zhangjunyiha" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhang junyi</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
